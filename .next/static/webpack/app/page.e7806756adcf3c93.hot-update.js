"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useNostr.ts":
/*!*******************************!*\
  !*** ./src/hooks/useNostr.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RELAYS: () => (/* binding */ RELAYS),\n/* harmony export */   useNostr: () => (/* binding */ useNostr)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/nostr/relay */ \"(app-pages-browser)/./src/lib/nostr/relay.ts\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/../node_modules/nostr-tools/lib/esm/index.js\");\n\n\n\nconst RELAYS = [\n    \"wss://relay.damus.io\",\n    \"wss://relay.nostr.band\",\n    \"wss://nostr-pub.wellorder.net\"\n];\nfunction useNostr() {\n    const [pubkey, setPubkey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [profile, setProfile] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null); // Current user's profile\n    const [following, setFollowing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]); // List of pubkeys the user follows\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false); // General loading state\n    const [relayStats, setRelayStats] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const profileCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const getWindowNostr = ()=>{\n        return window.nostr;\n    };\n    // --- Persist pubkey in localStorage ---\n    // On mount, rehydrate pubkey from localStorage if present\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if (true) {\n                const storedPubkey = window.localStorage.getItem('nostr_pubkey');\n                if (storedPubkey && !pubkey) {\n                    setPubkey(storedPubkey);\n                }\n            }\n        }\n    }[\"useNostr.useEffect\"], []);\n    // When pubkey changes, persist to localStorage\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if ( true && pubkey) {\n                window.localStorage.setItem('nostr_pubkey', pubkey);\n            }\n        }\n    }[\"useNostr.useEffect\"], [\n        pubkey\n    ]);\n    // Auth/login\n    const login = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[login]\": async ()=>{\n            const nostr = getWindowNostr();\n            if (nostr) {\n                setIsLoading(true);\n                setError(null);\n                try {\n                    const pk = await nostr.getPublicKey();\n                    setPubkey(pk);\n                    // Optional: Schnorr signing for custom message (e.g., NIP-42 auth)\n                    const message = \"Login to RAW.ROCKS: \".concat(Date.now());\n                    if (typeof nostr.signMessage === \"function\") {\n                        try {\n                            const signature = await nostr.signMessage(message);\n                            console.log(\"Signed login message:\", signature);\n                        } catch (err) {\n                            console.warn(\"signMessage for login failed:\", err);\n                        }\n                    } else {\n                        console.warn(\"signMessage is not supported by this NOSTR extension.\");\n                    }\n                    // Load profile from relays\n                    const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                    if (healthyRelays.length > 0) {\n                        const userProfileData = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrProfile)(healthyRelays, pk);\n                        if (userProfileData) {\n                            const userProfile = {\n                                ...userProfileData,\n                                pubkey: pk,\n                                username: userProfileData.name || pk\n                            };\n                            setProfile(userProfile);\n                            profileCache.current[pk] = userProfile;\n                        }\n                    } else {\n                        console.warn(\"No healthy relays to fetch initial profile.\");\n                    }\n                } catch (err) {\n                    console.error(\"Login failed:\", err);\n                    setError(err.message || \"Login failed. Please ensure your NOSTR extension is configured.\");\n                    setPubkey(null);\n                } finally{\n                    setIsLoading(false);\n                }\n            } else {\n                setError(\"NOSTR extension not found. Please install a NOSTR browser extension.\");\n            // alert(\"NOSTR extension not found. Please install a NOSTR browser extension.\");\n            }\n        }\n    }[\"useNostr.useCallback[login]\"], []);\n    // Fetch feed with pagination support\n    const fetchEvents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[fetchEvents]\": async (options)=>{\n            setIsLoading(true);\n            setError(null);\n            try {\n                const { healthyRelays, healthyCount, totalCount } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                setRelayStats({\n                    healthyCount,\n                    totalCount\n                });\n                if (!healthyRelays.length) {\n                    setError(\"No healthy relays available to fetch feed.\");\n                    return false;\n                }\n                const fetchedNostrEvents = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrFeed)(healthyRelays, {\n                    limit: 20,\n                    ...options\n                });\n                const uniquePubkeys = Array.from(new Set(fetchedNostrEvents.map({\n                    \"useNostr.useCallback[fetchEvents].uniquePubkeys\": (ev)=>ev.pubkey\n                }[\"useNostr.useCallback[fetchEvents].uniquePubkeys\"])));\n                const profilesToFetch = uniquePubkeys.filter({\n                    \"useNostr.useCallback[fetchEvents].profilesToFetch\": (pk)=>!profileCache.current[pk]\n                }[\"useNostr.useCallback[fetchEvents].profilesToFetch\"]);\n                if (profilesToFetch.length > 0) {\n                    await Promise.all(profilesToFetch.map({\n                        \"useNostr.useCallback[fetchEvents]\": async (pk)=>{\n                            const meta = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrProfile)(healthyRelays, pk);\n                            if (meta) {\n                                profileCache.current[pk] = {\n                                    ...meta,\n                                    pubkey: pk,\n                                    username: meta.name || pk\n                                };\n                            }\n                        }\n                    }[\"useNostr.useCallback[fetchEvents]\"]));\n                }\n                const processedFeed = fetchedNostrEvents.map({\n                    \"useNostr.useCallback[fetchEvents].processedFeed\": (ev)=>{\n                        let media = [];\n                        const urlRegex = /(https?:\\/\\/(?:[\\w-]+\\.)+[\\w-]+(?:\\/[\\w\\-._~:/?#[\\]@!$&'()*+,;=]*)?\\.(?:jpg|jpeg|png|gif|mp4|webm))/gi;\n                        let match;\n                        while(match = urlRegex.exec(ev.content)){\n                            media.push(match[1]);\n                        }\n                        const userProf = profileCache.current[ev.pubkey] || {\n                            pubkey: ev.pubkey,\n                            username: ev.pubkey\n                        };\n                        const picture = userProf.picture || \"/file.svg\"; // Default avatar\n                        return {\n                            ...ev,\n                            media,\n                            profile: {\n                                ...userProf,\n                                display_name: userProf.display_name || userProf.username || \"\".concat(ev.pubkey.slice(0, 6), \"...\").concat(ev.pubkey.slice(-4)),\n                                picture: userProf.picture || \"/file.svg\",\n                                username: userProf.username || ev.pubkey,\n                                pubkey: ev.pubkey\n                            }\n                        };\n                    }\n                }[\"useNostr.useCallback[fetchEvents].processedFeed\"]);\n                if (options === null || options === void 0 ? void 0 : options.until) {\n                    setEvents({\n                        \"useNostr.useCallback[fetchEvents]\": (prev)=>{\n                            const existingIds = new Set(prev.map({\n                                \"useNostr.useCallback[fetchEvents]\": (e)=>e.id\n                            }[\"useNostr.useCallback[fetchEvents]\"]));\n                            const newEvents = processedFeed.filter({\n                                \"useNostr.useCallback[fetchEvents].newEvents\": (e)=>!existingIds.has(e.id)\n                            }[\"useNostr.useCallback[fetchEvents].newEvents\"]);\n                            return [\n                                ...prev,\n                                ...newEvents\n                            ].sort({\n                                \"useNostr.useCallback[fetchEvents]\": (a, b)=>b.created_at - a.created_at\n                            }[\"useNostr.useCallback[fetchEvents]\"]);\n                        }\n                    }[\"useNostr.useCallback[fetchEvents]\"]);\n                } else {\n                    setEvents(processedFeed.sort({\n                        \"useNostr.useCallback[fetchEvents]\": (a, b)=>b.created_at - a.created_at\n                    }[\"useNostr.useCallback[fetchEvents]\"]));\n                }\n                return processedFeed.length > 0;\n            } catch (err) {\n                console.error(\"Error fetching events:\", err);\n                setError(err.message || \"Failed to fetch posts. Please try again later.\");\n                return false;\n            } finally{\n                setIsLoading(false);\n            }\n        }\n    }[\"useNostr.useCallback[fetchEvents]\"], []);\n    // Helper to publish a signed event\n    const publishEvent = async (signedEvent)=>{\n        try {\n            const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n            if (!healthyRelays.length) {\n                setError(\"No healthy relays available to publish event.\");\n                return false;\n            }\n            const pool = new nostr_tools__WEBPACK_IMPORTED_MODULE_2__.SimplePool();\n            const promises = pool.publish(healthyRelays, signedEvent);\n            // Wait for at least one successful publish or timeout\n            // This is a simplified version; nostr-tools' publish returns promises for each relay\n            await Promise.any(promises.map((p)=>Promise.race([\n                    p,\n                    new Promise((_, rej)=>setTimeout(()=>rej(new Error('timeout')), 5000))\n                ])));\n            pool.close(healthyRelays); // Close connections after publishing\n            return true;\n        } catch (err) {\n            console.error(\"Failed to publish event to relays:\", err);\n            setError(\"Failed to publish event. Some relays might be offline.\");\n            return false;\n        }\n    };\n    // Post event (sign and publish using extension)\n    const post = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[post]\": async (content)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                const unsignedEvent = {\n                    kind: 1,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: [],\n                    content\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    // Optimistic update\n                    const currentProfile = profileCache.current[pubkey] || {\n                        pubkey,\n                        username: pubkey\n                    };\n                    setEvents({\n                        \"useNostr.useCallback[post]\": (prev)=>[\n                                {\n                                    id: signedEvent.id,\n                                    pubkey: signedEvent.pubkey,\n                                    content: signedEvent.content,\n                                    created_at: signedEvent.created_at,\n                                    kind: signedEvent.kind,\n                                    tags: signedEvent.tags,\n                                    media: [],\n                                    profile: {\n                                        display_name: currentProfile.display_name || currentProfile.username || \"\".concat(pubkey.slice(0, 6), \"...\").concat(pubkey.slice(-4)),\n                                        username: currentProfile.username || pubkey,\n                                        picture: currentProfile.picture || \"/file.svg\",\n                                        pubkey: pubkey\n                                    }\n                                },\n                                ...prev\n                            ].sort({\n                                \"useNostr.useCallback[post]\": (a, b)=>b.created_at - a.created_at\n                            }[\"useNostr.useCallback[post]\"])\n                    }[\"useNostr.useCallback[post]\"]);\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to post event:\", err);\n                setError(err.message || \"Failed to post. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[post]\"], [\n        pubkey,\n        profile\n    ]);\n    // Update profile (Kind 0)\n    const updateProfileMetadata = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[updateProfileMetadata]\": async (newProfileData)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                // Ensure only valid profile fields are included\n                const contentPayload = {};\n                if (newProfileData.username !== undefined) contentPayload.name = newProfileData.username; // Always set 'name' from 'username'\n                if (newProfileData.display_name !== undefined) contentPayload.display_name = newProfileData.display_name;\n                if (newProfileData.about !== undefined) contentPayload.about = newProfileData.about;\n                if (newProfileData.picture !== undefined) contentPayload.picture = newProfileData.picture;\n                if (newProfileData.banner !== undefined) contentPayload.banner = newProfileData.banner;\n                if (newProfileData.website !== undefined) contentPayload.website = newProfileData.website;\n                if (newProfileData.lud06 !== undefined) contentPayload.lud06 = newProfileData.lud06;\n                if (newProfileData.lud16 !== undefined) contentPayload.lud16 = newProfileData.lud16;\n                if (newProfileData.nip05 !== undefined) contentPayload.nip05 = newProfileData.nip05;\n                const unsignedEvent = {\n                    kind: 0,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: [],\n                    content: JSON.stringify(contentPayload)\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    const updatedFullProfile = {\n                        ...profile,\n                        ...newProfileData,\n                        pubkey,\n                        username: newProfileData.username\n                    };\n                    setProfile(updatedFullProfile);\n                    profileCache.current[pubkey] = updatedFullProfile; // Update cache\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to update profile:\", err);\n                setError(err.message || \"Failed to update profile. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[updateProfileMetadata]\"], [\n        pubkey,\n        profile\n    ]);\n    // Manage contact list (Kind 3)\n    const updateContactList = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[updateContactList]\": async (newFollowingPubkeys)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                // NIP-02 recommends preserving existing non-\"p\" tags if any.\n                // For simplicity, this example only manages \"p\" tags.\n                // Fetch existing contact list to preserve other tags if necessary (more complex)\n                const tags = newFollowingPubkeys.map({\n                    \"useNostr.useCallback[updateContactList].tags\": (pk)=>[\n                            \"p\",\n                            pk\n                        ]\n                }[\"useNostr.useCallback[updateContactList].tags\"]);\n                const unsignedEvent = {\n                    kind: 3,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: tags,\n                    content: \"\"\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    setFollowing(newFollowingPubkeys);\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to update contact list:\", err);\n                setError(err.message || \"Failed to update contact list. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[updateContactList]\"], [\n        pubkey\n    ]);\n    const followUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[followUser]\": async (userPubkey)=>{\n            if (following.includes(userPubkey)) return true; // Already following\n            const newFollowingList = [\n                ...following,\n                userPubkey\n            ];\n            return await updateContactList(newFollowingList);\n        }\n    }[\"useNostr.useCallback[followUser]\"], [\n        following,\n        updateContactList\n    ]);\n    const unfollowUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[unfollowUser]\": async (userPubkey)=>{\n            if (!following.includes(userPubkey)) return true; // Not following\n            const newFollowingList = following.filter({\n                \"useNostr.useCallback[unfollowUser].newFollowingList\": (pk)=>pk !== userPubkey\n            }[\"useNostr.useCallback[unfollowUser].newFollowingList\"]);\n            return await updateContactList(newFollowingList);\n        }\n    }[\"useNostr.useCallback[unfollowUser]\"], [\n        following,\n        updateContactList\n    ]);\n    const isFollowing = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[isFollowing]\": (userPubkey)=>{\n            return following.includes(userPubkey);\n        }\n    }[\"useNostr.useCallback[isFollowing]\"], [\n        following\n    ]);\n    // Effect to load initial following list for the logged-in user\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if (pubkey) {\n                ({\n                    \"useNostr.useEffect\": async ()=>{\n                        try {\n                            const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                            if (healthyRelays.length === 0) return;\n                            // Use correct filter type for nostr-tools\n                            const filter = {\n                                kinds: [\n                                    3\n                                ],\n                                authors: [\n                                    pubkey\n                                ],\n                                limit: 1\n                            };\n                            // @ts-ignore: Filter type is broader than FeedOptions\n                            const contactListEvents = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrFeed)(healthyRelays, filter);\n                            if (contactListEvents.length > 0) {\n                                const latestContactList = contactListEvents.sort({\n                                    \"useNostr.useEffect\": (a, b)=>b.created_at - a.created_at\n                                }[\"useNostr.useEffect\"])[0];\n                                const followedPubkeys = latestContactList.tags.filter({\n                                    \"useNostr.useEffect.followedPubkeys\": (tag)=>tag[0] === 'p' && tag[1]\n                                }[\"useNostr.useEffect.followedPubkeys\"]).map({\n                                    \"useNostr.useEffect.followedPubkeys\": (tag)=>tag[1]\n                                }[\"useNostr.useEffect.followedPubkeys\"]);\n                                setFollowing(followedPubkeys);\n                            }\n                        } catch (err) {\n                            console.error(\"Failed to fetch initial contact list:\", err);\n                        }\n                    }\n                })[\"useNostr.useEffect\"]();\n            } else {\n                setFollowing([]); // Clear following list if not logged in\n            }\n        }\n    }[\"useNostr.useEffect\"], [\n        pubkey\n    ]);\n    return {\n        pubkey,\n        events,\n        profile,\n        following,\n        error,\n        isLoading,\n        relayStats,\n        login,\n        fetchEvents,\n        post,\n        updateProfile: updateProfileMetadata,\n        followUser,\n        unfollowUser,\n        isFollowing,\n        setEvents,\n        setProfile,\n        setFollowing\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VOb3N0ci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUU7QUFDdUI7QUFTeUI7QUFnQjFHLE1BQU1RLFNBQVM7SUFDbEI7SUFDQTtJQUNBO0NBRUgsQ0FBQztBQTJCSyxTQUFTQztJQUNaLE1BQU0sQ0FBQ0MsUUFBUUMsVUFBVSxHQUFHWCwrQ0FBUUEsQ0FBZ0I7SUFDcEQsTUFBTSxDQUFDWSxRQUFRQyxVQUFVLEdBQUdiLCtDQUFRQSxDQUFlLEVBQUU7SUFDckQsTUFBTSxDQUFDYyxTQUFTQyxXQUFXLEdBQUdmLCtDQUFRQSxDQUFzQixPQUFPLHlCQUF5QjtJQUM1RixNQUFNLENBQUNnQixXQUFXQyxhQUFhLEdBQUdqQiwrQ0FBUUEsQ0FBVyxFQUFFLEdBQUcsbUNBQW1DO0lBQzdGLE1BQU0sQ0FBQ2tCLE9BQU9DLFNBQVMsR0FBR25CLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUNvQixXQUFXQyxhQUFhLEdBQUdyQiwrQ0FBUUEsQ0FBVSxRQUFRLHdCQUF3QjtJQUNwRixNQUFNLENBQUNzQixZQUFZQyxjQUFjLEdBQUd2QiwrQ0FBUUEsQ0FBdUQ7SUFDbkcsTUFBTXdCLGVBQWV0Qiw2Q0FBTUEsQ0FBcUMsQ0FBQztJQUVqRSxNQUFNdUIsaUJBQWlCO1FBQ25CLE9BQU9DLE9BQU9DLEtBQUs7SUFDdkI7SUFFQSx5Q0FBeUM7SUFDekMsMERBQTBEO0lBQzFEeEIsZ0RBQVNBOzhCQUFDO1lBQ04sSUFBSSxJQUE2QixFQUFFO2dCQUMvQixNQUFNeUIsZUFBZUYsT0FBT0csWUFBWSxDQUFDQyxPQUFPLENBQUM7Z0JBQ2pELElBQUlGLGdCQUFnQixDQUFDbEIsUUFBUTtvQkFDekJDLFVBQVVpQjtnQkFDZDtZQUNKO1FBQ0o7NkJBQUcsRUFBRTtJQUVMLCtDQUErQztJQUMvQ3pCLGdEQUFTQTs4QkFBQztZQUNOLElBQUksS0FBNkIsSUFBSU8sUUFBUTtnQkFDekNnQixPQUFPRyxZQUFZLENBQUNFLE9BQU8sQ0FBQyxnQkFBZ0JyQjtZQUNoRDtRQUNKOzZCQUFHO1FBQUNBO0tBQU87SUFFWCxhQUFhO0lBQ2IsTUFBTXNCLFFBQVEvQixrREFBV0E7dUNBQUM7WUFDdEIsTUFBTTBCLFFBQVFGO1lBQ2QsSUFBSUUsT0FBTztnQkFDUE4sYUFBYTtnQkFDYkYsU0FBUztnQkFDVCxJQUFJO29CQUNBLE1BQU1jLEtBQUssTUFBTU4sTUFBTU8sWUFBWTtvQkFDbkN2QixVQUFVc0I7b0JBRVYsbUVBQW1FO29CQUNuRSxNQUFNRSxVQUFVLHVCQUFrQyxPQUFYQyxLQUFLQyxHQUFHO29CQUMvQyxJQUFJLE9BQU9WLE1BQU1XLFdBQVcsS0FBSyxZQUFZO3dCQUN6QyxJQUFJOzRCQUNBLE1BQU1DLFlBQVksTUFBTVosTUFBTVcsV0FBVyxDQUFDSDs0QkFDMUNLLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJGO3dCQUN6QyxFQUFFLE9BQU9HLEtBQUs7NEJBQ1ZGLFFBQVFHLElBQUksQ0FBQyxpQ0FBaUNEO3dCQUNsRDtvQkFDSixPQUFPO3dCQUNIRixRQUFRRyxJQUFJLENBQUM7b0JBQ2pCO29CQUVBLDJCQUEyQjtvQkFDM0IsTUFBTSxFQUFFQyxhQUFhLEVBQUUsR0FBRyxNQUFNdEMsa0VBQWdCQTtvQkFDaEQsSUFBSXNDLGNBQWNDLE1BQU0sR0FBRyxHQUFHO3dCQUMxQixNQUFNQyxrQkFBa0IsTUFBTXpDLG1FQUFpQkEsQ0FBQ3VDLGVBQWVYO3dCQUMvRCxJQUFJYSxpQkFBaUI7NEJBQ2pCLE1BQU1DLGNBQTRCO2dDQUM5QixHQUFHRCxlQUFlO2dDQUNsQnBDLFFBQVF1QjtnQ0FDUmUsVUFBVUYsZ0JBQWdCRyxJQUFJLElBQUloQjs0QkFDdEM7NEJBQ0FsQixXQUFXZ0M7NEJBQ1h2QixhQUFhMEIsT0FBTyxDQUFDakIsR0FBRyxHQUFHYzt3QkFDL0I7b0JBQ0osT0FBTzt3QkFDSFAsUUFBUUcsSUFBSSxDQUFDO29CQUNqQjtnQkFDSixFQUFFLE9BQU9ELEtBQVU7b0JBQ2ZGLFFBQVF0QixLQUFLLENBQUMsaUJBQWlCd0I7b0JBQy9CdkIsU0FBU3VCLElBQUlQLE9BQU8sSUFBSTtvQkFDeEJ4QixVQUFVO2dCQUNkLFNBQVU7b0JBQ05VLGFBQWE7Z0JBQ2pCO1lBQ0osT0FBTztnQkFDSEYsU0FBUztZQUNULGlGQUFpRjtZQUNyRjtRQUNKO3NDQUFHLEVBQUU7SUFFTCxxQ0FBcUM7SUFDckMsTUFBTWdDLGNBQWNsRCxrREFBV0E7NkNBQUMsT0FBT21EO1lBQ25DL0IsYUFBYTtZQUNiRixTQUFTO1lBQ1QsSUFBSTtnQkFDQSxNQUFNLEVBQUV5QixhQUFhLEVBQUVTLFlBQVksRUFBRUMsVUFBVSxFQUFFLEdBQUcsTUFBTWhELGtFQUFnQkE7Z0JBQzFFaUIsY0FBYztvQkFBRThCO29CQUFjQztnQkFBVztnQkFFekMsSUFBSSxDQUFDVixjQUFjQyxNQUFNLEVBQUU7b0JBQ3ZCMUIsU0FBUztvQkFDVCxPQUFPO2dCQUNYO2dCQUVBLE1BQU1vQyxxQkFBcUIsTUFBTW5ELGdFQUFjQSxDQUFDd0MsZUFBZTtvQkFDM0RZLE9BQU87b0JBQ1AsR0FBR0osT0FBTztnQkFDZDtnQkFFQSxNQUFNSyxnQkFBZ0JDLE1BQU1DLElBQUksQ0FBQyxJQUFJQyxJQUFJTCxtQkFBbUJNLEdBQUc7dUVBQUNDLENBQUFBLEtBQU1BLEdBQUdwRCxNQUFNOztnQkFDL0UsTUFBTXFELGtCQUFrQk4sY0FBY08sTUFBTTt5RUFBQy9CLENBQUFBLEtBQU0sQ0FBQ1QsYUFBYTBCLE9BQU8sQ0FBQ2pCLEdBQUc7O2dCQUU1RSxJQUFJOEIsZ0JBQWdCbEIsTUFBTSxHQUFHLEdBQUc7b0JBQzVCLE1BQU1vQixRQUFRQyxHQUFHLENBQUNILGdCQUFnQkYsR0FBRzs2REFBQyxPQUFPNUI7NEJBQ3pDLE1BQU1rQyxPQUFPLE1BQU05RCxtRUFBaUJBLENBQUN1QyxlQUFlWDs0QkFDcEQsSUFBSWtDLE1BQU07Z0NBQ04zQyxhQUFhMEIsT0FBTyxDQUFDakIsR0FBRyxHQUFHO29DQUN2QixHQUFHa0MsSUFBSTtvQ0FDUHpELFFBQVF1QjtvQ0FDUmUsVUFBVW1CLEtBQUtsQixJQUFJLElBQUloQjtnQ0FDM0I7NEJBQ0o7d0JBQ0o7O2dCQUNKO2dCQUVBLE1BQU1tQyxnQkFBZ0JiLG1CQUFtQk0sR0FBRzt1RUFBQyxDQUFDQzt3QkFDMUMsSUFBSU8sUUFBa0IsRUFBRTt3QkFDeEIsTUFBTUMsV0FBVzt3QkFDakIsSUFBSUM7d0JBQ0osTUFBUUEsUUFBUUQsU0FBU0UsSUFBSSxDQUFDVixHQUFHVyxPQUFPLEVBQUk7NEJBQ3hDSixNQUFNSyxJQUFJLENBQUNILEtBQUssQ0FBQyxFQUFFO3dCQUN2Qjt3QkFFQSxNQUFNSSxXQUFXbkQsYUFBYTBCLE9BQU8sQ0FBQ1ksR0FBR3BELE1BQU0sQ0FBQyxJQUFJOzRCQUFFQSxRQUFRb0QsR0FBR3BELE1BQU07NEJBQUVzQyxVQUFVYyxHQUFHcEQsTUFBTTt3QkFBQzt3QkFDN0YsTUFBTWtFLFVBQVVELFNBQVNDLE9BQU8sSUFBSSxhQUFhLGlCQUFpQjt3QkFFbEUsT0FBTzs0QkFDSCxHQUFHZCxFQUFFOzRCQUNMTzs0QkFDQXZELFNBQVM7Z0NBQ0wsR0FBRzZELFFBQVE7Z0NBQ1hFLGNBQWNGLFNBQVNFLFlBQVksSUFBSUYsU0FBUzNCLFFBQVEsSUFBSSxHQUE4QmMsT0FBM0JBLEdBQUdwRCxNQUFNLENBQUNvRSxLQUFLLENBQUMsR0FBRyxJQUFHLE9BQXlCLE9BQXBCaEIsR0FBR3BELE1BQU0sQ0FBQ29FLEtBQUssQ0FBQyxDQUFDO2dDQUMzR0YsU0FBU0QsU0FBU0MsT0FBTyxJQUFJO2dDQUM3QjVCLFVBQVUyQixTQUFTM0IsUUFBUSxJQUFJYyxHQUFHcEQsTUFBTTtnQ0FDeENBLFFBQVFvRCxHQUFHcEQsTUFBTTs0QkFDckI7d0JBQ0o7b0JBQ0o7O2dCQUVBLElBQUkwQyxvQkFBQUEsOEJBQUFBLFFBQVMyQixLQUFLLEVBQUU7b0JBQ2hCbEU7NkRBQVVtRSxDQUFBQTs0QkFDTixNQUFNQyxjQUFjLElBQUlyQixJQUFJb0IsS0FBS25CLEdBQUc7cUVBQUNxQixDQUFBQSxJQUFLQSxFQUFFQyxFQUFFOzs0QkFDOUMsTUFBTUMsWUFBWWhCLGNBQWNKLE1BQU07K0VBQUNrQixDQUFBQSxJQUFLLENBQUNELFlBQVlJLEdBQUcsQ0FBQ0gsRUFBRUMsRUFBRTs7NEJBQ2pFLE9BQU87bUNBQUlIO21DQUFTSTs2QkFBVSxDQUFDRSxJQUFJO3FFQUFDLENBQUNDLEdBQUdDLElBQU1BLEVBQUVDLFVBQVUsR0FBR0YsRUFBRUUsVUFBVTs7d0JBQzdFOztnQkFDSixPQUFPO29CQUNINUUsVUFBVXVELGNBQWNrQixJQUFJOzZEQUFDLENBQUNDLEdBQUdDLElBQU1BLEVBQUVDLFVBQVUsR0FBR0YsRUFBRUUsVUFBVTs7Z0JBQ3RFO2dCQUNBLE9BQU9yQixjQUFjdkIsTUFBTSxHQUFHO1lBQ2xDLEVBQUUsT0FBT0gsS0FBVTtnQkFDZkYsUUFBUXRCLEtBQUssQ0FBQywwQkFBMEJ3QjtnQkFDeEN2QixTQUFTdUIsSUFBSVAsT0FBTyxJQUFJO2dCQUN4QixPQUFPO1lBQ1gsU0FBVTtnQkFDTmQsYUFBYTtZQUNqQjtRQUNKOzRDQUFHLEVBQUU7SUFFTCxtQ0FBbUM7SUFDbkMsTUFBTXFFLGVBQWUsT0FBT0M7UUFDeEIsSUFBSTtZQUNBLE1BQU0sRUFBRS9DLGFBQWEsRUFBRSxHQUFHLE1BQU10QyxrRUFBZ0JBO1lBQ2hELElBQUksQ0FBQ3NDLGNBQWNDLE1BQU0sRUFBRTtnQkFDdkIxQixTQUFTO2dCQUNULE9BQU87WUFDWDtZQUNBLE1BQU15RSxPQUFPLElBQUlyRixtREFBVUE7WUFDM0IsTUFBTXNGLFdBQVdELEtBQUtFLE9BQU8sQ0FBQ2xELGVBQWUrQztZQUM3QyxzREFBc0Q7WUFDdEQscUZBQXFGO1lBQ3JGLE1BQU0xQixRQUFROEIsR0FBRyxDQUFDRixTQUFTaEMsR0FBRyxDQUFDbUMsQ0FBQUEsSUFBSy9CLFFBQVFnQyxJQUFJLENBQUM7b0JBQUNEO29CQUFHLElBQUkvQixRQUFRLENBQUNpQyxHQUFHQyxNQUFRQyxXQUFXLElBQU1ELElBQUksSUFBSUUsTUFBTSxhQUFhO2lCQUFPO1lBQ2hJVCxLQUFLVSxLQUFLLENBQUMxRCxnQkFBZ0IscUNBQXFDO1lBQ2hFLE9BQU87UUFDWCxFQUFFLE9BQU9GLEtBQUs7WUFDVkYsUUFBUXRCLEtBQUssQ0FBQyxzQ0FBc0N3QjtZQUNwRHZCLFNBQVM7WUFDVCxPQUFPO1FBQ1g7SUFDSjtJQUVBLGdEQUFnRDtJQUNoRCxNQUFNb0YsT0FBT3RHLGtEQUFXQTtzQ0FBQyxPQUFPd0U7WUFDNUIsTUFBTTlDLFFBQVFGO1lBQ2QsSUFBSSxDQUFDZixVQUFVLENBQUNpQixPQUFPO2dCQUNuQlIsU0FBUztnQkFDVDtZQUNKO1lBQ0FFLGFBQWE7WUFDYkYsU0FBUztZQUNULElBQUk7Z0JBQ0EsTUFBTXFGLGdCQUErQjtvQkFDakNDLE1BQU07b0JBQ04vRjtvQkFDQStFLFlBQVlpQixLQUFLQyxLQUFLLENBQUN2RSxLQUFLQyxHQUFHLEtBQUs7b0JBQ3BDdUUsTUFBTSxFQUFFO29CQUNSbkM7Z0JBQ0o7Z0JBQ0EsTUFBTWtCLGNBQWMsTUFBTWhFLE1BQU1rRixTQUFTLENBQUNMO2dCQUUxQyxJQUFJLE1BQU1kLGFBQWFDLGNBQWM7b0JBQ2pDLG9CQUFvQjtvQkFDcEIsTUFBTW1CLGlCQUFpQnRGLGFBQWEwQixPQUFPLENBQUN4QyxPQUFPLElBQUk7d0JBQUVBO3dCQUFRc0MsVUFBVXRDO29CQUFPO29CQUNsRkc7c0RBQVVtRSxDQUFBQSxPQUFRO2dDQUNkO29DQUNJRyxJQUFJUSxZQUFZUixFQUFFO29DQUNsQnpFLFFBQVFpRixZQUFZakYsTUFBTTtvQ0FDMUIrRCxTQUFTa0IsWUFBWWxCLE9BQU87b0NBQzVCZ0IsWUFBWUUsWUFBWUYsVUFBVTtvQ0FDbENnQixNQUFNZCxZQUFZYyxJQUFJO29DQUN0QkcsTUFBTWpCLFlBQVlpQixJQUFJO29DQUN0QnZDLE9BQU8sRUFBRTtvQ0FDVHZELFNBQVM7d0NBQ0wrRCxjQUFjaUMsZUFBZWpDLFlBQVksSUFBSWlDLGVBQWU5RCxRQUFRLElBQUksR0FBMkJ0QyxPQUF4QkEsT0FBT29FLEtBQUssQ0FBQyxHQUFHLElBQUcsT0FBc0IsT0FBakJwRSxPQUFPb0UsS0FBSyxDQUFDLENBQUM7d0NBQ2pIOUIsVUFBVThELGVBQWU5RCxRQUFRLElBQUl0Qzt3Q0FDckNrRSxTQUFTa0MsZUFBZWxDLE9BQU8sSUFBSTt3Q0FDbkNsRSxRQUFRQTtvQ0FDWjtnQ0FDSjttQ0FDR3NFOzZCQUNOLENBQUNNLElBQUk7OERBQUMsQ0FBQ0MsR0FBR0MsSUFBTUEsRUFBRUMsVUFBVSxHQUFHRixFQUFFRSxVQUFVOzs7b0JBQzVDLE9BQU87Z0JBQ1g7WUFDSixFQUFFLE9BQU8vQyxLQUFVO2dCQUNmRixRQUFRdEIsS0FBSyxDQUFDLHlCQUF5QndCO2dCQUN2Q3ZCLFNBQVN1QixJQUFJUCxPQUFPLElBQUk7WUFDNUIsU0FBVTtnQkFDTmQsYUFBYTtZQUNqQjtZQUNBLE9BQU87UUFDWDtxQ0FBRztRQUFDWDtRQUFRSTtLQUFRO0lBRXBCLDBCQUEwQjtJQUMxQixNQUFNaUcsd0JBQXdCOUcsa0RBQVdBO3VEQUFDLE9BQU8rRztZQUM3QyxNQUFNckYsUUFBUUY7WUFDZCxJQUFJLENBQUNmLFVBQVUsQ0FBQ2lCLE9BQU87Z0JBQ25CUixTQUFTO2dCQUNUO1lBQ0o7WUFDQUUsYUFBYTtZQUNiRixTQUFTO1lBQ1QsSUFBSTtnQkFDQSxnREFBZ0Q7Z0JBQ2hELE1BQU04RixpQkFBc0IsQ0FBQztnQkFDN0IsSUFBSUQsZUFBZWhFLFFBQVEsS0FBS2tFLFdBQVdELGVBQWVoRSxJQUFJLEdBQUcrRCxlQUFlaEUsUUFBUSxFQUFFLG9DQUFvQztnQkFDOUgsSUFBSWdFLGVBQWVuQyxZQUFZLEtBQUtxQyxXQUFXRCxlQUFlcEMsWUFBWSxHQUFHbUMsZUFBZW5DLFlBQVk7Z0JBQ3hHLElBQUltQyxlQUFlRyxLQUFLLEtBQUtELFdBQVdELGVBQWVFLEtBQUssR0FBR0gsZUFBZUcsS0FBSztnQkFDbkYsSUFBSUgsZUFBZXBDLE9BQU8sS0FBS3NDLFdBQVdELGVBQWVyQyxPQUFPLEdBQUdvQyxlQUFlcEMsT0FBTztnQkFDekYsSUFBSW9DLGVBQWVJLE1BQU0sS0FBS0YsV0FBV0QsZUFBZUcsTUFBTSxHQUFHSixlQUFlSSxNQUFNO2dCQUN0RixJQUFJSixlQUFlSyxPQUFPLEtBQUtILFdBQVdELGVBQWVJLE9BQU8sR0FBR0wsZUFBZUssT0FBTztnQkFDekYsSUFBSUwsZUFBZU0sS0FBSyxLQUFLSixXQUFXRCxlQUFlSyxLQUFLLEdBQUdOLGVBQWVNLEtBQUs7Z0JBQ25GLElBQUlOLGVBQWVPLEtBQUssS0FBS0wsV0FBV0QsZUFBZU0sS0FBSyxHQUFHUCxlQUFlTyxLQUFLO2dCQUNuRixJQUFJUCxlQUFlUSxLQUFLLEtBQUtOLFdBQVdELGVBQWVPLEtBQUssR0FBR1IsZUFBZVEsS0FBSztnQkFHbkYsTUFBTWhCLGdCQUErQjtvQkFDakNDLE1BQU07b0JBQ04vRjtvQkFDQStFLFlBQVlpQixLQUFLQyxLQUFLLENBQUN2RSxLQUFLQyxHQUFHLEtBQUs7b0JBQ3BDdUUsTUFBTSxFQUFFO29CQUNSbkMsU0FBU2dELEtBQUtDLFNBQVMsQ0FBQ1Q7Z0JBQzVCO2dCQUNBLE1BQU10QixjQUFjLE1BQU1oRSxNQUFNa0YsU0FBUyxDQUFDTDtnQkFDMUMsSUFBSSxNQUFNZCxhQUFhQyxjQUFjO29CQUNqQyxNQUFNZ0MscUJBQXFCO3dCQUFFLEdBQUc3RyxPQUFPO3dCQUFFLEdBQUdrRyxjQUFjO3dCQUFFdEc7d0JBQVFzQyxVQUFVZ0UsZUFBZWhFLFFBQVE7b0JBQUM7b0JBQ3RHakMsV0FBVzRHO29CQUNYbkcsYUFBYTBCLE9BQU8sQ0FBQ3hDLE9BQU8sR0FBR2lILG9CQUFvQixlQUFlO29CQUNsRSxPQUFPO2dCQUNYO1lBQ0osRUFBRSxPQUFPakYsS0FBVTtnQkFDZkYsUUFBUXRCLEtBQUssQ0FBQyw2QkFBNkJ3QjtnQkFDM0N2QixTQUFTdUIsSUFBSVAsT0FBTyxJQUFJO1lBQzVCLFNBQVU7Z0JBQ05kLGFBQWE7WUFDakI7WUFDQSxPQUFPO1FBQ1g7c0RBQUc7UUFBQ1g7UUFBUUk7S0FBUTtJQUVwQiwrQkFBK0I7SUFDL0IsTUFBTThHLG9CQUFvQjNILGtEQUFXQTttREFBQyxPQUFPNEg7WUFDekMsTUFBTWxHLFFBQVFGO1lBQ2QsSUFBSSxDQUFDZixVQUFVLENBQUNpQixPQUFPO2dCQUNuQlIsU0FBUztnQkFDVDtZQUNKO1lBQ0FFLGFBQWE7WUFDYkYsU0FBUztZQUNULElBQUk7Z0JBQ0EsNkRBQTZEO2dCQUM3RCxzREFBc0Q7Z0JBQ3RELGlGQUFpRjtnQkFFakYsTUFBTXlGLE9BQU9pQixvQkFBb0JoRSxHQUFHO29FQUFDNUIsQ0FBQUEsS0FBTTs0QkFBQzs0QkFBS0E7eUJBQUc7O2dCQUNwRCxNQUFNdUUsZ0JBQStCO29CQUNqQ0MsTUFBTTtvQkFDTi9GO29CQUNBK0UsWUFBWWlCLEtBQUtDLEtBQUssQ0FBQ3ZFLEtBQUtDLEdBQUcsS0FBSztvQkFDcEN1RSxNQUFNQTtvQkFDTm5DLFNBQVM7Z0JBQ2I7Z0JBQ0EsTUFBTWtCLGNBQWMsTUFBTWhFLE1BQU1rRixTQUFTLENBQUNMO2dCQUMxQyxJQUFJLE1BQU1kLGFBQWFDLGNBQWM7b0JBQ2pDMUUsYUFBYTRHO29CQUNiLE9BQU87Z0JBQ1g7WUFDSixFQUFFLE9BQU9uRixLQUFVO2dCQUNmRixRQUFRdEIsS0FBSyxDQUFDLGtDQUFrQ3dCO2dCQUNoRHZCLFNBQVN1QixJQUFJUCxPQUFPLElBQUk7WUFDNUIsU0FBVTtnQkFDTmQsYUFBYTtZQUNqQjtZQUNBLE9BQU87UUFDWDtrREFBRztRQUFDWDtLQUFPO0lBRVgsTUFBTW9ILGFBQWE3SCxrREFBV0E7NENBQUMsT0FBTzhIO1lBQ2xDLElBQUkvRyxVQUFVZ0gsUUFBUSxDQUFDRCxhQUFhLE9BQU8sTUFBTSxvQkFBb0I7WUFDckUsTUFBTUUsbUJBQW1CO21CQUFJakg7Z0JBQVcrRzthQUFXO1lBQ25ELE9BQU8sTUFBTUgsa0JBQWtCSztRQUNuQzsyQ0FBRztRQUFDakg7UUFBVzRHO0tBQWtCO0lBRWpDLE1BQU1NLGVBQWVqSSxrREFBV0E7OENBQUMsT0FBTzhIO1lBQ3BDLElBQUksQ0FBQy9HLFVBQVVnSCxRQUFRLENBQUNELGFBQWEsT0FBTyxNQUFNLGdCQUFnQjtZQUNsRSxNQUFNRSxtQkFBbUJqSCxVQUFVZ0QsTUFBTTt1RUFBQy9CLENBQUFBLEtBQU1BLE9BQU84Rjs7WUFDdkQsT0FBTyxNQUFNSCxrQkFBa0JLO1FBQ25DOzZDQUFHO1FBQUNqSDtRQUFXNEc7S0FBa0I7SUFHakMsTUFBTU8sY0FBY2xJLGtEQUFXQTs2Q0FBQyxDQUFDOEg7WUFDN0IsT0FBTy9HLFVBQVVnSCxRQUFRLENBQUNEO1FBQzlCOzRDQUFHO1FBQUMvRztLQUFVO0lBRWQsK0RBQStEO0lBQy9EYixnREFBU0E7OEJBQUM7WUFDTixJQUFJTyxRQUFRO2dCQUNSOzBDQUFDO3dCQUNHLElBQUk7NEJBQ0EsTUFBTSxFQUFFa0MsYUFBYSxFQUFFLEdBQUcsTUFBTXRDLGtFQUFnQkE7NEJBQ2hELElBQUlzQyxjQUFjQyxNQUFNLEtBQUssR0FBRzs0QkFFaEMsMENBQTBDOzRCQUMxQyxNQUFNbUIsU0FBUztnQ0FDWG9FLE9BQU87b0NBQUM7aUNBQUU7Z0NBQ1ZDLFNBQVM7b0NBQUMzSDtpQ0FBTztnQ0FDakI4QyxPQUFPOzRCQUNYOzRCQUNBLHNEQUFzRDs0QkFDdEQsTUFBTThFLG9CQUFvQixNQUFNbEksZ0VBQWNBLENBQUN3QyxlQUFlb0I7NEJBRTlELElBQUlzRSxrQkFBa0J6RixNQUFNLEdBQUcsR0FBRztnQ0FDOUIsTUFBTTBGLG9CQUFvQkQsa0JBQWtCaEQsSUFBSTswREFBQyxDQUFDQyxHQUFRQyxJQUFXQSxFQUFFQyxVQUFVLEdBQUdGLEVBQUVFLFVBQVU7d0RBQUMsQ0FBQyxFQUFFO2dDQUNwRyxNQUFNK0Msa0JBQWtCRCxrQkFBa0IzQixJQUFJLENBQ3pDNUMsTUFBTTswRUFBQyxDQUFDeUUsTUFBa0JBLEdBQUcsQ0FBQyxFQUFFLEtBQUssT0FBT0EsR0FBRyxDQUFDLEVBQUU7eUVBQ2xENUUsR0FBRzswRUFBQyxDQUFDNEUsTUFBa0JBLEdBQUcsQ0FBQyxFQUFFOztnQ0FDbEN4SCxhQUFhdUg7NEJBQ2pCO3dCQUNKLEVBQUUsT0FBTzlGLEtBQUs7NEJBQ1ZGLFFBQVF0QixLQUFLLENBQUMseUNBQXlDd0I7d0JBQzNEO29CQUNKOztZQUNKLE9BQU87Z0JBQ0h6QixhQUFhLEVBQUUsR0FBRyx3Q0FBd0M7WUFDOUQ7UUFDSjs2QkFBRztRQUFDUDtLQUFPO0lBR1gsT0FBTztRQUNIQTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBVTtRQUNBbUI7UUFDQW9EO1FBQ0FtQyxlQUFlM0I7UUFDZmU7UUFDQUk7UUFDQUM7UUFDQXRIO1FBQ0FFO1FBQ0FFO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL3NyYy9ob29rcy91c2VOb3N0ci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBmZXRjaE5vc3RyRmVlZCwgZmV0Y2hOb3N0clByb2ZpbGUsIGdldEhlYWx0aHlSZWxheXMgfSBmcm9tIFwiQC9saWIvbm9zdHIvcmVsYXlcIjtcblxuLy8gRXh0ZW5kIEZlZWRPcHRpb25zIHRvIGluY2x1ZGUgJ2F1dGhvcnMnXG5leHBvcnQgaW50ZXJmYWNlIEZlZWRPcHRpb25zIHtcbiAgICBsaW1pdD86IG51bWJlcjtcbiAgICB1bnRpbD86IG51bWJlcjtcbiAgICBraW5kcz86IG51bWJlcltdO1xuICAgIGF1dGhvcnM/OiBzdHJpbmdbXTsgLy8gQWRkZWQgYXV0aG9ycyBwcm9wZXJ0eSB0byBtYXRjaCB1c2FnZVxufVxuaW1wb3J0IHsgU2ltcGxlUG9vbCwgbmlwMTksIHR5cGUgRXZlbnQgYXMgTm9zdHJUb29sc0V2ZW50LCB0eXBlIFVuc2lnbmVkRXZlbnQsIGdldEV2ZW50SGFzaCB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuXG4vLyBEZWZpbmUgdGhlIE5JUC0wNyB3aW5kb3cubm9zdHIgaW50ZXJmYWNlXG5pbnRlcmZhY2UgV2luZG93Tm9zdHIge1xuICAgIGdldFB1YmxpY0tleSgpOiBQcm9taXNlPHN0cmluZz47XG4gICAgc2lnbkV2ZW50KGV2ZW50OiBVbnNpZ25lZEV2ZW50KTogUHJvbWlzZTxOb3N0clRvb2xzRXZlbnQ+O1xuICAgIHNpZ25NZXNzYWdlPyhtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz47IC8vIE9wdGlvbmFsIE5JUC00MiBvciBjdXN0b20gdXNhZ2VcbiAgICBnZXRSZWxheXM/KCk6IFByb21pc2U8eyBbdXJsOiBzdHJpbmddOiB7IHJlYWQ6IGJvb2xlYW47IHdyaXRlOiBib29sZWFuIH0gfT47IC8vIE9wdGlvbmFsXG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICAgICAgbm9zdHI/OiBXaW5kb3dOb3N0cjtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBSRUxBWVMgPSBbXG4gICAgXCJ3c3M6Ly9yZWxheS5kYW11cy5pb1wiLFxuICAgIFwid3NzOi8vcmVsYXkubm9zdHIuYmFuZFwiLFxuICAgIFwid3NzOi8vbm9zdHItcHViLndlbGxvcmRlci5uZXRcIixcbiAgICAvLyBBZGQgbW9yZSBkZWZhdWx0IHJlbGF5cyBvciBtYWtlIHRoaXMgY29uZmlndXJhYmxlXG5dO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5vc3RyUHJvZmlsZSB7XG4gICAgdXNlcm5hbWU/OiBzdHJpbmc7IC8vIEFsd2F5cyBzZXQ6IG1hcHBlZCBmcm9tICduYW1lJyBpbiBOb3N0ciBzcGVjXG4gICAgZGlzcGxheV9uYW1lPzogc3RyaW5nO1xuICAgIGFib3V0Pzogc3RyaW5nO1xuICAgIHBpY3R1cmU/OiBzdHJpbmc7XG4gICAgYmFubmVyPzogc3RyaW5nO1xuICAgIHdlYnNpdGU/OiBzdHJpbmc7XG4gICAgbHVkMDY/OiBzdHJpbmc7XG4gICAgbHVkMTY/OiBzdHJpbmc7XG4gICAgbmlwMDU/OiBzdHJpbmc7XG4gICAgcHVia2V5Pzogc3RyaW5nOyAvLyBBZGRlZCBmb3IgY29udmVuaWVuY2Vcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3N0ckV2ZW50IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHB1YmtleTogc3RyaW5nO1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICBjcmVhdGVkX2F0OiBudW1iZXI7XG4gICAga2luZDogbnVtYmVyO1xuICAgIHRhZ3M6IHN0cmluZ1tdW107XG4gICAgbWVkaWE6IHN0cmluZ1tdOyAvLyBDdXN0b20gZGVyaXZlZCBmaWVsZFxuICAgIHByb2ZpbGU/OiBOb3N0clByb2ZpbGU7IC8vIEN1c3RvbSBkZXJpdmVkIGZpZWxkXG4gICAgLy8gQWRkIG90aGVyIGV2ZW50IGZpZWxkcyBpZiBuZWVkZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU5vc3RyKCkge1xuICAgIGNvbnN0IFtwdWJrZXksIHNldFB1YmtleV0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbZXZlbnRzLCBzZXRFdmVudHNdID0gdXNlU3RhdGU8Tm9zdHJFdmVudFtdPihbXSk7XG4gICAgY29uc3QgW3Byb2ZpbGUsIHNldFByb2ZpbGVdID0gdXNlU3RhdGU8Tm9zdHJQcm9maWxlIHwgbnVsbD4obnVsbCk7IC8vIEN1cnJlbnQgdXNlcidzIHByb2ZpbGVcbiAgICBjb25zdCBbZm9sbG93aW5nLCBzZXRGb2xsb3dpbmddID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTsgLy8gTGlzdCBvZiBwdWJrZXlzIHRoZSB1c2VyIGZvbGxvd3NcbiAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7IC8vIEdlbmVyYWwgbG9hZGluZyBzdGF0ZVxuICAgIGNvbnN0IFtyZWxheVN0YXRzLCBzZXRSZWxheVN0YXRzXSA9IHVzZVN0YXRlPHsgaGVhbHRoeUNvdW50OiBudW1iZXI7IHRvdGFsQ291bnQ6IG51bWJlcjsgfSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHByb2ZpbGVDYWNoZSA9IHVzZVJlZjx7IFtwdWJrZXk6IHN0cmluZ106IE5vc3RyUHJvZmlsZSB9Pih7fSk7XG5cbiAgICBjb25zdCBnZXRXaW5kb3dOb3N0ciA9ICgpOiBXaW5kb3dOb3N0ciB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cubm9zdHI7XG4gICAgfTtcblxuICAgIC8vIC0tLSBQZXJzaXN0IHB1YmtleSBpbiBsb2NhbFN0b3JhZ2UgLS0tXG4gICAgLy8gT24gbW91bnQsIHJlaHlkcmF0ZSBwdWJrZXkgZnJvbSBsb2NhbFN0b3JhZ2UgaWYgcHJlc2VudFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkUHVia2V5ID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdub3N0cl9wdWJrZXknKTtcbiAgICAgICAgICAgIGlmIChzdG9yZWRQdWJrZXkgJiYgIXB1YmtleSkge1xuICAgICAgICAgICAgICAgIHNldFB1YmtleShzdG9yZWRQdWJrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8gV2hlbiBwdWJrZXkgY2hhbmdlcywgcGVyc2lzdCB0byBsb2NhbFN0b3JhZ2VcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHVia2V5KSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ25vc3RyX3B1YmtleScsIHB1YmtleSk7XG4gICAgICAgIH1cbiAgICB9LCBbcHVia2V5XSk7XG5cbiAgICAvLyBBdXRoL2xvZ2luXG4gICAgY29uc3QgbG9naW4gPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vc3RyID0gZ2V0V2luZG93Tm9zdHIoKTtcbiAgICAgICAgaWYgKG5vc3RyKSB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGsgPSBhd2FpdCBub3N0ci5nZXRQdWJsaWNLZXkoKTtcbiAgICAgICAgICAgICAgICBzZXRQdWJrZXkocGspO1xuXG4gICAgICAgICAgICAgICAgLy8gT3B0aW9uYWw6IFNjaG5vcnIgc2lnbmluZyBmb3IgY3VzdG9tIG1lc3NhZ2UgKGUuZy4sIE5JUC00MiBhdXRoKVxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgTG9naW4gdG8gUkFXLlJPQ0tTOiAke0RhdGUubm93KCl9YDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vc3RyLnNpZ25NZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IG5vc3RyLnNpZ25NZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTaWduZWQgbG9naW4gbWVzc2FnZTpcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzaWduTWVzc2FnZSBmb3IgbG9naW4gZmFpbGVkOlwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwic2lnbk1lc3NhZ2UgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIE5PU1RSIGV4dGVuc2lvbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTG9hZCBwcm9maWxlIGZyb20gcmVsYXlzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBoZWFsdGh5UmVsYXlzIH0gPSBhd2FpdCBnZXRIZWFsdGh5UmVsYXlzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWx0aHlSZWxheXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyUHJvZmlsZURhdGEgPSBhd2FpdCBmZXRjaE5vc3RyUHJvZmlsZShoZWFsdGh5UmVsYXlzLCBwayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyUHJvZmlsZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9maWxlOiBOb3N0clByb2ZpbGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udXNlclByb2ZpbGVEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YmtleTogcGssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXJQcm9maWxlRGF0YS5uYW1lIHx8IHBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb2ZpbGUodXNlclByb2ZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZUNhY2hlLmN1cnJlbnRbcGtdID0gdXNlclByb2ZpbGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyBoZWFsdGh5IHJlbGF5cyB0byBmZXRjaCBpbml0aWFsIHByb2ZpbGUuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkxvZ2luIGZhaWxlZDpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkxvZ2luIGZhaWxlZC4gUGxlYXNlIGVuc3VyZSB5b3VyIE5PU1RSIGV4dGVuc2lvbiBpcyBjb25maWd1cmVkLlwiKTtcbiAgICAgICAgICAgICAgICBzZXRQdWJrZXkobnVsbCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRFcnJvcihcIk5PU1RSIGV4dGVuc2lvbiBub3QgZm91bmQuIFBsZWFzZSBpbnN0YWxsIGEgTk9TVFIgYnJvd3NlciBleHRlbnNpb24uXCIpO1xuICAgICAgICAgICAgLy8gYWxlcnQoXCJOT1NUUiBleHRlbnNpb24gbm90IGZvdW5kLiBQbGVhc2UgaW5zdGFsbCBhIE5PU1RSIGJyb3dzZXIgZXh0ZW5zaW9uLlwiKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIEZldGNoIGZlZWQgd2l0aCBwYWdpbmF0aW9uIHN1cHBvcnRcbiAgICBjb25zdCBmZXRjaEV2ZW50cyA9IHVzZUNhbGxiYWNrKGFzeW5jIChvcHRpb25zPzogRmVlZE9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGVhbHRoeVJlbGF5cywgaGVhbHRoeUNvdW50LCB0b3RhbENvdW50IH0gPSBhd2FpdCBnZXRIZWFsdGh5UmVsYXlzKCk7XG4gICAgICAgICAgICBzZXRSZWxheVN0YXRzKHsgaGVhbHRoeUNvdW50LCB0b3RhbENvdW50IH0pO1xuXG4gICAgICAgICAgICBpZiAoIWhlYWx0aHlSZWxheXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoXCJObyBoZWFsdGh5IHJlbGF5cyBhdmFpbGFibGUgdG8gZmV0Y2ggZmVlZC5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBmZXRjaGVkTm9zdHJFdmVudHMgPSBhd2FpdCBmZXRjaE5vc3RyRmVlZChoZWFsdGh5UmVsYXlzLCB7XG4gICAgICAgICAgICAgICAgbGltaXQ6IDIwLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB1bmlxdWVQdWJrZXlzID0gQXJyYXkuZnJvbShuZXcgU2V0KGZldGNoZWROb3N0ckV2ZW50cy5tYXAoZXYgPT4gZXYucHVia2V5KSkpO1xuICAgICAgICAgICAgY29uc3QgcHJvZmlsZXNUb0ZldGNoID0gdW5pcXVlUHVia2V5cy5maWx0ZXIocGsgPT4gIXByb2ZpbGVDYWNoZS5jdXJyZW50W3BrXSk7XG5cbiAgICAgICAgICAgIGlmIChwcm9maWxlc1RvRmV0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb2ZpbGVzVG9GZXRjaC5tYXAoYXN5bmMgKHBrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBhd2FpdCBmZXRjaE5vc3RyUHJvZmlsZShoZWFsdGh5UmVsYXlzLCBwayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9maWxlQ2FjaGUuY3VycmVudFtwa10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWV0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJrZXk6IHBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBtZXRhLm5hbWUgfHwgcGssXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRGZWVkID0gZmV0Y2hlZE5vc3RyRXZlbnRzLm1hcCgoZXYpOiBOb3N0ckV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbWVkaWE6IHN0cmluZ1tdID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsUmVnZXggPSAvKGh0dHBzPzpcXC9cXC8oPzpbXFx3LV0rXFwuKStbXFx3LV0rKD86XFwvW1xcd1xcLS5ffjovPyNbXFxdQCEkJicoKSorLDs9XSopP1xcLig/OmpwZ3xqcGVnfHBuZ3xnaWZ8bXA0fHdlYm0pKS9naTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHVybFJlZ2V4LmV4ZWMoZXYuY29udGVudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lZGlhLnB1c2gobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9mID0gcHJvZmlsZUNhY2hlLmN1cnJlbnRbZXYucHVia2V5XSB8fCB7IHB1YmtleTogZXYucHVia2V5LCB1c2VybmFtZTogZXYucHVia2V5IH07XG4gICAgICAgICAgICAgICAgY29uc3QgcGljdHVyZSA9IHVzZXJQcm9mLnBpY3R1cmUgfHwgXCIvZmlsZS5zdmdcIjsgLy8gRGVmYXVsdCBhdmF0YXJcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmV2LFxuICAgICAgICAgICAgICAgICAgICBtZWRpYSxcbiAgICAgICAgICAgICAgICAgICAgcHJvZmlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udXNlclByb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IHVzZXJQcm9mLmRpc3BsYXlfbmFtZSB8fCB1c2VyUHJvZi51c2VybmFtZSB8fCBgJHtldi5wdWJrZXkuc2xpY2UoMCwgNil9Li4uJHtldi5wdWJrZXkuc2xpY2UoLTQpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWN0dXJlOiB1c2VyUHJvZi5waWN0dXJlIHx8IFwiL2ZpbGUuc3ZnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogdXNlclByb2YudXNlcm5hbWUgfHwgZXYucHVia2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHVia2V5OiBldi5wdWJrZXksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucz8udW50aWwpIHtcbiAgICAgICAgICAgICAgICBzZXRFdmVudHMocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSWRzID0gbmV3IFNldChwcmV2Lm1hcChlID0+IGUuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RXZlbnRzID0gcHJvY2Vzc2VkRmVlZC5maWx0ZXIoZSA9PiAhZXhpc3RpbmdJZHMuaGFzKGUuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5wcmV2LCAuLi5uZXdFdmVudHNdLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEV2ZW50cyhwcm9jZXNzZWRGZWVkLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NlZEZlZWQubGVuZ3RoID4gMDtcbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBldmVudHM6XCIsIGVycik7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBmZXRjaCBwb3N0cy4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8gSGVscGVyIHRvIHB1Ymxpc2ggYSBzaWduZWQgZXZlbnRcbiAgICBjb25zdCBwdWJsaXNoRXZlbnQgPSBhc3luYyAoc2lnbmVkRXZlbnQ6IE5vc3RyVG9vbHNFdmVudCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBoZWFsdGh5UmVsYXlzIH0gPSBhd2FpdCBnZXRIZWFsdGh5UmVsYXlzKCk7XG4gICAgICAgICAgICBpZiAoIWhlYWx0aHlSZWxheXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoXCJObyBoZWFsdGh5IHJlbGF5cyBhdmFpbGFibGUgdG8gcHVibGlzaCBldmVudC5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9vbCA9IG5ldyBTaW1wbGVQb29sKCk7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IHBvb2wucHVibGlzaChoZWFsdGh5UmVsYXlzLCBzaWduZWRFdmVudCk7XG4gICAgICAgICAgICAvLyBXYWl0IGZvciBhdCBsZWFzdCBvbmUgc3VjY2Vzc2Z1bCBwdWJsaXNoIG9yIHRpbWVvdXRcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIHZlcnNpb247IG5vc3RyLXRvb2xzJyBwdWJsaXNoIHJldHVybnMgcHJvbWlzZXMgZm9yIGVhY2ggcmVsYXlcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYW55KHByb21pc2VzLm1hcChwID0+IFByb21pc2UucmFjZShbcCwgbmV3IFByb21pc2UoKF8sIHJlaikgPT4gc2V0VGltZW91dCgoKSA9PiByZWoobmV3IEVycm9yKCd0aW1lb3V0JykpLCA1MDAwKSldKSkpO1xuICAgICAgICAgICAgcG9vbC5jbG9zZShoZWFsdGh5UmVsYXlzKTsgLy8gQ2xvc2UgY29ubmVjdGlvbnMgYWZ0ZXIgcHVibGlzaGluZ1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IHRvIHJlbGF5czpcIiwgZXJyKTtcbiAgICAgICAgICAgIHNldEVycm9yKFwiRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQuIFNvbWUgcmVsYXlzIG1pZ2h0IGJlIG9mZmxpbmUuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFBvc3QgZXZlbnQgKHNpZ24gYW5kIHB1Ymxpc2ggdXNpbmcgZXh0ZW5zaW9uKVxuICAgIGNvbnN0IHBvc3QgPSB1c2VDYWxsYmFjayhhc3luYyAoY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vc3RyID0gZ2V0V2luZG93Tm9zdHIoKTtcbiAgICAgICAgaWYgKCFwdWJrZXkgfHwgIW5vc3RyKSB7XG4gICAgICAgICAgICBzZXRFcnJvcihcIk5vdCBsb2dnZWQgaW4gb3IgTk9TVFIgZXh0ZW5zaW9uIG5vdCBmb3VuZC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkRXZlbnQ6IFVuc2lnbmVkRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAga2luZDogMSxcbiAgICAgICAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICAgICAgICAgICAgdGFnczogW10sXG4gICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IG5vc3RyLnNpZ25FdmVudCh1bnNpZ25lZEV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKGF3YWl0IHB1Ymxpc2hFdmVudChzaWduZWRFdmVudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBPcHRpbWlzdGljIHVwZGF0ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQcm9maWxlID0gcHJvZmlsZUNhY2hlLmN1cnJlbnRbcHVia2V5XSB8fCB7IHB1YmtleSwgdXNlcm5hbWU6IHB1YmtleSB9O1xuICAgICAgICAgICAgICAgIHNldEV2ZW50cyhwcmV2ID0+IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNpZ25lZEV2ZW50LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHVia2V5OiBzaWduZWRFdmVudC5wdWJrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBzaWduZWRFdmVudC5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogc2lnbmVkRXZlbnQuY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IHNpZ25lZEV2ZW50LmtpbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiBzaWduZWRFdmVudC50YWdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWE6IFtdLCAvLyBEZXJpdmUgbWVkaWEgaWYgbmVlZGVkLCBvciBsZWF2ZSBmb3IgZGlzcGxheSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGN1cnJlbnRQcm9maWxlLmRpc3BsYXlfbmFtZSB8fCBjdXJyZW50UHJvZmlsZS51c2VybmFtZSB8fCBgJHtwdWJrZXkuc2xpY2UoMCwgNil9Li4uJHtwdWJrZXkuc2xpY2UoLTQpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IGN1cnJlbnRQcm9maWxlLnVzZXJuYW1lIHx8IHB1YmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWN0dXJlOiBjdXJyZW50UHJvZmlsZS5waWN0dXJlIHx8IFwiL2ZpbGUuc3ZnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVia2V5OiBwdWJrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICAgICAgXS5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcG9zdCBldmVudDpcIiwgZXJyKTtcbiAgICAgICAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIHBvc3QuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW3B1YmtleSwgcHJvZmlsZV0pO1xuXG4gICAgLy8gVXBkYXRlIHByb2ZpbGUgKEtpbmQgMClcbiAgICBjb25zdCB1cGRhdGVQcm9maWxlTWV0YWRhdGEgPSB1c2VDYWxsYmFjayhhc3luYyAobmV3UHJvZmlsZURhdGE6IE5vc3RyUHJvZmlsZSkgPT4ge1xuICAgICAgICBjb25zdCBub3N0ciA9IGdldFdpbmRvd05vc3RyKCk7XG4gICAgICAgIGlmICghcHVia2V5IHx8ICFub3N0cikge1xuICAgICAgICAgICAgc2V0RXJyb3IoXCJOb3QgbG9nZ2VkIGluIG9yIE5PU1RSIGV4dGVuc2lvbiBub3QgZm91bmQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgb25seSB2YWxpZCBwcm9maWxlIGZpZWxkcyBhcmUgaW5jbHVkZWRcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRQYXlsb2FkOiBhbnkgPSB7fTtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS51c2VybmFtZSAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5uYW1lID0gbmV3UHJvZmlsZURhdGEudXNlcm5hbWU7IC8vIEFsd2F5cyBzZXQgJ25hbWUnIGZyb20gJ3VzZXJuYW1lJ1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLmRpc3BsYXlfbmFtZSAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5kaXNwbGF5X25hbWUgPSBuZXdQcm9maWxlRGF0YS5kaXNwbGF5X25hbWU7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEuYWJvdXQgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQuYWJvdXQgPSBuZXdQcm9maWxlRGF0YS5hYm91dDtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS5waWN0dXJlICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLnBpY3R1cmUgPSBuZXdQcm9maWxlRGF0YS5waWN0dXJlO1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLmJhbm5lciAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5iYW5uZXIgPSBuZXdQcm9maWxlRGF0YS5iYW5uZXI7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEud2Vic2l0ZSAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC53ZWJzaXRlID0gbmV3UHJvZmlsZURhdGEud2Vic2l0ZTtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS5sdWQwNiAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5sdWQwNiA9IG5ld1Byb2ZpbGVEYXRhLmx1ZDA2O1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLmx1ZDE2ICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLmx1ZDE2ID0gbmV3UHJvZmlsZURhdGEubHVkMTY7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEubmlwMDUgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQubmlwMDUgPSBuZXdQcm9maWxlRGF0YS5uaXAwNTtcblxuXG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZEV2ZW50OiBVbnNpZ25lZEV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IDAsXG4gICAgICAgICAgICAgICAgcHVia2V5LFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICAgICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KGNvbnRlbnRQYXlsb2FkKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IG5vc3RyLnNpZ25FdmVudCh1bnNpZ25lZEV2ZW50KTtcbiAgICAgICAgICAgIGlmIChhd2FpdCBwdWJsaXNoRXZlbnQoc2lnbmVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEZ1bGxQcm9maWxlID0geyAuLi5wcm9maWxlLCAuLi5uZXdQcm9maWxlRGF0YSwgcHVia2V5LCB1c2VybmFtZTogbmV3UHJvZmlsZURhdGEudXNlcm5hbWUgfTtcbiAgICAgICAgICAgICAgICBzZXRQcm9maWxlKHVwZGF0ZWRGdWxsUHJvZmlsZSk7XG4gICAgICAgICAgICAgICAgcHJvZmlsZUNhY2hlLmN1cnJlbnRbcHVia2V5XSA9IHVwZGF0ZWRGdWxsUHJvZmlsZTsgLy8gVXBkYXRlIGNhY2hlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBwcm9maWxlOlwiLCBlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gdXBkYXRlIHByb2ZpbGUuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW3B1YmtleSwgcHJvZmlsZV0pO1xuXG4gICAgLy8gTWFuYWdlIGNvbnRhY3QgbGlzdCAoS2luZCAzKVxuICAgIGNvbnN0IHVwZGF0ZUNvbnRhY3RMaXN0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKG5ld0ZvbGxvd2luZ1B1YmtleXM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vc3RyID0gZ2V0V2luZG93Tm9zdHIoKTtcbiAgICAgICAgaWYgKCFwdWJrZXkgfHwgIW5vc3RyKSB7XG4gICAgICAgICAgICBzZXRFcnJvcihcIk5vdCBsb2dnZWQgaW4gb3IgTk9TVFIgZXh0ZW5zaW9uIG5vdCBmb3VuZC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5JUC0wMiByZWNvbW1lbmRzIHByZXNlcnZpbmcgZXhpc3Rpbmcgbm9uLVwicFwiIHRhZ3MgaWYgYW55LlxuICAgICAgICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHRoaXMgZXhhbXBsZSBvbmx5IG1hbmFnZXMgXCJwXCIgdGFncy5cbiAgICAgICAgICAgIC8vIEZldGNoIGV4aXN0aW5nIGNvbnRhY3QgbGlzdCB0byBwcmVzZXJ2ZSBvdGhlciB0YWdzIGlmIG5lY2Vzc2FyeSAobW9yZSBjb21wbGV4KVxuXG4gICAgICAgICAgICBjb25zdCB0YWdzID0gbmV3Rm9sbG93aW5nUHVia2V5cy5tYXAocGsgPT4gW1wicFwiLCBwa10pO1xuICAgICAgICAgICAgY29uc3QgdW5zaWduZWRFdmVudDogVW5zaWduZWRFdmVudCA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiAzLFxuICAgICAgICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgICAgICAgICB0YWdzOiB0YWdzLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsIC8vIE9yIEpTT04gc3RyaW5nIG9mIHJlbGF5IGhpbnRzIHBlciBOSVAtMDJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IG5vc3RyLnNpZ25FdmVudCh1bnNpZ25lZEV2ZW50KTtcbiAgICAgICAgICAgIGlmIChhd2FpdCBwdWJsaXNoRXZlbnQoc2lnbmVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgc2V0Rm9sbG93aW5nKG5ld0ZvbGxvd2luZ1B1YmtleXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byB1cGRhdGUgY29udGFjdCBsaXN0OlwiLCBlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gdXBkYXRlIGNvbnRhY3QgbGlzdC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBbcHVia2V5XSk7XG5cbiAgICBjb25zdCBmb2xsb3dVc2VyID0gdXNlQ2FsbGJhY2soYXN5bmMgKHVzZXJQdWJrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoZm9sbG93aW5nLmluY2x1ZGVzKHVzZXJQdWJrZXkpKSByZXR1cm4gdHJ1ZTsgLy8gQWxyZWFkeSBmb2xsb3dpbmdcbiAgICAgICAgY29uc3QgbmV3Rm9sbG93aW5nTGlzdCA9IFsuLi5mb2xsb3dpbmcsIHVzZXJQdWJrZXldO1xuICAgICAgICByZXR1cm4gYXdhaXQgdXBkYXRlQ29udGFjdExpc3QobmV3Rm9sbG93aW5nTGlzdCk7XG4gICAgfSwgW2ZvbGxvd2luZywgdXBkYXRlQ29udGFjdExpc3RdKTtcblxuICAgIGNvbnN0IHVuZm9sbG93VXNlciA9IHVzZUNhbGxiYWNrKGFzeW5jICh1c2VyUHVia2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKCFmb2xsb3dpbmcuaW5jbHVkZXModXNlclB1YmtleSkpIHJldHVybiB0cnVlOyAvLyBOb3QgZm9sbG93aW5nXG4gICAgICAgIGNvbnN0IG5ld0ZvbGxvd2luZ0xpc3QgPSBmb2xsb3dpbmcuZmlsdGVyKHBrID0+IHBrICE9PSB1c2VyUHVia2V5KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHVwZGF0ZUNvbnRhY3RMaXN0KG5ld0ZvbGxvd2luZ0xpc3QpO1xuICAgIH0sIFtmb2xsb3dpbmcsIHVwZGF0ZUNvbnRhY3RMaXN0XSk7XG5cblxuICAgIGNvbnN0IGlzRm9sbG93aW5nID0gdXNlQ2FsbGJhY2soKHVzZXJQdWJrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICByZXR1cm4gZm9sbG93aW5nLmluY2x1ZGVzKHVzZXJQdWJrZXkpO1xuICAgIH0sIFtmb2xsb3dpbmddKTtcblxuICAgIC8vIEVmZmVjdCB0byBsb2FkIGluaXRpYWwgZm9sbG93aW5nIGxpc3QgZm9yIHRoZSBsb2dnZWQtaW4gdXNlclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwdWJrZXkpIHtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBoZWFsdGh5UmVsYXlzIH0gPSBhd2FpdCBnZXRIZWFsdGh5UmVsYXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFsdGh5UmVsYXlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBjb3JyZWN0IGZpbHRlciB0eXBlIGZvciBub3N0ci10b29sc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kczogWzNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9yczogW3B1YmtleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogRmlsdGVyIHR5cGUgaXMgYnJvYWRlciB0aGFuIEZlZWRPcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhY3RMaXN0RXZlbnRzID0gYXdhaXQgZmV0Y2hOb3N0ckZlZWQoaGVhbHRoeVJlbGF5cywgZmlsdGVyKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdExpc3RFdmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF0ZXN0Q29udGFjdExpc3QgPSBjb250YWN0TGlzdEV2ZW50cy5zb3J0KChhOiBhbnksIGI6IGFueSkgPT4gYi5jcmVhdGVkX2F0IC0gYS5jcmVhdGVkX2F0KVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvbGxvd2VkUHVia2V5cyA9IGxhdGVzdENvbnRhY3RMaXN0LnRhZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh0YWc6IHN0cmluZ1tdKSA9PiB0YWdbMF0gPT09ICdwJyAmJiB0YWdbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgodGFnOiBzdHJpbmdbXSkgPT4gdGFnWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEZvbGxvd2luZyhmb2xsb3dlZFB1YmtleXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggaW5pdGlhbCBjb250YWN0IGxpc3Q6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldEZvbGxvd2luZyhbXSk7IC8vIENsZWFyIGZvbGxvd2luZyBsaXN0IGlmIG5vdCBsb2dnZWQgaW5cbiAgICAgICAgfVxuICAgIH0sIFtwdWJrZXldKTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHVia2V5LFxuICAgICAgICBldmVudHMsXG4gICAgICAgIHByb2ZpbGUsXG4gICAgICAgIGZvbGxvd2luZyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgcmVsYXlTdGF0cyxcbiAgICAgICAgbG9naW4sXG4gICAgICAgIGZldGNoRXZlbnRzLFxuICAgICAgICBwb3N0LFxuICAgICAgICB1cGRhdGVQcm9maWxlOiB1cGRhdGVQcm9maWxlTWV0YWRhdGEsIC8vIFJlbmFtZWQgZm9yIGNsYXJpdHlcbiAgICAgICAgZm9sbG93VXNlcixcbiAgICAgICAgdW5mb2xsb3dVc2VyLFxuICAgICAgICBpc0ZvbGxvd2luZyxcbiAgICAgICAgc2V0RXZlbnRzLCAvLyBFeHBvc2luZyBzZXR0ZXJzIGNhbiBiZSB1c2VmdWwgYnV0IHVzZSB3aXRoIGNhdXRpb25cbiAgICAgICAgc2V0UHJvZmlsZSxcbiAgICAgICAgc2V0Rm9sbG93aW5nLFxuICAgIH07XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJmZXRjaE5vc3RyRmVlZCIsImZldGNoTm9zdHJQcm9maWxlIiwiZ2V0SGVhbHRoeVJlbGF5cyIsIlNpbXBsZVBvb2wiLCJSRUxBWVMiLCJ1c2VOb3N0ciIsInB1YmtleSIsInNldFB1YmtleSIsImV2ZW50cyIsInNldEV2ZW50cyIsInByb2ZpbGUiLCJzZXRQcm9maWxlIiwiZm9sbG93aW5nIiwic2V0Rm9sbG93aW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsInJlbGF5U3RhdHMiLCJzZXRSZWxheVN0YXRzIiwicHJvZmlsZUNhY2hlIiwiZ2V0V2luZG93Tm9zdHIiLCJ3aW5kb3ciLCJub3N0ciIsInN0b3JlZFB1YmtleSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzZXRJdGVtIiwibG9naW4iLCJwayIsImdldFB1YmxpY0tleSIsIm1lc3NhZ2UiLCJEYXRlIiwibm93Iiwic2lnbk1lc3NhZ2UiLCJzaWduYXR1cmUiLCJjb25zb2xlIiwibG9nIiwiZXJyIiwid2FybiIsImhlYWx0aHlSZWxheXMiLCJsZW5ndGgiLCJ1c2VyUHJvZmlsZURhdGEiLCJ1c2VyUHJvZmlsZSIsInVzZXJuYW1lIiwibmFtZSIsImN1cnJlbnQiLCJmZXRjaEV2ZW50cyIsIm9wdGlvbnMiLCJoZWFsdGh5Q291bnQiLCJ0b3RhbENvdW50IiwiZmV0Y2hlZE5vc3RyRXZlbnRzIiwibGltaXQiLCJ1bmlxdWVQdWJrZXlzIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwibWFwIiwiZXYiLCJwcm9maWxlc1RvRmV0Y2giLCJmaWx0ZXIiLCJQcm9taXNlIiwiYWxsIiwibWV0YSIsInByb2Nlc3NlZEZlZWQiLCJtZWRpYSIsInVybFJlZ2V4IiwibWF0Y2giLCJleGVjIiwiY29udGVudCIsInB1c2giLCJ1c2VyUHJvZiIsInBpY3R1cmUiLCJkaXNwbGF5X25hbWUiLCJzbGljZSIsInVudGlsIiwicHJldiIsImV4aXN0aW5nSWRzIiwiZSIsImlkIiwibmV3RXZlbnRzIiwiaGFzIiwic29ydCIsImEiLCJiIiwiY3JlYXRlZF9hdCIsInB1Ymxpc2hFdmVudCIsInNpZ25lZEV2ZW50IiwicG9vbCIsInByb21pc2VzIiwicHVibGlzaCIsImFueSIsInAiLCJyYWNlIiwiXyIsInJlaiIsInNldFRpbWVvdXQiLCJFcnJvciIsImNsb3NlIiwicG9zdCIsInVuc2lnbmVkRXZlbnQiLCJraW5kIiwiTWF0aCIsImZsb29yIiwidGFncyIsInNpZ25FdmVudCIsImN1cnJlbnRQcm9maWxlIiwidXBkYXRlUHJvZmlsZU1ldGFkYXRhIiwibmV3UHJvZmlsZURhdGEiLCJjb250ZW50UGF5bG9hZCIsInVuZGVmaW5lZCIsImFib3V0IiwiYmFubmVyIiwid2Vic2l0ZSIsImx1ZDA2IiwibHVkMTYiLCJuaXAwNSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1cGRhdGVkRnVsbFByb2ZpbGUiLCJ1cGRhdGVDb250YWN0TGlzdCIsIm5ld0ZvbGxvd2luZ1B1YmtleXMiLCJmb2xsb3dVc2VyIiwidXNlclB1YmtleSIsImluY2x1ZGVzIiwibmV3Rm9sbG93aW5nTGlzdCIsInVuZm9sbG93VXNlciIsImlzRm9sbG93aW5nIiwia2luZHMiLCJhdXRob3JzIiwiY29udGFjdExpc3RFdmVudHMiLCJsYXRlc3RDb250YWN0TGlzdCIsImZvbGxvd2VkUHVia2V5cyIsInRhZyIsInVwZGF0ZVByb2ZpbGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useNostr.ts\n"));

/***/ })

});