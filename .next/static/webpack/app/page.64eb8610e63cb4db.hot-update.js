"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useNostr.ts":
/*!*******************************!*\
  !*** ./src/hooks/useNostr.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RELAYS: () => (/* binding */ RELAYS),\n/* harmony export */   useNostr: () => (/* binding */ useNostr)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/nostr/relay */ \"(app-pages-browser)/./src/lib/nostr/relay.ts\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/../node_modules/nostr-tools/lib/esm/index.js\");\n\n\n\nconst RELAYS = [\n    \"wss://relay.damus.io\",\n    \"wss://relay.nostr.band\",\n    \"wss://nostr-pub.wellorder.net\"\n];\nfunction useNostr() {\n    const [pubkey, setPubkey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [profile, setProfile] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null); // Current user's profile\n    const [following, setFollowing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]); // List of pubkeys the user follows\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false); // General loading state\n    const [relayStats, setRelayStats] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const profileCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const getWindowNostr = ()=>{\n        return window.nostr;\n    };\n    // --- Persist pubkey in localStorage ---\n    // On mount, rehydrate pubkey from localStorage if present\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if (true) {\n                const storedPubkey = window.localStorage.getItem('nostr_pubkey');\n                if (storedPubkey && !pubkey) {\n                    setPubkey(storedPubkey);\n                }\n            }\n        }\n    }[\"useNostr.useEffect\"], []);\n    // When pubkey changes, persist to localStorage\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if ( true && pubkey) {\n                window.localStorage.setItem('nostr_pubkey', pubkey);\n            }\n        }\n    }[\"useNostr.useEffect\"], [\n        pubkey\n    ]);\n    // Auth/login\n    const login = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[login]\": async ()=>{\n            const nostr = getWindowNostr();\n            if (nostr) {\n                setIsLoading(true);\n                setError(null);\n                try {\n                    const pk = await nostr.getPublicKey();\n                    setPubkey(pk);\n                    // Optional: Schnorr signing for custom message (e.g., NIP-42 auth)\n                    const message = \"Login to RAW.ROCKS: \".concat(Date.now());\n                    if (typeof nostr.signMessage === \"function\") {\n                        try {\n                            const signature = await nostr.signMessage(message);\n                            console.log(\"Signed login message:\", signature);\n                        } catch (err) {\n                            console.warn(\"signMessage for login failed:\", err);\n                        }\n                    } else {\n                        console.warn(\"signMessage is not supported by this NOSTR extension.\");\n                    }\n                    // Load profile from relays\n                    const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                    if (healthyRelays.length > 0) {\n                        const userProfileData = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrProfile)(healthyRelays, pk);\n                        if (userProfileData) {\n                            const userProfile = {\n                                ...userProfileData,\n                                pubkey: pk\n                            };\n                            setProfile(userProfile);\n                            profileCache.current[pk] = userProfile;\n                        }\n                    } else {\n                        console.warn(\"No healthy relays to fetch initial profile.\");\n                    }\n                } catch (err) {\n                    console.error(\"Login failed:\", err);\n                    setError(err.message || \"Login failed. Please ensure your NOSTR extension is configured.\");\n                    setPubkey(null);\n                } finally{\n                    setIsLoading(false);\n                }\n            } else {\n                setError(\"NOSTR extension not found. Please install a NOSTR browser extension.\");\n            // alert(\"NOSTR extension not found. Please install a NOSTR browser extension.\");\n            }\n        }\n    }[\"useNostr.useCallback[login]\"], []);\n    // Fetch feed with pagination support\n    const fetchEvents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[fetchEvents]\": async (options)=>{\n            setIsLoading(true);\n            setError(null);\n            try {\n                const { healthyRelays, healthyCount, totalCount } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                setRelayStats({\n                    healthyCount,\n                    totalCount\n                });\n                if (!healthyRelays.length) {\n                    setError(\"No healthy relays available to fetch feed.\");\n                    return false;\n                }\n                const fetchedNostrEvents = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrFeed)(healthyRelays, {\n                    limit: 20,\n                    ...options\n                });\n                const uniquePubkeys = Array.from(new Set(fetchedNostrEvents.map({\n                    \"useNostr.useCallback[fetchEvents].uniquePubkeys\": (ev)=>ev.pubkey\n                }[\"useNostr.useCallback[fetchEvents].uniquePubkeys\"])));\n                const profilesToFetch = uniquePubkeys.filter({\n                    \"useNostr.useCallback[fetchEvents].profilesToFetch\": (pk)=>!profileCache.current[pk]\n                }[\"useNostr.useCallback[fetchEvents].profilesToFetch\"]);\n                if (profilesToFetch.length > 0) {\n                    await Promise.all(profilesToFetch.map({\n                        \"useNostr.useCallback[fetchEvents]\": async (pk)=>{\n                            const meta = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrProfile)(healthyRelays, pk);\n                            if (meta) {\n                                profileCache.current[pk] = {\n                                    ...meta,\n                                    pubkey: pk\n                                };\n                            }\n                        }\n                    }[\"useNostr.useCallback[fetchEvents]\"]));\n                }\n                const processedFeed = fetchedNostrEvents.map({\n                    \"useNostr.useCallback[fetchEvents].processedFeed\": (ev)=>{\n                        let media = [];\n                        const urlRegex = /(https?:\\/\\/(?:[\\w-]+\\.)+[\\w-]+(?:\\/[\\w\\-._~:/?#[\\]@!$&'()*+,;=]*)?\\.(?:jpg|jpeg|png|gif|mp4|webm))/gi;\n                        let match;\n                        while(match = urlRegex.exec(ev.content)){\n                            media.push(match[1]);\n                        }\n                        const userProf = profileCache.current[ev.pubkey] || {\n                            pubkey: ev.pubkey\n                        };\n                        const displayName = userProf.display_name || userProf.name || \"\".concat(ev.pubkey.slice(0, 6), \"...\").concat(ev.pubkey.slice(-4));\n                        const picture = userProf.picture || \"/file.svg\"; // Default avatar\n                        return {\n                            ...ev,\n                            media,\n                            profile: {\n                                ...userProf,\n                                display_name: displayName,\n                                name: userProf.name || displayName,\n                                picture: picture\n                            }\n                        };\n                    }\n                }[\"useNostr.useCallback[fetchEvents].processedFeed\"]);\n                if (options === null || options === void 0 ? void 0 : options.until) {\n                    setEvents({\n                        \"useNostr.useCallback[fetchEvents]\": (prev)=>{\n                            const existingIds = new Set(prev.map({\n                                \"useNostr.useCallback[fetchEvents]\": (e)=>e.id\n                            }[\"useNostr.useCallback[fetchEvents]\"]));\n                            const newEvents = processedFeed.filter({\n                                \"useNostr.useCallback[fetchEvents].newEvents\": (e)=>!existingIds.has(e.id)\n                            }[\"useNostr.useCallback[fetchEvents].newEvents\"]);\n                            return [\n                                ...prev,\n                                ...newEvents\n                            ].sort({\n                                \"useNostr.useCallback[fetchEvents]\": (a, b)=>b.created_at - a.created_at\n                            }[\"useNostr.useCallback[fetchEvents]\"]);\n                        }\n                    }[\"useNostr.useCallback[fetchEvents]\"]);\n                } else {\n                    setEvents(processedFeed.sort({\n                        \"useNostr.useCallback[fetchEvents]\": (a, b)=>b.created_at - a.created_at\n                    }[\"useNostr.useCallback[fetchEvents]\"]));\n                }\n                return processedFeed.length > 0;\n            } catch (err) {\n                console.error(\"Error fetching events:\", err);\n                setError(err.message || \"Failed to fetch posts. Please try again later.\");\n                return false;\n            } finally{\n                setIsLoading(false);\n            }\n        }\n    }[\"useNostr.useCallback[fetchEvents]\"], []);\n    // Helper to publish a signed event\n    const publishEvent = async (signedEvent)=>{\n        try {\n            const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n            if (!healthyRelays.length) {\n                setError(\"No healthy relays available to publish event.\");\n                return false;\n            }\n            const pool = new nostr_tools__WEBPACK_IMPORTED_MODULE_2__.SimplePool();\n            const promises = pool.publish(healthyRelays, signedEvent);\n            // Wait for at least one successful publish or timeout\n            // This is a simplified version; nostr-tools' publish returns promises for each relay\n            await Promise.any(promises.map((p)=>Promise.race([\n                    p,\n                    new Promise((_, rej)=>setTimeout(()=>rej(new Error('timeout')), 5000))\n                ])));\n            pool.close(healthyRelays); // Close connections after publishing\n            return true;\n        } catch (err) {\n            console.error(\"Failed to publish event to relays:\", err);\n            setError(\"Failed to publish event. Some relays might be offline.\");\n            return false;\n        }\n    };\n    // Post event (sign and publish using extension)\n    const post = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[post]\": async (content)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                const unsignedEvent = {\n                    kind: 1,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: [],\n                    content\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    // Optimistic update\n                    const currentProfile = profileCache.current[pubkey] || {\n                        pubkey\n                    };\n                    setEvents({\n                        \"useNostr.useCallback[post]\": (prev)=>[\n                                {\n                                    id: signedEvent.id,\n                                    pubkey: signedEvent.pubkey,\n                                    content: signedEvent.content,\n                                    created_at: signedEvent.created_at,\n                                    kind: signedEvent.kind,\n                                    tags: signedEvent.tags,\n                                    media: [],\n                                    profile: {\n                                        display_name: currentProfile.display_name || currentProfile.name || \"\".concat(pubkey.slice(0, 6), \"...\").concat(pubkey.slice(-4)),\n                                        name: currentProfile.name || \"\".concat(pubkey.slice(0, 6), \"...\").concat(pubkey.slice(-4)),\n                                        picture: currentProfile.picture || \"/file.svg\",\n                                        pubkey: pubkey\n                                    }\n                                },\n                                ...prev\n                            ].sort({\n                                \"useNostr.useCallback[post]\": (a, b)=>b.created_at - a.created_at\n                            }[\"useNostr.useCallback[post]\"])\n                    }[\"useNostr.useCallback[post]\"]);\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to post event:\", err);\n                setError(err.message || \"Failed to post. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[post]\"], [\n        pubkey,\n        profile\n    ]);\n    // Update profile (Kind 0)\n    const updateProfileMetadata = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[updateProfileMetadata]\": async (newProfileData)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                // Ensure only valid profile fields are included\n                const contentPayload = {};\n                if (newProfileData.name !== undefined) contentPayload.name = newProfileData.name;\n                if (newProfileData.display_name !== undefined) contentPayload.display_name = newProfileData.display_name;\n                if (newProfileData.about !== undefined) contentPayload.about = newProfileData.about;\n                if (newProfileData.picture !== undefined) contentPayload.picture = newProfileData.picture;\n                if (newProfileData.banner !== undefined) contentPayload.banner = newProfileData.banner;\n                if (newProfileData.website !== undefined) contentPayload.website = newProfileData.website;\n                if (newProfileData.lud06 !== undefined) contentPayload.lud06 = newProfileData.lud06;\n                if (newProfileData.lud16 !== undefined) contentPayload.lud16 = newProfileData.lud16;\n                if (newProfileData.nip05 !== undefined) contentPayload.nip05 = newProfileData.nip05;\n                const unsignedEvent = {\n                    kind: 0,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: [],\n                    content: JSON.stringify(contentPayload)\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    const updatedFullProfile = {\n                        ...profile,\n                        ...newProfileData,\n                        pubkey\n                    };\n                    setProfile(updatedFullProfile);\n                    profileCache.current[pubkey] = updatedFullProfile; // Update cache\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to update profile:\", err);\n                setError(err.message || \"Failed to update profile. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[updateProfileMetadata]\"], [\n        pubkey,\n        profile\n    ]);\n    // Manage contact list (Kind 3)\n    const updateContactList = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[updateContactList]\": async (newFollowingPubkeys)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                // NIP-02 recommends preserving existing non-\"p\" tags if any.\n                // For simplicity, this example only manages \"p\" tags.\n                // Fetch existing contact list to preserve other tags if necessary (more complex)\n                const tags = newFollowingPubkeys.map({\n                    \"useNostr.useCallback[updateContactList].tags\": (pk)=>[\n                            \"p\",\n                            pk\n                        ]\n                }[\"useNostr.useCallback[updateContactList].tags\"]);\n                const unsignedEvent = {\n                    kind: 3,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: tags,\n                    content: \"\"\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    setFollowing(newFollowingPubkeys);\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to update contact list:\", err);\n                setError(err.message || \"Failed to update contact list. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[updateContactList]\"], [\n        pubkey\n    ]);\n    const followUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[followUser]\": async (userPubkey)=>{\n            if (following.includes(userPubkey)) return true; // Already following\n            const newFollowingList = [\n                ...following,\n                userPubkey\n            ];\n            return await updateContactList(newFollowingList);\n        }\n    }[\"useNostr.useCallback[followUser]\"], [\n        following,\n        updateContactList\n    ]);\n    const unfollowUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[unfollowUser]\": async (userPubkey)=>{\n            if (!following.includes(userPubkey)) return true; // Not following\n            const newFollowingList = following.filter({\n                \"useNostr.useCallback[unfollowUser].newFollowingList\": (pk)=>pk !== userPubkey\n            }[\"useNostr.useCallback[unfollowUser].newFollowingList\"]);\n            return await updateContactList(newFollowingList);\n        }\n    }[\"useNostr.useCallback[unfollowUser]\"], [\n        following,\n        updateContactList\n    ]);\n    const isFollowing = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[isFollowing]\": (userPubkey)=>{\n            return following.includes(userPubkey);\n        }\n    }[\"useNostr.useCallback[isFollowing]\"], [\n        following\n    ]);\n    // Effect to load initial following list for the logged-in user\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if (pubkey) {\n                ({\n                    \"useNostr.useEffect\": async ()=>{\n                        try {\n                            const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                            if (healthyRelays.length === 0) return;\n                            // @ts-expect-error: authors is a valid filter for nostr-tools, but not in our FeedOptions type\n                            const contactListEvents = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrFeed)(healthyRelays, {\n                                kinds: [\n                                    3\n                                ],\n                                authors: [\n                                    pubkey\n                                ],\n                                limit: 1\n                            });\n                            if (contactListEvents.length > 0) {\n                                const latestContactList = contactListEvents.sort({\n                                    \"useNostr.useEffect\": (a, b)=>b.created_at - a.created_at\n                                }[\"useNostr.useEffect\"])[0];\n                                const followedPubkeys = latestContactList.tags.filter({\n                                    \"useNostr.useEffect.followedPubkeys\": (tag)=>tag[0] === 'p' && tag[1]\n                                }[\"useNostr.useEffect.followedPubkeys\"]).map({\n                                    \"useNostr.useEffect.followedPubkeys\": (tag)=>tag[1]\n                                }[\"useNostr.useEffect.followedPubkeys\"]);\n                                setFollowing(followedPubkeys);\n                            }\n                        } catch (err) {\n                            console.error(\"Failed to fetch initial contact list:\", err);\n                        }\n                    }\n                })[\"useNostr.useEffect\"]();\n            } else {\n                setFollowing([]); // Clear following list if not logged in\n            }\n        }\n    }[\"useNostr.useEffect\"], [\n        pubkey\n    ]);\n    return {\n        pubkey,\n        events,\n        profile,\n        following,\n        error,\n        isLoading,\n        relayStats,\n        login,\n        fetchEvents,\n        post,\n        updateProfile: updateProfileMetadata,\n        followUser,\n        unfollowUser,\n        isFollowing,\n        setEvents,\n        setProfile,\n        setFollowing\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VOb3N0ci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUU7QUFDdUI7QUFTeUI7QUFnQjFHLE1BQU1RLFNBQVM7SUFDbEI7SUFDQTtJQUNBO0NBRUgsQ0FBQztBQTJCSyxTQUFTQztJQUNaLE1BQU0sQ0FBQ0MsUUFBUUMsVUFBVSxHQUFHWCwrQ0FBUUEsQ0FBZ0I7SUFDcEQsTUFBTSxDQUFDWSxRQUFRQyxVQUFVLEdBQUdiLCtDQUFRQSxDQUFlLEVBQUU7SUFDckQsTUFBTSxDQUFDYyxTQUFTQyxXQUFXLEdBQUdmLCtDQUFRQSxDQUFzQixPQUFPLHlCQUF5QjtJQUM1RixNQUFNLENBQUNnQixXQUFXQyxhQUFhLEdBQUdqQiwrQ0FBUUEsQ0FBVyxFQUFFLEdBQUcsbUNBQW1DO0lBQzdGLE1BQU0sQ0FBQ2tCLE9BQU9DLFNBQVMsR0FBR25CLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUNvQixXQUFXQyxhQUFhLEdBQUdyQiwrQ0FBUUEsQ0FBVSxRQUFRLHdCQUF3QjtJQUNwRixNQUFNLENBQUNzQixZQUFZQyxjQUFjLEdBQUd2QiwrQ0FBUUEsQ0FBdUQ7SUFDbkcsTUFBTXdCLGVBQWV0Qiw2Q0FBTUEsQ0FBcUMsQ0FBQztJQUVqRSxNQUFNdUIsaUJBQWlCO1FBQ25CLE9BQU9DLE9BQU9DLEtBQUs7SUFDdkI7SUFFQSx5Q0FBeUM7SUFDekMsMERBQTBEO0lBQzFEeEIsZ0RBQVNBOzhCQUFDO1lBQ04sSUFBSSxJQUE2QixFQUFFO2dCQUMvQixNQUFNeUIsZUFBZUYsT0FBT0csWUFBWSxDQUFDQyxPQUFPLENBQUM7Z0JBQ2pELElBQUlGLGdCQUFnQixDQUFDbEIsUUFBUTtvQkFDekJDLFVBQVVpQjtnQkFDZDtZQUNKO1FBQ0o7NkJBQUcsRUFBRTtJQUVMLCtDQUErQztJQUMvQ3pCLGdEQUFTQTs4QkFBQztZQUNOLElBQUksS0FBNkIsSUFBSU8sUUFBUTtnQkFDekNnQixPQUFPRyxZQUFZLENBQUNF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QUM7UUFDQXRIO1FBQ0FFO1FBQ0FFO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL3NyYy9ob29rcy91c2VOb3N0ci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBmZXRjaE5vc3RyRmVlZCwgZmV0Y2hOb3N0clByb2ZpbGUsIGdldEhlYWx0aHlSZWxheXMgfSBmcm9tIFwiQC9saWIvbm9zdHIvcmVsYXlcIjtcblxuLy8gRXh0ZW5kIEZlZWRPcHRpb25zIHRvIGluY2x1ZGUgJ2F1dGhvcnMnXG5leHBvcnQgaW50ZXJmYWNlIEZlZWRPcHRpb25zIHtcbiAgICBsaW1pdD86IG51bWJlcjtcbiAgICB1bnRpbD86IG51bWJlcjtcbiAgICBraW5kcz86IG51bWJlcltdO1xuICAgIGF1dGhvcnM/OiBzdHJpbmdbXTsgLy8gQWRkZWQgYXV0aG9ycyBwcm9wZXJ0eSB0byBtYXRjaCB1c2FnZVxufVxuaW1wb3J0IHsgU2ltcGxlUG9vbCwgbmlwMTksIHR5cGUgRXZlbnQgYXMgTm9zdHJUb29sc0V2ZW50LCB0eXBlIFVuc2lnbmVkRXZlbnQsIGdldEV2ZW50SGFzaCB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuXG4vLyBEZWZpbmUgdGhlIE5JUC0wNyB3aW5kb3cubm9zdHIgaW50ZXJmYWNlXG5pbnRlcmZhY2UgV2luZG93Tm9zdHIge1xuICAgIGdldFB1YmxpY0tleSgpOiBQcm9taXNlPHN0cmluZz47XG4gICAgc2lnbkV2ZW50KGV2ZW50OiBVbnNpZ25lZEV2ZW50KTogUHJvbWlzZTxOb3N0clRvb2xzRXZlbnQ+O1xuICAgIHNpZ25NZXNzYWdlPyhtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz47IC8vIE9wdGlvbmFsIE5JUC00MiBvciBjdXN0b20gdXNhZ2VcbiAgICBnZXRSZWxheXM/KCk6IFByb21pc2U8eyBbdXJsOiBzdHJpbmddOiB7IHJlYWQ6IGJvb2xlYW47IHdyaXRlOiBib29sZWFuIH0gfT47IC8vIE9wdGlvbmFsXG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICAgICAgbm9zdHI/OiBXaW5kb3dOb3N0cjtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBSRUxBWVMgPSBbXG4gICAgXCJ3c3M6Ly9yZWxheS5kYW11cy5pb1wiLFxuICAgIFwid3NzOi8vcmVsYXkubm9zdHIuYmFuZFwiLFxuICAgIFwid3NzOi8vbm9zdHItcHViLndlbGxvcmRlci5uZXRcIixcbiAgICAvLyBBZGQgbW9yZSBkZWZhdWx0IHJlbGF5cyBvciBtYWtlIHRoaXMgY29uZmlndXJhYmxlXG5dO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5vc3RyUHJvZmlsZSB7XG4gICAgbmFtZT86IHN0cmluZzsgLy8gTklQLTAxIGZpZWxkIGZvciB1c2VybmFtZVxuICAgIGRpc3BsYXlfbmFtZT86IHN0cmluZzsgLy8gTklQLTAxIGZpZWxkIGZvciBkaXNwbGF5IG5hbWVcbiAgICBhYm91dD86IHN0cmluZzsgLy8gTklQLTAxIGZpZWxkIGZvciBiaW9cbiAgICBwaWN0dXJlPzogc3RyaW5nOyAvLyBOSVAtMDEgZmllbGQgZm9yIHBpY3R1cmUgVVJMXG4gICAgYmFubmVyPzogc3RyaW5nOyAvLyBOSVAtMDEgZmllbGQgZm9yIGJhbm5lciBVUkxcbiAgICB3ZWJzaXRlPzogc3RyaW5nOyAvLyBOSVAtMDEgZmllbGQgZm9yIHdlYnNpdGVcbiAgICBsdWQwNj86IHN0cmluZzsgLy8gTklQLTAxIGZpZWxkIGZvciBMTiBVUkwgKHBheW55bSlcbiAgICBsdWQxNj86IHN0cmluZzsgLy8gTklQLTAxIGZpZWxkIGZvciBMTiBBZGRyZXNzXG4gICAgbmlwMDU/OiBzdHJpbmc7IC8vIE5JUC0wNSBpZGVudGlmaWVyXG4gICAgcHVia2V5Pzogc3RyaW5nOyAvLyBBZGRlZCBmb3IgY29udmVuaWVuY2Vcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3N0ckV2ZW50IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHB1YmtleTogc3RyaW5nO1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICBjcmVhdGVkX2F0OiBudW1iZXI7XG4gICAga2luZDogbnVtYmVyO1xuICAgIHRhZ3M6IHN0cmluZ1tdW107XG4gICAgbWVkaWE6IHN0cmluZ1tdOyAvLyBDdXN0b20gZGVyaXZlZCBmaWVsZFxuICAgIHByb2ZpbGU/OiBOb3N0clByb2ZpbGU7IC8vIEN1c3RvbSBkZXJpdmVkIGZpZWxkXG4gICAgLy8gQWRkIG90aGVyIGV2ZW50IGZpZWxkcyBpZiBuZWVkZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU5vc3RyKCkge1xuICAgIGNvbnN0IFtwdWJrZXksIHNldFB1YmtleV0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbZXZlbnRzLCBzZXRFdmVudHNdID0gdXNlU3RhdGU8Tm9zdHJFdmVudFtdPihbXSk7XG4gICAgY29uc3QgW3Byb2ZpbGUsIHNldFByb2ZpbGVdID0gdXNlU3RhdGU8Tm9zdHJQcm9maWxlIHwgbnVsbD4obnVsbCk7IC8vIEN1cnJlbnQgdXNlcidzIHByb2ZpbGVcbiAgICBjb25zdCBbZm9sbG93aW5nLCBzZXRGb2xsb3dpbmddID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTsgLy8gTGlzdCBvZiBwdWJrZXlzIHRoZSB1c2VyIGZvbGxvd3NcbiAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7IC8vIEdlbmVyYWwgbG9hZGluZyBzdGF0ZVxuICAgIGNvbnN0IFtyZWxheVN0YXRzLCBzZXRSZWxheVN0YXRzXSA9IHVzZVN0YXRlPHsgaGVhbHRoeUNvdW50OiBudW1iZXI7IHRvdGFsQ291bnQ6IG51bWJlcjsgfSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHByb2ZpbGVDYWNoZSA9IHVzZVJlZjx7IFtwdWJrZXk6IHN0cmluZ106IE5vc3RyUHJvZmlsZSB9Pih7fSk7XG5cbiAgICBjb25zdCBnZXRXaW5kb3dOb3N0ciA9ICgpOiBXaW5kb3dOb3N0ciB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cubm9zdHI7XG4gICAgfTtcblxuICAgIC8vIC0tLSBQZXJzaXN0IHB1YmtleSBpbiBsb2NhbFN0b3JhZ2UgLS0tXG4gICAgLy8gT24gbW91bnQsIHJlaHlkcmF0ZSBwdWJrZXkgZnJvbSBsb2NhbFN0b3JhZ2UgaWYgcHJlc2VudFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkUHVia2V5ID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdub3N0cl9wdWJrZXknKTtcbiAgICAgICAgICAgIGlmIChzdG9yZWRQdWJrZXkgJiYgIXB1YmtleSkge1xuICAgICAgICAgICAgICAgIHNldFB1YmtleShzdG9yZWRQdWJrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8gV2hlbiBwdWJrZXkgY2hhbmdlcywgcGVyc2lzdCB0byBsb2NhbFN0b3JhZ2VcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHVia2V5KSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ25vc3RyX3B1YmtleScsIHB1YmtleSk7XG4gICAgICAgIH1cbiAgICB9LCBbcHVia2V5XSk7XG5cbiAgICAvLyBBdXRoL2xvZ2luXG4gICAgY29uc3QgbG9naW4gPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vc3RyID0gZ2V0V2luZG93Tm9zdHIoKTtcbiAgICAgICAgaWYgKG5vc3RyKSB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGsgPSBhd2FpdCBub3N0ci5nZXRQdWJsaWNLZXkoKTtcbiAgICAgICAgICAgICAgICBzZXRQdWJrZXkocGspO1xuXG4gICAgICAgICAgICAgICAgLy8gT3B0aW9uYWw6IFNjaG5vcnIgc2lnbmluZyBmb3IgY3VzdG9tIG1lc3NhZ2UgKGUuZy4sIE5JUC00MiBhdXRoKVxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgTG9naW4gdG8gUkFXLlJPQ0tTOiAke0RhdGUubm93KCl9YDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vc3RyLnNpZ25NZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IG5vc3RyLnNpZ25NZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTaWduZWQgbG9naW4gbWVzc2FnZTpcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzaWduTWVzc2FnZSBmb3IgbG9naW4gZmFpbGVkOlwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwic2lnbk1lc3NhZ2UgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIE5PU1RSIGV4dGVuc2lvbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTG9hZCBwcm9maWxlIGZyb20gcmVsYXlzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBoZWFsdGh5UmVsYXlzIH0gPSBhd2FpdCBnZXRIZWFsdGh5UmVsYXlzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWx0aHlSZWxheXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyUHJvZmlsZURhdGEgPSBhd2FpdCBmZXRjaE5vc3RyUHJvZmlsZShoZWFsdGh5UmVsYXlzLCBwayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyUHJvZmlsZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9maWxlOiBOb3N0clByb2ZpbGUgPSB7IC4uLnVzZXJQcm9maWxlRGF0YSwgcHVia2V5OiBwayB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UHJvZmlsZSh1c2VyUHJvZmlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9maWxlQ2FjaGUuY3VycmVudFtwa10gPSB1c2VyUHJvZmlsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIGhlYWx0aHkgcmVsYXlzIHRvIGZldGNoIGluaXRpYWwgcHJvZmlsZS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTG9naW4gZmFpbGVkOlwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8IFwiTG9naW4gZmFpbGVkLiBQbGVhc2UgZW5zdXJlIHlvdXIgTk9TVFIgZXh0ZW5zaW9uIGlzIGNvbmZpZ3VyZWQuXCIpO1xuICAgICAgICAgICAgICAgIHNldFB1YmtleShudWxsKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldEVycm9yKFwiTk9TVFIgZXh0ZW5zaW9uIG5vdCBmb3VuZC4gUGxlYXNlIGluc3RhbGwgYSBOT1NUUiBicm93c2VyIGV4dGVuc2lvbi5cIik7XG4gICAgICAgICAgICAvLyBhbGVydChcIk5PU1RSIGV4dGVuc2lvbiBub3QgZm91bmQuIFBsZWFzZSBpbnN0YWxsIGEgTk9TVFIgYnJvd3NlciBleHRlbnNpb24uXCIpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8gRmV0Y2ggZmVlZCB3aXRoIHBhZ2luYXRpb24gc3VwcG9ydFxuICAgIGNvbnN0IGZldGNoRXZlbnRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKG9wdGlvbnM/OiBGZWVkT3B0aW9ucyk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBoZWFsdGh5UmVsYXlzLCBoZWFsdGh5Q291bnQsIHRvdGFsQ291bnQgfSA9IGF3YWl0IGdldEhlYWx0aHlSZWxheXMoKTtcbiAgICAgICAgICAgIHNldFJlbGF5U3RhdHMoeyBoZWFsdGh5Q291bnQsIHRvdGFsQ291bnQgfSk7XG5cbiAgICAgICAgICAgIGlmICghaGVhbHRoeVJlbGF5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihcIk5vIGhlYWx0aHkgcmVsYXlzIGF2YWlsYWJsZSB0byBmZXRjaCBmZWVkLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGZldGNoZWROb3N0ckV2ZW50cyA9IGF3YWl0IGZldGNoTm9zdHJGZWVkKGhlYWx0aHlSZWxheXMsIHtcbiAgICAgICAgICAgICAgICBsaW1pdDogMjAsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVB1YmtleXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoZmV0Y2hlZE5vc3RyRXZlbnRzLm1hcChldiA9PiBldi5wdWJrZXkpKSk7XG4gICAgICAgICAgICBjb25zdCBwcm9maWxlc1RvRmV0Y2ggPSB1bmlxdWVQdWJrZXlzLmZpbHRlcihwayA9PiAhcHJvZmlsZUNhY2hlLmN1cnJlbnRbcGtdKTtcblxuICAgICAgICAgICAgaWYgKHByb2ZpbGVzVG9GZXRjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvZmlsZXNUb0ZldGNoLm1hcChhc3luYyAocGspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGF3YWl0IGZldGNoTm9zdHJQcm9maWxlKGhlYWx0aHlSZWxheXMsIHBrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGVDYWNoZS5jdXJyZW50W3BrXSA9IHsgLi4ubWV0YSwgcHVia2V5OiBwayB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRGZWVkID0gZmV0Y2hlZE5vc3RyRXZlbnRzLm1hcCgoZXYpOiBOb3N0ckV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbWVkaWE6IHN0cmluZ1tdID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsUmVnZXggPSAvKGh0dHBzPzpcXC9cXC8oPzpbXFx3LV0rXFwuKStbXFx3LV0rKD86XFwvW1xcd1xcLS5ffjovPyNbXFxdQCEkJicoKSorLDs9XSopP1xcLig/OmpwZ3xqcGVnfHBuZ3xnaWZ8bXA0fHdlYm0pKS9naTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHVybFJlZ2V4LmV4ZWMoZXYuY29udGVudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lZGlhLnB1c2gobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9mID0gcHJvZmlsZUNhY2hlLmN1cnJlbnRbZXYucHVia2V5XSB8fCB7IHB1YmtleTogZXYucHVia2V5IH07XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzcGxheU5hbWUgPSB1c2VyUHJvZi5kaXNwbGF5X25hbWUgfHwgdXNlclByb2YubmFtZSB8fCBgJHtldi5wdWJrZXkuc2xpY2UoMCwgNil9Li4uJHtldi5wdWJrZXkuc2xpY2UoLTQpfWA7XG4gICAgICAgICAgICAgICAgY29uc3QgcGljdHVyZSA9IHVzZXJQcm9mLnBpY3R1cmUgfHwgXCIvZmlsZS5zdmdcIjsgLy8gRGVmYXVsdCBhdmF0YXJcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmV2LFxuICAgICAgICAgICAgICAgICAgICBtZWRpYSxcbiAgICAgICAgICAgICAgICAgICAgcHJvZmlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udXNlclByb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdXNlclByb2YubmFtZSB8fCBkaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY3R1cmU6IHBpY3R1cmUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucz8udW50aWwpIHtcbiAgICAgICAgICAgICAgICBzZXRFdmVudHMocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSWRzID0gbmV3IFNldChwcmV2Lm1hcChlID0+IGUuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RXZlbnRzID0gcHJvY2Vzc2VkRmVlZC5maWx0ZXIoZSA9PiAhZXhpc3RpbmdJZHMuaGFzKGUuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5wcmV2LCAuLi5uZXdFdmVudHNdLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEV2ZW50cyhwcm9jZXNzZWRGZWVkLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NlZEZlZWQubGVuZ3RoID4gMDtcbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBldmVudHM6XCIsIGVycik7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBmZXRjaCBwb3N0cy4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8gSGVscGVyIHRvIHB1Ymxpc2ggYSBzaWduZWQgZXZlbnRcbiAgICBjb25zdCBwdWJsaXNoRXZlbnQgPSBhc3luYyAoc2lnbmVkRXZlbnQ6IE5vc3RyVG9vbHNFdmVudCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBoZWFsdGh5UmVsYXlzIH0gPSBhd2FpdCBnZXRIZWFsdGh5UmVsYXlzKCk7XG4gICAgICAgICAgICBpZiAoIWhlYWx0aHlSZWxheXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoXCJObyBoZWFsdGh5IHJlbGF5cyBhdmFpbGFibGUgdG8gcHVibGlzaCBldmVudC5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9vbCA9IG5ldyBTaW1wbGVQb29sKCk7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IHBvb2wucHVibGlzaChoZWFsdGh5UmVsYXlzLCBzaWduZWRFdmVudCk7XG4gICAgICAgICAgICAvLyBXYWl0IGZvciBhdCBsZWFzdCBvbmUgc3VjY2Vzc2Z1bCBwdWJsaXNoIG9yIHRpbWVvdXRcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIHZlcnNpb247IG5vc3RyLXRvb2xzJyBwdWJsaXNoIHJldHVybnMgcHJvbWlzZXMgZm9yIGVhY2ggcmVsYXlcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYW55KHByb21pc2VzLm1hcChwID0+IFByb21pc2UucmFjZShbcCwgbmV3IFByb21pc2UoKF8sIHJlaikgPT4gc2V0VGltZW91dCgoKSA9PiByZWoobmV3IEVycm9yKCd0aW1lb3V0JykpLCA1MDAwKSldKSkpO1xuICAgICAgICAgICAgcG9vbC5jbG9zZShoZWFsdGh5UmVsYXlzKTsgLy8gQ2xvc2UgY29ubmVjdGlvbnMgYWZ0ZXIgcHVibGlzaGluZ1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IHRvIHJlbGF5czpcIiwgZXJyKTtcbiAgICAgICAgICAgIHNldEVycm9yKFwiRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQuIFNvbWUgcmVsYXlzIG1pZ2h0IGJlIG9mZmxpbmUuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFBvc3QgZXZlbnQgKHNpZ24gYW5kIHB1Ymxpc2ggdXNpbmcgZXh0ZW5zaW9uKVxuICAgIGNvbnN0IHBvc3QgPSB1c2VDYWxsYmFjayhhc3luYyAoY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vc3RyID0gZ2V0V2luZG93Tm9zdHIoKTtcbiAgICAgICAgaWYgKCFwdWJrZXkgfHwgIW5vc3RyKSB7XG4gICAgICAgICAgICBzZXRFcnJvcihcIk5vdCBsb2dnZWQgaW4gb3IgTk9TVFIgZXh0ZW5zaW9uIG5vdCBmb3VuZC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkRXZlbnQ6IFVuc2lnbmVkRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAga2luZDogMSxcbiAgICAgICAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICAgICAgICAgICAgdGFnczogW10sXG4gICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IG5vc3RyLnNpZ25FdmVudCh1bnNpZ25lZEV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKGF3YWl0IHB1Ymxpc2hFdmVudChzaWduZWRFdmVudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBPcHRpbWlzdGljIHVwZGF0ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQcm9maWxlID0gcHJvZmlsZUNhY2hlLmN1cnJlbnRbcHVia2V5XSB8fCB7IHB1YmtleSB9O1xuICAgICAgICAgICAgICAgIHNldEV2ZW50cyhwcmV2ID0+IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNpZ25lZEV2ZW50LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHVia2V5OiBzaWduZWRFdmVudC5wdWJrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBzaWduZWRFdmVudC5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogc2lnbmVkRXZlbnQuY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IHNpZ25lZEV2ZW50LmtpbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiBzaWduZWRFdmVudC50YWdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWE6IFtdLCAvLyBEZXJpdmUgbWVkaWEgaWYgbmVlZGVkLCBvciBsZWF2ZSBmb3IgZGlzcGxheSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGN1cnJlbnRQcm9maWxlLmRpc3BsYXlfbmFtZSB8fCBjdXJyZW50UHJvZmlsZS5uYW1lIHx8IGAke3B1YmtleS5zbGljZSgwLCA2KX0uLi4ke3B1YmtleS5zbGljZSgtNCl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBjdXJyZW50UHJvZmlsZS5uYW1lIHx8IGAke3B1YmtleS5zbGljZSgwLCA2KX0uLi4ke3B1YmtleS5zbGljZSgtNCl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWN0dXJlOiBjdXJyZW50UHJvZmlsZS5waWN0dXJlIHx8IFwiL2ZpbGUuc3ZnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVia2V5OiBwdWJrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICAgICAgXS5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcG9zdCBldmVudDpcIiwgZXJyKTtcbiAgICAgICAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIHBvc3QuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW3B1YmtleSwgcHJvZmlsZV0pO1xuXG4gICAgLy8gVXBkYXRlIHByb2ZpbGUgKEtpbmQgMClcbiAgICBjb25zdCB1cGRhdGVQcm9maWxlTWV0YWRhdGEgPSB1c2VDYWxsYmFjayhhc3luYyAobmV3UHJvZmlsZURhdGE6IE5vc3RyUHJvZmlsZSkgPT4ge1xuICAgICAgICBjb25zdCBub3N0ciA9IGdldFdpbmRvd05vc3RyKCk7XG4gICAgICAgIGlmICghcHVia2V5IHx8ICFub3N0cikge1xuICAgICAgICAgICAgc2V0RXJyb3IoXCJOb3QgbG9nZ2VkIGluIG9yIE5PU1RSIGV4dGVuc2lvbiBub3QgZm91bmQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgb25seSB2YWxpZCBwcm9maWxlIGZpZWxkcyBhcmUgaW5jbHVkZWRcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRQYXlsb2FkOiBhbnkgPSB7fTtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS5uYW1lICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLm5hbWUgPSBuZXdQcm9maWxlRGF0YS5uYW1lO1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLmRpc3BsYXlfbmFtZSAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5kaXNwbGF5X25hbWUgPSBuZXdQcm9maWxlRGF0YS5kaXNwbGF5X25hbWU7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEuYWJvdXQgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQuYWJvdXQgPSBuZXdQcm9maWxlRGF0YS5hYm91dDtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS5waWN0dXJlICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLnBpY3R1cmUgPSBuZXdQcm9maWxlRGF0YS5waWN0dXJlO1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLmJhbm5lciAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5iYW5uZXIgPSBuZXdQcm9maWxlRGF0YS5iYW5uZXI7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEud2Vic2l0ZSAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC53ZWJzaXRlID0gbmV3UHJvZmlsZURhdGEud2Vic2l0ZTtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS5sdWQwNiAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5sdWQwNiA9IG5ld1Byb2ZpbGVEYXRhLmx1ZDA2O1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLmx1ZDE2ICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLmx1ZDE2ID0gbmV3UHJvZmlsZURhdGEubHVkMTY7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEubmlwMDUgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQubmlwMDUgPSBuZXdQcm9maWxlRGF0YS5uaXAwNTtcblxuXG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZEV2ZW50OiBVbnNpZ25lZEV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IDAsXG4gICAgICAgICAgICAgICAgcHVia2V5LFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICAgICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KGNvbnRlbnRQYXlsb2FkKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IG5vc3RyLnNpZ25FdmVudCh1bnNpZ25lZEV2ZW50KTtcbiAgICAgICAgICAgIGlmIChhd2FpdCBwdWJsaXNoRXZlbnQoc2lnbmVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEZ1bGxQcm9maWxlID0geyAuLi5wcm9maWxlLCAuLi5uZXdQcm9maWxlRGF0YSwgcHVia2V5IH07XG4gICAgICAgICAgICAgICAgc2V0UHJvZmlsZSh1cGRhdGVkRnVsbFByb2ZpbGUpO1xuICAgICAgICAgICAgICAgIHByb2ZpbGVDYWNoZS5jdXJyZW50W3B1YmtleV0gPSB1cGRhdGVkRnVsbFByb2ZpbGU7IC8vIFVwZGF0ZSBjYWNoZVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byB1cGRhdGUgcHJvZmlsZTpcIiwgZXJyKTtcbiAgICAgICAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIHVwZGF0ZSBwcm9maWxlLiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIFtwdWJrZXksIHByb2ZpbGVdKTtcblxuICAgIC8vIE1hbmFnZSBjb250YWN0IGxpc3QgKEtpbmQgMylcbiAgICBjb25zdCB1cGRhdGVDb250YWN0TGlzdCA9IHVzZUNhbGxiYWNrKGFzeW5jIChuZXdGb2xsb3dpbmdQdWJrZXlzOiBzdHJpbmdbXSkgPT4ge1xuICAgICAgICBjb25zdCBub3N0ciA9IGdldFdpbmRvd05vc3RyKCk7XG4gICAgICAgIGlmICghcHVia2V5IHx8ICFub3N0cikge1xuICAgICAgICAgICAgc2V0RXJyb3IoXCJOb3QgbG9nZ2VkIGluIG9yIE5PU1RSIGV4dGVuc2lvbiBub3QgZm91bmQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOSVAtMDIgcmVjb21tZW5kcyBwcmVzZXJ2aW5nIGV4aXN0aW5nIG5vbi1cInBcIiB0YWdzIGlmIGFueS5cbiAgICAgICAgICAgIC8vIEZvciBzaW1wbGljaXR5LCB0aGlzIGV4YW1wbGUgb25seSBtYW5hZ2VzIFwicFwiIHRhZ3MuXG4gICAgICAgICAgICAvLyBGZXRjaCBleGlzdGluZyBjb250YWN0IGxpc3QgdG8gcHJlc2VydmUgb3RoZXIgdGFncyBpZiBuZWNlc3NhcnkgKG1vcmUgY29tcGxleClcblxuICAgICAgICAgICAgY29uc3QgdGFncyA9IG5ld0ZvbGxvd2luZ1B1YmtleXMubWFwKHBrID0+IFtcInBcIiwgcGtdKTtcbiAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkRXZlbnQ6IFVuc2lnbmVkRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAga2luZDogMyxcbiAgICAgICAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICAgICAgICAgICAgdGFnczogdGFncyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLCAvLyBPciBKU09OIHN0cmluZyBvZiByZWxheSBoaW50cyBwZXIgTklQLTAyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkRXZlbnQgPSBhd2FpdCBub3N0ci5zaWduRXZlbnQodW5zaWduZWRFdmVudCk7XG4gICAgICAgICAgICBpZiAoYXdhaXQgcHVibGlzaEV2ZW50KHNpZ25lZEV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHNldEZvbGxvd2luZyhuZXdGb2xsb3dpbmdQdWJrZXlzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gdXBkYXRlIGNvbnRhY3QgbGlzdDpcIiwgZXJyKTtcbiAgICAgICAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIHVwZGF0ZSBjb250YWN0IGxpc3QuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW3B1YmtleV0pO1xuXG4gICAgY29uc3QgZm9sbG93VXNlciA9IHVzZUNhbGxiYWNrKGFzeW5jICh1c2VyUHVia2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKGZvbGxvd2luZy5pbmNsdWRlcyh1c2VyUHVia2V5KSkgcmV0dXJuIHRydWU7IC8vIEFscmVhZHkgZm9sbG93aW5nXG4gICAgICAgIGNvbnN0IG5ld0ZvbGxvd2luZ0xpc3QgPSBbLi4uZm9sbG93aW5nLCB1c2VyUHVia2V5XTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHVwZGF0ZUNvbnRhY3RMaXN0KG5ld0ZvbGxvd2luZ0xpc3QpO1xuICAgIH0sIFtmb2xsb3dpbmcsIHVwZGF0ZUNvbnRhY3RMaXN0XSk7XG5cbiAgICBjb25zdCB1bmZvbGxvd1VzZXIgPSB1c2VDYWxsYmFjayhhc3luYyAodXNlclB1YmtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICghZm9sbG93aW5nLmluY2x1ZGVzKHVzZXJQdWJrZXkpKSByZXR1cm4gdHJ1ZTsgLy8gTm90IGZvbGxvd2luZ1xuICAgICAgICBjb25zdCBuZXdGb2xsb3dpbmdMaXN0ID0gZm9sbG93aW5nLmZpbHRlcihwayA9PiBwayAhPT0gdXNlclB1YmtleSk7XG4gICAgICAgIHJldHVybiBhd2FpdCB1cGRhdGVDb250YWN0TGlzdChuZXdGb2xsb3dpbmdMaXN0KTtcbiAgICB9LCBbZm9sbG93aW5nLCB1cGRhdGVDb250YWN0TGlzdF0pO1xuXG5cbiAgICBjb25zdCBpc0ZvbGxvd2luZyA9IHVzZUNhbGxiYWNrKCh1c2VyUHVia2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgcmV0dXJuIGZvbGxvd2luZy5pbmNsdWRlcyh1c2VyUHVia2V5KTtcbiAgICB9LCBbZm9sbG93aW5nXSk7XG5cbiAgICAvLyBFZmZlY3QgdG8gbG9hZCBpbml0aWFsIGZvbGxvd2luZyBsaXN0IGZvciB0aGUgbG9nZ2VkLWluIHVzZXJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocHVia2V5KSB7XG4gICAgICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaGVhbHRoeVJlbGF5cyB9ID0gYXdhaXQgZ2V0SGVhbHRoeVJlbGF5cygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGVhbHRoeVJlbGF5cy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhdXRob3JzIGlzIGEgdmFsaWQgZmlsdGVyIGZvciBub3N0ci10b29scywgYnV0IG5vdCBpbiBvdXIgRmVlZE9wdGlvbnMgdHlwZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250YWN0TGlzdEV2ZW50cyA9IGF3YWl0IGZldGNoTm9zdHJGZWVkKGhlYWx0aHlSZWxheXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmRzOiBbM10sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRob3JzOiBbcHVia2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0OiAxLCAvLyBHZXQgdGhlIGxhdGVzdCBjb250YWN0IGxpc3RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3RMaXN0RXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVzdENvbnRhY3RMaXN0ID0gY29udGFjdExpc3RFdmVudHMuc29ydCgoYTogYW55LCBiOiBhbnkpID0+IGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdClbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb2xsb3dlZFB1YmtleXMgPSBsYXRlc3RDb250YWN0TGlzdC50YWdzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodGFnOiBzdHJpbmdbXSkgPT4gdGFnWzBdID09PSAncCcgJiYgdGFnWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKHRhZzogc3RyaW5nW10pID0+IHRhZ1sxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRGb2xsb3dpbmcoZm9sbG93ZWRQdWJrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIGluaXRpYWwgY29udGFjdCBsaXN0OlwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRGb2xsb3dpbmcoW10pOyAvLyBDbGVhciBmb2xsb3dpbmcgbGlzdCBpZiBub3QgbG9nZ2VkIGluXG4gICAgICAgIH1cbiAgICB9LCBbcHVia2V5XSk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIHB1YmtleSxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBwcm9maWxlLFxuICAgICAgICBmb2xsb3dpbmcsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBpc0xvYWRpbmcsXG4gICAgICAgIHJlbGF5U3RhdHMsXG4gICAgICAgIGxvZ2luLFxuICAgICAgICBmZXRjaEV2ZW50cyxcbiAgICAgICAgcG9zdCxcbiAgICAgICAgdXBkYXRlUHJvZmlsZTogdXBkYXRlUHJvZmlsZU1ldGFkYXRhLCAvLyBSZW5hbWVkIGZvciBjbGFyaXR5XG4gICAgICAgIGZvbGxvd1VzZXIsXG4gICAgICAgIHVuZm9sbG93VXNlcixcbiAgICAgICAgaXNGb2xsb3dpbmcsXG4gICAgICAgIHNldEV2ZW50cywgLy8gRXhwb3Npbmcgc2V0dGVycyBjYW4gYmUgdXNlZnVsIGJ1dCB1c2Ugd2l0aCBjYXV0aW9uXG4gICAgICAgIHNldFByb2ZpbGUsXG4gICAgICAgIHNldEZvbGxvd2luZyxcbiAgICB9O1xufSJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiZmV0Y2hOb3N0ckZlZWQiLCJmZXRjaE5vc3RyUHJvZmlsZSIsImdldEhlYWx0aHlSZWxheXMiLCJTaW1wbGVQb29sIiwiUkVMQVlTIiwidXNlTm9zdHIiLCJwdWJrZXkiLCJzZXRQdWJrZXkiLCJldmVudHMiLCJzZXRFdmVudHMiLCJwcm9maWxlIiwic2V0UHJvZmlsZSIsImZvbGxvd2luZyIsInNldEZvbGxvd2luZyIsImVycm9yIiwic2V0RXJyb3IiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJyZWxheVN0YXRzIiwic2V0UmVsYXlTdGF0cyIsInByb2ZpbGVDYWNoZSIsImdldFdpbmRvd05vc3RyIiwid2luZG93Iiwibm9zdHIiLCJzdG9yZWRQdWJrZXkiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0SXRlbSIsImxvZ2luIiwicGsiLCJnZXRQdWJsaWNLZXkiLCJtZXNzYWdlIiwiRGF0ZSIsIm5vdyIsInNpZ25NZXNzYWdlIiwic2lnbmF0dXJlIiwiY29uc29sZSIsImxvZyIsImVyciIsIndhcm4iLCJoZWFsdGh5UmVsYXlzIiwibGVuZ3RoIiwidXNlclByb2ZpbGVEYXRhIiwidXNlclByb2ZpbGUiLCJjdXJyZW50IiwiZmV0Y2hFdmVudHMiLCJvcHRpb25zIiwiaGVhbHRoeUNvdW50IiwidG90YWxDb3VudCIsImZldGNoZWROb3N0ckV2ZW50cyIsImxpbWl0IiwidW5pcXVlUHVia2V5cyIsIkFycmF5IiwiZnJvbSIsIlNldCIsIm1hcCIsImV2IiwicHJvZmlsZXNUb0ZldGNoIiwiZmlsdGVyIiwiUHJvbWlzZSIsImFsbCIsIm1ldGEiLCJwcm9jZXNzZWRGZWVkIiwibWVkaWEiLCJ1cmxSZWdleCIsIm1hdGNoIiwiZXhlYyIsImNvbnRlbnQiLCJwdXNoIiwidXNlclByb2YiLCJkaXNwbGF5TmFtZSIsImRpc3BsYXlfbmFtZSIsIm5hbWUiLCJzbGljZSIsInBpY3R1cmUiLCJ1bnRpbCIsInByZXYiLCJleGlzdGluZ0lkcyIsImUiLCJpZCIsIm5ld0V2ZW50cyIsImhhcyIsInNvcnQiLCJhIiwiYiIsImNyZWF0ZWRfYXQiLCJwdWJsaXNoRXZlbnQiLCJzaWduZWRFdmVudCIsInBvb2wiLCJwcm9taXNlcyIsInB1Ymxpc2giLCJhbnkiLCJwIiwicmFjZSIsIl8iLCJyZWoiLCJzZXRUaW1lb3V0IiwiRXJyb3IiLCJjbG9zZSIsInBvc3QiLCJ1bnNpZ25lZEV2ZW50Iiwia2luZCIsIk1hdGgiLCJmbG9vciIsInRhZ3MiLCJzaWduRXZlbnQiLCJjdXJyZW50UHJvZmlsZSIsInVwZGF0ZVByb2ZpbGVNZXRhZGF0YSIsIm5ld1Byb2ZpbGVEYXRhIiwiY29udGVudFBheWxvYWQiLCJ1bmRlZmluZWQiLCJhYm91dCIsImJhbm5lciIsIndlYnNpdGUiLCJsdWQwNiIsImx1ZDE2IiwibmlwMDUiLCJKU09OIiwic3RyaW5naWZ5IiwidXBkYXRlZEZ1bGxQcm9maWxlIiwidXBkYXRlQ29udGFjdExpc3QiLCJuZXdGb2xsb3dpbmdQdWJrZXlzIiwiZm9sbG93VXNlciIsInVzZXJQdWJrZXkiLCJpbmNsdWRlcyIsIm5ld0ZvbGxvd2luZ0xpc3QiLCJ1bmZvbGxvd1VzZXIiLCJpc0ZvbGxvd2luZyIsImNvbnRhY3RMaXN0RXZlbnRzIiwia2luZHMiLCJhdXRob3JzIiwibGF0ZXN0Q29udGFjdExpc3QiLCJmb2xsb3dlZFB1YmtleXMiLCJ0YWciLCJ1cGRhdGVQcm9maWxlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useNostr.ts\n"));

/***/ })

});