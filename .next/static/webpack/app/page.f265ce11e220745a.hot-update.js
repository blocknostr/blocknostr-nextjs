"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useNostr.ts":
/*!*******************************!*\
  !*** ./src/hooks/useNostr.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RELAYS: () => (/* binding */ RELAYS),\n/* harmony export */   useNostr: () => (/* binding */ useNostr)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/nostr/relay */ \"(app-pages-browser)/./src/lib/nostr/relay.ts\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/../node_modules/nostr-tools/lib/esm/index.js\");\n\n\n\nconst RELAYS = [\n    \"wss://relay.damus.io\",\n    \"wss://relay.nostr.band\",\n    \"wss://nostr-pub.wellorder.net\"\n];\nfunction useNostr() {\n    const [pubkey, setPubkey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [profile, setProfile] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null); // Current user's profile\n    const [following, setFollowing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]); // List of pubkeys the user follows\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false); // General loading state\n    const [relayStats, setRelayStats] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const profileCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const getWindowNostr = ()=>{\n        return window.nostr;\n    };\n    // --- Persist pubkey in localStorage ---\n    // On mount, rehydrate pubkey from localStorage if present\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if (true) {\n                const storedPubkey = window.localStorage.getItem('nostr_pubkey');\n                if (storedPubkey && !pubkey) {\n                    setPubkey(storedPubkey);\n                }\n            }\n        }\n    }[\"useNostr.useEffect\"], []);\n    // When pubkey changes, persist to localStorage\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if ( true && pubkey) {\n                window.localStorage.setItem('nostr_pubkey', pubkey);\n            }\n        }\n    }[\"useNostr.useEffect\"], [\n        pubkey\n    ]);\n    // Auth/login\n    const login = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[login]\": async ()=>{\n            const nostr = getWindowNostr();\n            if (nostr) {\n                setIsLoading(true);\n                setError(null);\n                try {\n                    const pk = await nostr.getPublicKey();\n                    setPubkey(pk);\n                    // Optional: Schnorr signing for custom message (e.g., NIP-42 auth)\n                    const message = \"Login to RAW.ROCKS: \".concat(Date.now());\n                    if (typeof nostr.signMessage === \"function\") {\n                        try {\n                            const signature = await nostr.signMessage(message);\n                            console.log(\"Signed login message:\", signature);\n                        } catch (err) {\n                            console.warn(\"signMessage for login failed:\", err);\n                        }\n                    } else {\n                        console.warn(\"signMessage is not supported by this NOSTR extension.\");\n                    }\n                    // Load profile from relays\n                    const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                    if (healthyRelays.length > 0) {\n                        const userProfileData = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrProfile)(healthyRelays, pk);\n                        if (userProfileData) {\n                            const userProfile = {\n                                ...userProfileData,\n                                pubkey: pk\n                            };\n                            setProfile(userProfile);\n                            profileCache.current[pk] = userProfile;\n                        }\n                    } else {\n                        console.warn(\"No healthy relays to fetch initial profile.\");\n                    }\n                } catch (err) {\n                    console.error(\"Login failed:\", err);\n                    setError(err.message || \"Login failed. Please ensure your NOSTR extension is configured.\");\n                    setPubkey(null);\n                } finally{\n                    setIsLoading(false);\n                }\n            } else {\n                setError(\"NOSTR extension not found. Please install a NOSTR browser extension.\");\n            // alert(\"NOSTR extension not found. Please install a NOSTR browser extension.\");\n            }\n        }\n    }[\"useNostr.useCallback[login]\"], []);\n    // Fetch feed with pagination support\n    const fetchEvents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[fetchEvents]\": async (options)=>{\n            setIsLoading(true);\n            setError(null);\n            try {\n                const { healthyRelays, healthyCount, totalCount } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                setRelayStats({\n                    healthyCount,\n                    totalCount\n                });\n                if (!healthyRelays.length) {\n                    setError(\"No healthy relays available to fetch feed.\");\n                    return false;\n                }\n                const fetchedNostrEvents = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrFeed)(healthyRelays, {\n                    limit: 20,\n                    ...options\n                });\n                const uniquePubkeys = Array.from(new Set(fetchedNostrEvents.map({\n                    \"useNostr.useCallback[fetchEvents].uniquePubkeys\": (ev)=>ev.pubkey\n                }[\"useNostr.useCallback[fetchEvents].uniquePubkeys\"])));\n                const profilesToFetch = uniquePubkeys.filter({\n                    \"useNostr.useCallback[fetchEvents].profilesToFetch\": (pk)=>!profileCache.current[pk]\n                }[\"useNostr.useCallback[fetchEvents].profilesToFetch\"]);\n                if (profilesToFetch.length > 0) {\n                    await Promise.all(profilesToFetch.map({\n                        \"useNostr.useCallback[fetchEvents]\": async (pk)=>{\n                            const meta = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrProfile)(healthyRelays, pk);\n                            if (meta) {\n                                profileCache.current[pk] = {\n                                    ...meta,\n                                    pubkey: pk\n                                };\n                            }\n                        }\n                    }[\"useNostr.useCallback[fetchEvents]\"]));\n                }\n                const processedFeed = fetchedNostrEvents.map({\n                    \"useNostr.useCallback[fetchEvents].processedFeed\": (ev)=>{\n                        let media = [];\n                        const urlRegex = /(https?:\\/\\/(?:[\\w-]+\\.)+[\\w-]+(?:\\/[\\w\\-._~:/?#[\\]@!$&'()*+,;=]*)?\\.(?:jpg|jpeg|png|gif|mp4|webm))/gi;\n                        let match;\n                        while(match = urlRegex.exec(ev.content)){\n                            media.push(match[1]);\n                        }\n                        const userProf = profileCache.current[ev.pubkey] || {\n                            pubkey: ev.pubkey\n                        };\n                        const displayName = userProf.display_name || userProf.name || \"\".concat(ev.pubkey.slice(0, 6), \"...\").concat(ev.pubkey.slice(-4));\n                        const picture = userProf.picture || \"/file.svg\"; // Default avatar\n                        return {\n                            ...ev,\n                            media,\n                            profile: {\n                                ...userProf,\n                                display_name: displayName,\n                                name: userProf.name || displayName,\n                                picture: picture\n                            }\n                        };\n                    }\n                }[\"useNostr.useCallback[fetchEvents].processedFeed\"]);\n                if (options === null || options === void 0 ? void 0 : options.until) {\n                    setEvents({\n                        \"useNostr.useCallback[fetchEvents]\": (prev)=>{\n                            const existingIds = new Set(prev.map({\n                                \"useNostr.useCallback[fetchEvents]\": (e)=>e.id\n                            }[\"useNostr.useCallback[fetchEvents]\"]));\n                            const newEvents = processedFeed.filter({\n                                \"useNostr.useCallback[fetchEvents].newEvents\": (e)=>!existingIds.has(e.id)\n                            }[\"useNostr.useCallback[fetchEvents].newEvents\"]);\n                            return [\n                                ...prev,\n                                ...newEvents\n                            ].sort({\n                                \"useNostr.useCallback[fetchEvents]\": (a, b)=>b.created_at - a.created_at\n                            }[\"useNostr.useCallback[fetchEvents]\"]);\n                        }\n                    }[\"useNostr.useCallback[fetchEvents]\"]);\n                } else {\n                    setEvents(processedFeed.sort({\n                        \"useNostr.useCallback[fetchEvents]\": (a, b)=>b.created_at - a.created_at\n                    }[\"useNostr.useCallback[fetchEvents]\"]));\n                }\n                return processedFeed.length > 0;\n            } catch (err) {\n                console.error(\"Error fetching events:\", err);\n                setError(err.message || \"Failed to fetch posts. Please try again later.\");\n                return false;\n            } finally{\n                setIsLoading(false);\n            }\n        }\n    }[\"useNostr.useCallback[fetchEvents]\"], []);\n    // Helper to publish a signed event\n    const publishEvent = async (signedEvent)=>{\n        try {\n            const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n            if (!healthyRelays.length) {\n                setError(\"No healthy relays available to publish event.\");\n                return false;\n            }\n            const pool = new nostr_tools__WEBPACK_IMPORTED_MODULE_2__.SimplePool();\n            const promises = pool.publish(healthyRelays, signedEvent);\n            // Wait for at least one successful publish or timeout\n            // This is a simplified version; nostr-tools' publish returns promises for each relay\n            await Promise.any(promises.map((p)=>Promise.race([\n                    p,\n                    new Promise((_, rej)=>setTimeout(()=>rej(new Error('timeout')), 5000))\n                ])));\n            pool.close(healthyRelays); // Close connections after publishing\n            return true;\n        } catch (err) {\n            console.error(\"Failed to publish event to relays:\", err);\n            setError(\"Failed to publish event. Some relays might be offline.\");\n            return false;\n        }\n    };\n    // Post event (sign and publish using extension)\n    const post = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[post]\": async (content)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                const unsignedEvent = {\n                    kind: 1,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: [],\n                    content\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    // Optimistic update\n                    const currentProfile = profileCache.current[pubkey] || {\n                        pubkey\n                    };\n                    setEvents({\n                        \"useNostr.useCallback[post]\": (prev)=>[\n                                {\n                                    id: signedEvent.id,\n                                    pubkey: signedEvent.pubkey,\n                                    content: signedEvent.content,\n                                    created_at: signedEvent.created_at,\n                                    kind: signedEvent.kind,\n                                    tags: signedEvent.tags,\n                                    media: [],\n                                    profile: {\n                                        display_name: currentProfile.display_name || currentProfile.name || \"\".concat(pubkey.slice(0, 6), \"...\").concat(pubkey.slice(-4)),\n                                        name: currentProfile.name || \"\".concat(pubkey.slice(0, 6), \"...\").concat(pubkey.slice(-4)),\n                                        picture: currentProfile.picture || \"/file.svg\",\n                                        pubkey: pubkey\n                                    }\n                                },\n                                ...prev\n                            ].sort({\n                                \"useNostr.useCallback[post]\": (a, b)=>b.created_at - a.created_at\n                            }[\"useNostr.useCallback[post]\"])\n                    }[\"useNostr.useCallback[post]\"]);\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to post event:\", err);\n                setError(err.message || \"Failed to post. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[post]\"], [\n        pubkey,\n        profile\n    ]);\n    // Update profile (Kind 0)\n    const updateProfileMetadata = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[updateProfileMetadata]\": async (newProfileData)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                // Ensure only valid profile fields are included\n                const contentPayload = {};\n                if (newProfileData.name !== undefined) contentPayload.name = newProfileData.name;\n                if (newProfileData.display_name !== undefined) contentPayload.display_name = newProfileData.display_name;\n                if (newProfileData.about !== undefined) contentPayload.about = newProfileData.about;\n                if (newProfileData.picture !== undefined) contentPayload.picture = newProfileData.picture;\n                if (newProfileData.banner !== undefined) contentPayload.banner = newProfileData.banner;\n                if (newProfileData.website !== undefined) contentPayload.website = newProfileData.website;\n                if (newProfileData.lud06 !== undefined) contentPayload.lud06 = newProfileData.lud06;\n                if (newProfileData.lud16 !== undefined) contentPayload.lud16 = newProfileData.lud16;\n                if (newProfileData.nip05 !== undefined) contentPayload.nip05 = newProfileData.nip05;\n                const unsignedEvent = {\n                    kind: 0,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: [],\n                    content: JSON.stringify(contentPayload)\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    const updatedFullProfile = {\n                        ...profile,\n                        ...newProfileData,\n                        pubkey\n                    };\n                    setProfile(updatedFullProfile);\n                    profileCache.current[pubkey] = updatedFullProfile; // Update cache\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to update profile:\", err);\n                setError(err.message || \"Failed to update profile. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[updateProfileMetadata]\"], [\n        pubkey,\n        profile\n    ]);\n    // Manage contact list (Kind 3)\n    const updateContactList = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[updateContactList]\": async (newFollowingPubkeys)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                // NIP-02 recommends preserving existing non-\"p\" tags if any.\n                // For simplicity, this example only manages \"p\" tags.\n                // Fetch existing contact list to preserve other tags if necessary (more complex)\n                const tags = newFollowingPubkeys.map({\n                    \"useNostr.useCallback[updateContactList].tags\": (pk)=>[\n                            \"p\",\n                            pk\n                        ]\n                }[\"useNostr.useCallback[updateContactList].tags\"]);\n                const unsignedEvent = {\n                    kind: 3,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: tags,\n                    content: \"\"\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    setFollowing(newFollowingPubkeys);\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to update contact list:\", err);\n                setError(err.message || \"Failed to update contact list. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[updateContactList]\"], [\n        pubkey\n    ]);\n    const followUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[followUser]\": async (userPubkey)=>{\n            if (following.includes(userPubkey)) return true; // Already following\n            const newFollowingList = [\n                ...following,\n                userPubkey\n            ];\n            return await updateContactList(newFollowingList);\n        }\n    }[\"useNostr.useCallback[followUser]\"], [\n        following,\n        updateContactList\n    ]);\n    const unfollowUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[unfollowUser]\": async (userPubkey)=>{\n            if (!following.includes(userPubkey)) return true; // Not following\n            const newFollowingList = following.filter({\n                \"useNostr.useCallback[unfollowUser].newFollowingList\": (pk)=>pk !== userPubkey\n            }[\"useNostr.useCallback[unfollowUser].newFollowingList\"]);\n            return await updateContactList(newFollowingList);\n        }\n    }[\"useNostr.useCallback[unfollowUser]\"], [\n        following,\n        updateContactList\n    ]);\n    const isFollowing = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[isFollowing]\": (userPubkey)=>{\n            return following.includes(userPubkey);\n        }\n    }[\"useNostr.useCallback[isFollowing]\"], [\n        following\n    ]);\n    // Effect to load initial following list for the logged-in user\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if (pubkey) {\n                ({\n                    \"useNostr.useEffect\": async ()=>{\n                        try {\n                            const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                            if (healthyRelays.length === 0) return;\n                            const contactListEvents = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrFeed)(healthyRelays, {\n                                authors: [\n                                    pubkey\n                                ],\n                                kinds: [\n                                    3\n                                ],\n                                limit: 1\n                            });\n                            if (contactListEvents.length > 0) {\n                                const latestContactList = contactListEvents.sort({\n                                    \"useNostr.useEffect\": (a, b)=>b.created_at - a.created_at\n                                }[\"useNostr.useEffect\"])[0];\n                                const followedPubkeys = latestContactList.tags.filter({\n                                    \"useNostr.useEffect.followedPubkeys\": (tag)=>tag[0] === 'p' && tag[1]\n                                }[\"useNostr.useEffect.followedPubkeys\"]).map({\n                                    \"useNostr.useEffect.followedPubkeys\": (tag)=>tag[1]\n                                }[\"useNostr.useEffect.followedPubkeys\"]);\n                                setFollowing(followedPubkeys);\n                            }\n                        } catch (err) {\n                            console.error(\"Failed to fetch initial contact list:\", err);\n                        }\n                    }\n                })[\"useNostr.useEffect\"]();\n            } else {\n                setFollowing([]); // Clear following list if not logged in\n            }\n        }\n    }[\"useNostr.useEffect\"], [\n        pubkey\n    ]);\n    return {\n        pubkey,\n        events,\n        profile,\n        following,\n        error,\n        isLoading,\n        relayStats,\n        login,\n        fetchEvents,\n        post,\n        updateProfile: updateProfileMetadata,\n        followUser,\n        unfollowUser,\n        isFollowing,\n        setEvents,\n        setProfile,\n        setFollowing\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VOb3N0ci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUU7QUFDdUI7QUFTeUI7QUFnQjFHLE1BQU1RLFNBQVM7SUFDbEI7SUFDQTtJQUNBO0NBRUgsQ0FBQztBQTJCSyxTQUFTQztJQUNaLE1BQU0sQ0FBQ0MsUUFBUUMsVUFBVSxHQUFHWCwrQ0FBUUEsQ0FBZ0I7SUFDcEQsTUFBTSxDQUFDWSxRQUFRQyxVQUFVLEdBQUdiLCtDQUFRQSxDQUFlLEVBQUU7SUFDckQsTUFBTSxDQUFDYyxTQUFTQyxXQUFXLEdBQUdmLCtDQUFRQSxDQUFzQixPQUFPLHlCQUF5QjtJQUM1RixNQUFNLENBQUNnQixXQUFXQyxhQUFhLEdBQUdqQiwrQ0FBUUEsQ0FBVyxFQUFFLEdBQUcsbUNBQW1DO0lBQzdGLE1BQU0sQ0FBQ2tCLE9BQU9DLFNBQVMsR0FBR25CLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUNvQixXQUFXQyxhQUFhLEdBQUdyQiwrQ0FBUUEsQ0FBVSxRQUFRLHdCQUF3QjtJQUNwRixNQUFNLENBQUNzQixZQUFZQyxjQUFjLEdBQUd2QiwrQ0FBUUEsQ0FBdUQ7SUFDbkcsTUFBTXdCLGVBQWV0Qiw2Q0FBTUEsQ0FBcUMsQ0FBQztJQUVqRSxNQUFNdUIsaUJBQWlCO1FBQ25CLE9BQU9DLE9BQU9DLEtBQUs7SUFDdkI7SUFFQSx5Q0FBeUM7SUFDekMsMERBQTBEO0lBQzFEeEIsZ0RBQVNBOzhCQUFDO1lBQ04sSUFBSSxJQUE2QixFQUFFO2dCQUMvQixNQUFNeUIsZUFBZUYsT0FBT0csWUFBWSxDQUFDQyxPQUFPLENBQUM7Z0JBQ2pELElBQUlGLGdCQUFnQixDQUFDbEIsUUFBUTtvQkFDekJDLFVBQVVpQjtnQkFDZDtZQUNKO1FBQ0o7NkJBQUcsRUFBRTtJQUVMLCtDQUErQztJQUMvQ3pCLGdEQUFTQTs4QkFBQztZQUNOLElBQUksS0FBNkIsSUFBSU8sUUFBUTtnQkFDekNnQixPQUFPRyxZQUFZLENBQUNF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QUU7UUFDQUU7SUFDSjtBQUNKIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvc3JjL2hvb2tzL3VzZU5vc3RyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGZldGNoTm9zdHJGZWVkLCBmZXRjaE5vc3RyUHJvZmlsZSwgZ2V0SGVhbHRoeVJlbGF5cyB9IGZyb20gXCJAL2xpYi9ub3N0ci9yZWxheVwiO1xuXG4vLyBFeHRlbmQgRmVlZE9wdGlvbnMgdG8gaW5jbHVkZSAnYXV0aG9ycydcbmV4cG9ydCBpbnRlcmZhY2UgRmVlZE9wdGlvbnMge1xuICAgIGxpbWl0PzogbnVtYmVyO1xuICAgIHVudGlsPzogbnVtYmVyO1xuICAgIGtpbmRzPzogbnVtYmVyW107XG4gICAgYXV0aG9ycz86IHN0cmluZ1tdOyAvLyBBZGRlZCBhdXRob3JzIHByb3BlcnR5IHRvIG1hdGNoIHVzYWdlXG59XG5pbXBvcnQgeyBTaW1wbGVQb29sLCBuaXAxOSwgdHlwZSBFdmVudCBhcyBOb3N0clRvb2xzRXZlbnQsIHR5cGUgVW5zaWduZWRFdmVudCwgZ2V0RXZlbnRIYXNoIH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG5cbi8vIERlZmluZSB0aGUgTklQLTA3IHdpbmRvdy5ub3N0ciBpbnRlcmZhY2VcbmludGVyZmFjZSBXaW5kb3dOb3N0ciB7XG4gICAgZ2V0UHVibGljS2V5KCk6IFByb21pc2U8c3RyaW5nPjtcbiAgICBzaWduRXZlbnQoZXZlbnQ6IFVuc2lnbmVkRXZlbnQpOiBQcm9taXNlPE5vc3RyVG9vbHNFdmVudD47XG4gICAgc2lnbk1lc3NhZ2U/KG1lc3NhZ2U6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPjsgLy8gT3B0aW9uYWwgTklQLTQyIG9yIGN1c3RvbSB1c2FnZVxuICAgIGdldFJlbGF5cz8oKTogUHJvbWlzZTx7IFt1cmw6IHN0cmluZ106IHsgcmVhZDogYm9vbGVhbjsgd3JpdGU6IGJvb2xlYW4gfSB9PjsgLy8gT3B0aW9uYWxcbn1cblxuZGVjbGFyZSBnbG9iYWwge1xuICAgIGludGVyZmFjZSBXaW5kb3cge1xuICAgICAgICBub3N0cj86IFdpbmRvd05vc3RyO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IFJFTEFZUyA9IFtcbiAgICBcIndzczovL3JlbGF5LmRhbXVzLmlvXCIsXG4gICAgXCJ3c3M6Ly9yZWxheS5ub3N0ci5iYW5kXCIsXG4gICAgXCJ3c3M6Ly9ub3N0ci1wdWIud2VsbG9yZGVyLm5ldFwiLFxuICAgIC8vIEFkZCBtb3JlIGRlZmF1bHQgcmVsYXlzIG9yIG1ha2UgdGhpcyBjb25maWd1cmFibGVcbl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9zdHJQcm9maWxlIHtcbiAgICBuYW1lPzogc3RyaW5nOyAvLyBOSVAtMDEgZmllbGQgZm9yIHVzZXJuYW1lXG4gICAgZGlzcGxheV9uYW1lPzogc3RyaW5nOyAvLyBOSVAtMDEgZmllbGQgZm9yIGRpc3BsYXkgbmFtZVxuICAgIGFib3V0Pzogc3RyaW5nOyAvLyBOSVAtMDEgZmllbGQgZm9yIGJpb1xuICAgIHBpY3R1cmU/OiBzdHJpbmc7IC8vIE5JUC0wMSBmaWVsZCBmb3IgcGljdHVyZSBVUkxcbiAgICBiYW5uZXI/OiBzdHJpbmc7IC8vIE5JUC0wMSBmaWVsZCBmb3IgYmFubmVyIFVSTFxuICAgIHdlYnNpdGU/OiBzdHJpbmc7IC8vIE5JUC0wMSBmaWVsZCBmb3Igd2Vic2l0ZVxuICAgIGx1ZDA2Pzogc3RyaW5nOyAvLyBOSVAtMDEgZmllbGQgZm9yIExOIFVSTCAocGF5bnltKVxuICAgIGx1ZDE2Pzogc3RyaW5nOyAvLyBOSVAtMDEgZmllbGQgZm9yIExOIEFkZHJlc3NcbiAgICBuaXAwNT86IHN0cmluZzsgLy8gTklQLTA1IGlkZW50aWZpZXJcbiAgICBwdWJrZXk/OiBzdHJpbmc7IC8vIEFkZGVkIGZvciBjb252ZW5pZW5jZVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vc3RyRXZlbnQge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgcHVia2V5OiBzdHJpbmc7XG4gICAgY29udGVudDogc3RyaW5nO1xuICAgIGNyZWF0ZWRfYXQ6IG51bWJlcjtcbiAgICBraW5kOiBudW1iZXI7XG4gICAgdGFnczogc3RyaW5nW11bXTtcbiAgICBtZWRpYTogc3RyaW5nW107IC8vIEN1c3RvbSBkZXJpdmVkIGZpZWxkXG4gICAgcHJvZmlsZT86IE5vc3RyUHJvZmlsZTsgLy8gQ3VzdG9tIGRlcml2ZWQgZmllbGRcbiAgICAvLyBBZGQgb3RoZXIgZXZlbnQgZmllbGRzIGlmIG5lZWRlZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlTm9zdHIoKSB7XG4gICAgY29uc3QgW3B1YmtleSwgc2V0UHVia2V5XSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IFtldmVudHMsIHNldEV2ZW50c10gPSB1c2VTdGF0ZTxOb3N0ckV2ZW50W10+KFtdKTtcbiAgICBjb25zdCBbcHJvZmlsZSwgc2V0UHJvZmlsZV0gPSB1c2VTdGF0ZTxOb3N0clByb2ZpbGUgfCBudWxsPihudWxsKTsgLy8gQ3VycmVudCB1c2VyJ3MgcHJvZmlsZVxuICAgIGNvbnN0IFtmb2xsb3dpbmcsIHNldEZvbGxvd2luZ10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pOyAvLyBMaXN0IG9mIHB1YmtleXMgdGhlIHVzZXIgZm9sbG93c1xuICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTsgLy8gR2VuZXJhbCBsb2FkaW5nIHN0YXRlXG4gICAgY29uc3QgW3JlbGF5U3RhdHMsIHNldFJlbGF5U3RhdHNdID0gdXNlU3RhdGU8eyBoZWFsdGh5Q291bnQ6IG51bWJlcjsgdG90YWxDb3VudDogbnVtYmVyOyB9IHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgcHJvZmlsZUNhY2hlID0gdXNlUmVmPHsgW3B1YmtleTogc3RyaW5nXTogTm9zdHJQcm9maWxlIH0+KHt9KTtcblxuICAgIGNvbnN0IGdldFdpbmRvd05vc3RyID0gKCk6IFdpbmRvd05vc3RyIHwgdW5kZWZpbmVkID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5ub3N0cjtcbiAgICB9O1xuXG4gICAgLy8gLS0tIFBlcnNpc3QgcHVia2V5IGluIGxvY2FsU3RvcmFnZSAtLS1cbiAgICAvLyBPbiBtb3VudCwgcmVoeWRyYXRlIHB1YmtleSBmcm9tIGxvY2FsU3RvcmFnZSBpZiBwcmVzZW50XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWRQdWJrZXkgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ25vc3RyX3B1YmtleScpO1xuICAgICAgICAgICAgaWYgKHN0b3JlZFB1YmtleSAmJiAhcHVia2V5KSB7XG4gICAgICAgICAgICAgICAgc2V0UHVia2V5KHN0b3JlZFB1YmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBXaGVuIHB1YmtleSBjaGFuZ2VzLCBwZXJzaXN0IHRvIGxvY2FsU3RvcmFnZVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBwdWJrZXkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbm9zdHJfcHVia2V5JywgcHVia2V5KTtcbiAgICAgICAgfVxuICAgIH0sIFtwdWJrZXldKTtcblxuICAgIC8vIEF1dGgvbG9naW5cbiAgICBjb25zdCBsb2dpbiA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgbm9zdHIgPSBnZXRXaW5kb3dOb3N0cigpO1xuICAgICAgICBpZiAobm9zdHIpIHtcbiAgICAgICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwayA9IGF3YWl0IG5vc3RyLmdldFB1YmxpY0tleSgpO1xuICAgICAgICAgICAgICAgIHNldFB1YmtleShwayk7XG5cbiAgICAgICAgICAgICAgICAvLyBPcHRpb25hbDogU2Nobm9yciBzaWduaW5nIGZvciBjdXN0b20gbWVzc2FnZSAoZS5nLiwgTklQLTQyIGF1dGgpXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBMb2dpbiB0byBSQVcuUk9DS1M6ICR7RGF0ZS5ub3coKX1gO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9zdHIuc2lnbk1lc3NhZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgbm9zdHIuc2lnbk1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNpZ25lZCBsb2dpbiBtZXNzYWdlOlwiLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInNpZ25NZXNzYWdlIGZvciBsb2dpbiBmYWlsZWQ6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzaWduTWVzc2FnZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgTk9TVFIgZXh0ZW5zaW9uLlwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMb2FkIHByb2ZpbGUgZnJvbSByZWxheXNcbiAgICAgICAgICAgICAgICBjb25zdCB7IGhlYWx0aHlSZWxheXMgfSA9IGF3YWl0IGdldEhlYWx0aHlSZWxheXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoaGVhbHRoeVJlbGF5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9maWxlRGF0YSA9IGF3YWl0IGZldGNoTm9zdHJQcm9maWxlKGhlYWx0aHlSZWxheXMsIHBrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJQcm9maWxlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlclByb2ZpbGU6IE5vc3RyUHJvZmlsZSA9IHsgLi4udXNlclByb2ZpbGVEYXRhLCBwdWJrZXk6IHBrIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9maWxlKHVzZXJQcm9maWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGVDYWNoZS5jdXJyZW50W3BrXSA9IHVzZXJQcm9maWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gaGVhbHRoeSByZWxheXMgdG8gZmV0Y2ggaW5pdGlhbCBwcm9maWxlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJMb2dpbiBmYWlsZWQ6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJMb2dpbiBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgeW91ciBOT1NUUiBleHRlbnNpb24gaXMgY29uZmlndXJlZC5cIik7XG4gICAgICAgICAgICAgICAgc2V0UHVia2V5KG51bGwpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0RXJyb3IoXCJOT1NUUiBleHRlbnNpb24gbm90IGZvdW5kLiBQbGVhc2UgaW5zdGFsbCBhIE5PU1RSIGJyb3dzZXIgZXh0ZW5zaW9uLlwiKTtcbiAgICAgICAgICAgIC8vIGFsZXJ0KFwiTk9TVFIgZXh0ZW5zaW9uIG5vdCBmb3VuZC4gUGxlYXNlIGluc3RhbGwgYSBOT1NUUiBicm93c2VyIGV4dGVuc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBGZXRjaCBmZWVkIHdpdGggcGFnaW5hdGlvbiBzdXBwb3J0XG4gICAgY29uc3QgZmV0Y2hFdmVudHMgPSB1c2VDYWxsYmFjayhhc3luYyAob3B0aW9ucz86IEZlZWRPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGhlYWx0aHlSZWxheXMsIGhlYWx0aHlDb3VudCwgdG90YWxDb3VudCB9ID0gYXdhaXQgZ2V0SGVhbHRoeVJlbGF5cygpO1xuICAgICAgICAgICAgc2V0UmVsYXlTdGF0cyh7IGhlYWx0aHlDb3VudCwgdG90YWxDb3VudCB9KTtcblxuICAgICAgICAgICAgaWYgKCFoZWFsdGh5UmVsYXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKFwiTm8gaGVhbHRoeSByZWxheXMgYXZhaWxhYmxlIHRvIGZldGNoIGZlZWQuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZmV0Y2hlZE5vc3RyRXZlbnRzID0gYXdhaXQgZmV0Y2hOb3N0ckZlZWQoaGVhbHRoeVJlbGF5cywge1xuICAgICAgICAgICAgICAgIGxpbWl0OiAyMCxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgdW5pcXVlUHVia2V5cyA9IEFycmF5LmZyb20obmV3IFNldChmZXRjaGVkTm9zdHJFdmVudHMubWFwKGV2ID0+IGV2LnB1YmtleSkpKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2ZpbGVzVG9GZXRjaCA9IHVuaXF1ZVB1YmtleXMuZmlsdGVyKHBrID0+ICFwcm9maWxlQ2FjaGUuY3VycmVudFtwa10pO1xuXG4gICAgICAgICAgICBpZiAocHJvZmlsZXNUb0ZldGNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9maWxlc1RvRmV0Y2gubWFwKGFzeW5jIChwaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gYXdhaXQgZmV0Y2hOb3N0clByb2ZpbGUoaGVhbHRoeVJlbGF5cywgcGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZUNhY2hlLmN1cnJlbnRbcGtdID0geyAuLi5tZXRhLCBwdWJrZXk6IHBrIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZEZlZWQgPSBmZXRjaGVkTm9zdHJFdmVudHMubWFwKChldik6IE5vc3RyRXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBtZWRpYTogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmxSZWdleCA9IC8oaHR0cHM/OlxcL1xcLyg/OltcXHctXStcXC4pK1tcXHctXSsoPzpcXC9bXFx3XFwtLl9+Oi8/I1tcXF1AISQmJygpKissOz1dKik/XFwuKD86anBnfGpwZWd8cG5nfGdpZnxtcDR8d2VibSkpL2dpO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gdXJsUmVnZXguZXhlYyhldi5jb250ZW50KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVkaWEucHVzaChtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgdXNlclByb2YgPSBwcm9maWxlQ2FjaGUuY3VycmVudFtldi5wdWJrZXldIHx8IHsgcHVia2V5OiBldi5wdWJrZXkgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNwbGF5TmFtZSA9IHVzZXJQcm9mLmRpc3BsYXlfbmFtZSB8fCB1c2VyUHJvZi5uYW1lIHx8IGAke2V2LnB1YmtleS5zbGljZSgwLCA2KX0uLi4ke2V2LnB1YmtleS5zbGljZSgtNCl9YDtcbiAgICAgICAgICAgICAgICBjb25zdCBwaWN0dXJlID0gdXNlclByb2YucGljdHVyZSB8fCBcIi9maWxlLnN2Z1wiOyAvLyBEZWZhdWx0IGF2YXRhclxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZXYsXG4gICAgICAgICAgICAgICAgICAgIG1lZGlhLFxuICAgICAgICAgICAgICAgICAgICBwcm9maWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi51c2VyUHJvZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB1c2VyUHJvZi5uYW1lIHx8IGRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGljdHVyZTogcGljdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zPy51bnRpbCkge1xuICAgICAgICAgICAgICAgIHNldEV2ZW50cyhwcmV2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdJZHMgPSBuZXcgU2V0KHByZXYubWFwKGUgPT4gZS5pZCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdFdmVudHMgPSBwcm9jZXNzZWRGZWVkLmZpbHRlcihlID0+ICFleGlzdGluZ0lkcy5oYXMoZS5pZCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnByZXYsIC4uLm5ld0V2ZW50c10uc29ydCgoYSwgYikgPT4gYi5jcmVhdGVkX2F0IC0gYS5jcmVhdGVkX2F0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0RXZlbnRzKHByb2Nlc3NlZEZlZWQuc29ydCgoYSwgYikgPT4gYi5jcmVhdGVkX2F0IC0gYS5jcmVhdGVkX2F0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRmVlZC5sZW5ndGggPiAwO1xuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGV2ZW50czpcIiwgZXJyKTtcbiAgICAgICAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIGZldGNoIHBvc3RzLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBIZWxwZXIgdG8gcHVibGlzaCBhIHNpZ25lZCBldmVudFxuICAgIGNvbnN0IHB1Ymxpc2hFdmVudCA9IGFzeW5jIChzaWduZWRFdmVudDogTm9zdHJUb29sc0V2ZW50KTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGhlYWx0aHlSZWxheXMgfSA9IGF3YWl0IGdldEhlYWx0aHlSZWxheXMoKTtcbiAgICAgICAgICAgIGlmICghaGVhbHRoeVJlbGF5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihcIk5vIGhlYWx0aHkgcmVsYXlzIGF2YWlsYWJsZSB0byBwdWJsaXNoIGV2ZW50LlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb29sID0gbmV3IFNpbXBsZVBvb2woKTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gcG9vbC5wdWJsaXNoKGhlYWx0aHlSZWxheXMsIHNpZ25lZEV2ZW50KTtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIGF0IGxlYXN0IG9uZSBzdWNjZXNzZnVsIHB1Ymxpc2ggb3IgdGltZW91dFxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgdmVyc2lvbjsgbm9zdHItdG9vbHMnIHB1Ymxpc2ggcmV0dXJucyBwcm9taXNlcyBmb3IgZWFjaCByZWxheVxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbnkocHJvbWlzZXMubWFwKHAgPT4gUHJvbWlzZS5yYWNlKFtwLCBuZXcgUHJvbWlzZSgoXywgcmVqKSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlaihuZXcgRXJyb3IoJ3RpbWVvdXQnKSksIDUwMDApKV0pKSk7XG4gICAgICAgICAgICBwb29sLmNsb3NlKGhlYWx0aHlSZWxheXMpOyAvLyBDbG9zZSBjb25uZWN0aW9ucyBhZnRlciBwdWJsaXNoaW5nXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgdG8gcmVsYXlzOlwiLCBlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoXCJGYWlsZWQgdG8gcHVibGlzaCBldmVudC4gU29tZSByZWxheXMgbWlnaHQgYmUgb2ZmbGluZS5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gUG9zdCBldmVudCAoc2lnbiBhbmQgcHVibGlzaCB1c2luZyBleHRlbnNpb24pXG4gICAgY29uc3QgcG9zdCA9IHVzZUNhbGxiYWNrKGFzeW5jIChjb250ZW50OiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3Qgbm9zdHIgPSBnZXRXaW5kb3dOb3N0cigpO1xuICAgICAgICBpZiAoIXB1YmtleSB8fCAhbm9zdHIpIHtcbiAgICAgICAgICAgIHNldEVycm9yKFwiTm90IGxvZ2dlZCBpbiBvciBOT1NUUiBleHRlbnNpb24gbm90IGZvdW5kLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdW5zaWduZWRFdmVudDogVW5zaWduZWRFdmVudCA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiAxLFxuICAgICAgICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZEV2ZW50ID0gYXdhaXQgbm9zdHIuc2lnbkV2ZW50KHVuc2lnbmVkRXZlbnQpO1xuXG4gICAgICAgICAgICBpZiAoYXdhaXQgcHVibGlzaEV2ZW50KHNpZ25lZEV2ZW50KSkge1xuICAgICAgICAgICAgICAgIC8vIE9wdGltaXN0aWMgdXBkYXRlXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFByb2ZpbGUgPSBwcm9maWxlQ2FjaGUuY3VycmVudFtwdWJrZXldIHx8IHsgcHVia2V5IH07XG4gICAgICAgICAgICAgICAgc2V0RXZlbnRzKHByZXYgPT4gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogc2lnbmVkRXZlbnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJrZXk6IHNpZ25lZEV2ZW50LnB1YmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHNpZ25lZEV2ZW50LmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBzaWduZWRFdmVudC5jcmVhdGVkX2F0LFxuICAgICAgICAgICAgICAgICAgICAgICAga2luZDogc2lnbmVkRXZlbnQua2luZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IHNpZ25lZEV2ZW50LnRhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYTogW10sIC8vIERlcml2ZSBtZWRpYSBpZiBuZWVkZWQsIG9yIGxlYXZlIGZvciBkaXNwbGF5IGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogY3VycmVudFByb2ZpbGUuZGlzcGxheV9uYW1lIHx8IGN1cnJlbnRQcm9maWxlLm5hbWUgfHwgYCR7cHVia2V5LnNsaWNlKDAsIDYpfS4uLiR7cHVia2V5LnNsaWNlKC00KX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGN1cnJlbnRQcm9maWxlLm5hbWUgfHwgYCR7cHVia2V5LnNsaWNlKDAsIDYpfS4uLiR7cHVia2V5LnNsaWNlKC00KX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY3R1cmU6IGN1cnJlbnRQcm9maWxlLnBpY3R1cmUgfHwgXCIvZmlsZS5zdmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJrZXk6IHB1YmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgICAgICBdLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwb3N0IGV2ZW50OlwiLCBlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gcG9zdC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBbcHVia2V5LCBwcm9maWxlXSk7XG5cbiAgICAvLyBVcGRhdGUgcHJvZmlsZSAoS2luZCAwKVxuICAgIGNvbnN0IHVwZGF0ZVByb2ZpbGVNZXRhZGF0YSA9IHVzZUNhbGxiYWNrKGFzeW5jIChuZXdQcm9maWxlRGF0YTogTm9zdHJQcm9maWxlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vc3RyID0gZ2V0V2luZG93Tm9zdHIoKTtcbiAgICAgICAgaWYgKCFwdWJrZXkgfHwgIW5vc3RyKSB7XG4gICAgICAgICAgICBzZXRFcnJvcihcIk5vdCBsb2dnZWQgaW4gb3IgTk9TVFIgZXh0ZW5zaW9uIG5vdCBmb3VuZC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBvbmx5IHZhbGlkIHByb2ZpbGUgZmllbGRzIGFyZSBpbmNsdWRlZFxuICAgICAgICAgICAgY29uc3QgY29udGVudFBheWxvYWQ6IGFueSA9IHt9O1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLm5hbWUgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQubmFtZSA9IG5ld1Byb2ZpbGVEYXRhLm5hbWU7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEuZGlzcGxheV9uYW1lICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLmRpc3BsYXlfbmFtZSA9IG5ld1Byb2ZpbGVEYXRhLmRpc3BsYXlfbmFtZTtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS5hYm91dCAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5hYm91dCA9IG5ld1Byb2ZpbGVEYXRhLmFib3V0O1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLnBpY3R1cmUgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQucGljdHVyZSA9IG5ld1Byb2ZpbGVEYXRhLnBpY3R1cmU7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEuYmFubmVyICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLmJhbm5lciA9IG5ld1Byb2ZpbGVEYXRhLmJhbm5lcjtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS53ZWJzaXRlICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLndlYnNpdGUgPSBuZXdQcm9maWxlRGF0YS53ZWJzaXRlO1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLmx1ZDA2ICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLmx1ZDA2ID0gbmV3UHJvZmlsZURhdGEubHVkMDY7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEubHVkMTYgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQubHVkMTYgPSBuZXdQcm9maWxlRGF0YS5sdWQxNjtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS5uaXAwNSAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5uaXAwNSA9IG5ld1Byb2ZpbGVEYXRhLm5pcDA1O1xuXG5cbiAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkRXZlbnQ6IFVuc2lnbmVkRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAga2luZDogMCxcbiAgICAgICAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICAgICAgICAgICAgdGFnczogW10sXG4gICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkoY29udGVudFBheWxvYWQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZEV2ZW50ID0gYXdhaXQgbm9zdHIuc2lnbkV2ZW50KHVuc2lnbmVkRXZlbnQpO1xuICAgICAgICAgICAgaWYgKGF3YWl0IHB1Ymxpc2hFdmVudChzaWduZWRFdmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkRnVsbFByb2ZpbGUgPSB7IC4uLnByb2ZpbGUsIC4uLm5ld1Byb2ZpbGVEYXRhLCBwdWJrZXkgfTtcbiAgICAgICAgICAgICAgICBzZXRQcm9maWxlKHVwZGF0ZWRGdWxsUHJvZmlsZSk7XG4gICAgICAgICAgICAgICAgcHJvZmlsZUNhY2hlLmN1cnJlbnRbcHVia2V5XSA9IHVwZGF0ZWRGdWxsUHJvZmlsZTsgLy8gVXBkYXRlIGNhY2hlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBwcm9maWxlOlwiLCBlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gdXBkYXRlIHByb2ZpbGUuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW3B1YmtleSwgcHJvZmlsZV0pO1xuXG4gICAgLy8gTWFuYWdlIGNvbnRhY3QgbGlzdCAoS2luZCAzKVxuICAgIGNvbnN0IHVwZGF0ZUNvbnRhY3RMaXN0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKG5ld0ZvbGxvd2luZ1B1YmtleXM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vc3RyID0gZ2V0V2luZG93Tm9zdHIoKTtcbiAgICAgICAgaWYgKCFwdWJrZXkgfHwgIW5vc3RyKSB7XG4gICAgICAgICAgICBzZXRFcnJvcihcIk5vdCBsb2dnZWQgaW4gb3IgTk9TVFIgZXh0ZW5zaW9uIG5vdCBmb3VuZC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5JUC0wMiByZWNvbW1lbmRzIHByZXNlcnZpbmcgZXhpc3Rpbmcgbm9uLVwicFwiIHRhZ3MgaWYgYW55LlxuICAgICAgICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHRoaXMgZXhhbXBsZSBvbmx5IG1hbmFnZXMgXCJwXCIgdGFncy5cbiAgICAgICAgICAgIC8vIEZldGNoIGV4aXN0aW5nIGNvbnRhY3QgbGlzdCB0byBwcmVzZXJ2ZSBvdGhlciB0YWdzIGlmIG5lY2Vzc2FyeSAobW9yZSBjb21wbGV4KVxuXG4gICAgICAgICAgICBjb25zdCB0YWdzID0gbmV3Rm9sbG93aW5nUHVia2V5cy5tYXAocGsgPT4gW1wicFwiLCBwa10pO1xuICAgICAgICAgICAgY29uc3QgdW5zaWduZWRFdmVudDogVW5zaWduZWRFdmVudCA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiAzLFxuICAgICAgICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgICAgICAgICB0YWdzOiB0YWdzLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsIC8vIE9yIEpTT04gc3RyaW5nIG9mIHJlbGF5IGhpbnRzIHBlciBOSVAtMDJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IG5vc3RyLnNpZ25FdmVudCh1bnNpZ25lZEV2ZW50KTtcbiAgICAgICAgICAgIGlmIChhd2FpdCBwdWJsaXNoRXZlbnQoc2lnbmVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgc2V0Rm9sbG93aW5nKG5ld0ZvbGxvd2luZ1B1YmtleXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byB1cGRhdGUgY29udGFjdCBsaXN0OlwiLCBlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gdXBkYXRlIGNvbnRhY3QgbGlzdC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBbcHVia2V5XSk7XG5cbiAgICBjb25zdCBmb2xsb3dVc2VyID0gdXNlQ2FsbGJhY2soYXN5bmMgKHVzZXJQdWJrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoZm9sbG93aW5nLmluY2x1ZGVzKHVzZXJQdWJrZXkpKSByZXR1cm4gdHJ1ZTsgLy8gQWxyZWFkeSBmb2xsb3dpbmdcbiAgICAgICAgY29uc3QgbmV3Rm9sbG93aW5nTGlzdCA9IFsuLi5mb2xsb3dpbmcsIHVzZXJQdWJrZXldO1xuICAgICAgICByZXR1cm4gYXdhaXQgdXBkYXRlQ29udGFjdExpc3QobmV3Rm9sbG93aW5nTGlzdCk7XG4gICAgfSwgW2ZvbGxvd2luZywgdXBkYXRlQ29udGFjdExpc3RdKTtcblxuICAgIGNvbnN0IHVuZm9sbG93VXNlciA9IHVzZUNhbGxiYWNrKGFzeW5jICh1c2VyUHVia2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKCFmb2xsb3dpbmcuaW5jbHVkZXModXNlclB1YmtleSkpIHJldHVybiB0cnVlOyAvLyBOb3QgZm9sbG93aW5nXG4gICAgICAgIGNvbnN0IG5ld0ZvbGxvd2luZ0xpc3QgPSBmb2xsb3dpbmcuZmlsdGVyKHBrID0+IHBrICE9PSB1c2VyUHVia2V5KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHVwZGF0ZUNvbnRhY3RMaXN0KG5ld0ZvbGxvd2luZ0xpc3QpO1xuICAgIH0sIFtmb2xsb3dpbmcsIHVwZGF0ZUNvbnRhY3RMaXN0XSk7XG5cblxuICAgIGNvbnN0IGlzRm9sbG93aW5nID0gdXNlQ2FsbGJhY2soKHVzZXJQdWJrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICByZXR1cm4gZm9sbG93aW5nLmluY2x1ZGVzKHVzZXJQdWJrZXkpO1xuICAgIH0sIFtmb2xsb3dpbmddKTtcblxuICAgIC8vIEVmZmVjdCB0byBsb2FkIGluaXRpYWwgZm9sbG93aW5nIGxpc3QgZm9yIHRoZSBsb2dnZWQtaW4gdXNlclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwdWJrZXkpIHtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBoZWFsdGh5UmVsYXlzIH0gPSBhd2FpdCBnZXRIZWFsdGh5UmVsYXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFsdGh5UmVsYXlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhY3RMaXN0RXZlbnRzID0gYXdhaXQgZmV0Y2hOb3N0ckZlZWQoaGVhbHRoeVJlbGF5cywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9yczogW3B1YmtleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kczogWzNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQ6IDEsIC8vIEdldCB0aGUgbGF0ZXN0IGNvbnRhY3QgbGlzdFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdExpc3RFdmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF0ZXN0Q29udGFjdExpc3QgPSBjb250YWN0TGlzdEV2ZW50cy5zb3J0KChhOiBhbnksIGI6IGFueSkgPT4gYi5jcmVhdGVkX2F0IC0gYS5jcmVhdGVkX2F0KVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvbGxvd2VkUHVia2V5cyA9IGxhdGVzdENvbnRhY3RMaXN0LnRhZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh0YWc6IHN0cmluZ1tdKSA9PiB0YWdbMF0gPT09ICdwJyAmJiB0YWdbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgodGFnOiBzdHJpbmdbXSkgPT4gdGFnWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEZvbGxvd2luZyhmb2xsb3dlZFB1YmtleXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggaW5pdGlhbCBjb250YWN0IGxpc3Q6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldEZvbGxvd2luZyhbXSk7IC8vIENsZWFyIGZvbGxvd2luZyBsaXN0IGlmIG5vdCBsb2dnZWQgaW5cbiAgICAgICAgfVxuICAgIH0sIFtwdWJrZXldKTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHVia2V5LFxuICAgICAgICBldmVudHMsXG4gICAgICAgIHByb2ZpbGUsXG4gICAgICAgIGZvbGxvd2luZyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgcmVsYXlTdGF0cyxcbiAgICAgICAgbG9naW4sXG4gICAgICAgIGZldGNoRXZlbnRzLFxuICAgICAgICBwb3N0LFxuICAgICAgICB1cGRhdGVQcm9maWxlOiB1cGRhdGVQcm9maWxlTWV0YWRhdGEsIC8vIFJlbmFtZWQgZm9yIGNsYXJpdHlcbiAgICAgICAgZm9sbG93VXNlcixcbiAgICAgICAgdW5mb2xsb3dVc2VyLFxuICAgICAgICBpc0ZvbGxvd2luZyxcbiAgICAgICAgc2V0RXZlbnRzLCAvLyBFeHBvc2luZyBzZXR0ZXJzIGNhbiBiZSB1c2VmdWwgYnV0IHVzZSB3aXRoIGNhdXRpb25cbiAgICAgICAgc2V0UHJvZmlsZSxcbiAgICAgICAgc2V0Rm9sbG93aW5nLFxuICAgIH07XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJmZXRjaE5vc3RyRmVlZCIsImZldGNoTm9zdHJQcm9maWxlIiwiZ2V0SGVhbHRoeVJlbGF5cyIsIlNpbXBsZVBvb2wiLCJSRUxBWVMiLCJ1c2VOb3N0ciIsInB1YmtleSIsInNldFB1YmtleSIsImV2ZW50cyIsInNldEV2ZW50cyIsInByb2ZpbGUiLCJzZXRQcm9maWxlIiwiZm9sbG93aW5nIiwic2V0Rm9sbG93aW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsInJlbGF5U3RhdHMiLCJzZXRSZWxheVN0YXRzIiwicHJvZmlsZUNhY2hlIiwiZ2V0V2luZG93Tm9zdHIiLCJ3aW5kb3ciLCJub3N0ciIsInN0b3JlZFB1YmtleSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzZXRJdGVtIiwibG9naW4iLCJwayIsImdldFB1YmxpY0tleSIsIm1lc3NhZ2UiLCJEYXRlIiwibm93Iiwic2lnbk1lc3NhZ2UiLCJzaWduYXR1cmUiLCJjb25zb2xlIiwibG9nIiwiZXJyIiwid2FybiIsImhlYWx0aHlSZWxheXMiLCJsZW5ndGgiLCJ1c2VyUHJvZmlsZURhdGEiLCJ1c2VyUHJvZmlsZSIsImN1cnJlbnQiLCJmZXRjaEV2ZW50cyIsIm9wdGlvbnMiLCJoZWFsdGh5Q291bnQiLCJ0b3RhbENvdW50IiwiZmV0Y2hlZE5vc3RyRXZlbnRzIiwibGltaXQiLCJ1bmlxdWVQdWJrZXlzIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwibWFwIiwiZXYiLCJwcm9maWxlc1RvRmV0Y2giLCJmaWx0ZXIiLCJQcm9taXNlIiwiYWxsIiwibWV0YSIsInByb2Nlc3NlZEZlZWQiLCJtZWRpYSIsInVybFJlZ2V4IiwibWF0Y2giLCJleGVjIiwiY29udGVudCIsInB1c2giLCJ1c2VyUHJvZiIsImRpc3BsYXlOYW1lIiwiZGlzcGxheV9uYW1lIiwibmFtZSIsInNsaWNlIiwicGljdHVyZSIsInVudGlsIiwicHJldiIsImV4aXN0aW5nSWRzIiwiZSIsImlkIiwibmV3RXZlbnRzIiwiaGFzIiwic29ydCIsImEiLCJiIiwiY3JlYXRlZF9hdCIsInB1Ymxpc2hFdmVudCIsInNpZ25lZEV2ZW50IiwicG9vbCIsInByb21pc2VzIiwicHVibGlzaCIsImFueSIsInAiLCJyYWNlIiwiXyIsInJlaiIsInNldFRpbWVvdXQiLCJFcnJvciIsImNsb3NlIiwicG9zdCIsInVuc2lnbmVkRXZlbnQiLCJraW5kIiwiTWF0aCIsImZsb29yIiwidGFncyIsInNpZ25FdmVudCIsImN1cnJlbnRQcm9maWxlIiwidXBkYXRlUHJvZmlsZU1ldGFkYXRhIiwibmV3UHJvZmlsZURhdGEiLCJjb250ZW50UGF5bG9hZCIsInVuZGVmaW5lZCIsImFib3V0IiwiYmFubmVyIiwid2Vic2l0ZSIsImx1ZDA2IiwibHVkMTYiLCJuaXAwNSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1cGRhdGVkRnVsbFByb2ZpbGUiLCJ1cGRhdGVDb250YWN0TGlzdCIsIm5ld0ZvbGxvd2luZ1B1YmtleXMiLCJmb2xsb3dVc2VyIiwidXNlclB1YmtleSIsImluY2x1ZGVzIiwibmV3Rm9sbG93aW5nTGlzdCIsInVuZm9sbG93VXNlciIsImlzRm9sbG93aW5nIiwiY29udGFjdExpc3RFdmVudHMiLCJhdXRob3JzIiwia2luZHMiLCJsYXRlc3RDb250YWN0TGlzdCIsImZvbGxvd2VkUHVia2V5cyIsInRhZyIsInVwZGF0ZVByb2ZpbGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useNostr.ts\n"));

/***/ })

});