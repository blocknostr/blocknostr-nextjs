"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useNostr.ts":
/*!*******************************!*\
  !*** ./src/hooks/useNostr.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RELAYS: () => (/* binding */ RELAYS),\n/* harmony export */   useNostr: () => (/* binding */ useNostr)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/nostr/relay */ \"(app-pages-browser)/./src/lib/nostr/relay.ts\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/../node_modules/nostr-tools/lib/esm/index.js\");\n\n\n\nconst RELAYS = [\n    \"wss://relay.damus.io\",\n    \"wss://relay.nostr.band\",\n    \"wss://nostr-pub.wellorder.net\"\n];\nfunction useNostr() {\n    const [pubkey, setPubkey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [profile, setProfile] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null); // Current user's profile\n    const [following, setFollowing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]); // List of pubkeys the user follows\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false); // General loading state\n    const [relayStats, setRelayStats] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const profileCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const getWindowNostr = ()=>{\n        return window.nostr;\n    };\n    // --- Persist pubkey in localStorage ---\n    // On mount, rehydrate pubkey from localStorage if present\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if (true) {\n                const storedPubkey = window.localStorage.getItem('nostr_pubkey');\n                if (storedPubkey && !pubkey) {\n                    setPubkey(storedPubkey);\n                }\n            }\n        }\n    }[\"useNostr.useEffect\"], []);\n    // When pubkey changes, persist to localStorage\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if ( true && pubkey) {\n                window.localStorage.setItem('nostr_pubkey', pubkey);\n            }\n        }\n    }[\"useNostr.useEffect\"], [\n        pubkey\n    ]);\n    // Auth/login\n    const login = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[login]\": async ()=>{\n            const nostr = getWindowNostr();\n            if (nostr) {\n                setIsLoading(true);\n                setError(null);\n                try {\n                    const pk = await nostr.getPublicKey();\n                    setPubkey(pk);\n                    // Optional: Schnorr signing for custom message (e.g., NIP-42 auth)\n                    const message = \"Login to RAW.ROCKS: \".concat(Date.now());\n                    if (typeof nostr.signMessage === \"function\") {\n                        try {\n                            const signature = await nostr.signMessage(message);\n                            console.log(\"Signed login message:\", signature);\n                        } catch (err) {\n                            console.warn(\"signMessage for login failed:\", err);\n                        }\n                    } else {\n                        console.warn(\"signMessage is not supported by this NOSTR extension.\");\n                    }\n                    // Load profile from relays\n                    const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                    if (healthyRelays.length > 0) {\n                        const userProfileData = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrProfile)(healthyRelays, pk);\n                        if (userProfileData) {\n                            const userProfile = {\n                                ...userProfileData,\n                                pubkey: pk,\n                                username: userProfileData.name || pk\n                            };\n                            setProfile(userProfile);\n                            profileCache.current[pk] = userProfile;\n                        }\n                    } else {\n                        console.warn(\"No healthy relays to fetch initial profile.\");\n                    }\n                } catch (err) {\n                    console.error(\"Login failed:\", err);\n                    setError(err.message || \"Login failed. Please ensure your NOSTR extension is configured.\");\n                    setPubkey(null);\n                } finally{\n                    setIsLoading(false);\n                }\n            } else {\n                setError(\"NOSTR extension not found. Please install a NOSTR browser extension.\");\n            // alert(\"NOSTR extension not found. Please install a NOSTR browser extension.\");\n            }\n        }\n    }[\"useNostr.useCallback[login]\"], []);\n    // Fetch feed with pagination support\n    const fetchEvents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[fetchEvents]\": async (options)=>{\n            setIsLoading(true);\n            setError(null);\n            try {\n                const { healthyRelays, healthyCount, totalCount } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                setRelayStats({\n                    healthyCount,\n                    totalCount\n                });\n                if (!healthyRelays.length) {\n                    setError(\"No healthy relays available to fetch feed.\");\n                    return false;\n                }\n                const fetchedNostrEvents = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrFeed)(healthyRelays, {\n                    limit: 20,\n                    ...options\n                });\n                const uniquePubkeys = Array.from(new Set(fetchedNostrEvents.map({\n                    \"useNostr.useCallback[fetchEvents].uniquePubkeys\": (ev)=>ev.pubkey\n                }[\"useNostr.useCallback[fetchEvents].uniquePubkeys\"])));\n                const profilesToFetch = uniquePubkeys.filter({\n                    \"useNostr.useCallback[fetchEvents].profilesToFetch\": (pk)=>!profileCache.current[pk]\n                }[\"useNostr.useCallback[fetchEvents].profilesToFetch\"]);\n                if (profilesToFetch.length > 0) {\n                    await Promise.all(profilesToFetch.map({\n                        \"useNostr.useCallback[fetchEvents]\": async (pk)=>{\n                            const meta = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrProfile)(healthyRelays, pk);\n                            if (meta) {\n                                profileCache.current[pk] = {\n                                    ...meta,\n                                    pubkey: pk,\n                                    username: meta.name || pk\n                                };\n                            }\n                        }\n                    }[\"useNostr.useCallback[fetchEvents]\"]));\n                }\n                const processedFeed = fetchedNostrEvents.map({\n                    \"useNostr.useCallback[fetchEvents].processedFeed\": (ev)=>{\n                        let media = [];\n                        const urlRegex = /(https?:\\/\\/(?:[\\w-]+\\.)+[\\w-]+(?:\\/[\\w\\-._~:/?#[\\]@!$&'()*+,;=]*)?\\.(?:jpg|jpeg|png|gif|mp4|webm))/gi;\n                        let match;\n                        while(match = urlRegex.exec(ev.content)){\n                            media.push(match[1]);\n                        }\n                        const userProf = profileCache.current[ev.pubkey] || {\n                            pubkey: ev.pubkey,\n                            username: ev.pubkey\n                        };\n                        const picture = userProf.picture || \"/file.svg\"; // Default avatar\n                        return {\n                            ...ev,\n                            media,\n                            profile: {\n                                ...userProf,\n                                display_name: userProf.display_name || userProf.username || \"\".concat(ev.pubkey.slice(0, 6), \"...\").concat(ev.pubkey.slice(-4)),\n                                picture: picture,\n                                username: userProf.username || userProf.name || ev.pubkey,\n                                pubkey: ev.pubkey\n                            }\n                        };\n                    }\n                }[\"useNostr.useCallback[fetchEvents].processedFeed\"]);\n                if (options === null || options === void 0 ? void 0 : options.until) {\n                    setEvents({\n                        \"useNostr.useCallback[fetchEvents]\": (prev)=>{\n                            const existingIds = new Set(prev.map({\n                                \"useNostr.useCallback[fetchEvents]\": (e)=>e.id\n                            }[\"useNostr.useCallback[fetchEvents]\"]));\n                            const newEvents = processedFeed.filter({\n                                \"useNostr.useCallback[fetchEvents].newEvents\": (e)=>!existingIds.has(e.id)\n                            }[\"useNostr.useCallback[fetchEvents].newEvents\"]);\n                            return [\n                                ...prev,\n                                ...newEvents\n                            ].sort({\n                                \"useNostr.useCallback[fetchEvents]\": (a, b)=>b.created_at - a.created_at\n                            }[\"useNostr.useCallback[fetchEvents]\"]);\n                        }\n                    }[\"useNostr.useCallback[fetchEvents]\"]);\n                } else {\n                    setEvents(processedFeed.sort({\n                        \"useNostr.useCallback[fetchEvents]\": (a, b)=>b.created_at - a.created_at\n                    }[\"useNostr.useCallback[fetchEvents]\"]));\n                }\n                return processedFeed.length > 0;\n            } catch (err) {\n                console.error(\"Error fetching events:\", err);\n                setError(err.message || \"Failed to fetch posts. Please try again later.\");\n                return false;\n            } finally{\n                setIsLoading(false);\n            }\n        }\n    }[\"useNostr.useCallback[fetchEvents]\"], []);\n    // Helper to publish a signed event\n    const publishEvent = async (signedEvent)=>{\n        try {\n            const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n            if (!healthyRelays.length) {\n                setError(\"No healthy relays available to publish event.\");\n                return false;\n            }\n            const pool = new nostr_tools__WEBPACK_IMPORTED_MODULE_2__.SimplePool();\n            const promises = pool.publish(healthyRelays, signedEvent);\n            // Wait for at least one successful publish or timeout\n            // This is a simplified version; nostr-tools' publish returns promises for each relay\n            await Promise.any(promises.map((p)=>Promise.race([\n                    p,\n                    new Promise((_, rej)=>setTimeout(()=>rej(new Error('timeout')), 5000))\n                ])));\n            pool.close(healthyRelays); // Close connections after publishing\n            return true;\n        } catch (err) {\n            console.error(\"Failed to publish event to relays:\", err);\n            setError(\"Failed to publish event. Some relays might be offline.\");\n            return false;\n        }\n    };\n    // Post event (sign and publish using extension)\n    const post = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[post]\": async (content)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                const unsignedEvent = {\n                    kind: 1,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: [],\n                    content\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    // Optimistic update\n                    const currentProfile = profileCache.current[pubkey] || {\n                        pubkey\n                    };\n                    setEvents({\n                        \"useNostr.useCallback[post]\": (prev)=>[\n                                {\n                                    id: signedEvent.id,\n                                    pubkey: signedEvent.pubkey,\n                                    content: signedEvent.content,\n                                    created_at: signedEvent.created_at,\n                                    kind: signedEvent.kind,\n                                    tags: signedEvent.tags,\n                                    media: [],\n                                    profile: {\n                                        display_name: currentProfile.display_name || currentProfile.username || \"\".concat(pubkey.slice(0, 6), \"...\").concat(pubkey.slice(-4)),\n                                        picture: currentProfile.picture || \"/file.svg\",\n                                        username: currentProfile.username || currentProfile.name || pubkey,\n                                        pubkey: pubkey\n                                    }\n                                },\n                                ...prev\n                            ].sort({\n                                \"useNostr.useCallback[post]\": (a, b)=>b.created_at - a.created_at\n                            }[\"useNostr.useCallback[post]\"])\n                    }[\"useNostr.useCallback[post]\"]);\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to post event:\", err);\n                setError(err.message || \"Failed to post. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[post]\"], [\n        pubkey,\n        profile\n    ]);\n    // Update profile (Kind 0)\n    const updateProfileMetadata = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[updateProfileMetadata]\": async (newProfileData)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                // Ensure only valid profile fields are included\n                const contentPayload = {};\n                if (newProfileData.username !== undefined) contentPayload.name = newProfileData.username; // Always set 'name' from 'username'\n                if (newProfileData.display_name !== undefined) contentPayload.display_name = newProfileData.display_name;\n                if (newProfileData.about !== undefined) contentPayload.about = newProfileData.about;\n                if (newProfileData.picture !== undefined) contentPayload.picture = newProfileData.picture;\n                if (newProfileData.banner !== undefined) contentPayload.banner = newProfileData.banner;\n                if (newProfileData.website !== undefined) contentPayload.website = newProfileData.website;\n                if (newProfileData.lud06 !== undefined) contentPayload.lud06 = newProfileData.lud06;\n                if (newProfileData.lud16 !== undefined) contentPayload.lud16 = newProfileData.lud16;\n                if (newProfileData.nip05 !== undefined) contentPayload.nip05 = newProfileData.nip05;\n                const unsignedEvent = {\n                    kind: 0,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: [],\n                    content: JSON.stringify(contentPayload)\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    const updatedFullProfile = {\n                        ...profile,\n                        ...newProfileData,\n                        pubkey,\n                        username: newProfileData.username\n                    };\n                    setProfile(updatedFullProfile);\n                    profileCache.current[pubkey] = updatedFullProfile; // Update cache\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to update profile:\", err);\n                setError(err.message || \"Failed to update profile. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[updateProfileMetadata]\"], [\n        pubkey,\n        profile\n    ]);\n    // Manage contact list (Kind 3)\n    const updateContactList = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[updateContactList]\": async (newFollowingPubkeys)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                // NIP-02 recommends preserving existing non-\"p\" tags if any.\n                // For simplicity, this example only manages \"p\" tags.\n                // Fetch existing contact list to preserve other tags if necessary (more complex)\n                const tags = newFollowingPubkeys.map({\n                    \"useNostr.useCallback[updateContactList].tags\": (pk)=>[\n                            \"p\",\n                            pk\n                        ]\n                }[\"useNostr.useCallback[updateContactList].tags\"]);\n                const unsignedEvent = {\n                    kind: 3,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: tags,\n                    content: \"\"\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    setFollowing(newFollowingPubkeys);\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to update contact list:\", err);\n                setError(err.message || \"Failed to update contact list. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[updateContactList]\"], [\n        pubkey\n    ]);\n    const followUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[followUser]\": async (userPubkey)=>{\n            if (following.includes(userPubkey)) return true; // Already following\n            const newFollowingList = [\n                ...following,\n                userPubkey\n            ];\n            return await updateContactList(newFollowingList);\n        }\n    }[\"useNostr.useCallback[followUser]\"], [\n        following,\n        updateContactList\n    ]);\n    const unfollowUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[unfollowUser]\": async (userPubkey)=>{\n            if (!following.includes(userPubkey)) return true; // Not following\n            const newFollowingList = following.filter({\n                \"useNostr.useCallback[unfollowUser].newFollowingList\": (pk)=>pk !== userPubkey\n            }[\"useNostr.useCallback[unfollowUser].newFollowingList\"]);\n            return await updateContactList(newFollowingList);\n        }\n    }[\"useNostr.useCallback[unfollowUser]\"], [\n        following,\n        updateContactList\n    ]);\n    const isFollowing = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[isFollowing]\": (userPubkey)=>{\n            return following.includes(userPubkey);\n        }\n    }[\"useNostr.useCallback[isFollowing]\"], [\n        following\n    ]);\n    // Effect to load initial following list for the logged-in user\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if (pubkey) {\n                ({\n                    \"useNostr.useEffect\": async ()=>{\n                        try {\n                            const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                            if (healthyRelays.length === 0) return;\n                            // Use correct filter type for nostr-tools\n                            const filter = {\n                                kinds: [\n                                    3\n                                ],\n                                authors: [\n                                    pubkey\n                                ],\n                                limit: 1\n                            };\n                            // @ts-ignore: Filter type is broader than FeedOptions\n                            const contactListEvents = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrFeed)(healthyRelays, filter);\n                            if (contactListEvents.length > 0) {\n                                const latestContactList = contactListEvents.sort({\n                                    \"useNostr.useEffect\": (a, b)=>b.created_at - a.created_at\n                                }[\"useNostr.useEffect\"])[0];\n                                const followedPubkeys = latestContactList.tags.filter({\n                                    \"useNostr.useEffect.followedPubkeys\": (tag)=>tag[0] === 'p' && tag[1]\n                                }[\"useNostr.useEffect.followedPubkeys\"]).map({\n                                    \"useNostr.useEffect.followedPubkeys\": (tag)=>tag[1]\n                                }[\"useNostr.useEffect.followedPubkeys\"]);\n                                setFollowing(followedPubkeys);\n                            }\n                        } catch (err) {\n                            console.error(\"Failed to fetch initial contact list:\", err);\n                        }\n                    }\n                })[\"useNostr.useEffect\"]();\n            } else {\n                setFollowing([]); // Clear following list if not logged in\n            }\n        }\n    }[\"useNostr.useEffect\"], [\n        pubkey\n    ]);\n    return {\n        pubkey,\n        events,\n        profile,\n        following,\n        error,\n        isLoading,\n        relayStats,\n        login,\n        fetchEvents,\n        post,\n        updateProfile: updateProfileMetadata,\n        followUser,\n        unfollowUser,\n        isFollowing,\n        setEvents,\n        setProfile,\n        setFollowing\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VOb3N0ci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUU7QUFDdUI7QUFTeUI7QUFnQjFHLE1BQU1RLFNBQVM7SUFDbEI7SUFDQTtJQUNBO0NBRUgsQ0FBQztBQTJCSyxTQUFTQztJQUNaLE1BQU0sQ0FBQ0MsUUFBUUMsVUFBVSxHQUFHWCwrQ0FBUUEsQ0FBZ0I7SUFDcEQsTUFBTSxDQUFDWSxRQUFRQyxVQUFVLEdBQUdiLCtDQUFRQSxDQUFlLEVBQUU7SUFDckQsTUFBTSxDQUFDYyxTQUFTQyxXQUFXLEdBQUdmLCtDQUFRQSxDQUFzQixPQUFPLHlCQUF5QjtJQUM1RixNQUFNLENBQUNnQixXQUFXQyxhQUFhLEdBQUdqQiwrQ0FBUUEsQ0FBVyxFQUFFLEdBQUcsbUNBQW1DO0lBQzdGLE1BQU0sQ0FBQ2tCLE9BQU9DLFNBQVMsR0FBR25CLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUNvQixXQUFXQyxhQUFhLEdBQUdyQiwrQ0FBUUEsQ0FBVSxRQUFRLHdCQUF3QjtJQUNwRixNQUFNLENBQUNzQixZQUFZQyxjQUFjLEdBQUd2QiwrQ0FBUUEsQ0FBdUQ7SUFDbkcsTUFBTXdCLGVBQWV0Qiw2Q0FBTUEsQ0FBcUMsQ0FBQztJQUVqRSxNQUFNdUIsaUJBQWlCO1FBQ25CLE9BQU9DLE9BQU9DLEtBQUs7SUFDdkI7SUFFQSx5Q0FBeUM7SUFDekMsMERBQTBEO0lBQzFEeEIsZ0RBQVNBOzhCQUFDO1lBQ04sSUFBSSxJQUE2QixFQUFFO2dCQUMvQixNQUFNeUIsZUFBZUYsT0FBT0csWUFBWSxDQUFDQyxPQUFPLENBQUM7Z0JBQ2pELElBQUlGLGdCQUFnQixDQUFDbEIsUUFBUTtvQkFDekJDLFVBQVVpQjtnQkFDZDtZQUNKO1FBQ0o7NkJBQUcsRUFBRTtJQUVMLCtDQUErQztJQUMvQ3pCLGdEQUFTQTs4QkFBQztZQUNOLElBQUksS0FBNkIsSUFBSU8sUUFBUTtnQkFDekNnQixPQUFPRyxZQUFZLENBQUNF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QUNIekIsYUFBYSxFQUFFLEdBQUcsd0NBQXdDO1lBQzlEO1FBQ0o7NkJBQUc7UUFBQ1A7S0FBTztJQUdYLE9BQU87UUFDSEE7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQVU7UUFDQW1CO1FBQ0FvRDtRQUNBbUMsZUFBZTNCO1FBQ2ZlO1FBQ0FJO1FBQ0FDO1FBQ0F0SDtRQUNBRTtRQUNBRTtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9zcmMvaG9va3MvdXNlTm9zdHIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZmV0Y2hOb3N0ckZlZWQsIGZldGNoTm9zdHJQcm9maWxlLCBnZXRIZWFsdGh5UmVsYXlzIH0gZnJvbSBcIkAvbGliL25vc3RyL3JlbGF5XCI7XG5cbi8vIEV4dGVuZCBGZWVkT3B0aW9ucyB0byBpbmNsdWRlICdhdXRob3JzJ1xuZXhwb3J0IGludGVyZmFjZSBGZWVkT3B0aW9ucyB7XG4gICAgbGltaXQ/OiBudW1iZXI7XG4gICAgdW50aWw/OiBudW1iZXI7XG4gICAga2luZHM/OiBudW1iZXJbXTtcbiAgICBhdXRob3JzPzogc3RyaW5nW107IC8vIEFkZGVkIGF1dGhvcnMgcHJvcGVydHkgdG8gbWF0Y2ggdXNhZ2Vcbn1cbmltcG9ydCB7IFNpbXBsZVBvb2wsIG5pcDE5LCB0eXBlIEV2ZW50IGFzIE5vc3RyVG9vbHNFdmVudCwgdHlwZSBVbnNpZ25lZEV2ZW50LCBnZXRFdmVudEhhc2ggfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcblxuLy8gRGVmaW5lIHRoZSBOSVAtMDcgd2luZG93Lm5vc3RyIGludGVyZmFjZVxuaW50ZXJmYWNlIFdpbmRvd05vc3RyIHtcbiAgICBnZXRQdWJsaWNLZXkoKTogUHJvbWlzZTxzdHJpbmc+O1xuICAgIHNpZ25FdmVudChldmVudDogVW5zaWduZWRFdmVudCk6IFByb21pc2U8Tm9zdHJUb29sc0V2ZW50PjtcbiAgICBzaWduTWVzc2FnZT8obWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+OyAvLyBPcHRpb25hbCBOSVAtNDIgb3IgY3VzdG9tIHVzYWdlXG4gICAgZ2V0UmVsYXlzPygpOiBQcm9taXNlPHsgW3VybDogc3RyaW5nXTogeyByZWFkOiBib29sZWFuOyB3cml0ZTogYm9vbGVhbiB9IH0+OyAvLyBPcHRpb25hbFxufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gICAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgICAgIG5vc3RyPzogV2luZG93Tm9zdHI7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgUkVMQVlTID0gW1xuICAgIFwid3NzOi8vcmVsYXkuZGFtdXMuaW9cIixcbiAgICBcIndzczovL3JlbGF5Lm5vc3RyLmJhbmRcIixcbiAgICBcIndzczovL25vc3RyLXB1Yi53ZWxsb3JkZXIubmV0XCIsXG4gICAgLy8gQWRkIG1vcmUgZGVmYXVsdCByZWxheXMgb3IgbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuXTtcblxuZXhwb3J0IGludGVyZmFjZSBOb3N0clByb2ZpbGUge1xuICAgIHVzZXJuYW1lPzogc3RyaW5nOyAvLyBBbHdheXMgc2V0OiBtYXBwZWQgZnJvbSAnbmFtZScgaW4gTm9zdHIgc3BlY1xuICAgIGRpc3BsYXlfbmFtZT86IHN0cmluZztcbiAgICBhYm91dD86IHN0cmluZztcbiAgICBwaWN0dXJlPzogc3RyaW5nO1xuICAgIGJhbm5lcj86IHN0cmluZztcbiAgICB3ZWJzaXRlPzogc3RyaW5nO1xuICAgIGx1ZDA2Pzogc3RyaW5nO1xuICAgIGx1ZDE2Pzogc3RyaW5nO1xuICAgIG5pcDA1Pzogc3RyaW5nO1xuICAgIHB1YmtleT86IHN0cmluZzsgLy8gQWRkZWQgZm9yIGNvbnZlbmllbmNlXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9zdHJFdmVudCB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBwdWJrZXk6IHN0cmluZztcbiAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgY3JlYXRlZF9hdDogbnVtYmVyO1xuICAgIGtpbmQ6IG51bWJlcjtcbiAgICB0YWdzOiBzdHJpbmdbXVtdO1xuICAgIG1lZGlhOiBzdHJpbmdbXTsgLy8gQ3VzdG9tIGRlcml2ZWQgZmllbGRcbiAgICBwcm9maWxlPzogTm9zdHJQcm9maWxlOyAvLyBDdXN0b20gZGVyaXZlZCBmaWVsZFxuICAgIC8vIEFkZCBvdGhlciBldmVudCBmaWVsZHMgaWYgbmVlZGVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VOb3N0cigpIHtcbiAgICBjb25zdCBbcHVia2V5LCBzZXRQdWJrZXldID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW2V2ZW50cywgc2V0RXZlbnRzXSA9IHVzZVN0YXRlPE5vc3RyRXZlbnRbXT4oW10pO1xuICAgIGNvbnN0IFtwcm9maWxlLCBzZXRQcm9maWxlXSA9IHVzZVN0YXRlPE5vc3RyUHJvZmlsZSB8IG51bGw+KG51bGwpOyAvLyBDdXJyZW50IHVzZXIncyBwcm9maWxlXG4gICAgY29uc3QgW2ZvbGxvd2luZywgc2V0Rm9sbG93aW5nXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7IC8vIExpc3Qgb2YgcHVia2V5cyB0aGUgdXNlciBmb2xsb3dzXG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpOyAvLyBHZW5lcmFsIGxvYWRpbmcgc3RhdGVcbiAgICBjb25zdCBbcmVsYXlTdGF0cywgc2V0UmVsYXlTdGF0c10gPSB1c2VTdGF0ZTx7IGhlYWx0aHlDb3VudDogbnVtYmVyOyB0b3RhbENvdW50OiBudW1iZXI7IH0gfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBwcm9maWxlQ2FjaGUgPSB1c2VSZWY8eyBbcHVia2V5OiBzdHJpbmddOiBOb3N0clByb2ZpbGUgfT4oe30pO1xuXG4gICAgY29uc3QgZ2V0V2luZG93Tm9zdHIgPSAoKTogV2luZG93Tm9zdHIgfCB1bmRlZmluZWQgPT4ge1xuICAgICAgICByZXR1cm4gd2luZG93Lm5vc3RyO1xuICAgIH07XG5cbiAgICAvLyAtLS0gUGVyc2lzdCBwdWJrZXkgaW4gbG9jYWxTdG9yYWdlIC0tLVxuICAgIC8vIE9uIG1vdW50LCByZWh5ZHJhdGUgcHVia2V5IGZyb20gbG9jYWxTdG9yYWdlIGlmIHByZXNlbnRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFB1YmtleSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbm9zdHJfcHVia2V5Jyk7XG4gICAgICAgICAgICBpZiAoc3RvcmVkUHVia2V5ICYmICFwdWJrZXkpIHtcbiAgICAgICAgICAgICAgICBzZXRQdWJrZXkoc3RvcmVkUHVia2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIFdoZW4gcHVia2V5IGNoYW5nZXMsIHBlcnNpc3QgdG8gbG9jYWxTdG9yYWdlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHB1YmtleSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKCdub3N0cl9wdWJrZXknLCBwdWJrZXkpO1xuICAgICAgICB9XG4gICAgfSwgW3B1YmtleV0pO1xuXG4gICAgLy8gQXV0aC9sb2dpblxuICAgIGNvbnN0IGxvZ2luID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBub3N0ciA9IGdldFdpbmRvd05vc3RyKCk7XG4gICAgICAgIGlmIChub3N0cikge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBrID0gYXdhaXQgbm9zdHIuZ2V0UHVibGljS2V5KCk7XG4gICAgICAgICAgICAgICAgc2V0UHVia2V5KHBrKTtcblxuICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsOiBTY2hub3JyIHNpZ25pbmcgZm9yIGN1c3RvbSBtZXNzYWdlIChlLmcuLCBOSVAtNDIgYXV0aClcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYExvZ2luIHRvIFJBVy5ST0NLUzogJHtEYXRlLm5vdygpfWA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub3N0ci5zaWduTWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBub3N0ci5zaWduTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2lnbmVkIGxvZ2luIG1lc3NhZ2U6XCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwic2lnbk1lc3NhZ2UgZm9yIGxvZ2luIGZhaWxlZDpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInNpZ25NZXNzYWdlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBOT1NUUiBleHRlbnNpb24uXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExvYWQgcHJvZmlsZSBmcm9tIHJlbGF5c1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGVhbHRoeVJlbGF5cyB9ID0gYXdhaXQgZ2V0SGVhbHRoeVJlbGF5cygpO1xuICAgICAgICAgICAgICAgIGlmIChoZWFsdGh5UmVsYXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlclByb2ZpbGVEYXRhID0gYXdhaXQgZmV0Y2hOb3N0clByb2ZpbGUoaGVhbHRoeVJlbGF5cywgcGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlclByb2ZpbGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyUHJvZmlsZTogTm9zdHJQcm9maWxlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVzZXJQcm9maWxlRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJrZXk6IHBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VyUHJvZmlsZURhdGEubmFtZSB8fCBwayxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQcm9maWxlKHVzZXJQcm9maWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGVDYWNoZS5jdXJyZW50W3BrXSA9IHVzZXJQcm9maWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTm8gaGVhbHRoeSByZWxheXMgdG8gZmV0Y2ggaW5pdGlhbCBwcm9maWxlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJMb2dpbiBmYWlsZWQ6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJMb2dpbiBmYWlsZWQuIFBsZWFzZSBlbnN1cmUgeW91ciBOT1NUUiBleHRlbnNpb24gaXMgY29uZmlndXJlZC5cIik7XG4gICAgICAgICAgICAgICAgc2V0UHVia2V5KG51bGwpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0RXJyb3IoXCJOT1NUUiBleHRlbnNpb24gbm90IGZvdW5kLiBQbGVhc2UgaW5zdGFsbCBhIE5PU1RSIGJyb3dzZXIgZXh0ZW5zaW9uLlwiKTtcbiAgICAgICAgICAgIC8vIGFsZXJ0KFwiTk9TVFIgZXh0ZW5zaW9uIG5vdCBmb3VuZC4gUGxlYXNlIGluc3RhbGwgYSBOT1NUUiBicm93c2VyIGV4dGVuc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICAvLyBGZXRjaCBmZWVkIHdpdGggcGFnaW5hdGlvbiBzdXBwb3J0XG4gICAgY29uc3QgZmV0Y2hFdmVudHMgPSB1c2VDYWxsYmFjayhhc3luYyAob3B0aW9ucz86IEZlZWRPcHRpb25zKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGhlYWx0aHlSZWxheXMsIGhlYWx0aHlDb3VudCwgdG90YWxDb3VudCB9ID0gYXdhaXQgZ2V0SGVhbHRoeVJlbGF5cygpO1xuICAgICAgICAgICAgc2V0UmVsYXlTdGF0cyh7IGhlYWx0aHlDb3VudCwgdG90YWxDb3VudCB9KTtcblxuICAgICAgICAgICAgaWYgKCFoZWFsdGh5UmVsYXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKFwiTm8gaGVhbHRoeSByZWxheXMgYXZhaWxhYmxlIHRvIGZldGNoIGZlZWQuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZmV0Y2hlZE5vc3RyRXZlbnRzID0gYXdhaXQgZmV0Y2hOb3N0ckZlZWQoaGVhbHRoeVJlbGF5cywge1xuICAgICAgICAgICAgICAgIGxpbWl0OiAyMCxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgdW5pcXVlUHVia2V5cyA9IEFycmF5LmZyb20obmV3IFNldChmZXRjaGVkTm9zdHJFdmVudHMubWFwKGV2ID0+IGV2LnB1YmtleSkpKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2ZpbGVzVG9GZXRjaCA9IHVuaXF1ZVB1YmtleXMuZmlsdGVyKHBrID0+ICFwcm9maWxlQ2FjaGUuY3VycmVudFtwa10pO1xuXG4gICAgICAgICAgICBpZiAocHJvZmlsZXNUb0ZldGNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9maWxlc1RvRmV0Y2gubWFwKGFzeW5jIChwaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gYXdhaXQgZmV0Y2hOb3N0clByb2ZpbGUoaGVhbHRoeVJlbGF5cywgcGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZUNhY2hlLmN1cnJlbnRbcGtdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1ldGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVia2V5OiBwayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogbWV0YS5uYW1lIHx8IHBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkRmVlZCA9IGZldGNoZWROb3N0ckV2ZW50cy5tYXAoKGV2KTogTm9zdHJFdmVudCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG1lZGlhOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybFJlZ2V4ID0gLyhodHRwcz86XFwvXFwvKD86W1xcdy1dK1xcLikrW1xcdy1dKyg/OlxcL1tcXHdcXC0uX346Lz8jW1xcXUAhJCYnKCkqKyw7PV0qKT9cXC4oPzpqcGd8anBlZ3xwbmd8Z2lmfG1wNHx3ZWJtKSkvZ2k7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSB1cmxSZWdleC5leGVjKGV2LmNvbnRlbnQpKSkge1xuICAgICAgICAgICAgICAgICAgICBtZWRpYS5wdXNoKG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyUHJvZiA9IHByb2ZpbGVDYWNoZS5jdXJyZW50W2V2LnB1YmtleV0gfHwgeyBwdWJrZXk6IGV2LnB1YmtleSwgdXNlcm5hbWU6IGV2LnB1YmtleSB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpY3R1cmUgPSB1c2VyUHJvZi5waWN0dXJlIHx8IFwiL2ZpbGUuc3ZnXCI7IC8vIERlZmF1bHQgYXZhdGFyXG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5ldixcbiAgICAgICAgICAgICAgICAgICAgbWVkaWEsXG4gICAgICAgICAgICAgICAgICAgIHByb2ZpbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVzZXJQcm9mLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9uYW1lOiB1c2VyUHJvZi5kaXNwbGF5X25hbWUgfHwgdXNlclByb2YudXNlcm5hbWUgfHwgYCR7ZXYucHVia2V5LnNsaWNlKDAsIDYpfS4uLiR7ZXYucHVia2V5LnNsaWNlKC00KX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGljdHVyZTogcGljdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiB1c2VyUHJvZi51c2VybmFtZSB8fCB1c2VyUHJvZi5uYW1lIHx8IGV2LnB1YmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YmtleTogZXYucHVia2V5LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnM/LnVudGlsKSB7XG4gICAgICAgICAgICAgICAgc2V0RXZlbnRzKHByZXYgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0lkcyA9IG5ldyBTZXQocHJldi5tYXAoZSA9PiBlLmlkKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0V2ZW50cyA9IHByb2Nlc3NlZEZlZWQuZmlsdGVyKGUgPT4gIWV4aXN0aW5nSWRzLmhhcyhlLmlkKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbLi4ucHJldiwgLi4ubmV3RXZlbnRzXS5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRFdmVudHMocHJvY2Vzc2VkRmVlZC5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzZWRGZWVkLmxlbmd0aCA+IDA7XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgZXZlbnRzOlwiLCBlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggcG9zdHMuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIEhlbHBlciB0byBwdWJsaXNoIGEgc2lnbmVkIGV2ZW50XG4gICAgY29uc3QgcHVibGlzaEV2ZW50ID0gYXN5bmMgKHNpZ25lZEV2ZW50OiBOb3N0clRvb2xzRXZlbnQpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGVhbHRoeVJlbGF5cyB9ID0gYXdhaXQgZ2V0SGVhbHRoeVJlbGF5cygpO1xuICAgICAgICAgICAgaWYgKCFoZWFsdGh5UmVsYXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKFwiTm8gaGVhbHRoeSByZWxheXMgYXZhaWxhYmxlIHRvIHB1Ymxpc2ggZXZlbnQuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBuZXcgU2ltcGxlUG9vbCgpO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBwb29sLnB1Ymxpc2goaGVhbHRoeVJlbGF5cywgc2lnbmVkRXZlbnQpO1xuICAgICAgICAgICAgLy8gV2FpdCBmb3IgYXQgbGVhc3Qgb25lIHN1Y2Nlc3NmdWwgcHVibGlzaCBvciB0aW1lb3V0XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCB2ZXJzaW9uOyBub3N0ci10b29scycgcHVibGlzaCByZXR1cm5zIHByb21pc2VzIGZvciBlYWNoIHJlbGF5XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFueShwcm9taXNlcy5tYXAocCA9PiBQcm9taXNlLnJhY2UoW3AsIG5ldyBQcm9taXNlKChfLCByZWopID0+IHNldFRpbWVvdXQoKCkgPT4gcmVqKG5ldyBFcnJvcigndGltZW91dCcpKSwgNTAwMCkpXSkpKTtcbiAgICAgICAgICAgIHBvb2wuY2xvc2UoaGVhbHRoeVJlbGF5cyk7IC8vIENsb3NlIGNvbm5lY3Rpb25zIGFmdGVyIHB1Ymxpc2hpbmdcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcHVibGlzaCBldmVudCB0byByZWxheXM6XCIsIGVycik7XG4gICAgICAgICAgICBzZXRFcnJvcihcIkZhaWxlZCB0byBwdWJsaXNoIGV2ZW50LiBTb21lIHJlbGF5cyBtaWdodCBiZSBvZmZsaW5lLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBQb3N0IGV2ZW50IChzaWduIGFuZCBwdWJsaXNoIHVzaW5nIGV4dGVuc2lvbilcbiAgICBjb25zdCBwb3N0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKGNvbnRlbnQ6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBub3N0ciA9IGdldFdpbmRvd05vc3RyKCk7XG4gICAgICAgIGlmICghcHVia2V5IHx8ICFub3N0cikge1xuICAgICAgICAgICAgc2V0RXJyb3IoXCJOb3QgbG9nZ2VkIGluIG9yIE5PU1RSIGV4dGVuc2lvbiBub3QgZm91bmQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZEV2ZW50OiBVbnNpZ25lZEV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IDEsXG4gICAgICAgICAgICAgICAgcHVia2V5LFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICAgICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkRXZlbnQgPSBhd2FpdCBub3N0ci5zaWduRXZlbnQodW5zaWduZWRFdmVudCk7XG5cbiAgICAgICAgICAgIGlmIChhd2FpdCBwdWJsaXNoRXZlbnQoc2lnbmVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gT3B0aW1pc3RpYyB1cGRhdGVcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UHJvZmlsZSA9IHByb2ZpbGVDYWNoZS5jdXJyZW50W3B1YmtleV0gfHwgeyBwdWJrZXkgfTtcbiAgICAgICAgICAgICAgICBzZXRFdmVudHMocHJldiA9PiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzaWduZWRFdmVudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YmtleTogc2lnbmVkRXZlbnQucHVia2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogc2lnbmVkRXZlbnQuY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IHNpZ25lZEV2ZW50LmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBzaWduZWRFdmVudC5raW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogc2lnbmVkRXZlbnQudGFncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhOiBbXSwgLy8gRGVyaXZlIG1lZGlhIGlmIG5lZWRlZCwgb3IgbGVhdmUgZm9yIGRpc3BsYXkgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9maWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9uYW1lOiBjdXJyZW50UHJvZmlsZS5kaXNwbGF5X25hbWUgfHwgY3VycmVudFByb2ZpbGUudXNlcm5hbWUgfHwgYCR7cHVia2V5LnNsaWNlKDAsIDYpfS4uLiR7cHVia2V5LnNsaWNlKC00KX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY3R1cmU6IGN1cnJlbnRQcm9maWxlLnBpY3R1cmUgfHwgXCIvZmlsZS5zdmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogY3VycmVudFByb2ZpbGUudXNlcm5hbWUgfHwgY3VycmVudFByb2ZpbGUubmFtZSB8fCBwdWJrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVia2V5OiBwdWJrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICAgICAgXS5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcG9zdCBldmVudDpcIiwgZXJyKTtcbiAgICAgICAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIHBvc3QuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW3B1YmtleSwgcHJvZmlsZV0pO1xuXG4gICAgLy8gVXBkYXRlIHByb2ZpbGUgKEtpbmQgMClcbiAgICBjb25zdCB1cGRhdGVQcm9maWxlTWV0YWRhdGEgPSB1c2VDYWxsYmFjayhhc3luYyAobmV3UHJvZmlsZURhdGE6IE5vc3RyUHJvZmlsZSkgPT4ge1xuICAgICAgICBjb25zdCBub3N0ciA9IGdldFdpbmRvd05vc3RyKCk7XG4gICAgICAgIGlmICghcHVia2V5IHx8ICFub3N0cikge1xuICAgICAgICAgICAgc2V0RXJyb3IoXCJOb3QgbG9nZ2VkIGluIG9yIE5PU1RSIGV4dGVuc2lvbiBub3QgZm91bmQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgb25seSB2YWxpZCBwcm9maWxlIGZpZWxkcyBhcmUgaW5jbHVkZWRcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRQYXlsb2FkOiBhbnkgPSB7fTtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS51c2VybmFtZSAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5uYW1lID0gbmV3UHJvZmlsZURhdGEudXNlcm5hbWU7IC8vIEFsd2F5cyBzZXQgJ25hbWUnIGZyb20gJ3VzZXJuYW1lJ1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLmRpc3BsYXlfbmFtZSAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5kaXNwbGF5X25hbWUgPSBuZXdQcm9maWxlRGF0YS5kaXNwbGF5X25hbWU7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEuYWJvdXQgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQuYWJvdXQgPSBuZXdQcm9maWxlRGF0YS5hYm91dDtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS5waWN0dXJlICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLnBpY3R1cmUgPSBuZXdQcm9maWxlRGF0YS5waWN0dXJlO1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLmJhbm5lciAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5iYW5uZXIgPSBuZXdQcm9maWxlRGF0YS5iYW5uZXI7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEud2Vic2l0ZSAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC53ZWJzaXRlID0gbmV3UHJvZmlsZURhdGEud2Vic2l0ZTtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS5sdWQwNiAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5sdWQwNiA9IG5ld1Byb2ZpbGVEYXRhLmx1ZDA2O1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLmx1ZDE2ICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLmx1ZDE2ID0gbmV3UHJvZmlsZURhdGEubHVkMTY7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEubmlwMDUgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQubmlwMDUgPSBuZXdQcm9maWxlRGF0YS5uaXAwNTtcblxuXG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZEV2ZW50OiBVbnNpZ25lZEV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IDAsXG4gICAgICAgICAgICAgICAgcHVia2V5LFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICAgICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KGNvbnRlbnRQYXlsb2FkKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IG5vc3RyLnNpZ25FdmVudCh1bnNpZ25lZEV2ZW50KTtcbiAgICAgICAgICAgIGlmIChhd2FpdCBwdWJsaXNoRXZlbnQoc2lnbmVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEZ1bGxQcm9maWxlID0geyAuLi5wcm9maWxlLCAuLi5uZXdQcm9maWxlRGF0YSwgcHVia2V5LCB1c2VybmFtZTogbmV3UHJvZmlsZURhdGEudXNlcm5hbWUgfTtcbiAgICAgICAgICAgICAgICBzZXRQcm9maWxlKHVwZGF0ZWRGdWxsUHJvZmlsZSk7XG4gICAgICAgICAgICAgICAgcHJvZmlsZUNhY2hlLmN1cnJlbnRbcHVia2V5XSA9IHVwZGF0ZWRGdWxsUHJvZmlsZTsgLy8gVXBkYXRlIGNhY2hlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBwcm9maWxlOlwiLCBlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gdXBkYXRlIHByb2ZpbGUuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW3B1YmtleSwgcHJvZmlsZV0pO1xuXG4gICAgLy8gTWFuYWdlIGNvbnRhY3QgbGlzdCAoS2luZCAzKVxuICAgIGNvbnN0IHVwZGF0ZUNvbnRhY3RMaXN0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKG5ld0ZvbGxvd2luZ1B1YmtleXM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vc3RyID0gZ2V0V2luZG93Tm9zdHIoKTtcbiAgICAgICAgaWYgKCFwdWJrZXkgfHwgIW5vc3RyKSB7XG4gICAgICAgICAgICBzZXRFcnJvcihcIk5vdCBsb2dnZWQgaW4gb3IgTk9TVFIgZXh0ZW5zaW9uIG5vdCBmb3VuZC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5JUC0wMiByZWNvbW1lbmRzIHByZXNlcnZpbmcgZXhpc3Rpbmcgbm9uLVwicFwiIHRhZ3MgaWYgYW55LlxuICAgICAgICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHRoaXMgZXhhbXBsZSBvbmx5IG1hbmFnZXMgXCJwXCIgdGFncy5cbiAgICAgICAgICAgIC8vIEZldGNoIGV4aXN0aW5nIGNvbnRhY3QgbGlzdCB0byBwcmVzZXJ2ZSBvdGhlciB0YWdzIGlmIG5lY2Vzc2FyeSAobW9yZSBjb21wbGV4KVxuXG4gICAgICAgICAgICBjb25zdCB0YWdzID0gbmV3Rm9sbG93aW5nUHVia2V5cy5tYXAocGsgPT4gW1wicFwiLCBwa10pO1xuICAgICAgICAgICAgY29uc3QgdW5zaWduZWRFdmVudDogVW5zaWduZWRFdmVudCA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiAzLFxuICAgICAgICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgICAgICAgICB0YWdzOiB0YWdzLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsIC8vIE9yIEpTT04gc3RyaW5nIG9mIHJlbGF5IGhpbnRzIHBlciBOSVAtMDJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IG5vc3RyLnNpZ25FdmVudCh1bnNpZ25lZEV2ZW50KTtcbiAgICAgICAgICAgIGlmIChhd2FpdCBwdWJsaXNoRXZlbnQoc2lnbmVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgc2V0Rm9sbG93aW5nKG5ld0ZvbGxvd2luZ1B1YmtleXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byB1cGRhdGUgY29udGFjdCBsaXN0OlwiLCBlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gdXBkYXRlIGNvbnRhY3QgbGlzdC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBbcHVia2V5XSk7XG5cbiAgICBjb25zdCBmb2xsb3dVc2VyID0gdXNlQ2FsbGJhY2soYXN5bmMgKHVzZXJQdWJrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoZm9sbG93aW5nLmluY2x1ZGVzKHVzZXJQdWJrZXkpKSByZXR1cm4gdHJ1ZTsgLy8gQWxyZWFkeSBmb2xsb3dpbmdcbiAgICAgICAgY29uc3QgbmV3Rm9sbG93aW5nTGlzdCA9IFsuLi5mb2xsb3dpbmcsIHVzZXJQdWJrZXldO1xuICAgICAgICByZXR1cm4gYXdhaXQgdXBkYXRlQ29udGFjdExpc3QobmV3Rm9sbG93aW5nTGlzdCk7XG4gICAgfSwgW2ZvbGxvd2luZywgdXBkYXRlQ29udGFjdExpc3RdKTtcblxuICAgIGNvbnN0IHVuZm9sbG93VXNlciA9IHVzZUNhbGxiYWNrKGFzeW5jICh1c2VyUHVia2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKCFmb2xsb3dpbmcuaW5jbHVkZXModXNlclB1YmtleSkpIHJldHVybiB0cnVlOyAvLyBOb3QgZm9sbG93aW5nXG4gICAgICAgIGNvbnN0IG5ld0ZvbGxvd2luZ0xpc3QgPSBmb2xsb3dpbmcuZmlsdGVyKHBrID0+IHBrICE9PSB1c2VyUHVia2V5KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHVwZGF0ZUNvbnRhY3RMaXN0KG5ld0ZvbGxvd2luZ0xpc3QpO1xuICAgIH0sIFtmb2xsb3dpbmcsIHVwZGF0ZUNvbnRhY3RMaXN0XSk7XG5cblxuICAgIGNvbnN0IGlzRm9sbG93aW5nID0gdXNlQ2FsbGJhY2soKHVzZXJQdWJrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICByZXR1cm4gZm9sbG93aW5nLmluY2x1ZGVzKHVzZXJQdWJrZXkpO1xuICAgIH0sIFtmb2xsb3dpbmddKTtcblxuICAgIC8vIEVmZmVjdCB0byBsb2FkIGluaXRpYWwgZm9sbG93aW5nIGxpc3QgZm9yIHRoZSBsb2dnZWQtaW4gdXNlclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwdWJrZXkpIHtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBoZWFsdGh5UmVsYXlzIH0gPSBhd2FpdCBnZXRIZWFsdGh5UmVsYXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFsdGh5UmVsYXlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBjb3JyZWN0IGZpbHRlciB0eXBlIGZvciBub3N0ci10b29sc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kczogWzNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9yczogW3B1YmtleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogRmlsdGVyIHR5cGUgaXMgYnJvYWRlciB0aGFuIEZlZWRPcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhY3RMaXN0RXZlbnRzID0gYXdhaXQgZmV0Y2hOb3N0ckZlZWQoaGVhbHRoeVJlbGF5cywgZmlsdGVyKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdExpc3RFdmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF0ZXN0Q29udGFjdExpc3QgPSBjb250YWN0TGlzdEV2ZW50cy5zb3J0KChhOiBhbnksIGI6IGFueSkgPT4gYi5jcmVhdGVkX2F0IC0gYS5jcmVhdGVkX2F0KVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvbGxvd2VkUHVia2V5cyA9IGxhdGVzdENvbnRhY3RMaXN0LnRhZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh0YWc6IHN0cmluZ1tdKSA9PiB0YWdbMF0gPT09ICdwJyAmJiB0YWdbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgodGFnOiBzdHJpbmdbXSkgPT4gdGFnWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEZvbGxvd2luZyhmb2xsb3dlZFB1YmtleXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggaW5pdGlhbCBjb250YWN0IGxpc3Q6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldEZvbGxvd2luZyhbXSk7IC8vIENsZWFyIGZvbGxvd2luZyBsaXN0IGlmIG5vdCBsb2dnZWQgaW5cbiAgICAgICAgfVxuICAgIH0sIFtwdWJrZXldKTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHVia2V5LFxuICAgICAgICBldmVudHMsXG4gICAgICAgIHByb2ZpbGUsXG4gICAgICAgIGZvbGxvd2luZyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgcmVsYXlTdGF0cyxcbiAgICAgICAgbG9naW4sXG4gICAgICAgIGZldGNoRXZlbnRzLFxuICAgICAgICBwb3N0LFxuICAgICAgICB1cGRhdGVQcm9maWxlOiB1cGRhdGVQcm9maWxlTWV0YWRhdGEsIC8vIFJlbmFtZWQgZm9yIGNsYXJpdHlcbiAgICAgICAgZm9sbG93VXNlcixcbiAgICAgICAgdW5mb2xsb3dVc2VyLFxuICAgICAgICBpc0ZvbGxvd2luZyxcbiAgICAgICAgc2V0RXZlbnRzLCAvLyBFeHBvc2luZyBzZXR0ZXJzIGNhbiBiZSB1c2VmdWwgYnV0IHVzZSB3aXRoIGNhdXRpb25cbiAgICAgICAgc2V0UHJvZmlsZSxcbiAgICAgICAgc2V0Rm9sbG93aW5nLFxuICAgIH07XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJmZXRjaE5vc3RyRmVlZCIsImZldGNoTm9zdHJQcm9maWxlIiwiZ2V0SGVhbHRoeVJlbGF5cyIsIlNpbXBsZVBvb2wiLCJSRUxBWVMiLCJ1c2VOb3N0ciIsInB1YmtleSIsInNldFB1YmtleSIsImV2ZW50cyIsInNldEV2ZW50cyIsInByb2ZpbGUiLCJzZXRQcm9maWxlIiwiZm9sbG93aW5nIiwic2V0Rm9sbG93aW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsInJlbGF5U3RhdHMiLCJzZXRSZWxheVN0YXRzIiwicHJvZmlsZUNhY2hlIiwiZ2V0V2luZG93Tm9zdHIiLCJ3aW5kb3ciLCJub3N0ciIsInN0b3JlZFB1YmtleSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzZXRJdGVtIiwibG9naW4iLCJwayIsImdldFB1YmxpY0tleSIsIm1lc3NhZ2UiLCJEYXRlIiwibm93Iiwic2lnbk1lc3NhZ2UiLCJzaWduYXR1cmUiLCJjb25zb2xlIiwibG9nIiwiZXJyIiwid2FybiIsImhlYWx0aHlSZWxheXMiLCJsZW5ndGgiLCJ1c2VyUHJvZmlsZURhdGEiLCJ1c2VyUHJvZmlsZSIsInVzZXJuYW1lIiwibmFtZSIsImN1cnJlbnQiLCJmZXRjaEV2ZW50cyIsIm9wdGlvbnMiLCJoZWFsdGh5Q291bnQiLCJ0b3RhbENvdW50IiwiZmV0Y2hlZE5vc3RyRXZlbnRzIiwibGltaXQiLCJ1bmlxdWVQdWJrZXlzIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwibWFwIiwiZXYiLCJwcm9maWxlc1RvRmV0Y2giLCJmaWx0ZXIiLCJQcm9taXNlIiwiYWxsIiwibWV0YSIsInByb2Nlc3NlZEZlZWQiLCJtZWRpYSIsInVybFJlZ2V4IiwibWF0Y2giLCJleGVjIiwiY29udGVudCIsInB1c2giLCJ1c2VyUHJvZiIsInBpY3R1cmUiLCJkaXNwbGF5X25hbWUiLCJzbGljZSIsInVudGlsIiwicHJldiIsImV4aXN0aW5nSWRzIiwiZSIsImlkIiwibmV3RXZlbnRzIiwiaGFzIiwic29ydCIsImEiLCJiIiwiY3JlYXRlZF9hdCIsInB1Ymxpc2hFdmVudCIsInNpZ25lZEV2ZW50IiwicG9vbCIsInByb21pc2VzIiwicHVibGlzaCIsImFueSIsInAiLCJyYWNlIiwiXyIsInJlaiIsInNldFRpbWVvdXQiLCJFcnJvciIsImNsb3NlIiwicG9zdCIsInVuc2lnbmVkRXZlbnQiLCJraW5kIiwiTWF0aCIsImZsb29yIiwidGFncyIsInNpZ25FdmVudCIsImN1cnJlbnRQcm9maWxlIiwidXBkYXRlUHJvZmlsZU1ldGFkYXRhIiwibmV3UHJvZmlsZURhdGEiLCJjb250ZW50UGF5bG9hZCIsInVuZGVmaW5lZCIsImFib3V0IiwiYmFubmVyIiwid2Vic2l0ZSIsImx1ZDA2IiwibHVkMTYiLCJuaXAwNSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1cGRhdGVkRnVsbFByb2ZpbGUiLCJ1cGRhdGVDb250YWN0TGlzdCIsIm5ld0ZvbGxvd2luZ1B1YmtleXMiLCJmb2xsb3dVc2VyIiwidXNlclB1YmtleSIsImluY2x1ZGVzIiwibmV3Rm9sbG93aW5nTGlzdCIsInVuZm9sbG93VXNlciIsImlzRm9sbG93aW5nIiwia2luZHMiLCJhdXRob3JzIiwiY29udGFjdExpc3RFdmVudHMiLCJsYXRlc3RDb250YWN0TGlzdCIsImZvbGxvd2VkUHVia2V5cyIsInRhZyIsInVwZGF0ZVByb2ZpbGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useNostr.ts\n"));

/***/ })

});