"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useNostr.ts":
/*!*******************************!*\
  !*** ./src/hooks/useNostr.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RELAYS: () => (/* binding */ RELAYS),\n/* harmony export */   useNostr: () => (/* binding */ useNostr)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/nostr/relay */ \"(app-pages-browser)/./src/lib/nostr/relay.ts\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/../node_modules/nostr-tools/lib/esm/index.js\");\n\n\n\nconst RELAYS = [\n    \"wss://relay.damus.io\",\n    \"wss://relay.nostr.band\",\n    \"wss://nostr-pub.wellorder.net\"\n];\nfunction useNostr() {\n    const [pubkey, setPubkey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [profile, setProfile] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null); // Current user's profile\n    const [following, setFollowing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]); // List of pubkeys the user follows\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false); // General loading state\n    const [relayStats, setRelayStats] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const profileCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const getWindowNostr = ()=>{\n        return window.nostr;\n    };\n    // --- Persist pubkey in localStorage ---\n    // On mount, rehydrate pubkey from localStorage if present\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if (true) {\n                const storedPubkey = window.localStorage.getItem('nostr_pubkey');\n                if (storedPubkey && !pubkey) {\n                    setPubkey(storedPubkey);\n                }\n            }\n        }\n    }[\"useNostr.useEffect\"], []);\n    // When pubkey changes, persist to localStorage\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if ( true && pubkey) {\n                window.localStorage.setItem('nostr_pubkey', pubkey);\n            }\n        }\n    }[\"useNostr.useEffect\"], [\n        pubkey\n    ]);\n    // Auth/login\n    const login = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[login]\": async ()=>{\n            const nostr = getWindowNostr();\n            if (nostr) {\n                setIsLoading(true);\n                setError(null);\n                try {\n                    const pk = await nostr.getPublicKey();\n                    setPubkey(pk);\n                    // Optional: Schnorr signing for custom message (e.g., NIP-42 auth)\n                    const message = \"Login to RAW.ROCKS: \".concat(Date.now());\n                    if (typeof nostr.signMessage === \"function\") {\n                        try {\n                            const signature = await nostr.signMessage(message);\n                            console.log(\"Signed login message:\", signature);\n                        } catch (err) {\n                            console.warn(\"signMessage for login failed:\", err);\n                        }\n                    } else {\n                        console.warn(\"signMessage is not supported by this NOSTR extension.\");\n                    }\n                    // Load profile from relays\n                    const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                    if (healthyRelays.length > 0) {\n                        const userProfileData = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrProfile)(healthyRelays, pk);\n                        if (userProfileData) {\n                            const userProfile = {\n                                ...userProfileData,\n                                pubkey: pk\n                            };\n                            setProfile(userProfile);\n                            profileCache.current[pk] = userProfile;\n                        }\n                    } else {\n                        console.warn(\"No healthy relays to fetch initial profile.\");\n                    }\n                } catch (err) {\n                    console.error(\"Login failed:\", err);\n                    setError(err.message || \"Login failed. Please ensure your NOSTR extension is configured.\");\n                    setPubkey(null);\n                } finally{\n                    setIsLoading(false);\n                }\n            } else {\n                setError(\"NOSTR extension not found. Please install a NOSTR browser extension.\");\n            // alert(\"NOSTR extension not found. Please install a NOSTR browser extension.\");\n            }\n        }\n    }[\"useNostr.useCallback[login]\"], []);\n    // Fetch feed with pagination support\n    const fetchEvents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[fetchEvents]\": async (options)=>{\n            setIsLoading(true);\n            setError(null);\n            try {\n                const { healthyRelays, healthyCount, totalCount } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                setRelayStats({\n                    healthyCount,\n                    totalCount\n                });\n                if (!healthyRelays.length) {\n                    setError(\"No healthy relays available to fetch feed.\");\n                    return false;\n                }\n                const fetchedNostrEvents = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrFeed)(healthyRelays, {\n                    limit: 20,\n                    ...options\n                });\n                const uniquePubkeys = Array.from(new Set(fetchedNostrEvents.map({\n                    \"useNostr.useCallback[fetchEvents].uniquePubkeys\": (ev)=>ev.pubkey\n                }[\"useNostr.useCallback[fetchEvents].uniquePubkeys\"])));\n                const profilesToFetch = uniquePubkeys.filter({\n                    \"useNostr.useCallback[fetchEvents].profilesToFetch\": (pk)=>!profileCache.current[pk]\n                }[\"useNostr.useCallback[fetchEvents].profilesToFetch\"]);\n                if (profilesToFetch.length > 0) {\n                    await Promise.all(profilesToFetch.map({\n                        \"useNostr.useCallback[fetchEvents]\": async (pk)=>{\n                            const meta = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrProfile)(healthyRelays, pk);\n                            if (meta) {\n                                profileCache.current[pk] = {\n                                    ...meta,\n                                    pubkey: pk\n                                };\n                            }\n                        }\n                    }[\"useNostr.useCallback[fetchEvents]\"]));\n                }\n                const processedFeed = fetchedNostrEvents.map({\n                    \"useNostr.useCallback[fetchEvents].processedFeed\": (ev)=>{\n                        let media = [];\n                        const urlRegex = /(https?:\\/\\/(?:[\\w-]+\\.)+[\\w-]+(?:\\/[\\w\\-._~:/?#[\\]@!$&'()*+,;=]*)?\\.(?:jpg|jpeg|png|gif|mp4|webm))/gi;\n                        let match;\n                        while(match = urlRegex.exec(ev.content)){\n                            media.push(match[1]);\n                        }\n                        const userProf = profileCache.current[ev.pubkey] || {\n                            pubkey: ev.pubkey\n                        };\n                        const displayName = userProf.display_name || userProf.name || \"\".concat(ev.pubkey.slice(0, 6), \"...\").concat(ev.pubkey.slice(-4));\n                        const picture = userProf.picture || \"/file.svg\"; // Default avatar\n                        return {\n                            ...ev,\n                            media,\n                            profile: {\n                                ...userProf,\n                                display_name: displayName,\n                                name: userProf.name || displayName,\n                                picture: picture\n                            }\n                        };\n                    }\n                }[\"useNostr.useCallback[fetchEvents].processedFeed\"]);\n                if (options === null || options === void 0 ? void 0 : options.until) {\n                    setEvents({\n                        \"useNostr.useCallback[fetchEvents]\": (prev)=>{\n                            const existingIds = new Set(prev.map({\n                                \"useNostr.useCallback[fetchEvents]\": (e)=>e.id\n                            }[\"useNostr.useCallback[fetchEvents]\"]));\n                            const newEvents = processedFeed.filter({\n                                \"useNostr.useCallback[fetchEvents].newEvents\": (e)=>!existingIds.has(e.id)\n                            }[\"useNostr.useCallback[fetchEvents].newEvents\"]);\n                            return [\n                                ...prev,\n                                ...newEvents\n                            ].sort({\n                                \"useNostr.useCallback[fetchEvents]\": (a, b)=>b.created_at - a.created_at\n                            }[\"useNostr.useCallback[fetchEvents]\"]);\n                        }\n                    }[\"useNostr.useCallback[fetchEvents]\"]);\n                } else {\n                    setEvents(processedFeed.sort({\n                        \"useNostr.useCallback[fetchEvents]\": (a, b)=>b.created_at - a.created_at\n                    }[\"useNostr.useCallback[fetchEvents]\"]));\n                }\n                return processedFeed.length > 0;\n            } catch (err) {\n                console.error(\"Error fetching events:\", err);\n                setError(err.message || \"Failed to fetch posts. Please try again later.\");\n                return false;\n            } finally{\n                setIsLoading(false);\n            }\n        }\n    }[\"useNostr.useCallback[fetchEvents]\"], []);\n    // Helper to publish a signed event\n    const publishEvent = async (signedEvent)=>{\n        try {\n            const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n            if (!healthyRelays.length) {\n                setError(\"No healthy relays available to publish event.\");\n                return false;\n            }\n            const pool = new nostr_tools__WEBPACK_IMPORTED_MODULE_2__.SimplePool();\n            const promises = pool.publish(healthyRelays, signedEvent);\n            // Wait for at least one successful publish or timeout\n            // This is a simplified version; nostr-tools' publish returns promises for each relay\n            await Promise.any(promises.map((p)=>Promise.race([\n                    p,\n                    new Promise((_, rej)=>setTimeout(()=>rej(new Error('timeout')), 5000))\n                ])));\n            pool.close(healthyRelays); // Close connections after publishing\n            return true;\n        } catch (err) {\n            console.error(\"Failed to publish event to relays:\", err);\n            setError(\"Failed to publish event. Some relays might be offline.\");\n            return false;\n        }\n    };\n    // Post event (sign and publish using extension)\n    const post = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[post]\": async (content)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                const unsignedEvent = {\n                    kind: 1,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: [],\n                    content\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    // Optimistic update\n                    const currentProfile = profileCache.current[pubkey] || {\n                        pubkey\n                    };\n                    setEvents({\n                        \"useNostr.useCallback[post]\": (prev)=>[\n                                {\n                                    id: signedEvent.id,\n                                    pubkey: signedEvent.pubkey,\n                                    content: signedEvent.content,\n                                    created_at: signedEvent.created_at,\n                                    kind: signedEvent.kind,\n                                    tags: signedEvent.tags,\n                                    media: [],\n                                    profile: {\n                                        display_name: currentProfile.display_name || currentProfile.name || \"\".concat(pubkey.slice(0, 6), \"...\").concat(pubkey.slice(-4)),\n                                        name: currentProfile.name || \"\".concat(pubkey.slice(0, 6), \"...\").concat(pubkey.slice(-4)),\n                                        picture: currentProfile.picture || \"/file.svg\",\n                                        pubkey: pubkey\n                                    }\n                                },\n                                ...prev\n                            ].sort({\n                                \"useNostr.useCallback[post]\": (a, b)=>b.created_at - a.created_at\n                            }[\"useNostr.useCallback[post]\"])\n                    }[\"useNostr.useCallback[post]\"]);\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to post event:\", err);\n                setError(err.message || \"Failed to post. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[post]\"], [\n        pubkey,\n        profile\n    ]);\n    // Update profile (Kind 0)\n    const updateProfileMetadata = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[updateProfileMetadata]\": async (newProfileData)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                // Ensure only valid profile fields are included\n                const contentPayload = {};\n                if (newProfileData.name !== undefined) contentPayload.name = newProfileData.name;\n                if (newProfileData.display_name !== undefined) contentPayload.display_name = newProfileData.display_name;\n                if (newProfileData.about !== undefined) contentPayload.about = newProfileData.about;\n                if (newProfileData.picture !== undefined) contentPayload.picture = newProfileData.picture;\n                if (newProfileData.banner !== undefined) contentPayload.banner = newProfileData.banner;\n                if (newProfileData.website !== undefined) contentPayload.website = newProfileData.website;\n                if (newProfileData.lud06 !== undefined) contentPayload.lud06 = newProfileData.lud06;\n                if (newProfileData.lud16 !== undefined) contentPayload.lud16 = newProfileData.lud16;\n                if (newProfileData.nip05 !== undefined) contentPayload.nip05 = newProfileData.nip05;\n                const unsignedEvent = {\n                    kind: 0,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: [],\n                    content: JSON.stringify(contentPayload)\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    const updatedFullProfile = {\n                        ...profile,\n                        ...newProfileData,\n                        pubkey\n                    };\n                    setProfile(updatedFullProfile);\n                    profileCache.current[pubkey] = updatedFullProfile; // Update cache\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to update profile:\", err);\n                setError(err.message || \"Failed to update profile. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[updateProfileMetadata]\"], [\n        pubkey,\n        profile\n    ]);\n    // Manage contact list (Kind 3)\n    const updateContactList = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[updateContactList]\": async (newFollowingPubkeys)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                // NIP-02 recommends preserving existing non-\"p\" tags if any.\n                // For simplicity, this example only manages \"p\" tags.\n                // Fetch existing contact list to preserve other tags if necessary (more complex)\n                const tags = newFollowingPubkeys.map({\n                    \"useNostr.useCallback[updateContactList].tags\": (pk)=>[\n                            \"p\",\n                            pk\n                        ]\n                }[\"useNostr.useCallback[updateContactList].tags\"]);\n                const unsignedEvent = {\n                    kind: 3,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: tags,\n                    content: \"\"\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    setFollowing(newFollowingPubkeys);\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to update contact list:\", err);\n                setError(err.message || \"Failed to update contact list. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[updateContactList]\"], [\n        pubkey\n    ]);\n    const followUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[followUser]\": async (userPubkey)=>{\n            if (following.includes(userPubkey)) return true; // Already following\n            const newFollowingList = [\n                ...following,\n                userPubkey\n            ];\n            return await updateContactList(newFollowingList);\n        }\n    }[\"useNostr.useCallback[followUser]\"], [\n        following,\n        updateContactList\n    ]);\n    const unfollowUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[unfollowUser]\": async (userPubkey)=>{\n            if (!following.includes(userPubkey)) return true; // Not following\n            const newFollowingList = following.filter({\n                \"useNostr.useCallback[unfollowUser].newFollowingList\": (pk)=>pk !== userPubkey\n            }[\"useNostr.useCallback[unfollowUser].newFollowingList\"]);\n            return await updateContactList(newFollowingList);\n        }\n    }[\"useNostr.useCallback[unfollowUser]\"], [\n        following,\n        updateContactList\n    ]);\n    const isFollowing = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[isFollowing]\": (userPubkey)=>{\n            return following.includes(userPubkey);\n        }\n    }[\"useNostr.useCallback[isFollowing]\"], [\n        following\n    ]);\n    // Effect to load initial following list for the logged-in user\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if (pubkey) {\n                ({\n                    \"useNostr.useEffect\": async ()=>{\n                        try {\n                            const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                            if (healthyRelays.length === 0) return;\n                            // Use correct filter type for nostr-tools\n                            const filter = {\n                                kinds: [\n                                    3\n                                ],\n                                authors: [\n                                    pubkey\n                                ],\n                                limit: 1\n                            };\n                            // @ts-ignore: Filter type is broader than FeedOptions\n                            const contactListEvents = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrFeed)(healthyRelays, filter);\n                            if (contactListEvents.length > 0) {\n                                const latestContactList = contactListEvents.sort({\n                                    \"useNostr.useEffect\": (a, b)=>b.created_at - a.created_at\n                                }[\"useNostr.useEffect\"])[0];\n                                const followedPubkeys = latestContactList.tags.filter({\n                                    \"useNostr.useEffect.followedPubkeys\": (tag)=>tag[0] === 'p' && tag[1]\n                                }[\"useNostr.useEffect.followedPubkeys\"]).map({\n                                    \"useNostr.useEffect.followedPubkeys\": (tag)=>tag[1]\n                                }[\"useNostr.useEffect.followedPubkeys\"]);\n                                setFollowing(followedPubkeys);\n                            }\n                        } catch (err) {\n                            console.error(\"Failed to fetch initial contact list:\", err);\n                        }\n                    }\n                })[\"useNostr.useEffect\"]();\n            } else {\n                setFollowing([]); // Clear following list if not logged in\n            }\n        }\n    }[\"useNostr.useEffect\"], [\n        pubkey\n    ]);\n    return {\n        pubkey,\n        events,\n        profile,\n        following,\n        error,\n        isLoading,\n        relayStats,\n        login,\n        fetchEvents,\n        post,\n        updateProfile: updateProfileMetadata,\n        followUser,\n        unfollowUser,\n        isFollowing,\n        setEvents,\n        setProfile,\n        setFollowing\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VOb3N0ci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUU7QUFDdUI7QUFTeUI7QUFnQjFHLE1BQU1RLFNBQVM7SUFDbEI7SUFDQTtJQUNBO0NBRUgsQ0FBQztBQTJCSyxTQUFTQztJQUNaLE1BQU0sQ0FBQ0MsUUFBUUMsVUFBVSxHQUFHWCwrQ0FBUUEsQ0FBZ0I7SUFDcEQsTUFBTSxDQUFDWSxRQUFRQyxVQUFVLEdBQUdiLCtDQUFRQSxDQUFlLEVBQUU7SUFDckQsTUFBTSxDQUFDYyxTQUFTQyxXQUFXLEdBQUdmLCtDQUFRQSxDQUFzQixPQUFPLHlCQUF5QjtJQUM1RixNQUFNLENBQUNnQixXQUFXQyxhQUFhLEdBQUdqQiwrQ0FBUUEsQ0FBVyxFQUFFLEdBQUcsbUNBQW1DO0lBQzdGLE1BQU0sQ0FBQ2tCLE9BQU9DLFNBQVMsR0FBR25CLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUNvQixXQUFXQyxhQUFhLEdBQUdyQiwrQ0FBUUEsQ0FBVSxRQUFRLHdCQUF3QjtJQUNwRixNQUFNLENBQUNzQixZQUFZQyxjQUFjLEdBQUd2QiwrQ0FBUUEsQ0FBdUQ7SUFDbkcsTUFBTXdCLGVBQWV0Qiw2Q0FBTUEsQ0FBcUMsQ0FBQztJQUVqRSxNQUFNdUIsaUJBQWlCO1FBQ25CLE9BQU9DLE9BQU9DLEtBQUs7SUFDdkI7SUFFQSx5Q0FBeUM7SUFDekMsMERBQTBEO0lBQzFEeEIsZ0RBQVNBOzhCQUFDO1lBQ04sSUFBSSxJQUE2QixFQUFFO2dCQUMvQixNQUFNeUIsZUFBZUYsT0FBT0csWUFBWSxDQUFDQyxPQUFPLENBQUM7Z0JBQ2pELElBQUlGLGdCQUFnQixDQUFDbEIsUUFBUTtvQkFDekJDLFVBQVVpQjtnQkFDZDtZQUNKO1FBQ0o7NkJBQUcsRUFBRTtJQUVMLCtDQUErQztJQUMvQ3pCLGdEQUFTQTs4QkFBQztZQUNOLElBQUksS0FBNkIsSUFBSU8sUUFBUTtnQkFDekNnQixPQUFPRyxZQUFZLENBQUNF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Q0FzRDtRQUNBbUMsZUFBZTNCO1FBQ2ZlO1FBQ0FJO1FBQ0FDO1FBQ0F0SDtRQUNBRTtRQUNBRTtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9zcmMvaG9va3MvdXNlTm9zdHIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZmV0Y2hOb3N0ckZlZWQsIGZldGNoTm9zdHJQcm9maWxlLCBnZXRIZWFsdGh5UmVsYXlzIH0gZnJvbSBcIkAvbGliL25vc3RyL3JlbGF5XCI7XG5cbi8vIEV4dGVuZCBGZWVkT3B0aW9ucyB0byBpbmNsdWRlICdhdXRob3JzJ1xuZXhwb3J0IGludGVyZmFjZSBGZWVkT3B0aW9ucyB7XG4gICAgbGltaXQ/OiBudW1iZXI7XG4gICAgdW50aWw/OiBudW1iZXI7XG4gICAga2luZHM/OiBudW1iZXJbXTtcbiAgICBhdXRob3JzPzogc3RyaW5nW107IC8vIEFkZGVkIGF1dGhvcnMgcHJvcGVydHkgdG8gbWF0Y2ggdXNhZ2Vcbn1cbmltcG9ydCB7IFNpbXBsZVBvb2wsIG5pcDE5LCB0eXBlIEV2ZW50IGFzIE5vc3RyVG9vbHNFdmVudCwgdHlwZSBVbnNpZ25lZEV2ZW50LCBnZXRFdmVudEhhc2ggfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcblxuLy8gRGVmaW5lIHRoZSBOSVAtMDcgd2luZG93Lm5vc3RyIGludGVyZmFjZVxuaW50ZXJmYWNlIFdpbmRvd05vc3RyIHtcbiAgICBnZXRQdWJsaWNLZXkoKTogUHJvbWlzZTxzdHJpbmc+O1xuICAgIHNpZ25FdmVudChldmVudDogVW5zaWduZWRFdmVudCk6IFByb21pc2U8Tm9zdHJUb29sc0V2ZW50PjtcbiAgICBzaWduTWVzc2FnZT8obWVzc2FnZTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+OyAvLyBPcHRpb25hbCBOSVAtNDIgb3IgY3VzdG9tIHVzYWdlXG4gICAgZ2V0UmVsYXlzPygpOiBQcm9taXNlPHsgW3VybDogc3RyaW5nXTogeyByZWFkOiBib29sZWFuOyB3cml0ZTogYm9vbGVhbiB9IH0+OyAvLyBPcHRpb25hbFxufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gICAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgICAgIG5vc3RyPzogV2luZG93Tm9zdHI7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgUkVMQVlTID0gW1xuICAgIFwid3NzOi8vcmVsYXkuZGFtdXMuaW9cIixcbiAgICBcIndzczovL3JlbGF5Lm5vc3RyLmJhbmRcIixcbiAgICBcIndzczovL25vc3RyLXB1Yi53ZWxsb3JkZXIubmV0XCIsXG4gICAgLy8gQWRkIG1vcmUgZGVmYXVsdCByZWxheXMgb3IgbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuXTtcblxuZXhwb3J0IGludGVyZmFjZSBOb3N0clByb2ZpbGUge1xuICAgIG5hbWU/OiBzdHJpbmc7IC8vIE5JUC0wMSBmaWVsZCBmb3IgdXNlcm5hbWVcbiAgICBkaXNwbGF5X25hbWU/OiBzdHJpbmc7IC8vIE5JUC0wMSBmaWVsZCBmb3IgZGlzcGxheSBuYW1lXG4gICAgYWJvdXQ/OiBzdHJpbmc7IC8vIE5JUC0wMSBmaWVsZCBmb3IgYmlvXG4gICAgcGljdHVyZT86IHN0cmluZzsgLy8gTklQLTAxIGZpZWxkIGZvciBwaWN0dXJlIFVSTFxuICAgIGJhbm5lcj86IHN0cmluZzsgLy8gTklQLTAxIGZpZWxkIGZvciBiYW5uZXIgVVJMXG4gICAgd2Vic2l0ZT86IHN0cmluZzsgLy8gTklQLTAxIGZpZWxkIGZvciB3ZWJzaXRlXG4gICAgbHVkMDY/OiBzdHJpbmc7IC8vIE5JUC0wMSBmaWVsZCBmb3IgTE4gVVJMIChwYXlueW0pXG4gICAgbHVkMTY/OiBzdHJpbmc7IC8vIE5JUC0wMSBmaWVsZCBmb3IgTE4gQWRkcmVzc1xuICAgIG5pcDA1Pzogc3RyaW5nOyAvLyBOSVAtMDUgaWRlbnRpZmllclxuICAgIHB1YmtleT86IHN0cmluZzsgLy8gQWRkZWQgZm9yIGNvbnZlbmllbmNlXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm9zdHJFdmVudCB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBwdWJrZXk6IHN0cmluZztcbiAgICBjb250ZW50OiBzdHJpbmc7XG4gICAgY3JlYXRlZF9hdDogbnVtYmVyO1xuICAgIGtpbmQ6IG51bWJlcjtcbiAgICB0YWdzOiBzdHJpbmdbXVtdO1xuICAgIG1lZGlhOiBzdHJpbmdbXTsgLy8gQ3VzdG9tIGRlcml2ZWQgZmllbGRcbiAgICBwcm9maWxlPzogTm9zdHJQcm9maWxlOyAvLyBDdXN0b20gZGVyaXZlZCBmaWVsZFxuICAgIC8vIEFkZCBvdGhlciBldmVudCBmaWVsZHMgaWYgbmVlZGVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VOb3N0cigpIHtcbiAgICBjb25zdCBbcHVia2V5LCBzZXRQdWJrZXldID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW2V2ZW50cywgc2V0RXZlbnRzXSA9IHVzZVN0YXRlPE5vc3RyRXZlbnRbXT4oW10pO1xuICAgIGNvbnN0IFtwcm9maWxlLCBzZXRQcm9maWxlXSA9IHVzZVN0YXRlPE5vc3RyUHJvZmlsZSB8IG51bGw+KG51bGwpOyAvLyBDdXJyZW50IHVzZXIncyBwcm9maWxlXG4gICAgY29uc3QgW2ZvbGxvd2luZywgc2V0Rm9sbG93aW5nXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7IC8vIExpc3Qgb2YgcHVia2V5cyB0aGUgdXNlciBmb2xsb3dzXG4gICAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpOyAvLyBHZW5lcmFsIGxvYWRpbmcgc3RhdGVcbiAgICBjb25zdCBbcmVsYXlTdGF0cywgc2V0UmVsYXlTdGF0c10gPSB1c2VTdGF0ZTx7IGhlYWx0aHlDb3VudDogbnVtYmVyOyB0b3RhbENvdW50OiBudW1iZXI7IH0gfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBwcm9maWxlQ2FjaGUgPSB1c2VSZWY8eyBbcHVia2V5OiBzdHJpbmddOiBOb3N0clByb2ZpbGUgfT4oe30pO1xuXG4gICAgY29uc3QgZ2V0V2luZG93Tm9zdHIgPSAoKTogV2luZG93Tm9zdHIgfCB1bmRlZmluZWQgPT4ge1xuICAgICAgICByZXR1cm4gd2luZG93Lm5vc3RyO1xuICAgIH07XG5cbiAgICAvLyAtLS0gUGVyc2lzdCBwdWJrZXkgaW4gbG9jYWxTdG9yYWdlIC0tLVxuICAgIC8vIE9uIG1vdW50LCByZWh5ZHJhdGUgcHVia2V5IGZyb20gbG9jYWxTdG9yYWdlIGlmIHByZXNlbnRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZFB1YmtleSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnbm9zdHJfcHVia2V5Jyk7XG4gICAgICAgICAgICBpZiAoc3RvcmVkUHVia2V5ICYmICFwdWJrZXkpIHtcbiAgICAgICAgICAgICAgICBzZXRQdWJrZXkoc3RvcmVkUHVia2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIFdoZW4gcHVia2V5IGNoYW5nZXMsIHBlcnNpc3QgdG8gbG9jYWxTdG9yYWdlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHB1YmtleSkge1xuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKCdub3N0cl9wdWJrZXknLCBwdWJrZXkpO1xuICAgICAgICB9XG4gICAgfSwgW3B1YmtleV0pO1xuXG4gICAgLy8gQXV0aC9sb2dpblxuICAgIGNvbnN0IGxvZ2luID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBub3N0ciA9IGdldFdpbmRvd05vc3RyKCk7XG4gICAgICAgIGlmIChub3N0cikge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBrID0gYXdhaXQgbm9zdHIuZ2V0UHVibGljS2V5KCk7XG4gICAgICAgICAgICAgICAgc2V0UHVia2V5KHBrKTtcblxuICAgICAgICAgICAgICAgIC8vIE9wdGlvbmFsOiBTY2hub3JyIHNpZ25pbmcgZm9yIGN1c3RvbSBtZXNzYWdlIChlLmcuLCBOSVAtNDIgYXV0aClcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYExvZ2luIHRvIFJBVy5ST0NLUzogJHtEYXRlLm5vdygpfWA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub3N0ci5zaWduTWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBub3N0ci5zaWduTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2lnbmVkIGxvZ2luIG1lc3NhZ2U6XCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwic2lnbk1lc3NhZ2UgZm9yIGxvZ2luIGZhaWxlZDpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInNpZ25NZXNzYWdlIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBOT1NUUiBleHRlbnNpb24uXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExvYWQgcHJvZmlsZSBmcm9tIHJlbGF5c1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGVhbHRoeVJlbGF5cyB9ID0gYXdhaXQgZ2V0SGVhbHRoeVJlbGF5cygpO1xuICAgICAgICAgICAgICAgIGlmIChoZWFsdGh5UmVsYXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXNlclByb2ZpbGVEYXRhID0gYXdhaXQgZmV0Y2hOb3N0clByb2ZpbGUoaGVhbHRoeVJlbGF5cywgcGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNlclByb2ZpbGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyUHJvZmlsZTogTm9zdHJQcm9maWxlID0geyAuLi51c2VyUHJvZmlsZURhdGEsIHB1YmtleTogcGsgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb2ZpbGUodXNlclByb2ZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZUNhY2hlLmN1cnJlbnRbcGtdID0gdXNlclByb2ZpbGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyBoZWFsdGh5IHJlbGF5cyB0byBmZXRjaCBpbml0aWFsIHByb2ZpbGUuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkxvZ2luIGZhaWxlZDpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkxvZ2luIGZhaWxlZC4gUGxlYXNlIGVuc3VyZSB5b3VyIE5PU1RSIGV4dGVuc2lvbiBpcyBjb25maWd1cmVkLlwiKTtcbiAgICAgICAgICAgICAgICBzZXRQdWJrZXkobnVsbCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRFcnJvcihcIk5PU1RSIGV4dGVuc2lvbiBub3QgZm91bmQuIFBsZWFzZSBpbnN0YWxsIGEgTk9TVFIgYnJvd3NlciBleHRlbnNpb24uXCIpO1xuICAgICAgICAgICAgLy8gYWxlcnQoXCJOT1NUUiBleHRlbnNpb24gbm90IGZvdW5kLiBQbGVhc2UgaW5zdGFsbCBhIE5PU1RSIGJyb3dzZXIgZXh0ZW5zaW9uLlwiKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIEZldGNoIGZlZWQgd2l0aCBwYWdpbmF0aW9uIHN1cHBvcnRcbiAgICBjb25zdCBmZXRjaEV2ZW50cyA9IHVzZUNhbGxiYWNrKGFzeW5jIChvcHRpb25zPzogRmVlZE9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGVhbHRoeVJlbGF5cywgaGVhbHRoeUNvdW50LCB0b3RhbENvdW50IH0gPSBhd2FpdCBnZXRIZWFsdGh5UmVsYXlzKCk7XG4gICAgICAgICAgICBzZXRSZWxheVN0YXRzKHsgaGVhbHRoeUNvdW50LCB0b3RhbENvdW50IH0pO1xuXG4gICAgICAgICAgICBpZiAoIWhlYWx0aHlSZWxheXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoXCJObyBoZWFsdGh5IHJlbGF5cyBhdmFpbGFibGUgdG8gZmV0Y2ggZmVlZC5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBmZXRjaGVkTm9zdHJFdmVudHMgPSBhd2FpdCBmZXRjaE5vc3RyRmVlZChoZWFsdGh5UmVsYXlzLCB7XG4gICAgICAgICAgICAgICAgbGltaXQ6IDIwLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB1bmlxdWVQdWJrZXlzID0gQXJyYXkuZnJvbShuZXcgU2V0KGZldGNoZWROb3N0ckV2ZW50cy5tYXAoZXYgPT4gZXYucHVia2V5KSkpO1xuICAgICAgICAgICAgY29uc3QgcHJvZmlsZXNUb0ZldGNoID0gdW5pcXVlUHVia2V5cy5maWx0ZXIocGsgPT4gIXByb2ZpbGVDYWNoZS5jdXJyZW50W3BrXSk7XG5cbiAgICAgICAgICAgIGlmIChwcm9maWxlc1RvRmV0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb2ZpbGVzVG9GZXRjaC5tYXAoYXN5bmMgKHBrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBhd2FpdCBmZXRjaE5vc3RyUHJvZmlsZShoZWFsdGh5UmVsYXlzLCBwayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9maWxlQ2FjaGUuY3VycmVudFtwa10gPSB7IC4uLm1ldGEsIHB1YmtleTogcGsgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkRmVlZCA9IGZldGNoZWROb3N0ckV2ZW50cy5tYXAoKGV2KTogTm9zdHJFdmVudCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IG1lZGlhOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybFJlZ2V4ID0gLyhodHRwcz86XFwvXFwvKD86W1xcdy1dK1xcLikrW1xcdy1dKyg/OlxcL1tcXHdcXC0uX346Lz8jW1xcXUAhJCYnKCkqKyw7PV0qKT9cXC4oPzpqcGd8anBlZ3xwbmd8Z2lmfG1wNHx3ZWJtKSkvZ2k7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSB1cmxSZWdleC5leGVjKGV2LmNvbnRlbnQpKSkge1xuICAgICAgICAgICAgICAgICAgICBtZWRpYS5wdXNoKG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB1c2VyUHJvZiA9IHByb2ZpbGVDYWNoZS5jdXJyZW50W2V2LnB1YmtleV0gfHwgeyBwdWJrZXk6IGV2LnB1YmtleSB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3BsYXlOYW1lID0gdXNlclByb2YuZGlzcGxheV9uYW1lIHx8IHVzZXJQcm9mLm5hbWUgfHwgYCR7ZXYucHVia2V5LnNsaWNlKDAsIDYpfS4uLiR7ZXYucHVia2V5LnNsaWNlKC00KX1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpY3R1cmUgPSB1c2VyUHJvZi5waWN0dXJlIHx8IFwiL2ZpbGUuc3ZnXCI7IC8vIERlZmF1bHQgYXZhdGFyXG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5ldixcbiAgICAgICAgICAgICAgICAgICAgbWVkaWEsXG4gICAgICAgICAgICAgICAgICAgIHByb2ZpbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnVzZXJQcm9mLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9uYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHVzZXJQcm9mLm5hbWUgfHwgZGlzcGxheU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWN0dXJlOiBwaWN0dXJlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnM/LnVudGlsKSB7XG4gICAgICAgICAgICAgICAgc2V0RXZlbnRzKHByZXYgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0lkcyA9IG5ldyBTZXQocHJldi5tYXAoZSA9PiBlLmlkKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0V2ZW50cyA9IHByb2Nlc3NlZEZlZWQuZmlsdGVyKGUgPT4gIWV4aXN0aW5nSWRzLmhhcyhlLmlkKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbLi4ucHJldiwgLi4ubmV3RXZlbnRzXS5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRFdmVudHMocHJvY2Vzc2VkRmVlZC5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzZWRGZWVkLmxlbmd0aCA+IDA7XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgZXZlbnRzOlwiLCBlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gZmV0Y2ggcG9zdHMuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIEhlbHBlciB0byBwdWJsaXNoIGEgc2lnbmVkIGV2ZW50XG4gICAgY29uc3QgcHVibGlzaEV2ZW50ID0gYXN5bmMgKHNpZ25lZEV2ZW50OiBOb3N0clRvb2xzRXZlbnQpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGVhbHRoeVJlbGF5cyB9ID0gYXdhaXQgZ2V0SGVhbHRoeVJlbGF5cygpO1xuICAgICAgICAgICAgaWYgKCFoZWFsdGh5UmVsYXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKFwiTm8gaGVhbHRoeSByZWxheXMgYXZhaWxhYmxlIHRvIHB1Ymxpc2ggZXZlbnQuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvb2wgPSBuZXcgU2ltcGxlUG9vbCgpO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBwb29sLnB1Ymxpc2goaGVhbHRoeVJlbGF5cywgc2lnbmVkRXZlbnQpO1xuICAgICAgICAgICAgLy8gV2FpdCBmb3IgYXQgbGVhc3Qgb25lIHN1Y2Nlc3NmdWwgcHVibGlzaCBvciB0aW1lb3V0XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCB2ZXJzaW9uOyBub3N0ci10b29scycgcHVibGlzaCByZXR1cm5zIHByb21pc2VzIGZvciBlYWNoIHJlbGF5XG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLmFueShwcm9taXNlcy5tYXAocCA9PiBQcm9taXNlLnJhY2UoW3AsIG5ldyBQcm9taXNlKChfLCByZWopID0+IHNldFRpbWVvdXQoKCkgPT4gcmVqKG5ldyBFcnJvcigndGltZW91dCcpKSwgNTAwMCkpXSkpKTtcbiAgICAgICAgICAgIHBvb2wuY2xvc2UoaGVhbHRoeVJlbGF5cyk7IC8vIENsb3NlIGNvbm5lY3Rpb25zIGFmdGVyIHB1Ymxpc2hpbmdcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcHVibGlzaCBldmVudCB0byByZWxheXM6XCIsIGVycik7XG4gICAgICAgICAgICBzZXRFcnJvcihcIkZhaWxlZCB0byBwdWJsaXNoIGV2ZW50LiBTb21lIHJlbGF5cyBtaWdodCBiZSBvZmZsaW5lLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBQb3N0IGV2ZW50IChzaWduIGFuZCBwdWJsaXNoIHVzaW5nIGV4dGVuc2lvbilcbiAgICBjb25zdCBwb3N0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKGNvbnRlbnQ6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBub3N0ciA9IGdldFdpbmRvd05vc3RyKCk7XG4gICAgICAgIGlmICghcHVia2V5IHx8ICFub3N0cikge1xuICAgICAgICAgICAgc2V0RXJyb3IoXCJOb3QgbG9nZ2VkIGluIG9yIE5PU1RSIGV4dGVuc2lvbiBub3QgZm91bmQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZEV2ZW50OiBVbnNpZ25lZEV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IDEsXG4gICAgICAgICAgICAgICAgcHVia2V5LFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICAgICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkRXZlbnQgPSBhd2FpdCBub3N0ci5zaWduRXZlbnQodW5zaWduZWRFdmVudCk7XG5cbiAgICAgICAgICAgIGlmIChhd2FpdCBwdWJsaXNoRXZlbnQoc2lnbmVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gT3B0aW1pc3RpYyB1cGRhdGVcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UHJvZmlsZSA9IHByb2ZpbGVDYWNoZS5jdXJyZW50W3B1YmtleV0gfHwgeyBwdWJrZXkgfTtcbiAgICAgICAgICAgICAgICBzZXRFdmVudHMocHJldiA9PiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzaWduZWRFdmVudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YmtleTogc2lnbmVkRXZlbnQucHVia2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogc2lnbmVkRXZlbnQuY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IHNpZ25lZEV2ZW50LmNyZWF0ZWRfYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBzaWduZWRFdmVudC5raW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnczogc2lnbmVkRXZlbnQudGFncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhOiBbXSwgLy8gRGVyaXZlIG1lZGlhIGlmIG5lZWRlZCwgb3IgbGVhdmUgZm9yIGRpc3BsYXkgY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9maWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9uYW1lOiBjdXJyZW50UHJvZmlsZS5kaXNwbGF5X25hbWUgfHwgY3VycmVudFByb2ZpbGUubmFtZSB8fCBgJHtwdWJrZXkuc2xpY2UoMCwgNil9Li4uJHtwdWJrZXkuc2xpY2UoLTQpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogY3VycmVudFByb2ZpbGUubmFtZSB8fCBgJHtwdWJrZXkuc2xpY2UoMCwgNil9Li4uJHtwdWJrZXkuc2xpY2UoLTQpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGljdHVyZTogY3VycmVudFByb2ZpbGUucGljdHVyZSB8fCBcIi9maWxlLnN2Z1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YmtleTogcHVia2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgICAgIF0uc29ydCgoYSwgYikgPT4gYi5jcmVhdGVkX2F0IC0gYS5jcmVhdGVkX2F0KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBvc3QgZXZlbnQ6XCIsIGVycik7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBwb3N0LiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIFtwdWJrZXksIHByb2ZpbGVdKTtcblxuICAgIC8vIFVwZGF0ZSBwcm9maWxlIChLaW5kIDApXG4gICAgY29uc3QgdXBkYXRlUHJvZmlsZU1ldGFkYXRhID0gdXNlQ2FsbGJhY2soYXN5bmMgKG5ld1Byb2ZpbGVEYXRhOiBOb3N0clByb2ZpbGUpID0+IHtcbiAgICAgICAgY29uc3Qgbm9zdHIgPSBnZXRXaW5kb3dOb3N0cigpO1xuICAgICAgICBpZiAoIXB1YmtleSB8fCAhbm9zdHIpIHtcbiAgICAgICAgICAgIHNldEVycm9yKFwiTm90IGxvZ2dlZCBpbiBvciBOT1NUUiBleHRlbnNpb24gbm90IGZvdW5kLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIG9ubHkgdmFsaWQgcHJvZmlsZSBmaWVsZHMgYXJlIGluY2x1ZGVkXG4gICAgICAgICAgICBjb25zdCBjb250ZW50UGF5bG9hZDogYW55ID0ge307XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEubmFtZSAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5uYW1lID0gbmV3UHJvZmlsZURhdGEubmFtZTtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS5kaXNwbGF5X25hbWUgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQuZGlzcGxheV9uYW1lID0gbmV3UHJvZmlsZURhdGEuZGlzcGxheV9uYW1lO1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLmFib3V0ICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLmFib3V0ID0gbmV3UHJvZmlsZURhdGEuYWJvdXQ7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEucGljdHVyZSAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5waWN0dXJlID0gbmV3UHJvZmlsZURhdGEucGljdHVyZTtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS5iYW5uZXIgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQuYmFubmVyID0gbmV3UHJvZmlsZURhdGEuYmFubmVyO1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLndlYnNpdGUgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQud2Vic2l0ZSA9IG5ld1Byb2ZpbGVEYXRhLndlYnNpdGU7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEubHVkMDYgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQubHVkMDYgPSBuZXdQcm9maWxlRGF0YS5sdWQwNjtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS5sdWQxNiAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5sdWQxNiA9IG5ld1Byb2ZpbGVEYXRhLmx1ZDE2O1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLm5pcDA1ICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLm5pcDA1ID0gbmV3UHJvZmlsZURhdGEubmlwMDU7XG5cblxuICAgICAgICAgICAgY29uc3QgdW5zaWduZWRFdmVudDogVW5zaWduZWRFdmVudCA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiAwLFxuICAgICAgICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgICAgICAgICB0YWdzOiBbXSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShjb250ZW50UGF5bG9hZCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkRXZlbnQgPSBhd2FpdCBub3N0ci5zaWduRXZlbnQodW5zaWduZWRFdmVudCk7XG4gICAgICAgICAgICBpZiAoYXdhaXQgcHVibGlzaEV2ZW50KHNpZ25lZEV2ZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGdWxsUHJvZmlsZSA9IHsgLi4ucHJvZmlsZSwgLi4ubmV3UHJvZmlsZURhdGEsIHB1YmtleSB9O1xuICAgICAgICAgICAgICAgIHNldFByb2ZpbGUodXBkYXRlZEZ1bGxQcm9maWxlKTtcbiAgICAgICAgICAgICAgICBwcm9maWxlQ2FjaGUuY3VycmVudFtwdWJrZXldID0gdXBkYXRlZEZ1bGxQcm9maWxlOyAvLyBVcGRhdGUgY2FjaGVcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gdXBkYXRlIHByb2ZpbGU6XCIsIGVycik7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkZhaWxlZCB0byB1cGRhdGUgcHJvZmlsZS4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBbcHVia2V5LCBwcm9maWxlXSk7XG5cbiAgICAvLyBNYW5hZ2UgY29udGFjdCBsaXN0IChLaW5kIDMpXG4gICAgY29uc3QgdXBkYXRlQ29udGFjdExpc3QgPSB1c2VDYWxsYmFjayhhc3luYyAobmV3Rm9sbG93aW5nUHVia2V5czogc3RyaW5nW10pID0+IHtcbiAgICAgICAgY29uc3Qgbm9zdHIgPSBnZXRXaW5kb3dOb3N0cigpO1xuICAgICAgICBpZiAoIXB1YmtleSB8fCAhbm9zdHIpIHtcbiAgICAgICAgICAgIHNldEVycm9yKFwiTm90IGxvZ2dlZCBpbiBvciBOT1NUUiBleHRlbnNpb24gbm90IGZvdW5kLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTklQLTAyIHJlY29tbWVuZHMgcHJlc2VydmluZyBleGlzdGluZyBub24tXCJwXCIgdGFncyBpZiBhbnkuXG4gICAgICAgICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgdGhpcyBleGFtcGxlIG9ubHkgbWFuYWdlcyBcInBcIiB0YWdzLlxuICAgICAgICAgICAgLy8gRmV0Y2ggZXhpc3RpbmcgY29udGFjdCBsaXN0IHRvIHByZXNlcnZlIG90aGVyIHRhZ3MgaWYgbmVjZXNzYXJ5IChtb3JlIGNvbXBsZXgpXG5cbiAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSBuZXdGb2xsb3dpbmdQdWJrZXlzLm1hcChwayA9PiBbXCJwXCIsIHBrXSk7XG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZEV2ZW50OiBVbnNpZ25lZEV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IDMsXG4gICAgICAgICAgICAgICAgcHVia2V5LFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICAgICAgICAgIHRhZ3M6IHRhZ3MsXG4gICAgICAgICAgICAgICAgY29udGVudDogXCJcIiwgLy8gT3IgSlNPTiBzdHJpbmcgb2YgcmVsYXkgaGludHMgcGVyIE5JUC0wMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZEV2ZW50ID0gYXdhaXQgbm9zdHIuc2lnbkV2ZW50KHVuc2lnbmVkRXZlbnQpO1xuICAgICAgICAgICAgaWYgKGF3YWl0IHB1Ymxpc2hFdmVudChzaWduZWRFdmVudCkpIHtcbiAgICAgICAgICAgICAgICBzZXRGb2xsb3dpbmcobmV3Rm9sbG93aW5nUHVia2V5cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBjb250YWN0IGxpc3Q6XCIsIGVycik7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkZhaWxlZCB0byB1cGRhdGUgY29udGFjdCBsaXN0LiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIFtwdWJrZXldKTtcblxuICAgIGNvbnN0IGZvbGxvd1VzZXIgPSB1c2VDYWxsYmFjayhhc3luYyAodXNlclB1YmtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChmb2xsb3dpbmcuaW5jbHVkZXModXNlclB1YmtleSkpIHJldHVybiB0cnVlOyAvLyBBbHJlYWR5IGZvbGxvd2luZ1xuICAgICAgICBjb25zdCBuZXdGb2xsb3dpbmdMaXN0ID0gWy4uLmZvbGxvd2luZywgdXNlclB1YmtleV07XG4gICAgICAgIHJldHVybiBhd2FpdCB1cGRhdGVDb250YWN0TGlzdChuZXdGb2xsb3dpbmdMaXN0KTtcbiAgICB9LCBbZm9sbG93aW5nLCB1cGRhdGVDb250YWN0TGlzdF0pO1xuXG4gICAgY29uc3QgdW5mb2xsb3dVc2VyID0gdXNlQ2FsbGJhY2soYXN5bmMgKHVzZXJQdWJrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoIWZvbGxvd2luZy5pbmNsdWRlcyh1c2VyUHVia2V5KSkgcmV0dXJuIHRydWU7IC8vIE5vdCBmb2xsb3dpbmdcbiAgICAgICAgY29uc3QgbmV3Rm9sbG93aW5nTGlzdCA9IGZvbGxvd2luZy5maWx0ZXIocGsgPT4gcGsgIT09IHVzZXJQdWJrZXkpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdXBkYXRlQ29udGFjdExpc3QobmV3Rm9sbG93aW5nTGlzdCk7XG4gICAgfSwgW2ZvbGxvd2luZywgdXBkYXRlQ29udGFjdExpc3RdKTtcblxuXG4gICAgY29uc3QgaXNGb2xsb3dpbmcgPSB1c2VDYWxsYmFjaygodXNlclB1YmtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHJldHVybiBmb2xsb3dpbmcuaW5jbHVkZXModXNlclB1YmtleSk7XG4gICAgfSwgW2ZvbGxvd2luZ10pO1xuXG4gICAgLy8gRWZmZWN0IHRvIGxvYWQgaW5pdGlhbCBmb2xsb3dpbmcgbGlzdCBmb3IgdGhlIGxvZ2dlZC1pbiB1c2VyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHB1YmtleSkge1xuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGhlYWx0aHlSZWxheXMgfSA9IGF3YWl0IGdldEhlYWx0aHlSZWxheXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWx0aHlSZWxheXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGNvcnJlY3QgZmlsdGVyIHR5cGUgZm9yIG5vc3RyLXRvb2xzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmRzOiBbM10sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRob3JzOiBbcHVia2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0OiAxLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlOiBGaWx0ZXIgdHlwZSBpcyBicm9hZGVyIHRoYW4gRmVlZE9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGFjdExpc3RFdmVudHMgPSBhd2FpdCBmZXRjaE5vc3RyRmVlZChoZWFsdGh5UmVsYXlzLCBmaWx0ZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWN0TGlzdEV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3RDb250YWN0TGlzdCA9IGNvbnRhY3RMaXN0RXZlbnRzLnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9sbG93ZWRQdWJrZXlzID0gbGF0ZXN0Q29udGFjdExpc3QudGFnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHRhZzogc3RyaW5nW10pID0+IHRhZ1swXSA9PT0gJ3AnICYmIHRhZ1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKCh0YWc6IHN0cmluZ1tdKSA9PiB0YWdbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Rm9sbG93aW5nKGZvbGxvd2VkUHVia2V5cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBmZXRjaCBpbml0aWFsIGNvbnRhY3QgbGlzdDpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0Rm9sbG93aW5nKFtdKTsgLy8gQ2xlYXIgZm9sbG93aW5nIGxpc3QgaWYgbm90IGxvZ2dlZCBpblxuICAgICAgICB9XG4gICAgfSwgW3B1YmtleV0pO1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBwdWJrZXksXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgcHJvZmlsZSxcbiAgICAgICAgZm9sbG93aW5nLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgaXNMb2FkaW5nLFxuICAgICAgICByZWxheVN0YXRzLFxuICAgICAgICBsb2dpbixcbiAgICAgICAgZmV0Y2hFdmVudHMsXG4gICAgICAgIHBvc3QsXG4gICAgICAgIHVwZGF0ZVByb2ZpbGU6IHVwZGF0ZVByb2ZpbGVNZXRhZGF0YSwgLy8gUmVuYW1lZCBmb3IgY2xhcml0eVxuICAgICAgICBmb2xsb3dVc2VyLFxuICAgICAgICB1bmZvbGxvd1VzZXIsXG4gICAgICAgIGlzRm9sbG93aW5nLFxuICAgICAgICBzZXRFdmVudHMsIC8vIEV4cG9zaW5nIHNldHRlcnMgY2FuIGJlIHVzZWZ1bCBidXQgdXNlIHdpdGggY2F1dGlvblxuICAgICAgICBzZXRQcm9maWxlLFxuICAgICAgICBzZXRGb2xsb3dpbmcsXG4gICAgfTtcbn0iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZVJlZiIsInVzZUVmZmVjdCIsImZldGNoTm9zdHJGZWVkIiwiZmV0Y2hOb3N0clByb2ZpbGUiLCJnZXRIZWFsdGh5UmVsYXlzIiwiU2ltcGxlUG9vbCIsIlJFTEFZUyIsInVzZU5vc3RyIiwicHVia2V5Iiwic2V0UHVia2V5IiwiZXZlbnRzIiwic2V0RXZlbnRzIiwicHJvZmlsZSIsInNldFByb2ZpbGUiLCJmb2xsb3dpbmciLCJzZXRGb2xsb3dpbmciLCJlcnJvciIsInNldEVycm9yIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwicmVsYXlTdGF0cyIsInNldFJlbGF5U3RhdHMiLCJwcm9maWxlQ2FjaGUiLCJnZXRXaW5kb3dOb3N0ciIsIndpbmRvdyIsIm5vc3RyIiwic3RvcmVkUHVia2V5IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNldEl0ZW0iLCJsb2dpbiIsInBrIiwiZ2V0UHVibGljS2V5IiwibWVzc2FnZSIsIkRhdGUiLCJub3ciLCJzaWduTWVzc2FnZSIsInNpZ25hdHVyZSIsImNvbnNvbGUiLCJsb2ciLCJlcnIiLCJ3YXJuIiwiaGVhbHRoeVJlbGF5cyIsImxlbmd0aCIsInVzZXJQcm9maWxlRGF0YSIsInVzZXJQcm9maWxlIiwiY3VycmVudCIsImZldGNoRXZlbnRzIiwib3B0aW9ucyIsImhlYWx0aHlDb3VudCIsInRvdGFsQ291bnQiLCJmZXRjaGVkTm9zdHJFdmVudHMiLCJsaW1pdCIsInVuaXF1ZVB1YmtleXMiLCJBcnJheSIsImZyb20iLCJTZXQiLCJtYXAiLCJldiIsInByb2ZpbGVzVG9GZXRjaCIsImZpbHRlciIsIlByb21pc2UiLCJhbGwiLCJtZXRhIiwicHJvY2Vzc2VkRmVlZCIsIm1lZGlhIiwidXJsUmVnZXgiLCJtYXRjaCIsImV4ZWMiLCJjb250ZW50IiwicHVzaCIsInVzZXJQcm9mIiwiZGlzcGxheU5hbWUiLCJkaXNwbGF5X25hbWUiLCJuYW1lIiwic2xpY2UiLCJwaWN0dXJlIiwidW50aWwiLCJwcmV2IiwiZXhpc3RpbmdJZHMiLCJlIiwiaWQiLCJuZXdFdmVudHMiLCJoYXMiLCJzb3J0IiwiYSIsImIiLCJjcmVhdGVkX2F0IiwicHVibGlzaEV2ZW50Iiwic2lnbmVkRXZlbnQiLCJwb29sIiwicHJvbWlzZXMiLCJwdWJsaXNoIiwiYW55IiwicCIsInJhY2UiLCJfIiwicmVqIiwic2V0VGltZW91dCIsIkVycm9yIiwiY2xvc2UiLCJwb3N0IiwidW5zaWduZWRFdmVudCIsImtpbmQiLCJNYXRoIiwiZmxvb3IiLCJ0YWdzIiwic2lnbkV2ZW50IiwiY3VycmVudFByb2ZpbGUiLCJ1cGRhdGVQcm9maWxlTWV0YWRhdGEiLCJuZXdQcm9maWxlRGF0YSIsImNvbnRlbnRQYXlsb2FkIiwidW5kZWZpbmVkIiwiYWJvdXQiLCJiYW5uZXIiLCJ3ZWJzaXRlIiwibHVkMDYiLCJsdWQxNiIsIm5pcDA1IiwiSlNPTiIsInN0cmluZ2lmeSIsInVwZGF0ZWRGdWxsUHJvZmlsZSIsInVwZGF0ZUNvbnRhY3RMaXN0IiwibmV3Rm9sbG93aW5nUHVia2V5cyIsImZvbGxvd1VzZXIiLCJ1c2VyUHVia2V5IiwiaW5jbHVkZXMiLCJuZXdGb2xsb3dpbmdMaXN0IiwidW5mb2xsb3dVc2VyIiwiaXNGb2xsb3dpbmciLCJraW5kcyIsImF1dGhvcnMiLCJjb250YWN0TGlzdEV2ZW50cyIsImxhdGVzdENvbnRhY3RMaXN0IiwiZm9sbG93ZWRQdWJrZXlzIiwidGFnIiwidXBkYXRlUHJvZmlsZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useNostr.ts\n"));

/***/ })

});