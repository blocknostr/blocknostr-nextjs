/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/../node_modules/nostr-tools/lib/cjs/index.js":
/*!****************************************************!*\
  !*** ../node_modules/nostr-tools/lib/cjs/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// index.ts\nvar nostr_tools_exports = {};\n__export(nostr_tools_exports, {\n  Relay: () => Relay,\n  SimplePool: () => SimplePool,\n  finalizeEvent: () => finalizeEvent,\n  fj: () => fakejson_exports,\n  generateSecretKey: () => generateSecretKey,\n  getEventHash: () => getEventHash,\n  getFilterLimit: () => getFilterLimit,\n  getPublicKey: () => getPublicKey,\n  kinds: () => kinds_exports,\n  matchFilter: () => matchFilter,\n  matchFilters: () => matchFilters,\n  mergeFilters: () => mergeFilters,\n  nip04: () => nip04_exports,\n  nip05: () => nip05_exports,\n  nip10: () => nip10_exports,\n  nip11: () => nip11_exports,\n  nip13: () => nip13_exports,\n  nip17: () => nip17_exports,\n  nip18: () => nip18_exports,\n  nip19: () => nip19_exports,\n  nip21: () => nip21_exports,\n  nip25: () => nip25_exports,\n  nip27: () => nip27_exports,\n  nip28: () => nip28_exports,\n  nip30: () => nip30_exports,\n  nip39: () => nip39_exports,\n  nip42: () => nip42_exports,\n  nip44: () => nip44_exports,\n  nip47: () => nip47_exports,\n  nip54: () => nip54_exports,\n  nip57: () => nip57_exports,\n  nip59: () => nip59_exports,\n  nip98: () => nip98_exports,\n  parseReferences: () => parseReferences,\n  serializeEvent: () => serializeEvent,\n  sortEvents: () => sortEvents,\n  utils: () => utils_exports,\n  validateEvent: () => validateEvent,\n  verifiedSymbol: () => verifiedSymbol,\n  verifyEvent: () => verifyEvent\n});\nmodule.exports = __toCommonJS(nostr_tools_exports);\n\n// pure.ts\nvar import_secp256k1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/secp256k1.js\");\nvar import_utils = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/utils.js\");\n\n// core.ts\nvar verifiedSymbol = Symbol(\"verified\");\nvar isRecord = (obj) => obj instanceof Object;\nfunction validateEvent(event) {\n  if (!isRecord(event))\n    return false;\n  if (typeof event.kind !== \"number\")\n    return false;\n  if (typeof event.content !== \"string\")\n    return false;\n  if (typeof event.created_at !== \"number\")\n    return false;\n  if (typeof event.pubkey !== \"string\")\n    return false;\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/))\n    return false;\n  if (!Array.isArray(event.tags))\n    return false;\n  for (let i2 = 0; i2 < event.tags.length; i2++) {\n    let tag = event.tags[i2];\n    if (!Array.isArray(tag))\n      return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\")\n        return false;\n    }\n  }\n  return true;\n}\nfunction sortEvents(events) {\n  return events.sort((a, b) => {\n    if (a.created_at !== b.created_at) {\n      return b.created_at - a.created_at;\n    }\n    return a.id.localeCompare(b.id);\n  });\n}\n\n// pure.ts\nvar import_sha256 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/sha256.js\");\n\n// utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Queue: () => Queue,\n  QueueNode: () => QueueNode,\n  binarySearch: () => binarySearch,\n  insertEventIntoAscendingList: () => insertEventIntoAscendingList,\n  insertEventIntoDescendingList: () => insertEventIntoDescendingList,\n  normalizeURL: () => normalizeURL,\n  utf8Decoder: () => utf8Decoder,\n  utf8Encoder: () => utf8Encoder\n});\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nvar utf8Encoder = new TextEncoder();\nfunction normalizeURL(url) {\n  if (url.indexOf(\"://\") === -1)\n    url = \"wss://\" + url;\n  let p = new URL(url);\n  p.pathname = p.pathname.replace(/\\/+/g, \"/\");\n  if (p.pathname.endsWith(\"/\"))\n    p.pathname = p.pathname.slice(0, -1);\n  if (p.port === \"80\" && p.protocol === \"ws:\" || p.port === \"443\" && p.protocol === \"wss:\")\n    p.port = \"\";\n  p.searchParams.sort();\n  p.hash = \"\";\n  return p.toString();\n}\nfunction insertEventIntoDescendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return b.created_at - event.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction insertEventIntoAscendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return event.created_at - b.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction binarySearch(arr, compare) {\n  let start = 0;\n  let end = arr.length - 1;\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n    const cmp = compare(arr[mid]);\n    if (cmp === 0) {\n      return [mid, true];\n    }\n    if (cmp < 0) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n  return [start, false];\n}\nvar QueueNode = class {\n  value;\n  next = null;\n  prev = null;\n  constructor(message) {\n    this.value = message;\n  }\n};\nvar Queue = class {\n  first;\n  last;\n  constructor() {\n    this.first = null;\n    this.last = null;\n  }\n  enqueue(value) {\n    const newNode = new QueueNode(value);\n    if (!this.last) {\n      this.first = newNode;\n      this.last = newNode;\n    } else if (this.last === this.first) {\n      this.last = newNode;\n      this.last.prev = this.first;\n      this.first.next = newNode;\n    } else {\n      newNode.prev = this.last;\n      this.last.next = newNode;\n      this.last = newNode;\n    }\n    return true;\n  }\n  dequeue() {\n    if (!this.first)\n      return null;\n    if (this.first === this.last) {\n      const target2 = this.first;\n      this.first = null;\n      this.last = null;\n      return target2.value;\n    }\n    const target = this.first;\n    this.first = target.next;\n    return target.value;\n  }\n};\n\n// pure.ts\nvar JS = class {\n  generateSecretKey() {\n    return import_secp256k1.schnorr.utils.randomPrivateKey();\n  }\n  getPublicKey(secretKey) {\n    return (0, import_utils.bytesToHex)(import_secp256k1.schnorr.getPublicKey(secretKey));\n  }\n  finalizeEvent(t, secretKey) {\n    const event = t;\n    event.pubkey = (0, import_utils.bytesToHex)(import_secp256k1.schnorr.getPublicKey(secretKey));\n    event.id = getEventHash(event);\n    event.sig = (0, import_utils.bytesToHex)(import_secp256k1.schnorr.sign(getEventHash(event), secretKey));\n    event[verifiedSymbol] = true;\n    return event;\n  }\n  verifyEvent(event) {\n    if (typeof event[verifiedSymbol] === \"boolean\")\n      return event[verifiedSymbol];\n    const hash = getEventHash(event);\n    if (hash !== event.id) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n    try {\n      const valid = import_secp256k1.schnorr.verify(event.sig, hash, event.pubkey);\n      event[verifiedSymbol] = valid;\n      return valid;\n    } catch (err) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n  }\n};\nfunction serializeEvent(evt) {\n  if (!validateEvent(evt))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);\n}\nfunction getEventHash(event) {\n  let eventHash = (0, import_sha256.sha256)(utf8Encoder.encode(serializeEvent(event)));\n  return (0, import_utils.bytesToHex)(eventHash);\n}\nvar i = new JS();\nvar generateSecretKey = i.generateSecretKey;\nvar getPublicKey = i.getPublicKey;\nvar finalizeEvent = i.finalizeEvent;\nvar verifyEvent = i.verifyEvent;\n\n// kinds.ts\nvar kinds_exports = {};\n__export(kinds_exports, {\n  Application: () => Application,\n  BadgeAward: () => BadgeAward,\n  BadgeDefinition: () => BadgeDefinition,\n  BlockedRelaysList: () => BlockedRelaysList,\n  BookmarkList: () => BookmarkList,\n  Bookmarksets: () => Bookmarksets,\n  Calendar: () => Calendar,\n  CalendarEventRSVP: () => CalendarEventRSVP,\n  ChannelCreation: () => ChannelCreation,\n  ChannelHideMessage: () => ChannelHideMessage,\n  ChannelMessage: () => ChannelMessage,\n  ChannelMetadata: () => ChannelMetadata,\n  ChannelMuteUser: () => ChannelMuteUser,\n  ClassifiedListing: () => ClassifiedListing,\n  ClientAuth: () => ClientAuth,\n  CommunitiesList: () => CommunitiesList,\n  CommunityDefinition: () => CommunityDefinition,\n  CommunityPostApproval: () => CommunityPostApproval,\n  Contacts: () => Contacts,\n  CreateOrUpdateProduct: () => CreateOrUpdateProduct,\n  CreateOrUpdateStall: () => CreateOrUpdateStall,\n  Curationsets: () => Curationsets,\n  Date: () => Date2,\n  DirectMessageRelaysList: () => DirectMessageRelaysList,\n  DraftClassifiedListing: () => DraftClassifiedListing,\n  DraftLong: () => DraftLong,\n  Emojisets: () => Emojisets,\n  EncryptedDirectMessage: () => EncryptedDirectMessage,\n  EventDeletion: () => EventDeletion,\n  FileMetadata: () => FileMetadata,\n  FileServerPreference: () => FileServerPreference,\n  Followsets: () => Followsets,\n  GenericRepost: () => GenericRepost,\n  Genericlists: () => Genericlists,\n  GiftWrap: () => GiftWrap,\n  HTTPAuth: () => HTTPAuth,\n  Handlerinformation: () => Handlerinformation,\n  Handlerrecommendation: () => Handlerrecommendation,\n  Highlights: () => Highlights,\n  InterestsList: () => InterestsList,\n  Interestsets: () => Interestsets,\n  JobFeedback: () => JobFeedback,\n  JobRequest: () => JobRequest,\n  JobResult: () => JobResult,\n  Label: () => Label,\n  LightningPubRPC: () => LightningPubRPC,\n  LiveChatMessage: () => LiveChatMessage,\n  LiveEvent: () => LiveEvent,\n  LongFormArticle: () => LongFormArticle,\n  Metadata: () => Metadata,\n  Mutelist: () => Mutelist,\n  NWCWalletInfo: () => NWCWalletInfo,\n  NWCWalletRequest: () => NWCWalletRequest,\n  NWCWalletResponse: () => NWCWalletResponse,\n  NostrConnect: () => NostrConnect,\n  OpenTimestamps: () => OpenTimestamps,\n  Pinlist: () => Pinlist,\n  PrivateDirectMessage: () => PrivateDirectMessage,\n  ProblemTracker: () => ProblemTracker,\n  ProfileBadges: () => ProfileBadges,\n  PublicChatsList: () => PublicChatsList,\n  Reaction: () => Reaction,\n  RecommendRelay: () => RecommendRelay,\n  RelayList: () => RelayList,\n  Relaysets: () => Relaysets,\n  Report: () => Report,\n  Reporting: () => Reporting,\n  Repost: () => Repost,\n  Seal: () => Seal,\n  SearchRelaysList: () => SearchRelaysList,\n  ShortTextNote: () => ShortTextNote,\n  Time: () => Time,\n  UserEmojiList: () => UserEmojiList,\n  UserStatuses: () => UserStatuses,\n  Zap: () => Zap,\n  ZapGoal: () => ZapGoal,\n  ZapRequest: () => ZapRequest,\n  classifyKind: () => classifyKind,\n  isAddressableKind: () => isAddressableKind,\n  isEphemeralKind: () => isEphemeralKind,\n  isKind: () => isKind,\n  isParameterizedReplaceableKind: () => isParameterizedReplaceableKind,\n  isRegularKind: () => isRegularKind,\n  isReplaceableKind: () => isReplaceableKind\n});\nfunction isRegularKind(kind) {\n  return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);\n}\nfunction isReplaceableKind(kind) {\n  return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;\n}\nfunction isEphemeralKind(kind) {\n  return 2e4 <= kind && kind < 3e4;\n}\nfunction isAddressableKind(kind) {\n  return 3e4 <= kind && kind < 4e4;\n}\nvar isParameterizedReplaceableKind = isAddressableKind;\nfunction classifyKind(kind) {\n  if (isRegularKind(kind))\n    return \"regular\";\n  if (isReplaceableKind(kind))\n    return \"replaceable\";\n  if (isEphemeralKind(kind))\n    return \"ephemeral\";\n  if (isAddressableKind(kind))\n    return \"parameterized\";\n  return \"unknown\";\n}\nfunction isKind(event, kind) {\n  const kindAsArray = kind instanceof Array ? kind : [kind];\n  return validateEvent(event) && kindAsArray.includes(event.kind) || false;\n}\nvar Metadata = 0;\nvar ShortTextNote = 1;\nvar RecommendRelay = 2;\nvar Contacts = 3;\nvar EncryptedDirectMessage = 4;\nvar EventDeletion = 5;\nvar Repost = 6;\nvar Reaction = 7;\nvar BadgeAward = 8;\nvar Seal = 13;\nvar PrivateDirectMessage = 14;\nvar GenericRepost = 16;\nvar ChannelCreation = 40;\nvar ChannelMetadata = 41;\nvar ChannelMessage = 42;\nvar ChannelHideMessage = 43;\nvar ChannelMuteUser = 44;\nvar OpenTimestamps = 1040;\nvar GiftWrap = 1059;\nvar FileMetadata = 1063;\nvar LiveChatMessage = 1311;\nvar ProblemTracker = 1971;\nvar Report = 1984;\nvar Reporting = 1984;\nvar Label = 1985;\nvar CommunityPostApproval = 4550;\nvar JobRequest = 5999;\nvar JobResult = 6999;\nvar JobFeedback = 7e3;\nvar ZapGoal = 9041;\nvar ZapRequest = 9734;\nvar Zap = 9735;\nvar Highlights = 9802;\nvar Mutelist = 1e4;\nvar Pinlist = 10001;\nvar RelayList = 10002;\nvar BookmarkList = 10003;\nvar CommunitiesList = 10004;\nvar PublicChatsList = 10005;\nvar BlockedRelaysList = 10006;\nvar SearchRelaysList = 10007;\nvar InterestsList = 10015;\nvar UserEmojiList = 10030;\nvar DirectMessageRelaysList = 10050;\nvar FileServerPreference = 10096;\nvar NWCWalletInfo = 13194;\nvar LightningPubRPC = 21e3;\nvar ClientAuth = 22242;\nvar NWCWalletRequest = 23194;\nvar NWCWalletResponse = 23195;\nvar NostrConnect = 24133;\nvar HTTPAuth = 27235;\nvar Followsets = 3e4;\nvar Genericlists = 30001;\nvar Relaysets = 30002;\nvar Bookmarksets = 30003;\nvar Curationsets = 30004;\nvar ProfileBadges = 30008;\nvar BadgeDefinition = 30009;\nvar Interestsets = 30015;\nvar CreateOrUpdateStall = 30017;\nvar CreateOrUpdateProduct = 30018;\nvar LongFormArticle = 30023;\nvar DraftLong = 30024;\nvar Emojisets = 30030;\nvar Application = 30078;\nvar LiveEvent = 30311;\nvar UserStatuses = 30315;\nvar ClassifiedListing = 30402;\nvar DraftClassifiedListing = 30403;\nvar Date2 = 31922;\nvar Time = 31923;\nvar Calendar = 31924;\nvar CalendarEventRSVP = 31925;\nvar Handlerrecommendation = 31989;\nvar Handlerinformation = 31990;\nvar CommunityDefinition = 34550;\n\n// filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (let f in filter) {\n    if (f[0] === \"#\") {\n      let tagName = f.slice(1);\n      let values = filter[`#${tagName}`];\n      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1))\n        return false;\n    }\n  }\n  if (filter.since && event.created_at < filter.since)\n    return false;\n  if (filter.until && event.created_at > filter.until)\n    return false;\n  return true;\n}\nfunction matchFilters(filters, event) {\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    if (matchFilter(filters[i2], event)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction mergeFilters(...filters) {\n  let result = {};\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    let filter = filters[i2];\n    Object.entries(filter).forEach(([property, values]) => {\n      if (property === \"kinds\" || property === \"ids\" || property === \"authors\" || property[0] === \"#\") {\n        result[property] = result[property] || [];\n        for (let v = 0; v < values.length; v++) {\n          let value = values[v];\n          if (!result[property].includes(value))\n            result[property].push(value);\n        }\n      }\n    });\n    if (filter.limit && (!result.limit || filter.limit > result.limit))\n      result.limit = filter.limit;\n    if (filter.until && (!result.until || filter.until > result.until))\n      result.until = filter.until;\n    if (filter.since && (!result.since || filter.since < result.since))\n      result.since = filter.since;\n  }\n  return result;\n}\nfunction getFilterLimit(filter) {\n  if (filter.ids && !filter.ids.length)\n    return 0;\n  if (filter.kinds && !filter.kinds.length)\n    return 0;\n  if (filter.authors && !filter.authors.length)\n    return 0;\n  for (const [key, value] of Object.entries(filter)) {\n    if (key[0] === \"#\" && Array.isArray(value) && !value.length)\n      return 0;\n  }\n  return Math.min(\n    Math.max(0, filter.limit ?? Infinity),\n    filter.ids?.length ?? Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isReplaceableKind(kind)) ? filter.authors.length * filter.kinds.length : Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isAddressableKind(kind)) && filter[\"#d\"]?.length ? filter.authors.length * filter.kinds.length * filter[\"#d\"].length : Infinity\n  );\n}\n\n// fakejson.ts\nvar fakejson_exports = {};\n__export(fakejson_exports, {\n  getHex64: () => getHex64,\n  getInt: () => getInt,\n  getSubscriptionId: () => getSubscriptionId,\n  matchEventId: () => matchEventId,\n  matchEventKind: () => matchEventKind,\n  matchEventPubkey: () => matchEventPubkey\n});\nfunction getHex64(json, field) {\n  let len = field.length + 3;\n  let idx = json.indexOf(`\"${field}\":`) + len;\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1;\n  return json.slice(s, s + 64);\n}\nfunction getInt(json, field) {\n  let len = field.length;\n  let idx = json.indexOf(`\"${field}\":`) + len + 3;\n  let sliced = json.slice(idx);\n  let end = Math.min(sliced.indexOf(\",\"), sliced.indexOf(\"}\"));\n  return parseInt(sliced.slice(0, end), 10);\n}\nfunction getSubscriptionId(json) {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`);\n  if (idx === -1)\n    return null;\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`);\n  if (pstart === -1)\n    return null;\n  let start = idx + 7 + 1 + pstart;\n  let pend = json.slice(start + 1, 80).indexOf(`\"`);\n  if (pend === -1)\n    return null;\n  let end = start + 1 + pend;\n  return json.slice(start + 1, end);\n}\nfunction matchEventId(json, id) {\n  return id === getHex64(json, \"id\");\n}\nfunction matchEventPubkey(json, pubkey) {\n  return pubkey === getHex64(json, \"pubkey\");\n}\nfunction matchEventKind(json, kind) {\n  return kind === getInt(json, \"kind\");\n}\n\n// nip42.ts\nvar nip42_exports = {};\n__export(nip42_exports, {\n  makeAuthEvent: () => makeAuthEvent\n});\nfunction makeAuthEvent(relayURL, challenge) {\n  return {\n    kind: ClientAuth,\n    created_at: Math.floor(Date.now() / 1e3),\n    tags: [\n      [\"relay\", relayURL],\n      [\"challenge\", challenge]\n    ],\n    content: \"\"\n  };\n}\n\n// helpers.ts\nasync function yieldThread() {\n  return new Promise((resolve) => {\n    const ch = new MessageChannel();\n    const handler = () => {\n      ch.port1.removeEventListener(\"message\", handler);\n      resolve();\n    };\n    ch.port1.addEventListener(\"message\", handler);\n    ch.port2.postMessage(0);\n    ch.port1.start();\n  });\n}\nvar alwaysTrue = (t) => {\n  t[verifiedSymbol] = true;\n  return true;\n};\n\n// abstract-relay.ts\nvar AbstractRelay = class {\n  url;\n  _connected = false;\n  onclose = null;\n  onnotice = (msg) => console.debug(`NOTICE from ${this.url}: ${msg}`);\n  _onauth = null;\n  baseEoseTimeout = 4400;\n  connectionTimeout = 4400;\n  publishTimeout = 4400;\n  openSubs = /* @__PURE__ */ new Map();\n  connectionTimeoutHandle;\n  connectionPromise;\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  ws;\n  incomingMessageQueue = new Queue();\n  queueRunning = false;\n  challenge;\n  authPromise;\n  serial = 0;\n  verifyEvent;\n  _WebSocket;\n  constructor(url, opts) {\n    this.url = normalizeURL(url);\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation || WebSocket;\n  }\n  static async connect(url, opts) {\n    const relay = new AbstractRelay(url, opts);\n    await relay.connect();\n    return relay;\n  }\n  closeAllSubscriptions(reason) {\n    for (let [_, sub] of this.openSubs) {\n      sub.close(reason);\n    }\n    this.openSubs.clear();\n    for (let [_, ep] of this.openEventPublishes) {\n      ep.reject(new Error(reason));\n    }\n    this.openEventPublishes.clear();\n    for (let [_, cr] of this.openCountRequests) {\n      cr.reject(new Error(reason));\n    }\n    this.openCountRequests.clear();\n  }\n  get connected() {\n    return this._connected;\n  }\n  async connect() {\n    if (this.connectionPromise)\n      return this.connectionPromise;\n    this.challenge = void 0;\n    this.authPromise = void 0;\n    this.connectionPromise = new Promise((resolve, reject) => {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        reject(\"connection timed out\");\n        this.connectionPromise = void 0;\n        this.onclose?.();\n        this.closeAllSubscriptions(\"relay connection timed out\");\n      }, this.connectionTimeout);\n      try {\n        this.ws = new this._WebSocket(this.url);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      this.ws.onopen = () => {\n        clearTimeout(this.connectionTimeoutHandle);\n        this._connected = true;\n        resolve();\n      };\n      this.ws.onerror = (ev) => {\n        reject(ev.message || \"websocket error\");\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection errored\");\n        }\n      };\n      this.ws.onclose = async () => {\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection closed\");\n        }\n      };\n      this.ws.onmessage = this._onmessage.bind(this);\n    });\n    return this.connectionPromise;\n  }\n  async runQueue() {\n    this.queueRunning = true;\n    while (true) {\n      if (false === this.handleNext()) {\n        break;\n      }\n      await yieldThread();\n    }\n    this.queueRunning = false;\n  }\n  handleNext() {\n    const json = this.incomingMessageQueue.dequeue();\n    if (!json) {\n      return false;\n    }\n    const subid = getSubscriptionId(json);\n    if (subid) {\n      const so = this.openSubs.get(subid);\n      if (!so) {\n        return;\n      }\n      const id = getHex64(json, \"id\");\n      const alreadyHave = so.alreadyHaveEvent?.(id);\n      so.receivedEvent?.(this, id);\n      if (alreadyHave) {\n        return;\n      }\n    }\n    try {\n      let data = JSON.parse(json);\n      switch (data[0]) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(data[1]);\n          const event = data[2];\n          if (this.verifyEvent(event) && matchFilters(so.filters, event)) {\n            so.onevent(event);\n          }\n          return;\n        }\n        case \"COUNT\": {\n          const id = data[1];\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(data[1]);\n          if (!so)\n            return;\n          so.receivedEose();\n          return;\n        }\n        case \"OK\": {\n          const id = data[1];\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          if (ep) {\n            clearTimeout(ep.timeout);\n            if (ok)\n              ep.resolve(reason);\n            else\n              ep.reject(new Error(reason));\n            this.openEventPublishes.delete(id);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const id = data[1];\n          const so = this.openSubs.get(id);\n          if (!so)\n            return;\n          so.closed = true;\n          so.close(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onnotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.challenge = data[1];\n          this.authPromise = void 0;\n          this._onauth?.(data[1]);\n          return;\n        }\n      }\n    } catch (err) {\n      return;\n    }\n  }\n  async send(message) {\n    if (!this.connectionPromise)\n      throw new Error(\"sending on closed connection\");\n    this.connectionPromise.then(() => {\n      this.ws?.send(message);\n    });\n  }\n  async auth(signAuthEvent) {\n    if (!this.challenge)\n      throw new Error(\"can't perform auth, no challenge was received\");\n    if (this.authPromise)\n      return this.authPromise;\n    const evt = await signAuthEvent(makeAuthEvent(this.url, this.challenge));\n    this.authPromise = new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        const ep = this.openEventPublishes.get(evt.id);\n        if (ep) {\n          ep.reject(new Error(\"auth timed out\"));\n          this.openEventPublishes.delete(evt.id);\n        }\n      }, this.publishTimeout);\n      this.openEventPublishes.set(evt.id, { resolve, reject, timeout });\n    });\n    this.send('[\"AUTH\",' + JSON.stringify(evt) + \"]\");\n    return this.authPromise;\n  }\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        const ep = this.openEventPublishes.get(event.id);\n        if (ep) {\n          ep.reject(new Error(\"publish timed out\"));\n          this.openEventPublishes.delete(event.id);\n        }\n      }, this.publishTimeout);\n      this.openEventPublishes.set(event.id, { resolve, reject, timeout });\n    });\n    this.send('[\"EVENT\",' + JSON.stringify(event) + \"]\");\n    return ret;\n  }\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || \"count:\" + this.serial;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send('[\"COUNT\",\"' + id + '\",' + JSON.stringify(filters).substring(1));\n    return ret;\n  }\n  subscribe(filters, params) {\n    const subscription = this.prepareSubscription(filters, params);\n    subscription.fire();\n    return subscription;\n  }\n  prepareSubscription(filters, params) {\n    this.serial++;\n    const id = params.id || (params.label ? params.label + \":\" : \"sub:\") + this.serial;\n    const subscription = new Subscription(this, id, filters, params);\n    this.openSubs.set(id, subscription);\n    return subscription;\n  }\n  close() {\n    this.closeAllSubscriptions(\"relay connection closed by us\");\n    this._connected = false;\n    this.ws?.close();\n  }\n  _onmessage(ev) {\n    this.incomingMessageQueue.enqueue(ev.data);\n    if (!this.queueRunning) {\n      this.runQueue();\n    }\n  }\n};\nvar Subscription = class {\n  relay;\n  id;\n  closed = false;\n  eosed = false;\n  filters;\n  alreadyHaveEvent;\n  receivedEvent;\n  onevent;\n  oneose;\n  onclose;\n  eoseTimeout;\n  eoseTimeoutHandle;\n  constructor(relay, id, filters, params) {\n    this.relay = relay;\n    this.filters = filters;\n    this.id = id;\n    this.alreadyHaveEvent = params.alreadyHaveEvent;\n    this.receivedEvent = params.receivedEvent;\n    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;\n    this.oneose = params.oneose;\n    this.onclose = params.onclose;\n    this.onevent = params.onevent || ((event) => {\n      console.warn(\n        `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,\n        event\n      );\n    });\n  }\n  fire() {\n    this.relay.send('[\"REQ\",\"' + this.id + '\",' + JSON.stringify(this.filters).substring(1));\n    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);\n  }\n  receivedEose() {\n    if (this.eosed)\n      return;\n    clearTimeout(this.eoseTimeoutHandle);\n    this.eosed = true;\n    this.oneose?.();\n  }\n  close(reason = \"closed by caller\") {\n    if (!this.closed && this.relay.connected) {\n      this.relay.send('[\"CLOSE\",' + JSON.stringify(this.id) + \"]\");\n      this.closed = true;\n    }\n    this.relay.openSubs.delete(this.id);\n    this.onclose?.(reason);\n  }\n};\n\n// relay.ts\nvar _WebSocket;\ntry {\n  _WebSocket = WebSocket;\n} catch {\n}\nvar Relay = class extends AbstractRelay {\n  constructor(url) {\n    super(url, { verifyEvent, websocketImplementation: _WebSocket });\n  }\n  static async connect(url) {\n    const relay = new Relay(url);\n    await relay.connect();\n    return relay;\n  }\n};\n\n// abstract-pool.ts\nvar AbstractSimplePool = class {\n  relays = /* @__PURE__ */ new Map();\n  seenOn = /* @__PURE__ */ new Map();\n  trackRelays = false;\n  verifyEvent;\n  trustedRelayURLs = /* @__PURE__ */ new Set();\n  _WebSocket;\n  constructor(opts) {\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation;\n  }\n  async ensureRelay(url, params) {\n    url = normalizeURL(url);\n    let relay = this.relays.get(url);\n    if (!relay) {\n      relay = new AbstractRelay(url, {\n        verifyEvent: this.trustedRelayURLs.has(url) ? alwaysTrue : this.verifyEvent,\n        websocketImplementation: this._WebSocket\n      });\n      if (params?.connectionTimeout)\n        relay.connectionTimeout = params.connectionTimeout;\n      this.relays.set(url, relay);\n    }\n    await relay.connect();\n    return relay;\n  }\n  close(relays) {\n    relays.map(normalizeURL).forEach((url) => {\n      this.relays.get(url)?.close();\n    });\n  }\n  subscribe(relays, filter, params) {\n    return this.subscribeMap(\n      relays.map((url) => ({ url, filter })),\n      params\n    );\n  }\n  subscribeMany(relays, filters, params) {\n    return this.subscribeMap(\n      relays.flatMap((url) => filters.map((filter) => ({ url, filter }))),\n      params\n    );\n  }\n  subscribeMap(requests, params) {\n    if (this.trackRelays) {\n      params.receivedEvent = (relay, id) => {\n        let set = this.seenOn.get(id);\n        if (!set) {\n          set = /* @__PURE__ */ new Set();\n          this.seenOn.set(id, set);\n        }\n        set.add(relay);\n      };\n    }\n    const _knownIds = /* @__PURE__ */ new Set();\n    const subs = [];\n    const eosesReceived = [];\n    let handleEose = (i2) => {\n      if (eosesReceived[i2])\n        return;\n      eosesReceived[i2] = true;\n      if (eosesReceived.filter((a) => a).length === requests.length) {\n        params.oneose?.();\n        handleEose = () => {\n        };\n      }\n    };\n    const closesReceived = [];\n    let handleClose = (i2, reason) => {\n      if (closesReceived[i2])\n        return;\n      handleEose(i2);\n      closesReceived[i2] = reason;\n      if (closesReceived.filter((a) => a).length === requests.length) {\n        params.onclose?.(closesReceived);\n        handleClose = () => {\n        };\n      }\n    };\n    const localAlreadyHaveEventHandler = (id) => {\n      if (params.alreadyHaveEvent?.(id)) {\n        return true;\n      }\n      const have = _knownIds.has(id);\n      _knownIds.add(id);\n      return have;\n    };\n    const allOpened = Promise.all(\n      requests.map(async ({ url, filter }, i2) => {\n        url = normalizeURL(url);\n        let relay;\n        try {\n          relay = await this.ensureRelay(url, {\n            connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0\n          });\n        } catch (err) {\n          handleClose(i2, err?.message || String(err));\n          return;\n        }\n        let subscription = relay.subscribe([filter], {\n          ...params,\n          oneose: () => handleEose(i2),\n          onclose: (reason) => {\n            if (reason.startsWith(\"auth-required:\") && params.doauth) {\n              relay.auth(params.doauth).then(() => {\n                relay.subscribe([filter], {\n                  ...params,\n                  oneose: () => handleEose(i2),\n                  onclose: (reason2) => {\n                    handleClose(i2, reason2);\n                  },\n                  alreadyHaveEvent: localAlreadyHaveEventHandler,\n                  eoseTimeout: params.maxWait\n                });\n              }).catch((err) => {\n                handleClose(i2, `auth was required and attempted, but failed with: ${err}`);\n              });\n            } else {\n              handleClose(i2, reason);\n            }\n          },\n          alreadyHaveEvent: localAlreadyHaveEventHandler,\n          eoseTimeout: params.maxWait\n        });\n        subs.push(subscription);\n      })\n    );\n    return {\n      async close() {\n        await allOpened;\n        subs.forEach((sub) => {\n          sub.close();\n        });\n      }\n    };\n  }\n  subscribeManyMap(requests, params) {\n    if (this.trackRelays) {\n      params.receivedEvent = (relay, id) => {\n        let set = this.seenOn.get(id);\n        if (!set) {\n          set = /* @__PURE__ */ new Set();\n          this.seenOn.set(id, set);\n        }\n        set.add(relay);\n      };\n    }\n    const _knownIds = /* @__PURE__ */ new Set();\n    const subs = [];\n    const relaysLength = Object.keys(requests).length;\n    const eosesReceived = [];\n    let handleEose = (i2) => {\n      if (eosesReceived[i2])\n        return;\n      eosesReceived[i2] = true;\n      if (eosesReceived.filter((a) => a).length === relaysLength) {\n        params.oneose?.();\n        handleEose = () => {\n        };\n      }\n    };\n    const closesReceived = [];\n    let handleClose = (i2, reason) => {\n      if (closesReceived[i2])\n        return;\n      handleEose(i2);\n      closesReceived[i2] = reason;\n      if (closesReceived.filter((a) => a).length === relaysLength) {\n        params.onclose?.(closesReceived);\n        handleClose = () => {\n        };\n      }\n    };\n    const localAlreadyHaveEventHandler = (id) => {\n      if (params.alreadyHaveEvent?.(id)) {\n        return true;\n      }\n      const have = _knownIds.has(id);\n      _knownIds.add(id);\n      return have;\n    };\n    const allOpened = Promise.all(\n      Object.entries(requests).map(async (req, i2, arr) => {\n        if (arr.indexOf(req) !== i2) {\n          handleClose(i2, \"duplicate url\");\n          return;\n        }\n        let [url, filters] = req;\n        url = normalizeURL(url);\n        let relay;\n        try {\n          relay = await this.ensureRelay(url, {\n            connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0\n          });\n        } catch (err) {\n          handleClose(i2, err?.message || String(err));\n          return;\n        }\n        let subscription = relay.subscribe(filters, {\n          ...params,\n          oneose: () => handleEose(i2),\n          onclose: (reason) => {\n            if (reason.startsWith(\"auth-required:\") && params.doauth) {\n              relay.auth(params.doauth).then(() => {\n                relay.subscribe(filters, {\n                  ...params,\n                  oneose: () => handleEose(i2),\n                  onclose: (reason2) => {\n                    handleClose(i2, reason2);\n                  },\n                  alreadyHaveEvent: localAlreadyHaveEventHandler,\n                  eoseTimeout: params.maxWait\n                });\n              }).catch((err) => {\n                handleClose(i2, `auth was required and attempted, but failed with: ${err}`);\n              });\n            } else {\n              handleClose(i2, reason);\n            }\n          },\n          alreadyHaveEvent: localAlreadyHaveEventHandler,\n          eoseTimeout: params.maxWait\n        });\n        subs.push(subscription);\n      })\n    );\n    return {\n      async close() {\n        await allOpened;\n        subs.forEach((sub) => {\n          sub.close();\n        });\n      }\n    };\n  }\n  subscribeEose(relays, filter, params) {\n    const subcloser = this.subscribe(relays, filter, {\n      ...params,\n      oneose() {\n        subcloser.close();\n      }\n    });\n    return subcloser;\n  }\n  subscribeManyEose(relays, filters, params) {\n    const subcloser = this.subscribeMany(relays, filters, {\n      ...params,\n      oneose() {\n        subcloser.close();\n      }\n    });\n    return subcloser;\n  }\n  async querySync(relays, filter, params) {\n    return new Promise(async (resolve) => {\n      const events = [];\n      this.subscribeEose(relays, filter, {\n        ...params,\n        onevent(event) {\n          events.push(event);\n        },\n        onclose(_) {\n          resolve(events);\n        }\n      });\n    });\n  }\n  async get(relays, filter, params) {\n    filter.limit = 1;\n    const events = await this.querySync(relays, filter, params);\n    events.sort((a, b) => b.created_at - a.created_at);\n    return events[0] || null;\n  }\n  publish(relays, event) {\n    return relays.map(normalizeURL).map(async (url, i2, arr) => {\n      if (arr.indexOf(url) !== i2) {\n        return Promise.reject(\"duplicate url\");\n      }\n      let r = await this.ensureRelay(url);\n      return r.publish(event).then((reason) => {\n        if (this.trackRelays) {\n          let set = this.seenOn.get(event.id);\n          if (!set) {\n            set = /* @__PURE__ */ new Set();\n            this.seenOn.set(event.id, set);\n          }\n          set.add(r);\n        }\n        return reason;\n      });\n    });\n  }\n  listConnectionStatus() {\n    const map = /* @__PURE__ */ new Map();\n    this.relays.forEach((relay, url) => map.set(url, relay.connected));\n    return map;\n  }\n  destroy() {\n    this.relays.forEach((conn) => conn.close());\n    this.relays = /* @__PURE__ */ new Map();\n  }\n};\n\n// pool.ts\nvar _WebSocket2;\ntry {\n  _WebSocket2 = WebSocket;\n} catch {\n}\nvar SimplePool = class extends AbstractSimplePool {\n  constructor() {\n    super({ verifyEvent, websocketImplementation: _WebSocket2 });\n  }\n};\n\n// nip19.ts\nvar nip19_exports = {};\n__export(nip19_exports, {\n  BECH32_REGEX: () => BECH32_REGEX,\n  Bech32MaxSize: () => Bech32MaxSize,\n  NostrTypeGuard: () => NostrTypeGuard,\n  decode: () => decode,\n  decodeNostrURI: () => decodeNostrURI,\n  encodeBytes: () => encodeBytes,\n  naddrEncode: () => naddrEncode,\n  neventEncode: () => neventEncode,\n  noteEncode: () => noteEncode,\n  nprofileEncode: () => nprofileEncode,\n  npubEncode: () => npubEncode,\n  nsecEncode: () => nsecEncode\n});\nvar import_utils5 = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/utils.js\");\nvar import_base = __webpack_require__(/*! @scure/base */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@scure/base/lib/index.js\");\nvar NostrTypeGuard = {\n  isNProfile: (value) => /^nprofile1[a-z\\d]+$/.test(value || \"\"),\n  isNEvent: (value) => /^nevent1[a-z\\d]+$/.test(value || \"\"),\n  isNAddr: (value) => /^naddr1[a-z\\d]+$/.test(value || \"\"),\n  isNSec: (value) => /^nsec1[a-z\\d]{58}$/.test(value || \"\"),\n  isNPub: (value) => /^npub1[a-z\\d]{58}$/.test(value || \"\"),\n  isNote: (value) => /^note1[a-z\\d]+$/.test(value || \"\"),\n  isNcryptsec: (value) => /^ncryptsec1[a-z\\d]+$/.test(value || \"\")\n};\nvar Bech32MaxSize = 5e3;\nvar BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;\nfunction integerToUint8Array(number) {\n  const uint8Array = new Uint8Array(4);\n  uint8Array[0] = number >> 24 & 255;\n  uint8Array[1] = number >> 16 & 255;\n  uint8Array[2] = number >> 8 & 255;\n  uint8Array[3] = number & 255;\n  return uint8Array;\n}\nfunction decodeNostrURI(nip19code) {\n  try {\n    if (nip19code.startsWith(\"nostr:\"))\n      nip19code = nip19code.substring(6);\n    return decode(nip19code);\n  } catch (_err) {\n    return { type: \"invalid\", data: null };\n  }\n}\nfunction decode(nip19) {\n  let { prefix, words } = import_base.bech32.decode(nip19, Bech32MaxSize);\n  let data = new Uint8Array(import_base.bech32.fromWords(words));\n  switch (prefix) {\n    case \"nprofile\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nprofile\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      return {\n        type: \"nprofile\",\n        data: {\n          pubkey: (0, import_utils5.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nevent\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nevent\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      if (tlv[2] && tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (tlv[3] && tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"nevent\",\n        data: {\n          id: (0, import_utils5.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0] ? (0, import_utils5.bytesToHex)(tlv[2][0]) : void 0,\n          kind: tlv[3]?.[0] ? parseInt((0, import_utils5.bytesToHex)(tlv[3][0]), 16) : void 0\n        }\n      };\n    }\n    case \"naddr\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for naddr\");\n      if (!tlv[2]?.[0])\n        throw new Error(\"missing TLV 2 for naddr\");\n      if (tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (!tlv[3]?.[0])\n        throw new Error(\"missing TLV 3 for naddr\");\n      if (tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"naddr\",\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: (0, import_utils5.bytesToHex)(tlv[2][0]),\n          kind: parseInt((0, import_utils5.bytesToHex)(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nsec\":\n      return { type: prefix, data };\n    case \"npub\":\n    case \"note\":\n      return { type: prefix, data: (0, import_utils5.bytesToHex)(data) };\n    default:\n      throw new Error(`unknown prefix ${prefix}`);\n  }\n}\nfunction parseTLV(data) {\n  let result = {};\n  let rest = data;\n  while (rest.length > 0) {\n    let t = rest[0];\n    let l = rest[1];\n    let v = rest.slice(2, 2 + l);\n    rest = rest.slice(2 + l);\n    if (v.length < l)\n      throw new Error(`not enough data to read on TLV ${t}`);\n    result[t] = result[t] || [];\n    result[t].push(v);\n  }\n  return result;\n}\nfunction nsecEncode(key) {\n  return encodeBytes(\"nsec\", key);\n}\nfunction npubEncode(hex) {\n  return encodeBytes(\"npub\", (0, import_utils5.hexToBytes)(hex));\n}\nfunction noteEncode(hex) {\n  return encodeBytes(\"note\", (0, import_utils5.hexToBytes)(hex));\n}\nfunction encodeBech32(prefix, data) {\n  let words = import_base.bech32.toWords(data);\n  return import_base.bech32.encode(prefix, words, Bech32MaxSize);\n}\nfunction encodeBytes(prefix, bytes) {\n  return encodeBech32(prefix, bytes);\n}\nfunction nprofileEncode(profile) {\n  let data = encodeTLV({\n    0: [(0, import_utils5.hexToBytes)(profile.pubkey)],\n    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))\n  });\n  return encodeBech32(\"nprofile\", data);\n}\nfunction neventEncode(event) {\n  let kindArray;\n  if (event.kind !== void 0) {\n    kindArray = integerToUint8Array(event.kind);\n  }\n  let data = encodeTLV({\n    0: [(0, import_utils5.hexToBytes)(event.id)],\n    1: (event.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: event.author ? [(0, import_utils5.hexToBytes)(event.author)] : [],\n    3: kindArray ? [new Uint8Array(kindArray)] : []\n  });\n  return encodeBech32(\"nevent\", data);\n}\nfunction naddrEncode(addr) {\n  let kind = new ArrayBuffer(4);\n  new DataView(kind).setUint32(0, addr.kind, false);\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: [(0, import_utils5.hexToBytes)(addr.pubkey)],\n    3: [new Uint8Array(kind)]\n  });\n  return encodeBech32(\"naddr\", data);\n}\nfunction encodeTLV(tlv) {\n  let entries = [];\n  Object.entries(tlv).reverse().forEach(([t, vs]) => {\n    vs.forEach((v) => {\n      let entry = new Uint8Array(v.length + 2);\n      entry.set([parseInt(t)], 0);\n      entry.set([v.length], 1);\n      entry.set(v, 2);\n      entries.push(entry);\n    });\n  });\n  return (0, import_utils5.concatBytes)(...entries);\n}\n\n// references.ts\nvar mentionRegex = /\\bnostr:((note|npub|naddr|nevent|nprofile)1\\w+)\\b|#\\[(\\d+)\\]/g;\nfunction parseReferences(evt) {\n  let references = [];\n  for (let ref of evt.content.matchAll(mentionRegex)) {\n    if (ref[2]) {\n      try {\n        let { type, data } = decode(ref[1]);\n        switch (type) {\n          case \"npub\": {\n            references.push({\n              text: ref[0],\n              profile: { pubkey: data, relays: [] }\n            });\n            break;\n          }\n          case \"nprofile\": {\n            references.push({\n              text: ref[0],\n              profile: data\n            });\n            break;\n          }\n          case \"note\": {\n            references.push({\n              text: ref[0],\n              event: { id: data, relays: [] }\n            });\n            break;\n          }\n          case \"nevent\": {\n            references.push({\n              text: ref[0],\n              event: data\n            });\n            break;\n          }\n          case \"naddr\": {\n            references.push({\n              text: ref[0],\n              address: data\n            });\n            break;\n          }\n        }\n      } catch (err) {\n      }\n    } else if (ref[3]) {\n      let idx = parseInt(ref[3], 10);\n      let tag = evt.tags[idx];\n      if (!tag)\n        continue;\n      switch (tag[0]) {\n        case \"p\": {\n          references.push({\n            text: ref[0],\n            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"e\": {\n          references.push({\n            text: ref[0],\n            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"a\": {\n          try {\n            let [kind, pubkey, identifier] = tag[1].split(\":\");\n            references.push({\n              text: ref[0],\n              address: {\n                identifier,\n                pubkey,\n                kind: parseInt(kind, 10),\n                relays: tag[2] ? [tag[2]] : []\n              }\n            });\n          } catch (err) {\n          }\n          break;\n        }\n      }\n    }\n  }\n  return references;\n}\n\n// nip04.ts\nvar nip04_exports = {};\n__export(nip04_exports, {\n  decrypt: () => decrypt,\n  encrypt: () => encrypt\n});\nvar import_utils7 = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/utils.js\");\nvar import_secp256k12 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/secp256k1.js\");\nvar import_aes = __webpack_require__(/*! @noble/ciphers/aes */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/aes.js\");\nvar import_base2 = __webpack_require__(/*! @scure/base */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@scure/base/lib/index.js\");\nfunction encrypt(secretKey, pubkey, text) {\n  const privkey = secretKey instanceof Uint8Array ? (0, import_utils7.bytesToHex)(secretKey) : secretKey;\n  const key = import_secp256k12.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  const normalizedKey = getNormalizedX(key);\n  let iv = Uint8Array.from((0, import_utils7.randomBytes)(16));\n  let plaintext = utf8Encoder.encode(text);\n  let ciphertext = (0, import_aes.cbc)(normalizedKey, iv).encrypt(plaintext);\n  let ctb64 = import_base2.base64.encode(new Uint8Array(ciphertext));\n  let ivb64 = import_base2.base64.encode(new Uint8Array(iv.buffer));\n  return `${ctb64}?iv=${ivb64}`;\n}\nfunction decrypt(secretKey, pubkey, data) {\n  const privkey = secretKey instanceof Uint8Array ? (0, import_utils7.bytesToHex)(secretKey) : secretKey;\n  let [ctb64, ivb64] = data.split(\"?iv=\");\n  let key = import_secp256k12.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  let normalizedKey = getNormalizedX(key);\n  let iv = import_base2.base64.decode(ivb64);\n  let ciphertext = import_base2.base64.decode(ctb64);\n  let plaintext = (0, import_aes.cbc)(normalizedKey, iv).decrypt(ciphertext);\n  return utf8Decoder.decode(plaintext);\n}\nfunction getNormalizedX(key) {\n  return key.slice(1, 33);\n}\n\n// nip05.ts\nvar nip05_exports = {};\n__export(nip05_exports, {\n  NIP05_REGEX: () => NIP05_REGEX,\n  isNip05: () => isNip05,\n  isValid: () => isValid,\n  queryProfile: () => queryProfile,\n  searchDomain: () => searchDomain,\n  useFetchImplementation: () => useFetchImplementation\n});\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w_-]+(\\.[\\w_-]+)+)$/;\nvar isNip05 = (value) => NIP05_REGEX.test(value || \"\");\nvar _fetch;\ntry {\n  _fetch = fetch;\n} catch (_) {\n  null;\n}\nfunction useFetchImplementation(fetchImplementation) {\n  _fetch = fetchImplementation;\n}\nasync function searchDomain(domain, query = \"\") {\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${query}`;\n    const res = await _fetch(url, { redirect: \"manual\" });\n    if (res.status !== 200) {\n      throw Error(\"Wrong response code\");\n    }\n    const json = await res.json();\n    return json.names;\n  } catch (_) {\n    return {};\n  }\n}\nasync function queryProfile(fullname) {\n  const match = fullname.match(NIP05_REGEX);\n  if (!match)\n    return null;\n  const [, name = \"_\", domain] = match;\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${name}`;\n    const res = await _fetch(url, { redirect: \"manual\" });\n    if (res.status !== 200) {\n      throw Error(\"Wrong response code\");\n    }\n    const json = await res.json();\n    const pubkey = json.names[name];\n    return pubkey ? { pubkey, relays: json.relays?.[pubkey] } : null;\n  } catch (_e) {\n    return null;\n  }\n}\nasync function isValid(pubkey, nip05) {\n  const res = await queryProfile(nip05);\n  return res ? res.pubkey === pubkey : false;\n}\n\n// nip10.ts\nvar nip10_exports = {};\n__export(nip10_exports, {\n  parse: () => parse\n});\nfunction parse(event) {\n  const result = {\n    reply: void 0,\n    root: void 0,\n    mentions: [],\n    profiles: [],\n    quotes: []\n  };\n  let maybeParent;\n  let maybeRoot;\n  for (let i2 = event.tags.length - 1; i2 >= 0; i2--) {\n    const tag = event.tags[i2];\n    if (tag[0] === \"e\" && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl, eTagMarker, eTagAuthor] = tag;\n      const eventPointer = {\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : [],\n        author: eTagAuthor\n      };\n      if (eTagMarker === \"root\") {\n        result.root = eventPointer;\n        continue;\n      }\n      if (eTagMarker === \"reply\") {\n        result.reply = eventPointer;\n        continue;\n      }\n      if (eTagMarker === \"mention\") {\n        result.mentions.push(eventPointer);\n        continue;\n      }\n      if (!maybeParent) {\n        maybeParent = eventPointer;\n      } else {\n        maybeRoot = eventPointer;\n      }\n      result.mentions.push(eventPointer);\n      continue;\n    }\n    if (tag[0] === \"q\" && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl] = tag;\n      result.quotes.push({\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : []\n      });\n    }\n    if (tag[0] === \"p\" && tag[1]) {\n      result.profiles.push({\n        pubkey: tag[1],\n        relays: tag[2] ? [tag[2]] : []\n      });\n      continue;\n    }\n  }\n  if (!result.root) {\n    result.root = maybeRoot || maybeParent || result.reply;\n  }\n  if (!result.reply) {\n    result.reply = maybeParent || result.root;\n  }\n  ;\n  [result.reply, result.root].forEach((ref) => {\n    if (!ref)\n      return;\n    let idx = result.mentions.indexOf(ref);\n    if (idx !== -1) {\n      result.mentions.splice(idx, 1);\n    }\n    if (ref.author) {\n      let author = result.profiles.find((p) => p.pubkey === ref.author);\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = [];\n        }\n        author.relays.forEach((url) => {\n          if (ref.relays?.indexOf(url) === -1)\n            ref.relays.push(url);\n        });\n        author.relays = ref.relays;\n      }\n    }\n  });\n  result.mentions.forEach((ref) => {\n    if (ref.author) {\n      let author = result.profiles.find((p) => p.pubkey === ref.author);\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = [];\n        }\n        author.relays.forEach((url) => {\n          if (ref.relays.indexOf(url) === -1)\n            ref.relays.push(url);\n        });\n        author.relays = ref.relays;\n      }\n    }\n  });\n  return result;\n}\n\n// nip11.ts\nvar nip11_exports = {};\n__export(nip11_exports, {\n  fetchRelayInformation: () => fetchRelayInformation,\n  useFetchImplementation: () => useFetchImplementation2\n});\nvar _fetch2;\ntry {\n  _fetch2 = fetch;\n} catch {\n}\nfunction useFetchImplementation2(fetchImplementation) {\n  _fetch2 = fetchImplementation;\n}\nasync function fetchRelayInformation(url) {\n  return await (await fetch(url.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\"), {\n    headers: { Accept: \"application/nostr+json\" }\n  })).json();\n}\n\n// nip13.ts\nvar nip13_exports = {};\n__export(nip13_exports, {\n  fastEventHash: () => fastEventHash,\n  getPow: () => getPow,\n  minePow: () => minePow\n});\nvar import_utils9 = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/utils.js\");\nvar import_sha2562 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/sha256.js\");\nfunction getPow(hex) {\n  let count = 0;\n  for (let i2 = 0; i2 < 64; i2 += 8) {\n    const nibble = parseInt(hex.substring(i2, i2 + 8), 16);\n    if (nibble === 0) {\n      count += 32;\n    } else {\n      count += Math.clz32(nibble);\n      break;\n    }\n  }\n  return count;\n}\nfunction minePow(unsigned, difficulty) {\n  let count = 0;\n  const event = unsigned;\n  const tag = [\"nonce\", count.toString(), difficulty.toString()];\n  event.tags.push(tag);\n  while (true) {\n    const now2 = Math.floor(new Date().getTime() / 1e3);\n    if (now2 !== event.created_at) {\n      count = 0;\n      event.created_at = now2;\n    }\n    tag[1] = (++count).toString();\n    event.id = fastEventHash(event);\n    if (getPow(event.id) >= difficulty) {\n      break;\n    }\n  }\n  return event;\n}\nfunction fastEventHash(evt) {\n  return (0, import_utils9.bytesToHex)(\n    (0, import_sha2562.sha256)(utf8Encoder.encode(JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])))\n  );\n}\n\n// nip17.ts\nvar nip17_exports = {};\n__export(nip17_exports, {\n  unwrapEvent: () => unwrapEvent2,\n  unwrapManyEvents: () => unwrapManyEvents2,\n  wrapEvent: () => wrapEvent2,\n  wrapManyEvents: () => wrapManyEvents2\n});\n\n// nip59.ts\nvar nip59_exports = {};\n__export(nip59_exports, {\n  createRumor: () => createRumor,\n  createSeal: () => createSeal,\n  createWrap: () => createWrap,\n  unwrapEvent: () => unwrapEvent,\n  unwrapManyEvents: () => unwrapManyEvents,\n  wrapEvent: () => wrapEvent,\n  wrapManyEvents: () => wrapManyEvents\n});\n\n// nip44.ts\nvar nip44_exports = {};\n__export(nip44_exports, {\n  decrypt: () => decrypt2,\n  encrypt: () => encrypt2,\n  getConversationKey: () => getConversationKey,\n  v2: () => v2\n});\nvar import_chacha = __webpack_require__(/*! @noble/ciphers/chacha */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/chacha.js\");\nvar import_utils11 = __webpack_require__(/*! @noble/ciphers/utils */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/utils.js\");\nvar import_secp256k13 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/secp256k1.js\");\nvar import_hkdf = __webpack_require__(/*! @noble/hashes/hkdf */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/hkdf.js\");\nvar import_hmac = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/hmac.js\");\nvar import_sha2563 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/sha256.js\");\nvar import_utils12 = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/utils.js\");\nvar import_base3 = __webpack_require__(/*! @scure/base */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@scure/base/lib/index.js\");\nvar minPlaintextSize = 1;\nvar maxPlaintextSize = 65535;\nfunction getConversationKey(privkeyA, pubkeyB) {\n  const sharedX = import_secp256k13.secp256k1.getSharedSecret(privkeyA, \"02\" + pubkeyB).subarray(1, 33);\n  return (0, import_hkdf.extract)(import_sha2563.sha256, sharedX, \"nip44-v2\");\n}\nfunction getMessageKeys(conversationKey, nonce) {\n  const keys = (0, import_hkdf.expand)(import_sha2563.sha256, conversationKey, nonce, 76);\n  return {\n    chacha_key: keys.subarray(0, 32),\n    chacha_nonce: keys.subarray(32, 44),\n    hmac_key: keys.subarray(44, 76)\n  };\n}\nfunction calcPaddedLen(len) {\n  if (!Number.isSafeInteger(len) || len < 1)\n    throw new Error(\"expected positive integer\");\n  if (len <= 32)\n    return 32;\n  const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;\n  const chunk = nextPower <= 256 ? 32 : nextPower / 8;\n  return chunk * (Math.floor((len - 1) / chunk) + 1);\n}\nfunction writeU16BE(num) {\n  if (!Number.isSafeInteger(num) || num < minPlaintextSize || num > maxPlaintextSize)\n    throw new Error(\"invalid plaintext size: must be between 1 and 65535 bytes\");\n  const arr = new Uint8Array(2);\n  new DataView(arr.buffer).setUint16(0, num, false);\n  return arr;\n}\nfunction pad(plaintext) {\n  const unpadded = utf8Encoder.encode(plaintext);\n  const unpaddedLen = unpadded.length;\n  const prefix = writeU16BE(unpaddedLen);\n  const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen);\n  return (0, import_utils12.concatBytes)(prefix, unpadded, suffix);\n}\nfunction unpad(padded) {\n  const unpaddedLen = new DataView(padded.buffer).getUint16(0);\n  const unpadded = padded.subarray(2, 2 + unpaddedLen);\n  if (unpaddedLen < minPlaintextSize || unpaddedLen > maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen(unpaddedLen))\n    throw new Error(\"invalid padding\");\n  return utf8Decoder.decode(unpadded);\n}\nfunction hmacAad(key, message, aad) {\n  if (aad.length !== 32)\n    throw new Error(\"AAD associated data must be 32 bytes\");\n  const combined = (0, import_utils12.concatBytes)(aad, message);\n  return (0, import_hmac.hmac)(import_sha2563.sha256, key, combined);\n}\nfunction decodePayload(payload) {\n  if (typeof payload !== \"string\")\n    throw new Error(\"payload must be a valid string\");\n  const plen = payload.length;\n  if (plen < 132 || plen > 87472)\n    throw new Error(\"invalid payload length: \" + plen);\n  if (payload[0] === \"#\")\n    throw new Error(\"unknown encryption version\");\n  let data;\n  try {\n    data = import_base3.base64.decode(payload);\n  } catch (error) {\n    throw new Error(\"invalid base64: \" + error.message);\n  }\n  const dlen = data.length;\n  if (dlen < 99 || dlen > 65603)\n    throw new Error(\"invalid data length: \" + dlen);\n  const vers = data[0];\n  if (vers !== 2)\n    throw new Error(\"unknown encryption version \" + vers);\n  return {\n    nonce: data.subarray(1, 33),\n    ciphertext: data.subarray(33, -32),\n    mac: data.subarray(-32)\n  };\n}\nfunction encrypt2(plaintext, conversationKey, nonce = (0, import_utils12.randomBytes)(32)) {\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const padded = pad(plaintext);\n  const ciphertext = (0, import_chacha.chacha20)(chacha_key, chacha_nonce, padded);\n  const mac = hmacAad(hmac_key, ciphertext, nonce);\n  return import_base3.base64.encode((0, import_utils12.concatBytes)(new Uint8Array([2]), nonce, ciphertext, mac));\n}\nfunction decrypt2(payload, conversationKey) {\n  const { nonce, ciphertext, mac } = decodePayload(payload);\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const calculatedMac = hmacAad(hmac_key, ciphertext, nonce);\n  if (!(0, import_utils11.equalBytes)(calculatedMac, mac))\n    throw new Error(\"invalid MAC\");\n  const padded = (0, import_chacha.chacha20)(chacha_key, chacha_nonce, ciphertext);\n  return unpad(padded);\n}\nvar v2 = {\n  utils: {\n    getConversationKey,\n    calcPaddedLen\n  },\n  encrypt: encrypt2,\n  decrypt: decrypt2\n};\n\n// nip59.ts\nvar TWO_DAYS = 2 * 24 * 60 * 60;\nvar now = () => Math.round(Date.now() / 1e3);\nvar randomNow = () => Math.round(now() - Math.random() * TWO_DAYS);\nvar nip44ConversationKey = (privateKey, publicKey) => getConversationKey(privateKey, publicKey);\nvar nip44Encrypt = (data, privateKey, publicKey) => encrypt2(JSON.stringify(data), nip44ConversationKey(privateKey, publicKey));\nvar nip44Decrypt = (data, privateKey) => JSON.parse(decrypt2(data.content, nip44ConversationKey(privateKey, data.pubkey)));\nfunction createRumor(event, privateKey) {\n  const rumor = {\n    created_at: now(),\n    content: \"\",\n    tags: [],\n    ...event,\n    pubkey: getPublicKey(privateKey)\n  };\n  rumor.id = getEventHash(rumor);\n  return rumor;\n}\nfunction createSeal(rumor, privateKey, recipientPublicKey) {\n  return finalizeEvent(\n    {\n      kind: Seal,\n      content: nip44Encrypt(rumor, privateKey, recipientPublicKey),\n      created_at: randomNow(),\n      tags: []\n    },\n    privateKey\n  );\n}\nfunction createWrap(seal, recipientPublicKey) {\n  const randomKey = generateSecretKey();\n  return finalizeEvent(\n    {\n      kind: GiftWrap,\n      content: nip44Encrypt(seal, randomKey, recipientPublicKey),\n      created_at: randomNow(),\n      tags: [[\"p\", recipientPublicKey]]\n    },\n    randomKey\n  );\n}\nfunction wrapEvent(event, senderPrivateKey, recipientPublicKey) {\n  const rumor = createRumor(event, senderPrivateKey);\n  const seal = createSeal(rumor, senderPrivateKey, recipientPublicKey);\n  return createWrap(seal, recipientPublicKey);\n}\nfunction wrapManyEvents(event, senderPrivateKey, recipientsPublicKeys) {\n  if (!recipientsPublicKeys || recipientsPublicKeys.length === 0) {\n    throw new Error(\"At least one recipient is required.\");\n  }\n  const senderPublicKey = getPublicKey(senderPrivateKey);\n  const wrappeds = [wrapEvent(event, senderPrivateKey, senderPublicKey)];\n  recipientsPublicKeys.forEach((recipientPublicKey) => {\n    wrappeds.push(wrapEvent(event, senderPrivateKey, recipientPublicKey));\n  });\n  return wrappeds;\n}\nfunction unwrapEvent(wrap, recipientPrivateKey) {\n  const unwrappedSeal = nip44Decrypt(wrap, recipientPrivateKey);\n  return nip44Decrypt(unwrappedSeal, recipientPrivateKey);\n}\nfunction unwrapManyEvents(wrappedEvents, recipientPrivateKey) {\n  let unwrappedEvents = [];\n  wrappedEvents.forEach((e) => {\n    unwrappedEvents.push(unwrapEvent(e, recipientPrivateKey));\n  });\n  unwrappedEvents.sort((a, b) => a.created_at - b.created_at);\n  return unwrappedEvents;\n}\n\n// nip17.ts\nfunction createEvent(recipients, message, conversationTitle, replyTo) {\n  const baseEvent = {\n    created_at: Math.ceil(Date.now() / 1e3),\n    kind: PrivateDirectMessage,\n    tags: [],\n    content: message\n  };\n  const recipientsArray = Array.isArray(recipients) ? recipients : [recipients];\n  recipientsArray.forEach(({ publicKey, relayUrl }) => {\n    baseEvent.tags.push(relayUrl ? [\"p\", publicKey, relayUrl] : [\"p\", publicKey]);\n  });\n  if (replyTo) {\n    baseEvent.tags.push([\"e\", replyTo.eventId, replyTo.relayUrl || \"\", \"reply\"]);\n  }\n  if (conversationTitle) {\n    baseEvent.tags.push([\"subject\", conversationTitle]);\n  }\n  return baseEvent;\n}\nfunction wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo) {\n  const event = createEvent(recipient, message, conversationTitle, replyTo);\n  return wrapEvent(event, senderPrivateKey, recipient.publicKey);\n}\nfunction wrapManyEvents2(senderPrivateKey, recipients, message, conversationTitle, replyTo) {\n  if (!recipients || recipients.length === 0) {\n    throw new Error(\"At least one recipient is required.\");\n  }\n  const senderPublicKey = getPublicKey(senderPrivateKey);\n  return [{ publicKey: senderPublicKey }, ...recipients].map(\n    (recipient) => wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo)\n  );\n}\nvar unwrapEvent2 = unwrapEvent;\nvar unwrapManyEvents2 = unwrapManyEvents;\n\n// nip18.ts\nvar nip18_exports = {};\n__export(nip18_exports, {\n  finishRepostEvent: () => finishRepostEvent,\n  getRepostedEvent: () => getRepostedEvent,\n  getRepostedEventPointer: () => getRepostedEventPointer\n});\nfunction finishRepostEvent(t, reposted, relayUrl, privateKey) {\n  let kind;\n  const tags = [...t.tags ?? [], [\"e\", reposted.id, relayUrl], [\"p\", reposted.pubkey]];\n  if (reposted.kind === ShortTextNote) {\n    kind = Repost;\n  } else {\n    kind = GenericRepost;\n    tags.push([\"k\", String(reposted.kind)]);\n  }\n  return finalizeEvent(\n    {\n      kind,\n      tags,\n      content: t.content === \"\" || reposted.tags?.find((tag) => tag[0] === \"-\") ? \"\" : JSON.stringify(reposted),\n      created_at: t.created_at\n    },\n    privateKey\n  );\n}\nfunction getRepostedEventPointer(event) {\n  if (![Repost, GenericRepost].includes(event.kind)) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag?.[2]].filter((x) => typeof x === \"string\"),\n    author: lastPTag?.[1]\n  };\n}\nfunction getRepostedEvent(event, { skipVerification } = {}) {\n  const pointer = getRepostedEventPointer(event);\n  if (pointer === void 0 || event.content === \"\") {\n    return void 0;\n  }\n  let repostedEvent;\n  try {\n    repostedEvent = JSON.parse(event.content);\n  } catch (error) {\n    return void 0;\n  }\n  if (repostedEvent.id !== pointer.id) {\n    return void 0;\n  }\n  if (!skipVerification && !verifyEvent(repostedEvent)) {\n    return void 0;\n  }\n  return repostedEvent;\n}\n\n// nip21.ts\nvar nip21_exports = {};\n__export(nip21_exports, {\n  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,\n  parse: () => parse2,\n  test: () => test\n});\nvar NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);\nfunction test(value) {\n  return typeof value === \"string\" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);\n}\nfunction parse2(uri) {\n  const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));\n  if (!match)\n    throw new Error(`Invalid Nostr URI: ${uri}`);\n  return {\n    uri: match[0],\n    value: match[1],\n    decoded: decode(match[1])\n  };\n}\n\n// nip25.ts\nvar nip25_exports = {};\n__export(nip25_exports, {\n  finishReactionEvent: () => finishReactionEvent,\n  getReactedEventPointer: () => getReactedEventPointer\n});\nfunction finishReactionEvent(t, reacted, privateKey) {\n  const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === \"e\" || tag[0] === \"p\"));\n  return finalizeEvent(\n    {\n      ...t,\n      kind: Reaction,\n      tags: [...t.tags ?? [], ...inheritedTags, [\"e\", reacted.id], [\"p\", reacted.pubkey]],\n      content: t.content ?? \"+\"\n    },\n    privateKey\n  );\n}\nfunction getReactedEventPointer(event) {\n  if (event.kind !== Reaction) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0 || lastPTag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag[2]].filter((x) => x !== void 0),\n    author: lastPTag[1]\n  };\n}\n\n// nip27.ts\nvar nip27_exports = {};\n__export(nip27_exports, {\n  parse: () => parse3\n});\nvar noCharacter = /\\W/m;\nvar noURLCharacter = /\\W |\\W$|$|,| /m;\nfunction* parse3(content) {\n  const max = content.length;\n  let prevIndex = 0;\n  let index = 0;\n  while (index < max) {\n    let u = content.indexOf(\":\", index);\n    if (u === -1) {\n      break;\n    }\n    if (content.substring(u - 5, u) === \"nostr\") {\n      const m = content.substring(u + 60).match(noCharacter);\n      const end = m ? u + 60 + m.index : max;\n      try {\n        let pointer;\n        let { data, type } = decode(content.substring(u + 1, end));\n        switch (type) {\n          case \"npub\":\n            pointer = { pubkey: data };\n            break;\n          case \"nsec\":\n          case \"note\":\n            index = end + 1;\n            continue;\n          default:\n            pointer = data;\n        }\n        if (prevIndex !== u - 5) {\n          yield { type: \"text\", text: content.substring(prevIndex, u - 5) };\n        }\n        yield { type: \"reference\", pointer };\n        index = end;\n        prevIndex = index;\n        continue;\n      } catch (_err) {\n        index = u + 1;\n        continue;\n      }\n    } else if (content.substring(u - 5, u) === \"https\" || content.substring(u - 4, u) === \"http\") {\n      const m = content.substring(u + 4).match(noURLCharacter);\n      const end = m ? u + 4 + m.index : max;\n      const prefixLen = content[u - 1] === \"s\" ? 5 : 4;\n      try {\n        let url = new URL(content.substring(u - prefixLen, end));\n        if (url.hostname.indexOf(\".\") === -1) {\n          throw new Error(\"invalid url\");\n        }\n        if (prevIndex !== u - prefixLen) {\n          yield { type: \"text\", text: content.substring(prevIndex, u - prefixLen) };\n        }\n        if (url.pathname.endsWith(\".png\") || url.pathname.endsWith(\".jpg\") || url.pathname.endsWith(\".jpeg\") || url.pathname.endsWith(\".gif\") || url.pathname.endsWith(\".webp\")) {\n          yield { type: \"image\", url: url.toString() };\n          index = end;\n          prevIndex = index;\n          continue;\n        }\n        if (url.pathname.endsWith(\".mp4\") || url.pathname.endsWith(\".avi\") || url.pathname.endsWith(\".webm\") || url.pathname.endsWith(\".mkv\")) {\n          yield { type: \"video\", url: url.toString() };\n          index = end;\n          prevIndex = index;\n          continue;\n        }\n        if (url.pathname.endsWith(\".mp3\") || url.pathname.endsWith(\".aac\") || url.pathname.endsWith(\".ogg\") || url.pathname.endsWith(\".opus\")) {\n          yield { type: \"audio\", url: url.toString() };\n          index = end;\n          prevIndex = index;\n          continue;\n        }\n        yield { type: \"url\", url: url.toString() };\n        index = end;\n        prevIndex = index;\n        continue;\n      } catch (_err) {\n        index = end + 1;\n        continue;\n      }\n    } else if (content.substring(u - 3, u) === \"wss\" || content.substring(u - 2, u) === \"ws\") {\n      const m = content.substring(u + 4).match(noURLCharacter);\n      const end = m ? u + 4 + m.index : max;\n      const prefixLen = content[u - 1] === \"s\" ? 3 : 2;\n      try {\n        let url = new URL(content.substring(u - prefixLen, end));\n        if (url.hostname.indexOf(\".\") === -1) {\n          throw new Error(\"invalid ws url\");\n        }\n        if (prevIndex !== u - prefixLen) {\n          yield { type: \"text\", text: content.substring(prevIndex, u - prefixLen) };\n        }\n        yield { type: \"relay\", url: url.toString() };\n        index = end;\n        prevIndex = index;\n        continue;\n      } catch (_err) {\n        index = end + 1;\n        continue;\n      }\n    } else {\n      index = u + 1;\n      continue;\n    }\n  }\n  if (prevIndex !== max) {\n    yield { type: \"text\", text: content.substring(prevIndex) };\n  }\n}\n\n// nip28.ts\nvar nip28_exports = {};\n__export(nip28_exports, {\n  channelCreateEvent: () => channelCreateEvent,\n  channelHideMessageEvent: () => channelHideMessageEvent,\n  channelMessageEvent: () => channelMessageEvent,\n  channelMetadataEvent: () => channelMetadataEvent,\n  channelMuteUserEvent: () => channelMuteUserEvent\n});\nvar channelCreateEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelCreation,\n      tags: [...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMetadataEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMetadata,\n      tags: [[\"e\", t.channel_create_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMessageEvent = (t, privateKey) => {\n  const tags = [[\"e\", t.channel_create_event_id, t.relay_url, \"root\"]];\n  if (t.reply_to_channel_message_event_id) {\n    tags.push([\"e\", t.reply_to_channel_message_event_id, t.relay_url, \"reply\"]);\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMessage,\n      tags: [...tags, ...t.tags ?? []],\n      content: t.content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelHideMessageEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelHideMessage,\n      tags: [[\"e\", t.channel_message_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMuteUserEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMuteUser,\n      tags: [[\"p\", t.pubkey_to_mute], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\n\n// nip30.ts\nvar nip30_exports = {};\n__export(nip30_exports, {\n  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,\n  matchAll: () => matchAll,\n  regex: () => regex,\n  replaceAll: () => replaceAll\n});\nvar EMOJI_SHORTCODE_REGEX = /:(\\w+):/;\nvar regex = () => new RegExp(`\\\\B${EMOJI_SHORTCODE_REGEX.source}\\\\B`, \"g\");\nfunction* matchAll(content) {\n  const matches = content.matchAll(regex());\n  for (const match of matches) {\n    try {\n      const [shortcode, name] = match;\n      yield {\n        shortcode,\n        name,\n        start: match.index,\n        end: match.index + shortcode.length\n      };\n    } catch (_e) {\n    }\n  }\n}\nfunction replaceAll(content, replacer) {\n  return content.replaceAll(regex(), (shortcode, name) => {\n    return replacer({\n      shortcode,\n      name\n    });\n  });\n}\n\n// nip39.ts\nvar nip39_exports = {};\n__export(nip39_exports, {\n  useFetchImplementation: () => useFetchImplementation3,\n  validateGithub: () => validateGithub\n});\nvar _fetch3;\ntry {\n  _fetch3 = fetch;\n} catch {\n}\nfunction useFetchImplementation3(fetchImplementation) {\n  _fetch3 = fetchImplementation;\n}\nasync function validateGithub(pubkey, username, proof) {\n  try {\n    let res = await (await _fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();\n    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;\n  } catch (_) {\n    return false;\n  }\n}\n\n// nip47.ts\nvar nip47_exports = {};\n__export(nip47_exports, {\n  makeNwcRequestEvent: () => makeNwcRequestEvent,\n  parseConnectionString: () => parseConnectionString\n});\nfunction parseConnectionString(connectionString) {\n  const { pathname, searchParams } = new URL(connectionString);\n  const pubkey = pathname;\n  const relay = searchParams.get(\"relay\");\n  const secret = searchParams.get(\"secret\");\n  if (!pubkey || !relay || !secret) {\n    throw new Error(\"invalid connection string\");\n  }\n  return { pubkey, relay, secret };\n}\nasync function makeNwcRequestEvent(pubkey, secretKey, invoice) {\n  const content = {\n    method: \"pay_invoice\",\n    params: {\n      invoice\n    }\n  };\n  const encryptedContent = await encrypt(secretKey, pubkey, JSON.stringify(content));\n  const eventTemplate = {\n    kind: NWCWalletRequest,\n    created_at: Math.round(Date.now() / 1e3),\n    content: encryptedContent,\n    tags: [[\"p\", pubkey]]\n  };\n  return finalizeEvent(eventTemplate, secretKey);\n}\n\n// nip54.ts\nvar nip54_exports = {};\n__export(nip54_exports, {\n  normalizeIdentifier: () => normalizeIdentifier\n});\nfunction normalizeIdentifier(name) {\n  name = name.trim().toLowerCase();\n  name = name.normalize(\"NFKC\");\n  return Array.from(name).map((char) => {\n    if (/\\p{Letter}/u.test(char) || /\\p{Number}/u.test(char)) {\n      return char;\n    }\n    return \"-\";\n  }).join(\"\");\n}\n\n// nip57.ts\nvar nip57_exports = {};\n__export(nip57_exports, {\n  getZapEndpoint: () => getZapEndpoint,\n  makeZapReceipt: () => makeZapReceipt,\n  makeZapRequest: () => makeZapRequest,\n  useFetchImplementation: () => useFetchImplementation4,\n  validateZapRequest: () => validateZapRequest\n});\nvar import_base4 = __webpack_require__(/*! @scure/base */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@scure/base/lib/index.js\");\nvar _fetch4;\ntry {\n  _fetch4 = fetch;\n} catch {\n}\nfunction useFetchImplementation4(fetchImplementation) {\n  _fetch4 = fetchImplementation;\n}\nasync function getZapEndpoint(metadata) {\n  try {\n    let lnurl = \"\";\n    let { lud06, lud16 } = JSON.parse(metadata.content);\n    if (lud06) {\n      let { words } = import_base4.bech32.decode(lud06, 1e3);\n      let data = import_base4.bech32.fromWords(words);\n      lnurl = utf8Decoder.decode(data);\n    } else if (lud16) {\n      let [name, domain] = lud16.split(\"@\");\n      lnurl = new URL(`/.well-known/lnurlp/${name}`, `https://${domain}`).toString();\n    } else {\n      return null;\n    }\n    let res = await _fetch4(lnurl);\n    let body = await res.json();\n    if (body.allowsNostr && body.nostrPubkey) {\n      return body.callback;\n    }\n  } catch (err) {\n  }\n  return null;\n}\nfunction makeZapRequest({\n  profile,\n  event,\n  amount,\n  relays,\n  comment = \"\"\n}) {\n  if (!amount)\n    throw new Error(\"amount not given\");\n  if (!profile)\n    throw new Error(\"profile not given\");\n  let zr = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1e3),\n    content: comment,\n    tags: [\n      [\"p\", profile],\n      [\"amount\", amount.toString()],\n      [\"relays\", ...relays]\n    ]\n  };\n  if (event && typeof event === \"string\") {\n    zr.tags.push([\"e\", event]);\n  }\n  if (event && typeof event === \"object\") {\n    if (isReplaceableKind(event.kind)) {\n      const a = [\"a\", `${event.kind}:${event.pubkey}:`];\n      zr.tags.push(a);\n    } else if (isAddressableKind(event.kind)) {\n      let d = event.tags.find(([t, v]) => t === \"d\" && v);\n      if (!d)\n        throw new Error(\"d tag not found or is empty\");\n      const a = [\"a\", `${event.kind}:${event.pubkey}:${d[1]}`];\n      zr.tags.push(a);\n    }\n  }\n  return zr;\n}\nfunction validateZapRequest(zapRequestString) {\n  let zapRequest;\n  try {\n    zapRequest = JSON.parse(zapRequestString);\n  } catch (err) {\n    return \"Invalid zap request JSON.\";\n  }\n  if (!validateEvent(zapRequest))\n    return \"Zap request is not a valid Nostr event.\";\n  if (!verifyEvent(zapRequest))\n    return \"Invalid signature on zap request.\";\n  let p = zapRequest.tags.find(([t, v]) => t === \"p\" && v);\n  if (!p)\n    return \"Zap request doesn't have a 'p' tag.\";\n  if (!p[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'p' tag is not valid hex.\";\n  let e = zapRequest.tags.find(([t, v]) => t === \"e\" && v);\n  if (e && !e[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'e' tag is not valid hex.\";\n  let relays = zapRequest.tags.find(([t, v]) => t === \"relays\" && v);\n  if (!relays)\n    return \"Zap request doesn't have a 'relays' tag.\";\n  return null;\n}\nfunction makeZapReceipt({\n  zapRequest,\n  preimage,\n  bolt11,\n  paidAt\n}) {\n  let zr = JSON.parse(zapRequest);\n  let tagsFromZapRequest = zr.tags.filter(([t]) => t === \"e\" || t === \"p\" || t === \"a\");\n  let zap = {\n    kind: 9735,\n    created_at: Math.round(paidAt.getTime() / 1e3),\n    content: \"\",\n    tags: [...tagsFromZapRequest, [\"P\", zr.pubkey], [\"bolt11\", bolt11], [\"description\", zapRequest]]\n  };\n  if (preimage) {\n    zap.tags.push([\"preimage\", preimage]);\n  }\n  return zap;\n}\n\n// nip98.ts\nvar nip98_exports = {};\n__export(nip98_exports, {\n  getToken: () => getToken,\n  hashPayload: () => hashPayload,\n  unpackEventFromToken: () => unpackEventFromToken,\n  validateEvent: () => validateEvent2,\n  validateEventKind: () => validateEventKind,\n  validateEventMethodTag: () => validateEventMethodTag,\n  validateEventPayloadTag: () => validateEventPayloadTag,\n  validateEventTimestamp: () => validateEventTimestamp,\n  validateEventUrlTag: () => validateEventUrlTag,\n  validateToken: () => validateToken\n});\nvar import_sha2564 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/sha256.js\");\nvar import_utils15 = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/utils.js\");\nvar import_base5 = __webpack_require__(/*! @scure/base */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@scure/base/lib/index.js\");\nvar _authorizationScheme = \"Nostr \";\nasync function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false, payload) {\n  const event = {\n    kind: HTTPAuth,\n    tags: [\n      [\"u\", loginUrl],\n      [\"method\", httpMethod]\n    ],\n    created_at: Math.round(new Date().getTime() / 1e3),\n    content: \"\"\n  };\n  if (payload) {\n    event.tags.push([\"payload\", hashPayload(payload)]);\n  }\n  const signedEvent = await sign(event);\n  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : \"\";\n  return authorizationScheme + import_base5.base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));\n}\nasync function validateToken(token, url, method) {\n  const event = await unpackEventFromToken(token).catch((error) => {\n    throw error;\n  });\n  const valid = await validateEvent2(event, url, method).catch((error) => {\n    throw error;\n  });\n  return valid;\n}\nasync function unpackEventFromToken(token) {\n  if (!token) {\n    throw new Error(\"Missing token\");\n  }\n  token = token.replace(_authorizationScheme, \"\");\n  const eventB64 = utf8Decoder.decode(import_base5.base64.decode(token));\n  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith(\"{\")) {\n    throw new Error(\"Invalid token\");\n  }\n  const event = JSON.parse(eventB64);\n  return event;\n}\nfunction validateEventTimestamp(event) {\n  if (!event.created_at) {\n    return false;\n  }\n  return Math.round(new Date().getTime() / 1e3) - event.created_at < 60;\n}\nfunction validateEventKind(event) {\n  return event.kind === HTTPAuth;\n}\nfunction validateEventUrlTag(event, url) {\n  const urlTag = event.tags.find((t) => t[0] === \"u\");\n  if (!urlTag) {\n    return false;\n  }\n  return urlTag.length > 0 && urlTag[1] === url;\n}\nfunction validateEventMethodTag(event, method) {\n  const methodTag = event.tags.find((t) => t[0] === \"method\");\n  if (!methodTag) {\n    return false;\n  }\n  return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();\n}\nfunction hashPayload(payload) {\n  const hash = (0, import_sha2564.sha256)(utf8Encoder.encode(JSON.stringify(payload)));\n  return (0, import_utils15.bytesToHex)(hash);\n}\nfunction validateEventPayloadTag(event, payload) {\n  const payloadTag = event.tags.find((t) => t[0] === \"payload\");\n  if (!payloadTag) {\n    return false;\n  }\n  const payloadHash = hashPayload(payload);\n  return payloadTag.length > 0 && payloadTag[1] === payloadHash;\n}\nasync function validateEvent2(event, url, method, body) {\n  if (!verifyEvent(event)) {\n    throw new Error(\"Invalid nostr event, signature invalid\");\n  }\n  if (!validateEventKind(event)) {\n    throw new Error(\"Invalid nostr event, kind invalid\");\n  }\n  if (!validateEventTimestamp(event)) {\n    throw new Error(\"Invalid nostr event, created_at timestamp invalid\");\n  }\n  if (!validateEventUrlTag(event, url)) {\n    throw new Error(\"Invalid nostr event, url tag invalid\");\n  }\n  if (!validateEventMethodTag(event, method)) {\n    throw new Error(\"Invalid nostr event, method tag invalid\");\n  }\n  if (Boolean(body) && typeof body === \"object\" && Object.keys(body).length > 0) {\n    if (!validateEventPayloadTag(event, body)) {\n      throw new Error(\"Invalid nostr event, payload tag does not match request body hash\");\n    }\n  }\n  return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbGliL2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLHdIQUF5QjtBQUN4RCxtQkFBbUIsbUJBQU8sQ0FBQyxnSEFBcUI7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsR0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsa0hBQXNCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTLElBQUksSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFD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Q047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1DQUFtQyw2QkFBNkI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsU0FBUyxHQUFHLE1BQU07QUFDaEYsK0VBQStFLE9BQU87QUFDdEYsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU8scUJBQXFCLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsMEdBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw2Q0FBNkMsS0FBSyxjQUFjLE9BQU87QUFDdkUsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXLEdBQUcsYUFBYTtBQUNwRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVyxHQUFHLGFBQWEsR0FBRyxLQUFLO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsR0FBRztBQUNoQztBQUNBO0FBQ0Esa0NBQWtDLEdBQUc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQkFBcUIsbUJBQU8sQ0FBQyxrSEFBc0I7QUFDbkQscUJBQXFCLG1CQUFPLENBQUMsZ0hBQXFCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLDBHQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbGliL2Nqcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIGluZGV4LnRzXG52YXIgbm9zdHJfdG9vbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobm9zdHJfdG9vbHNfZXhwb3J0cywge1xuICBSZWxheTogKCkgPT4gUmVsYXksXG4gIFNpbXBsZVBvb2w6ICgpID0+IFNpbXBsZVBvb2wsXG4gIGZpbmFsaXplRXZlbnQ6ICgpID0+IGZpbmFsaXplRXZlbnQsXG4gIGZqOiAoKSA9PiBmYWtlanNvbl9leHBvcnRzLFxuICBnZW5lcmF0ZVNlY3JldEtleTogKCkgPT4gZ2VuZXJhdGVTZWNyZXRLZXksXG4gIGdldEV2ZW50SGFzaDogKCkgPT4gZ2V0RXZlbnRIYXNoLFxuICBnZXRGaWx0ZXJMaW1pdDogKCkgPT4gZ2V0RmlsdGVyTGltaXQsXG4gIGdldFB1YmxpY0tleTogKCkgPT4gZ2V0UHVibGljS2V5LFxuICBraW5kczogKCkgPT4ga2luZHNfZXhwb3J0cyxcbiAgbWF0Y2hGaWx0ZXI6ICgpID0+IG1hdGNoRmlsdGVyLFxuICBtYXRjaEZpbHRlcnM6ICgpID0+IG1hdGNoRmlsdGVycyxcbiAgbWVyZ2VGaWx0ZXJzOiAoKSA9PiBtZXJnZUZpbHRlcnMsXG4gIG5pcDA0OiAoKSA9PiBuaXAwNF9leHBvcnRzLFxuICBuaXAwNTogKCkgPT4gbmlwMDVfZXhwb3J0cyxcbiAgbmlwMTA6ICgpID0+IG5pcDEwX2V4cG9ydHMsXG4gIG5pcDExOiAoKSA9PiBuaXAxMV9leHBvcnRzLFxuICBuaXAxMzogKCkgPT4gbmlwMTNfZXhwb3J0cyxcbiAgbmlwMTc6ICgpID0+IG5pcDE3X2V4cG9ydHMsXG4gIG5pcDE4OiAoKSA9PiBuaXAxOF9leHBvcnRzLFxuICBuaXAxOTogKCkgPT4gbmlwMTlfZXhwb3J0cyxcbiAgbmlwMjE6ICgpID0+IG5pcDIxX2V4cG9ydHMsXG4gIG5pcDI1OiAoKSA9PiBuaXAyNV9leHBvcnRzLFxuICBuaXAyNzogKCkgPT4gbmlwMjdfZXhwb3J0cyxcbiAgbmlwMjg6ICgpID0+IG5pcDI4X2V4cG9ydHMsXG4gIG5pcDMwOiAoKSA9PiBuaXAzMF9leHBvcnRzLFxuICBuaXAzOTogKCkgPT4gbmlwMzlfZXhwb3J0cyxcbiAgbmlwNDI6ICgpID0+IG5pcDQyX2V4cG9ydHMsXG4gIG5pcDQ0OiAoKSA9PiBuaXA0NF9leHBvcnRzLFxuICBuaXA0NzogKCkgPT4gbmlwNDdfZXhwb3J0cyxcbiAgbmlwNTQ6ICgpID0+IG5pcDU0X2V4cG9ydHMsXG4gIG5pcDU3OiAoKSA9PiBuaXA1N19leHBvcnRzLFxuICBuaXA1OTogKCkgPT4gbmlwNTlfZXhwb3J0cyxcbiAgbmlwOTg6ICgpID0+IG5pcDk4X2V4cG9ydHMsXG4gIHBhcnNlUmVmZXJlbmNlczogKCkgPT4gcGFyc2VSZWZlcmVuY2VzLFxuICBzZXJpYWxpemVFdmVudDogKCkgPT4gc2VyaWFsaXplRXZlbnQsXG4gIHNvcnRFdmVudHM6ICgpID0+IHNvcnRFdmVudHMsXG4gIHV0aWxzOiAoKSA9PiB1dGlsc19leHBvcnRzLFxuICB2YWxpZGF0ZUV2ZW50OiAoKSA9PiB2YWxpZGF0ZUV2ZW50LFxuICB2ZXJpZmllZFN5bWJvbDogKCkgPT4gdmVyaWZpZWRTeW1ib2wsXG4gIHZlcmlmeUV2ZW50OiAoKSA9PiB2ZXJpZnlFdmVudFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhub3N0cl90b29sc19leHBvcnRzKTtcblxuLy8gcHVyZS50c1xudmFyIGltcG9ydF9zZWNwMjU2azEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIik7XG52YXIgaW1wb3J0X3V0aWxzID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5cbi8vIGNvcmUudHNcbnZhciB2ZXJpZmllZFN5bWJvbCA9IFN5bWJvbChcInZlcmlmaWVkXCIpO1xudmFyIGlzUmVjb3JkID0gKG9iaikgPT4gb2JqIGluc3RhbmNlb2YgT2JqZWN0O1xuZnVuY3Rpb24gdmFsaWRhdGVFdmVudChldmVudCkge1xuICBpZiAoIWlzUmVjb3JkKGV2ZW50KSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQua2luZCAhPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQuY29udGVudCAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQuY3JlYXRlZF9hdCAhPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQucHVia2V5ICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCFldmVudC5wdWJrZXkubWF0Y2goL15bYS1mMC05XXs2NH0kLykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXZlbnQudGFncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZXZlbnQudGFncy5sZW5ndGg7IGkyKyspIHtcbiAgICBsZXQgdGFnID0gZXZlbnQudGFnc1tpMl07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRhZykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWcubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnW2pdID09PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc29ydEV2ZW50cyhldmVudHMpIHtcbiAgcmV0dXJuIGV2ZW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgaWYgKGEuY3JlYXRlZF9hdCAhPT0gYi5jcmVhdGVkX2F0KSB7XG4gICAgICByZXR1cm4gYi5jcmVhdGVkX2F0IC0gYS5jcmVhdGVkX2F0O1xuICAgIH1cbiAgICByZXR1cm4gYS5pZC5sb2NhbGVDb21wYXJlKGIuaWQpO1xuICB9KTtcbn1cblxuLy8gcHVyZS50c1xudmFyIGltcG9ydF9zaGEyNTYgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIik7XG5cbi8vIHV0aWxzLnRzXG52YXIgdXRpbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbHNfZXhwb3J0cywge1xuICBRdWV1ZTogKCkgPT4gUXVldWUsXG4gIFF1ZXVlTm9kZTogKCkgPT4gUXVldWVOb2RlLFxuICBiaW5hcnlTZWFyY2g6ICgpID0+IGJpbmFyeVNlYXJjaCxcbiAgaW5zZXJ0RXZlbnRJbnRvQXNjZW5kaW5nTGlzdDogKCkgPT4gaW5zZXJ0RXZlbnRJbnRvQXNjZW5kaW5nTGlzdCxcbiAgaW5zZXJ0RXZlbnRJbnRvRGVzY2VuZGluZ0xpc3Q6ICgpID0+IGluc2VydEV2ZW50SW50b0Rlc2NlbmRpbmdMaXN0LFxuICBub3JtYWxpemVVUkw6ICgpID0+IG5vcm1hbGl6ZVVSTCxcbiAgdXRmOERlY29kZXI6ICgpID0+IHV0ZjhEZWNvZGVyLFxuICB1dGY4RW5jb2RlcjogKCkgPT4gdXRmOEVuY29kZXJcbn0pO1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG52YXIgdXRmOEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVSTCh1cmwpIHtcbiAgaWYgKHVybC5pbmRleE9mKFwiOi8vXCIpID09PSAtMSlcbiAgICB1cmwgPSBcIndzczovL1wiICsgdXJsO1xuICBsZXQgcCA9IG5ldyBVUkwodXJsKTtcbiAgcC5wYXRobmFtZSA9IHAucGF0aG5hbWUucmVwbGFjZSgvXFwvKy9nLCBcIi9cIik7XG4gIGlmIChwLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSlcbiAgICBwLnBhdGhuYW1lID0gcC5wYXRobmFtZS5zbGljZSgwLCAtMSk7XG4gIGlmIChwLnBvcnQgPT09IFwiODBcIiAmJiBwLnByb3RvY29sID09PSBcIndzOlwiIHx8IHAucG9ydCA9PT0gXCI0NDNcIiAmJiBwLnByb3RvY29sID09PSBcIndzczpcIilcbiAgICBwLnBvcnQgPSBcIlwiO1xuICBwLnNlYXJjaFBhcmFtcy5zb3J0KCk7XG4gIHAuaGFzaCA9IFwiXCI7XG4gIHJldHVybiBwLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBpbnNlcnRFdmVudEludG9EZXNjZW5kaW5nTGlzdChzb3J0ZWRBcnJheSwgZXZlbnQpIHtcbiAgY29uc3QgW2lkeCwgZm91bmRdID0gYmluYXJ5U2VhcmNoKHNvcnRlZEFycmF5LCAoYikgPT4ge1xuICAgIGlmIChldmVudC5pZCA9PT0gYi5pZClcbiAgICAgIHJldHVybiAwO1xuICAgIGlmIChldmVudC5jcmVhdGVkX2F0ID09PSBiLmNyZWF0ZWRfYXQpXG4gICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIGIuY3JlYXRlZF9hdCAtIGV2ZW50LmNyZWF0ZWRfYXQ7XG4gIH0pO1xuICBpZiAoIWZvdW5kKSB7XG4gICAgc29ydGVkQXJyYXkuc3BsaWNlKGlkeCwgMCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBzb3J0ZWRBcnJheTtcbn1cbmZ1bmN0aW9uIGluc2VydEV2ZW50SW50b0FzY2VuZGluZ0xpc3Qoc29ydGVkQXJyYXksIGV2ZW50KSB7XG4gIGNvbnN0IFtpZHgsIGZvdW5kXSA9IGJpbmFyeVNlYXJjaChzb3J0ZWRBcnJheSwgKGIpID0+IHtcbiAgICBpZiAoZXZlbnQuaWQgPT09IGIuaWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBpZiAoZXZlbnQuY3JlYXRlZF9hdCA9PT0gYi5jcmVhdGVkX2F0KVxuICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiBldmVudC5jcmVhdGVkX2F0IC0gYi5jcmVhdGVkX2F0O1xuICB9KTtcbiAgaWYgKCFmb3VuZCkge1xuICAgIHNvcnRlZEFycmF5LnNwbGljZShpZHgsIDAsIGV2ZW50KTtcbiAgfVxuICByZXR1cm4gc29ydGVkQXJyYXk7XG59XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2goYXJyLCBjb21wYXJlKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgIGNvbnN0IGNtcCA9IGNvbXBhcmUoYXJyW21pZF0pO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHJldHVybiBbbWlkLCB0cnVlXTtcbiAgICB9XG4gICAgaWYgKGNtcCA8IDApIHtcbiAgICAgIGVuZCA9IG1pZCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gbWlkICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtzdGFydCwgZmFsc2VdO1xufVxudmFyIFF1ZXVlTm9kZSA9IGNsYXNzIHtcbiAgdmFsdWU7XG4gIG5leHQgPSBudWxsO1xuICBwcmV2ID0gbnVsbDtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHRoaXMudmFsdWUgPSBtZXNzYWdlO1xuICB9XG59O1xudmFyIFF1ZXVlID0gY2xhc3Mge1xuICBmaXJzdDtcbiAgbGFzdDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5maXJzdCA9IG51bGw7XG4gICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgfVxuICBlbnF1ZXVlKHZhbHVlKSB7XG4gICAgY29uc3QgbmV3Tm9kZSA9IG5ldyBRdWV1ZU5vZGUodmFsdWUpO1xuICAgIGlmICghdGhpcy5sYXN0KSB7XG4gICAgICB0aGlzLmZpcnN0ID0gbmV3Tm9kZTtcbiAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxhc3QgPT09IHRoaXMuZmlyc3QpIHtcbiAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QucHJldiA9IHRoaXMuZmlyc3Q7XG4gICAgICB0aGlzLmZpcnN0Lm5leHQgPSBuZXdOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOb2RlLnByZXYgPSB0aGlzLmxhc3Q7XG4gICAgICB0aGlzLmxhc3QubmV4dCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QgPSBuZXdOb2RlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZXF1ZXVlKCkge1xuICAgIGlmICghdGhpcy5maXJzdClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh0aGlzLmZpcnN0ID09PSB0aGlzLmxhc3QpIHtcbiAgICAgIGNvbnN0IHRhcmdldDIgPSB0aGlzLmZpcnN0O1xuICAgICAgdGhpcy5maXJzdCA9IG51bGw7XG4gICAgICB0aGlzLmxhc3QgPSBudWxsO1xuICAgICAgcmV0dXJuIHRhcmdldDIudmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZmlyc3Q7XG4gICAgdGhpcy5maXJzdCA9IHRhcmdldC5uZXh0O1xuICAgIHJldHVybiB0YXJnZXQudmFsdWU7XG4gIH1cbn07XG5cbi8vIHB1cmUudHNcbnZhciBKUyA9IGNsYXNzIHtcbiAgZ2VuZXJhdGVTZWNyZXRLZXkoKSB7XG4gICAgcmV0dXJuIGltcG9ydF9zZWNwMjU2azEuc2Nobm9yci51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gIH1cbiAgZ2V0UHVibGljS2V5KHNlY3JldEtleSkge1xuICAgIHJldHVybiAoMCwgaW1wb3J0X3V0aWxzLmJ5dGVzVG9IZXgpKGltcG9ydF9zZWNwMjU2azEuc2Nobm9yci5nZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSk7XG4gIH1cbiAgZmluYWxpemVFdmVudCh0LCBzZWNyZXRLZXkpIHtcbiAgICBjb25zdCBldmVudCA9IHQ7XG4gICAgZXZlbnQucHVia2V5ID0gKDAsIGltcG9ydF91dGlscy5ieXRlc1RvSGV4KShpbXBvcnRfc2VjcDI1NmsxLnNjaG5vcnIuZ2V0UHVibGljS2V5KHNlY3JldEtleSkpO1xuICAgIGV2ZW50LmlkID0gZ2V0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBldmVudC5zaWcgPSAoMCwgaW1wb3J0X3V0aWxzLmJ5dGVzVG9IZXgpKGltcG9ydF9zZWNwMjU2azEuc2Nobm9yci5zaWduKGdldEV2ZW50SGFzaChldmVudCksIHNlY3JldEtleSkpO1xuICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IHRydWU7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIHZlcmlmeUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudFt2ZXJpZmllZFN5bWJvbF0gPT09IFwiYm9vbGVhblwiKVxuICAgICAgcmV0dXJuIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXTtcbiAgICBjb25zdCBoYXNoID0gZ2V0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBpZiAoaGFzaCAhPT0gZXZlbnQuaWQpIHtcbiAgICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgdmFsaWQgPSBpbXBvcnRfc2VjcDI1NmsxLnNjaG5vcnIudmVyaWZ5KGV2ZW50LnNpZywgaGFzaCwgZXZlbnQucHVia2V5KTtcbiAgICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IHZhbGlkO1xuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gc2VyaWFsaXplRXZlbnQoZXZ0KSB7XG4gIGlmICghdmFsaWRhdGVFdmVudChldnQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHNlcmlhbGl6ZSBldmVudCB3aXRoIHdyb25nIG9yIG1pc3NpbmcgcHJvcGVydGllc1wiKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFswLCBldnQucHVia2V5LCBldnQuY3JlYXRlZF9hdCwgZXZ0LmtpbmQsIGV2dC50YWdzLCBldnQuY29udGVudF0pO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRIYXNoKGV2ZW50KSB7XG4gIGxldCBldmVudEhhc2ggPSAoMCwgaW1wb3J0X3NoYTI1Ni5zaGEyNTYpKHV0ZjhFbmNvZGVyLmVuY29kZShzZXJpYWxpemVFdmVudChldmVudCkpKTtcbiAgcmV0dXJuICgwLCBpbXBvcnRfdXRpbHMuYnl0ZXNUb0hleCkoZXZlbnRIYXNoKTtcbn1cbnZhciBpID0gbmV3IEpTKCk7XG52YXIgZ2VuZXJhdGVTZWNyZXRLZXkgPSBpLmdlbmVyYXRlU2VjcmV0S2V5O1xudmFyIGdldFB1YmxpY0tleSA9IGkuZ2V0UHVibGljS2V5O1xudmFyIGZpbmFsaXplRXZlbnQgPSBpLmZpbmFsaXplRXZlbnQ7XG52YXIgdmVyaWZ5RXZlbnQgPSBpLnZlcmlmeUV2ZW50O1xuXG4vLyBraW5kcy50c1xudmFyIGtpbmRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGtpbmRzX2V4cG9ydHMsIHtcbiAgQXBwbGljYXRpb246ICgpID0+IEFwcGxpY2F0aW9uLFxuICBCYWRnZUF3YXJkOiAoKSA9PiBCYWRnZUF3YXJkLFxuICBCYWRnZURlZmluaXRpb246ICgpID0+IEJhZGdlRGVmaW5pdGlvbixcbiAgQmxvY2tlZFJlbGF5c0xpc3Q6ICgpID0+IEJsb2NrZWRSZWxheXNMaXN0LFxuICBCb29rbWFya0xpc3Q6ICgpID0+IEJvb2ttYXJrTGlzdCxcbiAgQm9va21hcmtzZXRzOiAoKSA9PiBCb29rbWFya3NldHMsXG4gIENhbGVuZGFyOiAoKSA9PiBDYWxlbmRhcixcbiAgQ2FsZW5kYXJFdmVudFJTVlA6ICgpID0+IENhbGVuZGFyRXZlbnRSU1ZQLFxuICBDaGFubmVsQ3JlYXRpb246ICgpID0+IENoYW5uZWxDcmVhdGlvbixcbiAgQ2hhbm5lbEhpZGVNZXNzYWdlOiAoKSA9PiBDaGFubmVsSGlkZU1lc3NhZ2UsXG4gIENoYW5uZWxNZXNzYWdlOiAoKSA9PiBDaGFubmVsTWVzc2FnZSxcbiAgQ2hhbm5lbE1ldGFkYXRhOiAoKSA9PiBDaGFubmVsTWV0YWRhdGEsXG4gIENoYW5uZWxNdXRlVXNlcjogKCkgPT4gQ2hhbm5lbE11dGVVc2VyLFxuICBDbGFzc2lmaWVkTGlzdGluZzogKCkgPT4gQ2xhc3NpZmllZExpc3RpbmcsXG4gIENsaWVudEF1dGg6ICgpID0+IENsaWVudEF1dGgsXG4gIENvbW11bml0aWVzTGlzdDogKCkgPT4gQ29tbXVuaXRpZXNMaXN0LFxuICBDb21tdW5pdHlEZWZpbml0aW9uOiAoKSA9PiBDb21tdW5pdHlEZWZpbml0aW9uLFxuICBDb21tdW5pdHlQb3N0QXBwcm92YWw6ICgpID0+IENvbW11bml0eVBvc3RBcHByb3ZhbCxcbiAgQ29udGFjdHM6ICgpID0+IENvbnRhY3RzLFxuICBDcmVhdGVPclVwZGF0ZVByb2R1Y3Q6ICgpID0+IENyZWF0ZU9yVXBkYXRlUHJvZHVjdCxcbiAgQ3JlYXRlT3JVcGRhdGVTdGFsbDogKCkgPT4gQ3JlYXRlT3JVcGRhdGVTdGFsbCxcbiAgQ3VyYXRpb25zZXRzOiAoKSA9PiBDdXJhdGlvbnNldHMsXG4gIERhdGU6ICgpID0+IERhdGUyLFxuICBEaXJlY3RNZXNzYWdlUmVsYXlzTGlzdDogKCkgPT4gRGlyZWN0TWVzc2FnZVJlbGF5c0xpc3QsXG4gIERyYWZ0Q2xhc3NpZmllZExpc3Rpbmc6ICgpID0+IERyYWZ0Q2xhc3NpZmllZExpc3RpbmcsXG4gIERyYWZ0TG9uZzogKCkgPT4gRHJhZnRMb25nLFxuICBFbW9qaXNldHM6ICgpID0+IEVtb2ppc2V0cyxcbiAgRW5jcnlwdGVkRGlyZWN0TWVzc2FnZTogKCkgPT4gRW5jcnlwdGVkRGlyZWN0TWVzc2FnZSxcbiAgRXZlbnREZWxldGlvbjogKCkgPT4gRXZlbnREZWxldGlvbixcbiAgRmlsZU1ldGFkYXRhOiAoKSA9PiBGaWxlTWV0YWRhdGEsXG4gIEZpbGVTZXJ2ZXJQcmVmZXJlbmNlOiAoKSA9PiBGaWxlU2VydmVyUHJlZmVyZW5jZSxcbiAgRm9sbG93c2V0czogKCkgPT4gRm9sbG93c2V0cyxcbiAgR2VuZXJpY1JlcG9zdDogKCkgPT4gR2VuZXJpY1JlcG9zdCxcbiAgR2VuZXJpY2xpc3RzOiAoKSA9PiBHZW5lcmljbGlzdHMsXG4gIEdpZnRXcmFwOiAoKSA9PiBHaWZ0V3JhcCxcbiAgSFRUUEF1dGg6ICgpID0+IEhUVFBBdXRoLFxuICBIYW5kbGVyaW5mb3JtYXRpb246ICgpID0+IEhhbmRsZXJpbmZvcm1hdGlvbixcbiAgSGFuZGxlcnJlY29tbWVuZGF0aW9uOiAoKSA9PiBIYW5kbGVycmVjb21tZW5kYXRpb24sXG4gIEhpZ2hsaWdodHM6ICgpID0+IEhpZ2hsaWdodHMsXG4gIEludGVyZXN0c0xpc3Q6ICgpID0+IEludGVyZXN0c0xpc3QsXG4gIEludGVyZXN0c2V0czogKCkgPT4gSW50ZXJlc3RzZXRzLFxuICBKb2JGZWVkYmFjazogKCkgPT4gSm9iRmVlZGJhY2ssXG4gIEpvYlJlcXVlc3Q6ICgpID0+IEpvYlJlcXVlc3QsXG4gIEpvYlJlc3VsdDogKCkgPT4gSm9iUmVzdWx0LFxuICBMYWJlbDogKCkgPT4gTGFiZWwsXG4gIExpZ2h0bmluZ1B1YlJQQzogKCkgPT4gTGlnaHRuaW5nUHViUlBDLFxuICBMaXZlQ2hhdE1lc3NhZ2U6ICgpID0+IExpdmVDaGF0TWVzc2FnZSxcbiAgTGl2ZUV2ZW50OiAoKSA9PiBMaXZlRXZlbnQsXG4gIExvbmdGb3JtQXJ0aWNsZTogKCkgPT4gTG9uZ0Zvcm1BcnRpY2xlLFxuICBNZXRhZGF0YTogKCkgPT4gTWV0YWRhdGEsXG4gIE11dGVsaXN0OiAoKSA9PiBNdXRlbGlzdCxcbiAgTldDV2FsbGV0SW5mbzogKCkgPT4gTldDV2FsbGV0SW5mbyxcbiAgTldDV2FsbGV0UmVxdWVzdDogKCkgPT4gTldDV2FsbGV0UmVxdWVzdCxcbiAgTldDV2FsbGV0UmVzcG9uc2U6ICgpID0+IE5XQ1dhbGxldFJlc3BvbnNlLFxuICBOb3N0ckNvbm5lY3Q6ICgpID0+IE5vc3RyQ29ubmVjdCxcbiAgT3BlblRpbWVzdGFtcHM6ICgpID0+IE9wZW5UaW1lc3RhbXBzLFxuICBQaW5saXN0OiAoKSA9PiBQaW5saXN0LFxuICBQcml2YXRlRGlyZWN0TWVzc2FnZTogKCkgPT4gUHJpdmF0ZURpcmVjdE1lc3NhZ2UsXG4gIFByb2JsZW1UcmFja2VyOiAoKSA9PiBQcm9ibGVtVHJhY2tlcixcbiAgUHJvZmlsZUJhZGdlczogKCkgPT4gUHJvZmlsZUJhZGdlcyxcbiAgUHVibGljQ2hhdHNMaXN0OiAoKSA9PiBQdWJsaWNDaGF0c0xpc3QsXG4gIFJlYWN0aW9uOiAoKSA9PiBSZWFjdGlvbixcbiAgUmVjb21tZW5kUmVsYXk6ICgpID0+IFJlY29tbWVuZFJlbGF5LFxuICBSZWxheUxpc3Q6ICgpID0+IFJlbGF5TGlzdCxcbiAgUmVsYXlzZXRzOiAoKSA9PiBSZWxheXNldHMsXG4gIFJlcG9ydDogKCkgPT4gUmVwb3J0LFxuICBSZXBvcnRpbmc6ICgpID0+IFJlcG9ydGluZyxcbiAgUmVwb3N0OiAoKSA9PiBSZXBvc3QsXG4gIFNlYWw6ICgpID0+IFNlYWwsXG4gIFNlYXJjaFJlbGF5c0xpc3Q6ICgpID0+IFNlYXJjaFJlbGF5c0xpc3QsXG4gIFNob3J0VGV4dE5vdGU6ICgpID0+IFNob3J0VGV4dE5vdGUsXG4gIFRpbWU6ICgpID0+IFRpbWUsXG4gIFVzZXJFbW9qaUxpc3Q6ICgpID0+IFVzZXJFbW9qaUxpc3QsXG4gIFVzZXJTdGF0dXNlczogKCkgPT4gVXNlclN0YXR1c2VzLFxuICBaYXA6ICgpID0+IFphcCxcbiAgWmFwR29hbDogKCkgPT4gWmFwR29hbCxcbiAgWmFwUmVxdWVzdDogKCkgPT4gWmFwUmVxdWVzdCxcbiAgY2xhc3NpZnlLaW5kOiAoKSA9PiBjbGFzc2lmeUtpbmQsXG4gIGlzQWRkcmVzc2FibGVLaW5kOiAoKSA9PiBpc0FkZHJlc3NhYmxlS2luZCxcbiAgaXNFcGhlbWVyYWxLaW5kOiAoKSA9PiBpc0VwaGVtZXJhbEtpbmQsXG4gIGlzS2luZDogKCkgPT4gaXNLaW5kLFxuICBpc1BhcmFtZXRlcml6ZWRSZXBsYWNlYWJsZUtpbmQ6ICgpID0+IGlzUGFyYW1ldGVyaXplZFJlcGxhY2VhYmxlS2luZCxcbiAgaXNSZWd1bGFyS2luZDogKCkgPT4gaXNSZWd1bGFyS2luZCxcbiAgaXNSZXBsYWNlYWJsZUtpbmQ6ICgpID0+IGlzUmVwbGFjZWFibGVLaW5kXG59KTtcbmZ1bmN0aW9uIGlzUmVndWxhcktpbmQoa2luZCkge1xuICByZXR1cm4gMWUzIDw9IGtpbmQgJiYga2luZCA8IDFlNCB8fCBbMSwgMiwgNCwgNSwgNiwgNywgOCwgMTYsIDQwLCA0MSwgNDIsIDQzLCA0NF0uaW5jbHVkZXMoa2luZCk7XG59XG5mdW5jdGlvbiBpc1JlcGxhY2VhYmxlS2luZChraW5kKSB7XG4gIHJldHVybiBbMCwgM10uaW5jbHVkZXMoa2luZCkgfHwgMWU0IDw9IGtpbmQgJiYga2luZCA8IDJlNDtcbn1cbmZ1bmN0aW9uIGlzRXBoZW1lcmFsS2luZChraW5kKSB7XG4gIHJldHVybiAyZTQgPD0ga2luZCAmJiBraW5kIDwgM2U0O1xufVxuZnVuY3Rpb24gaXNBZGRyZXNzYWJsZUtpbmQoa2luZCkge1xuICByZXR1cm4gM2U0IDw9IGtpbmQgJiYga2luZCA8IDRlNDtcbn1cbnZhciBpc1BhcmFtZXRlcml6ZWRSZXBsYWNlYWJsZUtpbmQgPSBpc0FkZHJlc3NhYmxlS2luZDtcbmZ1bmN0aW9uIGNsYXNzaWZ5S2luZChraW5kKSB7XG4gIGlmIChpc1JlZ3VsYXJLaW5kKGtpbmQpKVxuICAgIHJldHVybiBcInJlZ3VsYXJcIjtcbiAgaWYgKGlzUmVwbGFjZWFibGVLaW5kKGtpbmQpKVxuICAgIHJldHVybiBcInJlcGxhY2VhYmxlXCI7XG4gIGlmIChpc0VwaGVtZXJhbEtpbmQoa2luZCkpXG4gICAgcmV0dXJuIFwiZXBoZW1lcmFsXCI7XG4gIGlmIChpc0FkZHJlc3NhYmxlS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJwYXJhbWV0ZXJpemVkXCI7XG4gIHJldHVybiBcInVua25vd25cIjtcbn1cbmZ1bmN0aW9uIGlzS2luZChldmVudCwga2luZCkge1xuICBjb25zdCBraW5kQXNBcnJheSA9IGtpbmQgaW5zdGFuY2VvZiBBcnJheSA/IGtpbmQgOiBba2luZF07XG4gIHJldHVybiB2YWxpZGF0ZUV2ZW50KGV2ZW50KSAmJiBraW5kQXNBcnJheS5pbmNsdWRlcyhldmVudC5raW5kKSB8fCBmYWxzZTtcbn1cbnZhciBNZXRhZGF0YSA9IDA7XG52YXIgU2hvcnRUZXh0Tm90ZSA9IDE7XG52YXIgUmVjb21tZW5kUmVsYXkgPSAyO1xudmFyIENvbnRhY3RzID0gMztcbnZhciBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlID0gNDtcbnZhciBFdmVudERlbGV0aW9uID0gNTtcbnZhciBSZXBvc3QgPSA2O1xudmFyIFJlYWN0aW9uID0gNztcbnZhciBCYWRnZUF3YXJkID0gODtcbnZhciBTZWFsID0gMTM7XG52YXIgUHJpdmF0ZURpcmVjdE1lc3NhZ2UgPSAxNDtcbnZhciBHZW5lcmljUmVwb3N0ID0gMTY7XG52YXIgQ2hhbm5lbENyZWF0aW9uID0gNDA7XG52YXIgQ2hhbm5lbE1ldGFkYXRhID0gNDE7XG52YXIgQ2hhbm5lbE1lc3NhZ2UgPSA0MjtcbnZhciBDaGFubmVsSGlkZU1lc3NhZ2UgPSA0MztcbnZhciBDaGFubmVsTXV0ZVVzZXIgPSA0NDtcbnZhciBPcGVuVGltZXN0YW1wcyA9IDEwNDA7XG52YXIgR2lmdFdyYXAgPSAxMDU5O1xudmFyIEZpbGVNZXRhZGF0YSA9IDEwNjM7XG52YXIgTGl2ZUNoYXRNZXNzYWdlID0gMTMxMTtcbnZhciBQcm9ibGVtVHJhY2tlciA9IDE5NzE7XG52YXIgUmVwb3J0ID0gMTk4NDtcbnZhciBSZXBvcnRpbmcgPSAxOTg0O1xudmFyIExhYmVsID0gMTk4NTtcbnZhciBDb21tdW5pdHlQb3N0QXBwcm92YWwgPSA0NTUwO1xudmFyIEpvYlJlcXVlc3QgPSA1OTk5O1xudmFyIEpvYlJlc3VsdCA9IDY5OTk7XG52YXIgSm9iRmVlZGJhY2sgPSA3ZTM7XG52YXIgWmFwR29hbCA9IDkwNDE7XG52YXIgWmFwUmVxdWVzdCA9IDk3MzQ7XG52YXIgWmFwID0gOTczNTtcbnZhciBIaWdobGlnaHRzID0gOTgwMjtcbnZhciBNdXRlbGlzdCA9IDFlNDtcbnZhciBQaW5saXN0ID0gMTAwMDE7XG52YXIgUmVsYXlMaXN0ID0gMTAwMDI7XG52YXIgQm9va21hcmtMaXN0ID0gMTAwMDM7XG52YXIgQ29tbXVuaXRpZXNMaXN0ID0gMTAwMDQ7XG52YXIgUHVibGljQ2hhdHNMaXN0ID0gMTAwMDU7XG52YXIgQmxvY2tlZFJlbGF5c0xpc3QgPSAxMDAwNjtcbnZhciBTZWFyY2hSZWxheXNMaXN0ID0gMTAwMDc7XG52YXIgSW50ZXJlc3RzTGlzdCA9IDEwMDE1O1xudmFyIFVzZXJFbW9qaUxpc3QgPSAxMDAzMDtcbnZhciBEaXJlY3RNZXNzYWdlUmVsYXlzTGlzdCA9IDEwMDUwO1xudmFyIEZpbGVTZXJ2ZXJQcmVmZXJlbmNlID0gMTAwOTY7XG52YXIgTldDV2FsbGV0SW5mbyA9IDEzMTk0O1xudmFyIExpZ2h0bmluZ1B1YlJQQyA9IDIxZTM7XG52YXIgQ2xpZW50QXV0aCA9IDIyMjQyO1xudmFyIE5XQ1dhbGxldFJlcXVlc3QgPSAyMzE5NDtcbnZhciBOV0NXYWxsZXRSZXNwb25zZSA9IDIzMTk1O1xudmFyIE5vc3RyQ29ubmVjdCA9IDI0MTMzO1xudmFyIEhUVFBBdXRoID0gMjcyMzU7XG52YXIgRm9sbG93c2V0cyA9IDNlNDtcbnZhciBHZW5lcmljbGlzdHMgPSAzMDAwMTtcbnZhciBSZWxheXNldHMgPSAzMDAwMjtcbnZhciBCb29rbWFya3NldHMgPSAzMDAwMztcbnZhciBDdXJhdGlvbnNldHMgPSAzMDAwNDtcbnZhciBQcm9maWxlQmFkZ2VzID0gMzAwMDg7XG52YXIgQmFkZ2VEZWZpbml0aW9uID0gMzAwMDk7XG52YXIgSW50ZXJlc3RzZXRzID0gMzAwMTU7XG52YXIgQ3JlYXRlT3JVcGRhdGVTdGFsbCA9IDMwMDE3O1xudmFyIENyZWF0ZU9yVXBkYXRlUHJvZHVjdCA9IDMwMDE4O1xudmFyIExvbmdGb3JtQXJ0aWNsZSA9IDMwMDIzO1xudmFyIERyYWZ0TG9uZyA9IDMwMDI0O1xudmFyIEVtb2ppc2V0cyA9IDMwMDMwO1xudmFyIEFwcGxpY2F0aW9uID0gMzAwNzg7XG52YXIgTGl2ZUV2ZW50ID0gMzAzMTE7XG52YXIgVXNlclN0YXR1c2VzID0gMzAzMTU7XG52YXIgQ2xhc3NpZmllZExpc3RpbmcgPSAzMDQwMjtcbnZhciBEcmFmdENsYXNzaWZpZWRMaXN0aW5nID0gMzA0MDM7XG52YXIgRGF0ZTIgPSAzMTkyMjtcbnZhciBUaW1lID0gMzE5MjM7XG52YXIgQ2FsZW5kYXIgPSAzMTkyNDtcbnZhciBDYWxlbmRhckV2ZW50UlNWUCA9IDMxOTI1O1xudmFyIEhhbmRsZXJyZWNvbW1lbmRhdGlvbiA9IDMxOTg5O1xudmFyIEhhbmRsZXJpbmZvcm1hdGlvbiA9IDMxOTkwO1xudmFyIENvbW11bml0eURlZmluaXRpb24gPSAzNDU1MDtcblxuLy8gZmlsdGVyLnRzXG5mdW5jdGlvbiBtYXRjaEZpbHRlcihmaWx0ZXIsIGV2ZW50KSB7XG4gIGlmIChmaWx0ZXIuaWRzICYmIGZpbHRlci5pZHMuaW5kZXhPZihldmVudC5pZCkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWx0ZXIua2luZHMgJiYgZmlsdGVyLmtpbmRzLmluZGV4T2YoZXZlbnQua2luZCkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWx0ZXIuYXV0aG9ycyAmJiBmaWx0ZXIuYXV0aG9ycy5pbmRleE9mKGV2ZW50LnB1YmtleSkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGYgaW4gZmlsdGVyKSB7XG4gICAgaWYgKGZbMF0gPT09IFwiI1wiKSB7XG4gICAgICBsZXQgdGFnTmFtZSA9IGYuc2xpY2UoMSk7XG4gICAgICBsZXQgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdO1xuICAgICAgaWYgKHZhbHVlcyAmJiAhZXZlbnQudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IGYuc2xpY2UoMSkgJiYgdmFsdWVzLmluZGV4T2YodikgIT09IC0xKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyLnNpbmNlICYmIGV2ZW50LmNyZWF0ZWRfYXQgPCBmaWx0ZXIuc2luY2UpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmlsdGVyLnVudGlsICYmIGV2ZW50LmNyZWF0ZWRfYXQgPiBmaWx0ZXIudW50aWwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hdGNoRmlsdGVycyhmaWx0ZXJzLCBldmVudCkge1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZmlsdGVycy5sZW5ndGg7IGkyKyspIHtcbiAgICBpZiAobWF0Y2hGaWx0ZXIoZmlsdGVyc1tpMl0sIGV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1lcmdlRmlsdGVycyguLi5maWx0ZXJzKSB7XG4gIGxldCByZXN1bHQgPSB7fTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGZpbHRlcnMubGVuZ3RoOyBpMisrKSB7XG4gICAgbGV0IGZpbHRlciA9IGZpbHRlcnNbaTJdO1xuICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZm9yRWFjaCgoW3Byb3BlcnR5LCB2YWx1ZXNdKSA9PiB7XG4gICAgICBpZiAocHJvcGVydHkgPT09IFwia2luZHNcIiB8fCBwcm9wZXJ0eSA9PT0gXCJpZHNcIiB8fCBwcm9wZXJ0eSA9PT0gXCJhdXRob3JzXCIgfHwgcHJvcGVydHlbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSByZXN1bHRbcHJvcGVydHldIHx8IFtdO1xuICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHZhbHVlcy5sZW5ndGg7IHYrKykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1t2XTtcbiAgICAgICAgICBpZiAoIXJlc3VsdFtwcm9wZXJ0eV0uaW5jbHVkZXModmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmaWx0ZXIubGltaXQgJiYgKCFyZXN1bHQubGltaXQgfHwgZmlsdGVyLmxpbWl0ID4gcmVzdWx0LmxpbWl0KSlcbiAgICAgIHJlc3VsdC5saW1pdCA9IGZpbHRlci5saW1pdDtcbiAgICBpZiAoZmlsdGVyLnVudGlsICYmICghcmVzdWx0LnVudGlsIHx8IGZpbHRlci51bnRpbCA+IHJlc3VsdC51bnRpbCkpXG4gICAgICByZXN1bHQudW50aWwgPSBmaWx0ZXIudW50aWw7XG4gICAgaWYgKGZpbHRlci5zaW5jZSAmJiAoIXJlc3VsdC5zaW5jZSB8fCBmaWx0ZXIuc2luY2UgPCByZXN1bHQuc2luY2UpKVxuICAgICAgcmVzdWx0LnNpbmNlID0gZmlsdGVyLnNpbmNlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRGaWx0ZXJMaW1pdChmaWx0ZXIpIHtcbiAgaWYgKGZpbHRlci5pZHMgJiYgIWZpbHRlci5pZHMubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuICBpZiAoZmlsdGVyLmtpbmRzICYmICFmaWx0ZXIua2luZHMubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuICBpZiAoZmlsdGVyLmF1dGhvcnMgJiYgIWZpbHRlci5hdXRob3JzLmxlbmd0aClcbiAgICByZXR1cm4gMDtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmlsdGVyKSkge1xuICAgIGlmIChrZXlbMF0gPT09IFwiI1wiICYmIEFycmF5LmlzQXJyYXkodmFsdWUpICYmICF2YWx1ZS5sZW5ndGgpXG4gICAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4oXG4gICAgTWF0aC5tYXgoMCwgZmlsdGVyLmxpbWl0ID8/IEluZmluaXR5KSxcbiAgICBmaWx0ZXIuaWRzPy5sZW5ndGggPz8gSW5maW5pdHksXG4gICAgZmlsdGVyLmF1dGhvcnM/Lmxlbmd0aCAmJiBmaWx0ZXIua2luZHM/LmV2ZXJ5KChraW5kKSA9PiBpc1JlcGxhY2VhYmxlS2luZChraW5kKSkgPyBmaWx0ZXIuYXV0aG9ycy5sZW5ndGggKiBmaWx0ZXIua2luZHMubGVuZ3RoIDogSW5maW5pdHksXG4gICAgZmlsdGVyLmF1dGhvcnM/Lmxlbmd0aCAmJiBmaWx0ZXIua2luZHM/LmV2ZXJ5KChraW5kKSA9PiBpc0FkZHJlc3NhYmxlS2luZChraW5kKSkgJiYgZmlsdGVyW1wiI2RcIl0/Lmxlbmd0aCA/IGZpbHRlci5hdXRob3JzLmxlbmd0aCAqIGZpbHRlci5raW5kcy5sZW5ndGggKiBmaWx0ZXJbXCIjZFwiXS5sZW5ndGggOiBJbmZpbml0eVxuICApO1xufVxuXG4vLyBmYWtlanNvbi50c1xudmFyIGZha2Vqc29uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGZha2Vqc29uX2V4cG9ydHMsIHtcbiAgZ2V0SGV4NjQ6ICgpID0+IGdldEhleDY0LFxuICBnZXRJbnQ6ICgpID0+IGdldEludCxcbiAgZ2V0U3Vic2NyaXB0aW9uSWQ6ICgpID0+IGdldFN1YnNjcmlwdGlvbklkLFxuICBtYXRjaEV2ZW50SWQ6ICgpID0+IG1hdGNoRXZlbnRJZCxcbiAgbWF0Y2hFdmVudEtpbmQ6ICgpID0+IG1hdGNoRXZlbnRLaW5kLFxuICBtYXRjaEV2ZW50UHVia2V5OiAoKSA9PiBtYXRjaEV2ZW50UHVia2V5XG59KTtcbmZ1bmN0aW9uIGdldEhleDY0KGpzb24sIGZpZWxkKSB7XG4gIGxldCBsZW4gPSBmaWVsZC5sZW5ndGggKyAzO1xuICBsZXQgaWR4ID0ganNvbi5pbmRleE9mKGBcIiR7ZmllbGR9XCI6YCkgKyBsZW47XG4gIGxldCBzID0ganNvbi5zbGljZShpZHgpLmluZGV4T2YoYFwiYCkgKyBpZHggKyAxO1xuICByZXR1cm4ganNvbi5zbGljZShzLCBzICsgNjQpO1xufVxuZnVuY3Rpb24gZ2V0SW50KGpzb24sIGZpZWxkKSB7XG4gIGxldCBsZW4gPSBmaWVsZC5sZW5ndGg7XG4gIGxldCBpZHggPSBqc29uLmluZGV4T2YoYFwiJHtmaWVsZH1cIjpgKSArIGxlbiArIDM7XG4gIGxldCBzbGljZWQgPSBqc29uLnNsaWNlKGlkeCk7XG4gIGxldCBlbmQgPSBNYXRoLm1pbihzbGljZWQuaW5kZXhPZihcIixcIiksIHNsaWNlZC5pbmRleE9mKFwifVwiKSk7XG4gIHJldHVybiBwYXJzZUludChzbGljZWQuc2xpY2UoMCwgZW5kKSwgMTApO1xufVxuZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uSWQoanNvbikge1xuICBsZXQgaWR4ID0ganNvbi5zbGljZSgwLCAyMikuaW5kZXhPZihgXCJFVkVOVFwiYCk7XG4gIGlmIChpZHggPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgcHN0YXJ0ID0ganNvbi5zbGljZShpZHggKyA3ICsgMSkuaW5kZXhPZihgXCJgKTtcbiAgaWYgKHBzdGFydCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBzdGFydCA9IGlkeCArIDcgKyAxICsgcHN0YXJ0O1xuICBsZXQgcGVuZCA9IGpzb24uc2xpY2Uoc3RhcnQgKyAxLCA4MCkuaW5kZXhPZihgXCJgKTtcbiAgaWYgKHBlbmQgPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgZW5kID0gc3RhcnQgKyAxICsgcGVuZDtcbiAgcmV0dXJuIGpzb24uc2xpY2Uoc3RhcnQgKyAxLCBlbmQpO1xufVxuZnVuY3Rpb24gbWF0Y2hFdmVudElkKGpzb24sIGlkKSB7XG4gIHJldHVybiBpZCA9PT0gZ2V0SGV4NjQoanNvbiwgXCJpZFwiKTtcbn1cbmZ1bmN0aW9uIG1hdGNoRXZlbnRQdWJrZXkoanNvbiwgcHVia2V5KSB7XG4gIHJldHVybiBwdWJrZXkgPT09IGdldEhleDY0KGpzb24sIFwicHVia2V5XCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hFdmVudEtpbmQoanNvbiwga2luZCkge1xuICByZXR1cm4ga2luZCA9PT0gZ2V0SW50KGpzb24sIFwia2luZFwiKTtcbn1cblxuLy8gbmlwNDIudHNcbnZhciBuaXA0Ml9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA0Ml9leHBvcnRzLCB7XG4gIG1ha2VBdXRoRXZlbnQ6ICgpID0+IG1ha2VBdXRoRXZlbnRcbn0pO1xuZnVuY3Rpb24gbWFrZUF1dGhFdmVudChyZWxheVVSTCwgY2hhbGxlbmdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogQ2xpZW50QXV0aCxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpLFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInJlbGF5XCIsIHJlbGF5VVJMXSxcbiAgICAgIFtcImNoYWxsZW5nZVwiLCBjaGFsbGVuZ2VdXG4gICAgXSxcbiAgICBjb250ZW50OiBcIlwiXG4gIH07XG59XG5cbi8vIGhlbHBlcnMudHNcbmFzeW5jIGZ1bmN0aW9uIHlpZWxkVGhyZWFkKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBjaCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjaC5wb3J0MS5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGNoLnBvcnQxLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgIGNoLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgIGNoLnBvcnQxLnN0YXJ0KCk7XG4gIH0pO1xufVxudmFyIGFsd2F5c1RydWUgPSAodCkgPT4ge1xuICB0W3ZlcmlmaWVkU3ltYm9sXSA9IHRydWU7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gYWJzdHJhY3QtcmVsYXkudHNcbnZhciBBYnN0cmFjdFJlbGF5ID0gY2xhc3Mge1xuICB1cmw7XG4gIF9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgb25jbG9zZSA9IG51bGw7XG4gIG9ubm90aWNlID0gKG1zZykgPT4gY29uc29sZS5kZWJ1ZyhgTk9USUNFIGZyb20gJHt0aGlzLnVybH06ICR7bXNnfWApO1xuICBfb25hdXRoID0gbnVsbDtcbiAgYmFzZUVvc2VUaW1lb3V0ID0gNDQwMDtcbiAgY29ubmVjdGlvblRpbWVvdXQgPSA0NDAwO1xuICBwdWJsaXNoVGltZW91dCA9IDQ0MDA7XG4gIG9wZW5TdWJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29ubmVjdGlvblRpbWVvdXRIYW5kbGU7XG4gIGNvbm5lY3Rpb25Qcm9taXNlO1xuICBvcGVuQ291bnRSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIG9wZW5FdmVudFB1Ymxpc2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHdzO1xuICBpbmNvbWluZ01lc3NhZ2VRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuICBxdWV1ZVJ1bm5pbmcgPSBmYWxzZTtcbiAgY2hhbGxlbmdlO1xuICBhdXRoUHJvbWlzZTtcbiAgc2VyaWFsID0gMDtcbiAgdmVyaWZ5RXZlbnQ7XG4gIF9XZWJTb2NrZXQ7XG4gIGNvbnN0cnVjdG9yKHVybCwgb3B0cykge1xuICAgIHRoaXMudXJsID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgdGhpcy52ZXJpZnlFdmVudCA9IG9wdHMudmVyaWZ5RXZlbnQ7XG4gICAgdGhpcy5fV2ViU29ja2V0ID0gb3B0cy53ZWJzb2NrZXRJbXBsZW1lbnRhdGlvbiB8fCBXZWJTb2NrZXQ7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbm5lY3QodXJsLCBvcHRzKSB7XG4gICAgY29uc3QgcmVsYXkgPSBuZXcgQWJzdHJhY3RSZWxheSh1cmwsIG9wdHMpO1xuICAgIGF3YWl0IHJlbGF5LmNvbm5lY3QoKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgY2xvc2VBbGxTdWJzY3JpcHRpb25zKHJlYXNvbikge1xuICAgIGZvciAobGV0IFtfLCBzdWJdIG9mIHRoaXMub3BlblN1YnMpIHtcbiAgICAgIHN1Yi5jbG9zZShyZWFzb24pO1xuICAgIH1cbiAgICB0aGlzLm9wZW5TdWJzLmNsZWFyKCk7XG4gICAgZm9yIChsZXQgW18sIGVwXSBvZiB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcykge1xuICAgICAgZXAucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICB9XG4gICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuY2xlYXIoKTtcbiAgICBmb3IgKGxldCBbXywgY3JdIG9mIHRoaXMub3BlbkNvdW50UmVxdWVzdHMpIHtcbiAgICAgIGNyLnJlamVjdChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgfVxuICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuY2xlYXIoKTtcbiAgfVxuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0ZWQ7XG4gIH1cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uUHJvbWlzZSlcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICAgIHRoaXMuY2hhbGxlbmdlID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aFByb21pc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KFwiY29ubmVjdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKFwicmVsYXkgY29ubmVjdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICB9LCB0aGlzLmNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMud3MgPSBuZXcgdGhpcy5fV2ViU29ja2V0KHRoaXMudXJsKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25lcnJvciA9IChldikgPT4ge1xuICAgICAgICByZWplY3QoZXYubWVzc2FnZSB8fCBcIndlYnNvY2tldCBlcnJvclwiKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgdGhpcy5vbmNsb3NlPy4oKTtcbiAgICAgICAgICB0aGlzLmNsb3NlQWxsU3Vic2NyaXB0aW9ucyhcInJlbGF5IGNvbm5lY3Rpb24gZXJyb3JlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25jbG9zZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgdGhpcy5vbmNsb3NlPy4oKTtcbiAgICAgICAgICB0aGlzLmNsb3NlQWxsU3Vic2NyaXB0aW9ucyhcInJlbGF5IGNvbm5lY3Rpb24gY2xvc2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSB0aGlzLl9vbm1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uUHJvbWlzZTtcbiAgfVxuICBhc3luYyBydW5RdWV1ZSgpIHtcbiAgICB0aGlzLnF1ZXVlUnVubmluZyA9IHRydWU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gdGhpcy5oYW5kbGVOZXh0KCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBhd2FpdCB5aWVsZFRocmVhZCgpO1xuICAgIH1cbiAgICB0aGlzLnF1ZXVlUnVubmluZyA9IGZhbHNlO1xuICB9XG4gIGhhbmRsZU5leHQoKSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuaW5jb21pbmdNZXNzYWdlUXVldWUuZGVxdWV1ZSgpO1xuICAgIGlmICghanNvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzdWJpZCA9IGdldFN1YnNjcmlwdGlvbklkKGpzb24pO1xuICAgIGlmIChzdWJpZCkge1xuICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChzdWJpZCk7XG4gICAgICBpZiAoIXNvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlkID0gZ2V0SGV4NjQoanNvbiwgXCJpZFwiKTtcbiAgICAgIGNvbnN0IGFscmVhZHlIYXZlID0gc28uYWxyZWFkeUhhdmVFdmVudD8uKGlkKTtcbiAgICAgIHNvLnJlY2VpdmVkRXZlbnQ/Lih0aGlzLCBpZCk7XG4gICAgICBpZiAoYWxyZWFkeUhhdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgc3dpdGNoIChkYXRhWzBdKSB7XG4gICAgICAgIGNhc2UgXCJFVkVOVFwiOiB7XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChkYXRhWzFdKTtcbiAgICAgICAgICBjb25zdCBldmVudCA9IGRhdGFbMl07XG4gICAgICAgICAgaWYgKHRoaXMudmVyaWZ5RXZlbnQoZXZlbnQpICYmIG1hdGNoRmlsdGVycyhzby5maWx0ZXJzLCBldmVudCkpIHtcbiAgICAgICAgICAgIHNvLm9uZXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkNPVU5UXCI6IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGRhdGFbMV07XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGFbMl07XG4gICAgICAgICAgY29uc3QgY3IgPSB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmdldChpZCk7XG4gICAgICAgICAgaWYgKGNyKSB7XG4gICAgICAgICAgICBjci5yZXNvbHZlKHBheWxvYWQuY291bnQpO1xuICAgICAgICAgICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5kZWxldGUoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkVPU0VcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoZGF0YVsxXSk7XG4gICAgICAgICAgaWYgKCFzbylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBzby5yZWNlaXZlZEVvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9LXCI6IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGRhdGFbMV07XG4gICAgICAgICAgY29uc3Qgb2sgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGRhdGFbM107XG4gICAgICAgICAgY29uc3QgZXAgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoaWQpO1xuICAgICAgICAgIGlmIChlcCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGVwLnRpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKG9rKVxuICAgICAgICAgICAgICBlcC5yZXNvbHZlKHJlYXNvbik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGVwLnJlamVjdChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5kZWxldGUoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkNMT1NFRFwiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoaWQpO1xuICAgICAgICAgIGlmICghc28pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgc28uY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICBzby5jbG9zZShkYXRhWzJdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk5PVElDRVwiOlxuICAgICAgICAgIHRoaXMub25ub3RpY2UoZGF0YVsxXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiQVVUSFwiOiB7XG4gICAgICAgICAgdGhpcy5jaGFsbGVuZ2UgPSBkYXRhWzFdO1xuICAgICAgICAgIHRoaXMuYXV0aFByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgdGhpcy5fb25hdXRoPy4oZGF0YVsxXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGFzeW5jIHNlbmQobWVzc2FnZSkge1xuICAgIGlmICghdGhpcy5jb25uZWN0aW9uUHJvbWlzZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNlbmRpbmcgb24gY2xvc2VkIGNvbm5lY3Rpb25cIik7XG4gICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMud3M/LnNlbmQobWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYXV0aChzaWduQXV0aEV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmNoYWxsZW5nZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHBlcmZvcm0gYXV0aCwgbm8gY2hhbGxlbmdlIHdhcyByZWNlaXZlZFwiKTtcbiAgICBpZiAodGhpcy5hdXRoUHJvbWlzZSlcbiAgICAgIHJldHVybiB0aGlzLmF1dGhQcm9taXNlO1xuICAgIGNvbnN0IGV2dCA9IGF3YWl0IHNpZ25BdXRoRXZlbnQobWFrZUF1dGhFdmVudCh0aGlzLnVybCwgdGhpcy5jaGFsbGVuZ2UpKTtcbiAgICB0aGlzLmF1dGhQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBlcCA9IHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmdldChldnQuaWQpO1xuICAgICAgICBpZiAoZXApIHtcbiAgICAgICAgICBlcC5yZWplY3QobmV3IEVycm9yKFwiYXV0aCB0aW1lZCBvdXRcIikpO1xuICAgICAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmRlbGV0ZShldnQuaWQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLnB1Ymxpc2hUaW1lb3V0KTtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldnQuaWQsIHsgcmVzb2x2ZSwgcmVqZWN0LCB0aW1lb3V0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZCgnW1wiQVVUSFwiLCcgKyBKU09OLnN0cmluZ2lmeShldnQpICsgXCJdXCIpO1xuICAgIHJldHVybiB0aGlzLmF1dGhQcm9taXNlO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goZXZlbnQpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVwID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGV2ZW50LmlkKTtcbiAgICAgICAgaWYgKGVwKSB7XG4gICAgICAgICAgZXAucmVqZWN0KG5ldyBFcnJvcihcInB1Ymxpc2ggdGltZWQgb3V0XCIpKTtcbiAgICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5kZWxldGUoZXZlbnQuaWQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLnB1Ymxpc2hUaW1lb3V0KTtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldmVudC5pZCwgeyByZXNvbHZlLCByZWplY3QsIHRpbWVvdXQgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJFVkVOVFwiLCcgKyBKU09OLnN0cmluZ2lmeShldmVudCkgKyBcIl1cIik7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBhc3luYyBjb3VudChmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnNlcmlhbCsrO1xuICAgIGNvbnN0IGlkID0gcGFyYW1zPy5pZCB8fCBcImNvdW50OlwiICsgdGhpcy5zZXJpYWw7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZCgnW1wiQ09VTlRcIixcIicgKyBpZCArICdcIiwnICsgSlNPTi5zdHJpbmdpZnkoZmlsdGVycykuc3Vic3RyaW5nKDEpKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHN1YnNjcmliZShmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLnByZXBhcmVTdWJzY3JpcHRpb24oZmlsdGVycywgcGFyYW1zKTtcbiAgICBzdWJzY3JpcHRpb24uZmlyZSgpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbiAgcHJlcGFyZVN1YnNjcmlwdGlvbihmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnNlcmlhbCsrO1xuICAgIGNvbnN0IGlkID0gcGFyYW1zLmlkIHx8IChwYXJhbXMubGFiZWwgPyBwYXJhbXMubGFiZWwgKyBcIjpcIiA6IFwic3ViOlwiKSArIHRoaXMuc2VyaWFsO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGhpcywgaWQsIGZpbHRlcnMsIHBhcmFtcyk7XG4gICAgdGhpcy5vcGVuU3Vicy5zZXQoaWQsIHN1YnNjcmlwdGlvbik7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmNsb3NlQWxsU3Vic2NyaXB0aW9ucyhcInJlbGF5IGNvbm5lY3Rpb24gY2xvc2VkIGJ5IHVzXCIpO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMud3M/LmNsb3NlKCk7XG4gIH1cbiAgX29ubWVzc2FnZShldikge1xuICAgIHRoaXMuaW5jb21pbmdNZXNzYWdlUXVldWUuZW5xdWV1ZShldi5kYXRhKTtcbiAgICBpZiAoIXRoaXMucXVldWVSdW5uaW5nKSB7XG4gICAgICB0aGlzLnJ1blF1ZXVlKCk7XG4gICAgfVxuICB9XG59O1xudmFyIFN1YnNjcmlwdGlvbiA9IGNsYXNzIHtcbiAgcmVsYXk7XG4gIGlkO1xuICBjbG9zZWQgPSBmYWxzZTtcbiAgZW9zZWQgPSBmYWxzZTtcbiAgZmlsdGVycztcbiAgYWxyZWFkeUhhdmVFdmVudDtcbiAgcmVjZWl2ZWRFdmVudDtcbiAgb25ldmVudDtcbiAgb25lb3NlO1xuICBvbmNsb3NlO1xuICBlb3NlVGltZW91dDtcbiAgZW9zZVRpbWVvdXRIYW5kbGU7XG4gIGNvbnN0cnVjdG9yKHJlbGF5LCBpZCwgZmlsdGVycywgcGFyYW1zKSB7XG4gICAgdGhpcy5yZWxheSA9IHJlbGF5O1xuICAgIHRoaXMuZmlsdGVycyA9IGZpbHRlcnM7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuYWxyZWFkeUhhdmVFdmVudCA9IHBhcmFtcy5hbHJlYWR5SGF2ZUV2ZW50O1xuICAgIHRoaXMucmVjZWl2ZWRFdmVudCA9IHBhcmFtcy5yZWNlaXZlZEV2ZW50O1xuICAgIHRoaXMuZW9zZVRpbWVvdXQgPSBwYXJhbXMuZW9zZVRpbWVvdXQgfHwgcmVsYXkuYmFzZUVvc2VUaW1lb3V0O1xuICAgIHRoaXMub25lb3NlID0gcGFyYW1zLm9uZW9zZTtcbiAgICB0aGlzLm9uY2xvc2UgPSBwYXJhbXMub25jbG9zZTtcbiAgICB0aGlzLm9uZXZlbnQgPSBwYXJhbXMub25ldmVudCB8fCAoKGV2ZW50KSA9PiB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBvbmV2ZW50KCkgY2FsbGJhY2sgbm90IGRlZmluZWQgZm9yIHN1YnNjcmlwdGlvbiAnJHt0aGlzLmlkfScgaW4gcmVsYXkgJHt0aGlzLnJlbGF5LnVybH0uIGV2ZW50IHJlY2VpdmVkOmAsXG4gICAgICAgIGV2ZW50XG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGZpcmUoKSB7XG4gICAgdGhpcy5yZWxheS5zZW5kKCdbXCJSRVFcIixcIicgKyB0aGlzLmlkICsgJ1wiLCcgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmZpbHRlcnMpLnN1YnN0cmluZygxKSk7XG4gICAgdGhpcy5lb3NlVGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQodGhpcy5yZWNlaXZlZEVvc2UuYmluZCh0aGlzKSwgdGhpcy5lb3NlVGltZW91dCk7XG4gIH1cbiAgcmVjZWl2ZWRFb3NlKCkge1xuICAgIGlmICh0aGlzLmVvc2VkKVxuICAgICAgcmV0dXJuO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmVvc2VUaW1lb3V0SGFuZGxlKTtcbiAgICB0aGlzLmVvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLm9uZW9zZT8uKCk7XG4gIH1cbiAgY2xvc2UocmVhc29uID0gXCJjbG9zZWQgYnkgY2FsbGVyXCIpIHtcbiAgICBpZiAoIXRoaXMuY2xvc2VkICYmIHRoaXMucmVsYXkuY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnJlbGF5LnNlbmQoJ1tcIkNMT1NFXCIsJyArIEpTT04uc3RyaW5naWZ5KHRoaXMuaWQpICsgXCJdXCIpO1xuICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnJlbGF5Lm9wZW5TdWJzLmRlbGV0ZSh0aGlzLmlkKTtcbiAgICB0aGlzLm9uY2xvc2U/LihyZWFzb24pO1xuICB9XG59O1xuXG4vLyByZWxheS50c1xudmFyIF9XZWJTb2NrZXQ7XG50cnkge1xuICBfV2ViU29ja2V0ID0gV2ViU29ja2V0O1xufSBjYXRjaCB7XG59XG52YXIgUmVsYXkgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0UmVsYXkge1xuICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICBzdXBlcih1cmwsIHsgdmVyaWZ5RXZlbnQsIHdlYnNvY2tldEltcGxlbWVudGF0aW9uOiBfV2ViU29ja2V0IH0pO1xuICB9XG4gIHN0YXRpYyBhc3luYyBjb25uZWN0KHVybCkge1xuICAgIGNvbnN0IHJlbGF5ID0gbmV3IFJlbGF5KHVybCk7XG4gICAgYXdhaXQgcmVsYXkuY29ubmVjdCgpO1xuICAgIHJldHVybiByZWxheTtcbiAgfVxufTtcblxuLy8gYWJzdHJhY3QtcG9vbC50c1xudmFyIEFic3RyYWN0U2ltcGxlUG9vbCA9IGNsYXNzIHtcbiAgcmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc2Vlbk9uID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgdHJhY2tSZWxheXMgPSBmYWxzZTtcbiAgdmVyaWZ5RXZlbnQ7XG4gIHRydXN0ZWRSZWxheVVSTHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBfV2ViU29ja2V0O1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy52ZXJpZnlFdmVudCA9IG9wdHMudmVyaWZ5RXZlbnQ7XG4gICAgdGhpcy5fV2ViU29ja2V0ID0gb3B0cy53ZWJzb2NrZXRJbXBsZW1lbnRhdGlvbjtcbiAgfVxuICBhc3luYyBlbnN1cmVSZWxheSh1cmwsIHBhcmFtcykge1xuICAgIHVybCA9IG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgIGxldCByZWxheSA9IHRoaXMucmVsYXlzLmdldCh1cmwpO1xuICAgIGlmICghcmVsYXkpIHtcbiAgICAgIHJlbGF5ID0gbmV3IEFic3RyYWN0UmVsYXkodXJsLCB7XG4gICAgICAgIHZlcmlmeUV2ZW50OiB0aGlzLnRydXN0ZWRSZWxheVVSTHMuaGFzKHVybCkgPyBhbHdheXNUcnVlIDogdGhpcy52ZXJpZnlFdmVudCxcbiAgICAgICAgd2Vic29ja2V0SW1wbGVtZW50YXRpb246IHRoaXMuX1dlYlNvY2tldFxuICAgICAgfSk7XG4gICAgICBpZiAocGFyYW1zPy5jb25uZWN0aW9uVGltZW91dClcbiAgICAgICAgcmVsYXkuY29ubmVjdGlvblRpbWVvdXQgPSBwYXJhbXMuY29ubmVjdGlvblRpbWVvdXQ7XG4gICAgICB0aGlzLnJlbGF5cy5zZXQodXJsLCByZWxheSk7XG4gICAgfVxuICAgIGF3YWl0IHJlbGF5LmNvbm5lY3QoKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgY2xvc2UocmVsYXlzKSB7XG4gICAgcmVsYXlzLm1hcChub3JtYWxpemVVUkwpLmZvckVhY2goKHVybCkgPT4ge1xuICAgICAgdGhpcy5yZWxheXMuZ2V0KHVybCk/LmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbiAgc3Vic2NyaWJlKHJlbGF5cywgZmlsdGVyLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmVNYXAoXG4gICAgICByZWxheXMubWFwKCh1cmwpID0+ICh7IHVybCwgZmlsdGVyIH0pKSxcbiAgICAgIHBhcmFtc1xuICAgICk7XG4gIH1cbiAgc3Vic2NyaWJlTWFueShyZWxheXMsIGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZU1hcChcbiAgICAgIHJlbGF5cy5mbGF0TWFwKCh1cmwpID0+IGZpbHRlcnMubWFwKChmaWx0ZXIpID0+ICh7IHVybCwgZmlsdGVyIH0pKSksXG4gICAgICBwYXJhbXNcbiAgICApO1xuICB9XG4gIHN1YnNjcmliZU1hcChyZXF1ZXN0cywgcGFyYW1zKSB7XG4gICAgaWYgKHRoaXMudHJhY2tSZWxheXMpIHtcbiAgICAgIHBhcmFtcy5yZWNlaXZlZEV2ZW50ID0gKHJlbGF5LCBpZCkgPT4ge1xuICAgICAgICBsZXQgc2V0ID0gdGhpcy5zZWVuT24uZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFzZXQpIHtcbiAgICAgICAgICBzZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgIHRoaXMuc2Vlbk9uLnNldChpZCwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBzZXQuYWRkKHJlbGF5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IF9rbm93bklkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgc3VicyA9IFtdO1xuICAgIGNvbnN0IGVvc2VzUmVjZWl2ZWQgPSBbXTtcbiAgICBsZXQgaGFuZGxlRW9zZSA9IChpMikgPT4ge1xuICAgICAgaWYgKGVvc2VzUmVjZWl2ZWRbaTJdKVxuICAgICAgICByZXR1cm47XG4gICAgICBlb3Nlc1JlY2VpdmVkW2kyXSA9IHRydWU7XG4gICAgICBpZiAoZW9zZXNSZWNlaXZlZC5maWx0ZXIoKGEpID0+IGEpLmxlbmd0aCA9PT0gcmVxdWVzdHMubGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5vbmVvc2U/LigpO1xuICAgICAgICBoYW5kbGVFb3NlID0gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2xvc2VzUmVjZWl2ZWQgPSBbXTtcbiAgICBsZXQgaGFuZGxlQ2xvc2UgPSAoaTIsIHJlYXNvbikgPT4ge1xuICAgICAgaWYgKGNsb3Nlc1JlY2VpdmVkW2kyXSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaGFuZGxlRW9zZShpMik7XG4gICAgICBjbG9zZXNSZWNlaXZlZFtpMl0gPSByZWFzb247XG4gICAgICBpZiAoY2xvc2VzUmVjZWl2ZWQuZmlsdGVyKChhKSA9PiBhKS5sZW5ndGggPT09IHJlcXVlc3RzLmxlbmd0aCkge1xuICAgICAgICBwYXJhbXMub25jbG9zZT8uKGNsb3Nlc1JlY2VpdmVkKTtcbiAgICAgICAgaGFuZGxlQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2NhbEFscmVhZHlIYXZlRXZlbnRIYW5kbGVyID0gKGlkKSA9PiB7XG4gICAgICBpZiAocGFyYW1zLmFscmVhZHlIYXZlRXZlbnQ/LihpZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBoYXZlID0gX2tub3duSWRzLmhhcyhpZCk7XG4gICAgICBfa25vd25JZHMuYWRkKGlkKTtcbiAgICAgIHJldHVybiBoYXZlO1xuICAgIH07XG4gICAgY29uc3QgYWxsT3BlbmVkID0gUHJvbWlzZS5hbGwoXG4gICAgICByZXF1ZXN0cy5tYXAoYXN5bmMgKHsgdXJsLCBmaWx0ZXIgfSwgaTIpID0+IHtcbiAgICAgICAgdXJsID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgICAgIGxldCByZWxheTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWxheSA9IGF3YWl0IHRoaXMuZW5zdXJlUmVsYXkodXJsLCB7XG4gICAgICAgICAgICBjb25uZWN0aW9uVGltZW91dDogcGFyYW1zLm1heFdhaXQgPyBNYXRoLm1heChwYXJhbXMubWF4V2FpdCAqIDAuOCwgcGFyYW1zLm1heFdhaXQgLSAxZTMpIDogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCBlcnI/Lm1lc3NhZ2UgfHwgU3RyaW5nKGVycikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3Vic2NyaXB0aW9uID0gcmVsYXkuc3Vic2NyaWJlKFtmaWx0ZXJdLCB7XG4gICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgIG9uZW9zZTogKCkgPT4gaGFuZGxlRW9zZShpMiksXG4gICAgICAgICAgb25jbG9zZTogKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHJlYXNvbi5zdGFydHNXaXRoKFwiYXV0aC1yZXF1aXJlZDpcIikgJiYgcGFyYW1zLmRvYXV0aCkge1xuICAgICAgICAgICAgICByZWxheS5hdXRoKHBhcmFtcy5kb2F1dGgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlbGF5LnN1YnNjcmliZShbZmlsdGVyXSwge1xuICAgICAgICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgICAgICAgb25lb3NlOiAoKSA9PiBoYW5kbGVFb3NlKGkyKSxcbiAgICAgICAgICAgICAgICAgIG9uY2xvc2U6IChyZWFzb24yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCByZWFzb24yKTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBhbHJlYWR5SGF2ZUV2ZW50OiBsb2NhbEFscmVhZHlIYXZlRXZlbnRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgZW9zZVRpbWVvdXQ6IHBhcmFtcy5tYXhXYWl0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgYGF1dGggd2FzIHJlcXVpcmVkIGFuZCBhdHRlbXB0ZWQsIGJ1dCBmYWlsZWQgd2l0aDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaGFuZGxlQ2xvc2UoaTIsIHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbHJlYWR5SGF2ZUV2ZW50OiBsb2NhbEFscmVhZHlIYXZlRXZlbnRIYW5kbGVyLFxuICAgICAgICAgIGVvc2VUaW1lb3V0OiBwYXJhbXMubWF4V2FpdFxuICAgICAgICB9KTtcbiAgICAgICAgc3Vicy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBhd2FpdCBhbGxPcGVuZWQ7XG4gICAgICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICAgICAgc3ViLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3Vic2NyaWJlTWFueU1hcChyZXF1ZXN0cywgcGFyYW1zKSB7XG4gICAgaWYgKHRoaXMudHJhY2tSZWxheXMpIHtcbiAgICAgIHBhcmFtcy5yZWNlaXZlZEV2ZW50ID0gKHJlbGF5LCBpZCkgPT4ge1xuICAgICAgICBsZXQgc2V0ID0gdGhpcy5zZWVuT24uZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFzZXQpIHtcbiAgICAgICAgICBzZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgIHRoaXMuc2Vlbk9uLnNldChpZCwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBzZXQuYWRkKHJlbGF5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IF9rbm93bklkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgc3VicyA9IFtdO1xuICAgIGNvbnN0IHJlbGF5c0xlbmd0aCA9IE9iamVjdC5rZXlzKHJlcXVlc3RzKS5sZW5ndGg7XG4gICAgY29uc3QgZW9zZXNSZWNlaXZlZCA9IFtdO1xuICAgIGxldCBoYW5kbGVFb3NlID0gKGkyKSA9PiB7XG4gICAgICBpZiAoZW9zZXNSZWNlaXZlZFtpMl0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGVvc2VzUmVjZWl2ZWRbaTJdID0gdHJ1ZTtcbiAgICAgIGlmIChlb3Nlc1JlY2VpdmVkLmZpbHRlcigoYSkgPT4gYSkubGVuZ3RoID09PSByZWxheXNMZW5ndGgpIHtcbiAgICAgICAgcGFyYW1zLm9uZW9zZT8uKCk7XG4gICAgICAgIGhhbmRsZUVvc2UgPSAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjbG9zZXNSZWNlaXZlZCA9IFtdO1xuICAgIGxldCBoYW5kbGVDbG9zZSA9IChpMiwgcmVhc29uKSA9PiB7XG4gICAgICBpZiAoY2xvc2VzUmVjZWl2ZWRbaTJdKVxuICAgICAgICByZXR1cm47XG4gICAgICBoYW5kbGVFb3NlKGkyKTtcbiAgICAgIGNsb3Nlc1JlY2VpdmVkW2kyXSA9IHJlYXNvbjtcbiAgICAgIGlmIChjbG9zZXNSZWNlaXZlZC5maWx0ZXIoKGEpID0+IGEpLmxlbmd0aCA9PT0gcmVsYXlzTGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5vbmNsb3NlPy4oY2xvc2VzUmVjZWl2ZWQpO1xuICAgICAgICBoYW5kbGVDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxvY2FsQWxyZWFkeUhhdmVFdmVudEhhbmRsZXIgPSAoaWQpID0+IHtcbiAgICAgIGlmIChwYXJhbXMuYWxyZWFkeUhhdmVFdmVudD8uKGlkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhhdmUgPSBfa25vd25JZHMuaGFzKGlkKTtcbiAgICAgIF9rbm93bklkcy5hZGQoaWQpO1xuICAgICAgcmV0dXJuIGhhdmU7XG4gICAgfTtcbiAgICBjb25zdCBhbGxPcGVuZWQgPSBQcm9taXNlLmFsbChcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJlcXVlc3RzKS5tYXAoYXN5bmMgKHJlcSwgaTIsIGFycikgPT4ge1xuICAgICAgICBpZiAoYXJyLmluZGV4T2YocmVxKSAhPT0gaTIpIHtcbiAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgXCJkdXBsaWNhdGUgdXJsXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgW3VybCwgZmlsdGVyc10gPSByZXE7XG4gICAgICAgIHVybCA9IG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgICAgICBsZXQgcmVsYXk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVsYXkgPSBhd2FpdCB0aGlzLmVuc3VyZVJlbGF5KHVybCwge1xuICAgICAgICAgICAgY29ubmVjdGlvblRpbWVvdXQ6IHBhcmFtcy5tYXhXYWl0ID8gTWF0aC5tYXgocGFyYW1zLm1heFdhaXQgKiAwLjgsIHBhcmFtcy5tYXhXYWl0IC0gMWUzKSA6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgZXJyPy5tZXNzYWdlIHx8IFN0cmluZyhlcnIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IHJlbGF5LnN1YnNjcmliZShmaWx0ZXJzLCB7XG4gICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgIG9uZW9zZTogKCkgPT4gaGFuZGxlRW9zZShpMiksXG4gICAgICAgICAgb25jbG9zZTogKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHJlYXNvbi5zdGFydHNXaXRoKFwiYXV0aC1yZXF1aXJlZDpcIikgJiYgcGFyYW1zLmRvYXV0aCkge1xuICAgICAgICAgICAgICByZWxheS5hdXRoKHBhcmFtcy5kb2F1dGgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlbGF5LnN1YnNjcmliZShmaWx0ZXJzLCB7XG4gICAgICAgICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICAgICAgICBvbmVvc2U6ICgpID0+IGhhbmRsZUVvc2UoaTIpLFxuICAgICAgICAgICAgICAgICAgb25jbG9zZTogKHJlYXNvbjIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ2xvc2UoaTIsIHJlYXNvbjIpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGFscmVhZHlIYXZlRXZlbnQ6IGxvY2FsQWxyZWFkeUhhdmVFdmVudEhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICBlb3NlVGltZW91dDogcGFyYW1zLm1heFdhaXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCBgYXV0aCB3YXMgcmVxdWlyZWQgYW5kIGF0dGVtcHRlZCwgYnV0IGZhaWxlZCB3aXRoOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGFscmVhZHlIYXZlRXZlbnQ6IGxvY2FsQWxyZWFkeUhhdmVFdmVudEhhbmRsZXIsXG4gICAgICAgICAgZW9zZVRpbWVvdXQ6IHBhcmFtcy5tYXhXYWl0XG4gICAgICAgIH0pO1xuICAgICAgICBzdWJzLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIGF3YWl0IGFsbE9wZW5lZDtcbiAgICAgICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgICAgICBzdWIuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBzdWJzY3JpYmVFb3NlKHJlbGF5cywgZmlsdGVyLCBwYXJhbXMpIHtcbiAgICBjb25zdCBzdWJjbG9zZXIgPSB0aGlzLnN1YnNjcmliZShyZWxheXMsIGZpbHRlciwge1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgb25lb3NlKCkge1xuICAgICAgICBzdWJjbG9zZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3ViY2xvc2VyO1xuICB9XG4gIHN1YnNjcmliZU1hbnlFb3NlKHJlbGF5cywgZmlsdGVycywgcGFyYW1zKSB7XG4gICAgY29uc3Qgc3ViY2xvc2VyID0gdGhpcy5zdWJzY3JpYmVNYW55KHJlbGF5cywgZmlsdGVycywge1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgb25lb3NlKCkge1xuICAgICAgICBzdWJjbG9zZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3ViY2xvc2VyO1xuICB9XG4gIGFzeW5jIHF1ZXJ5U3luYyhyZWxheXMsIGZpbHRlciwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBldmVudHMgPSBbXTtcbiAgICAgIHRoaXMuc3Vic2NyaWJlRW9zZShyZWxheXMsIGZpbHRlciwge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIG9uZXZlbnQoZXZlbnQpIHtcbiAgICAgICAgICBldmVudHMucHVzaChldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2xvc2UoXykge1xuICAgICAgICAgIHJlc29sdmUoZXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0KHJlbGF5cywgZmlsdGVyLCBwYXJhbXMpIHtcbiAgICBmaWx0ZXIubGltaXQgPSAxO1xuICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IHRoaXMucXVlcnlTeW5jKHJlbGF5cywgZmlsdGVyLCBwYXJhbXMpO1xuICAgIGV2ZW50cy5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQpO1xuICAgIHJldHVybiBldmVudHNbMF0gfHwgbnVsbDtcbiAgfVxuICBwdWJsaXNoKHJlbGF5cywgZXZlbnQpIHtcbiAgICByZXR1cm4gcmVsYXlzLm1hcChub3JtYWxpemVVUkwpLm1hcChhc3luYyAodXJsLCBpMiwgYXJyKSA9PiB7XG4gICAgICBpZiAoYXJyLmluZGV4T2YodXJsKSAhPT0gaTIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiZHVwbGljYXRlIHVybFwiKTtcbiAgICAgIH1cbiAgICAgIGxldCByID0gYXdhaXQgdGhpcy5lbnN1cmVSZWxheSh1cmwpO1xuICAgICAgcmV0dXJuIHIucHVibGlzaChldmVudCkudGhlbigocmVhc29uKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNrUmVsYXlzKSB7XG4gICAgICAgICAgbGV0IHNldCA9IHRoaXMuc2Vlbk9uLmdldChldmVudC5pZCk7XG4gICAgICAgICAgaWYgKCFzZXQpIHtcbiAgICAgICAgICAgIHNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgICB0aGlzLnNlZW5Pbi5zZXQoZXZlbnQuaWQsIHNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldC5hZGQocik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYXNvbjtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGxpc3RDb25uZWN0aW9uU3RhdHVzKCkge1xuICAgIGNvbnN0IG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5yZWxheXMuZm9yRWFjaCgocmVsYXksIHVybCkgPT4gbWFwLnNldCh1cmwsIHJlbGF5LmNvbm5lY3RlZCkpO1xuICAgIHJldHVybiBtYXA7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbGF5cy5mb3JFYWNoKChjb25uKSA9PiBjb25uLmNsb3NlKCkpO1xuICAgIHRoaXMucmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxufTtcblxuLy8gcG9vbC50c1xudmFyIF9XZWJTb2NrZXQyO1xudHJ5IHtcbiAgX1dlYlNvY2tldDIgPSBXZWJTb2NrZXQ7XG59IGNhdGNoIHtcbn1cbnZhciBTaW1wbGVQb29sID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFNpbXBsZVBvb2wge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7IHZlcmlmeUV2ZW50LCB3ZWJzb2NrZXRJbXBsZW1lbnRhdGlvbjogX1dlYlNvY2tldDIgfSk7XG4gIH1cbn07XG5cbi8vIG5pcDE5LnRzXG52YXIgbmlwMTlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMTlfZXhwb3J0cywge1xuICBCRUNIMzJfUkVHRVg6ICgpID0+IEJFQ0gzMl9SRUdFWCxcbiAgQmVjaDMyTWF4U2l6ZTogKCkgPT4gQmVjaDMyTWF4U2l6ZSxcbiAgTm9zdHJUeXBlR3VhcmQ6ICgpID0+IE5vc3RyVHlwZUd1YXJkLFxuICBkZWNvZGU6ICgpID0+IGRlY29kZSxcbiAgZGVjb2RlTm9zdHJVUkk6ICgpID0+IGRlY29kZU5vc3RyVVJJLFxuICBlbmNvZGVCeXRlczogKCkgPT4gZW5jb2RlQnl0ZXMsXG4gIG5hZGRyRW5jb2RlOiAoKSA9PiBuYWRkckVuY29kZSxcbiAgbmV2ZW50RW5jb2RlOiAoKSA9PiBuZXZlbnRFbmNvZGUsXG4gIG5vdGVFbmNvZGU6ICgpID0+IG5vdGVFbmNvZGUsXG4gIG5wcm9maWxlRW5jb2RlOiAoKSA9PiBucHJvZmlsZUVuY29kZSxcbiAgbnB1YkVuY29kZTogKCkgPT4gbnB1YkVuY29kZSxcbiAgbnNlY0VuY29kZTogKCkgPT4gbnNlY0VuY29kZVxufSk7XG52YXIgaW1wb3J0X3V0aWxzNSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xudmFyIGltcG9ydF9iYXNlID0gcmVxdWlyZShcIkBzY3VyZS9iYXNlXCIpO1xudmFyIE5vc3RyVHlwZUd1YXJkID0ge1xuICBpc05Qcm9maWxlOiAodmFsdWUpID0+IC9ebnByb2ZpbGUxW2EtelxcZF0rJC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNORXZlbnQ6ICh2YWx1ZSkgPT4gL15uZXZlbnQxW2EtelxcZF0rJC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNOQWRkcjogKHZhbHVlKSA9PiAvXm5hZGRyMVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTlNlYzogKHZhbHVlKSA9PiAvXm5zZWMxW2EtelxcZF17NTh9JC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNOUHViOiAodmFsdWUpID0+IC9ebnB1YjFbYS16XFxkXXs1OH0kLy50ZXN0KHZhbHVlIHx8IFwiXCIpLFxuICBpc05vdGU6ICh2YWx1ZSkgPT4gL15ub3RlMVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTmNyeXB0c2VjOiAodmFsdWUpID0+IC9ebmNyeXB0c2VjMVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIilcbn07XG52YXIgQmVjaDMyTWF4U2l6ZSA9IDVlMztcbnZhciBCRUNIMzJfUkVHRVggPSAvW1xceDIxLVxceDdFXXsxLDgzfTFbMDIzNDU2Nzg5YWNkZWZnaGprbG1ucHFyc3R1dnd4eXpdezYsfS87XG5mdW5jdGlvbiBpbnRlZ2VyVG9VaW50OEFycmF5KG51bWJlcikge1xuICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIHVpbnQ4QXJyYXlbMF0gPSBudW1iZXIgPj4gMjQgJiAyNTU7XG4gIHVpbnQ4QXJyYXlbMV0gPSBudW1iZXIgPj4gMTYgJiAyNTU7XG4gIHVpbnQ4QXJyYXlbMl0gPSBudW1iZXIgPj4gOCAmIDI1NTtcbiAgdWludDhBcnJheVszXSA9IG51bWJlciAmIDI1NTtcbiAgcmV0dXJuIHVpbnQ4QXJyYXk7XG59XG5mdW5jdGlvbiBkZWNvZGVOb3N0clVSSShuaXAxOWNvZGUpIHtcbiAgdHJ5IHtcbiAgICBpZiAobmlwMTljb2RlLnN0YXJ0c1dpdGgoXCJub3N0cjpcIikpXG4gICAgICBuaXAxOWNvZGUgPSBuaXAxOWNvZGUuc3Vic3RyaW5nKDYpO1xuICAgIHJldHVybiBkZWNvZGUobmlwMTljb2RlKTtcbiAgfSBjYXRjaCAoX2Vycikge1xuICAgIHJldHVybiB7IHR5cGU6IFwiaW52YWxpZFwiLCBkYXRhOiBudWxsIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY29kZShuaXAxOSkge1xuICBsZXQgeyBwcmVmaXgsIHdvcmRzIH0gPSBpbXBvcnRfYmFzZS5iZWNoMzIuZGVjb2RlKG5pcDE5LCBCZWNoMzJNYXhTaXplKTtcbiAgbGV0IGRhdGEgPSBuZXcgVWludDhBcnJheShpbXBvcnRfYmFzZS5iZWNoMzIuZnJvbVdvcmRzKHdvcmRzKSk7XG4gIHN3aXRjaCAocHJlZml4KSB7XG4gICAgY2FzZSBcIm5wcm9maWxlXCI6IHtcbiAgICAgIGxldCB0bHYgPSBwYXJzZVRMVihkYXRhKTtcbiAgICAgIGlmICghdGx2WzBdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5wcm9maWxlXCIpO1xuICAgICAgaWYgKHRsdlswXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMCBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5wcm9maWxlXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBwdWJrZXk6ICgwLCBpbXBvcnRfdXRpbHM1LmJ5dGVzVG9IZXgpKHRsdlswXVswXSksXG4gICAgICAgICAgcmVsYXlzOiB0bHZbMV0gPyB0bHZbMV0ubWFwKChkKSA9PiB1dGY4RGVjb2Rlci5kZWNvZGUoZCkpIDogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIm5ldmVudFwiOiB7XG4gICAgICBsZXQgdGx2ID0gcGFyc2VUTFYoZGF0YSk7XG4gICAgICBpZiAoIXRsdlswXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAwIGZvciBuZXZlbnRcIik7XG4gICAgICBpZiAodGx2WzBdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAwIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIGlmICh0bHZbMl0gJiYgdGx2WzJdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAyIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIGlmICh0bHZbM10gJiYgdGx2WzNdWzBdLmxlbmd0aCAhPT0gNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDMgc2hvdWxkIGJlIDQgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5ldmVudFwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6ICgwLCBpbXBvcnRfdXRpbHM1LmJ5dGVzVG9IZXgpKHRsdlswXVswXSksXG4gICAgICAgICAgcmVsYXlzOiB0bHZbMV0gPyB0bHZbMV0ubWFwKChkKSA9PiB1dGY4RGVjb2Rlci5kZWNvZGUoZCkpIDogW10sXG4gICAgICAgICAgYXV0aG9yOiB0bHZbMl0/LlswXSA/ICgwLCBpbXBvcnRfdXRpbHM1LmJ5dGVzVG9IZXgpKHRsdlsyXVswXSkgOiB2b2lkIDAsXG4gICAgICAgICAga2luZDogdGx2WzNdPy5bMF0gPyBwYXJzZUludCgoMCwgaW1wb3J0X3V0aWxzNS5ieXRlc1RvSGV4KSh0bHZbM11bMF0pLCAxNikgOiB2b2lkIDBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIm5hZGRyXCI6IHtcbiAgICAgIGxldCB0bHYgPSBwYXJzZVRMVihkYXRhKTtcbiAgICAgIGlmICghdGx2WzBdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5hZGRyXCIpO1xuICAgICAgaWYgKCF0bHZbMl0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMiBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAodGx2WzJdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAyIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIGlmICghdGx2WzNdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDMgZm9yIG5hZGRyXCIpO1xuICAgICAgaWYgKHRsdlszXVswXS5sZW5ndGggIT09IDQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAzIHNob3VsZCBiZSA0IGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJuYWRkclwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWRlbnRpZmllcjogdXRmOERlY29kZXIuZGVjb2RlKHRsdlswXVswXSksXG4gICAgICAgICAgcHVia2V5OiAoMCwgaW1wb3J0X3V0aWxzNS5ieXRlc1RvSGV4KSh0bHZbMl1bMF0pLFxuICAgICAgICAgIGtpbmQ6IHBhcnNlSW50KCgwLCBpbXBvcnRfdXRpbHM1LmJ5dGVzVG9IZXgpKHRsdlszXVswXSksIDE2KSxcbiAgICAgICAgICByZWxheXM6IHRsdlsxXSA/IHRsdlsxXS5tYXAoKGQpID0+IHV0ZjhEZWNvZGVyLmRlY29kZShkKSkgOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibnNlY1wiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogcHJlZml4LCBkYXRhIH07XG4gICAgY2FzZSBcIm5wdWJcIjpcbiAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogcHJlZml4LCBkYXRhOiAoMCwgaW1wb3J0X3V0aWxzNS5ieXRlc1RvSGV4KShkYXRhKSB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gcHJlZml4ICR7cHJlZml4fWApO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZVRMVihkYXRhKSB7XG4gIGxldCByZXN1bHQgPSB7fTtcbiAgbGV0IHJlc3QgPSBkYXRhO1xuICB3aGlsZSAocmVzdC5sZW5ndGggPiAwKSB7XG4gICAgbGV0IHQgPSByZXN0WzBdO1xuICAgIGxldCBsID0gcmVzdFsxXTtcbiAgICBsZXQgdiA9IHJlc3Quc2xpY2UoMiwgMiArIGwpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDIgKyBsKTtcbiAgICBpZiAodi5sZW5ndGggPCBsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3QgZW5vdWdoIGRhdGEgdG8gcmVhZCBvbiBUTFYgJHt0fWApO1xuICAgIHJlc3VsdFt0XSA9IHJlc3VsdFt0XSB8fCBbXTtcbiAgICByZXN1bHRbdF0ucHVzaCh2KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbnNlY0VuY29kZShrZXkpIHtcbiAgcmV0dXJuIGVuY29kZUJ5dGVzKFwibnNlY1wiLCBrZXkpO1xufVxuZnVuY3Rpb24gbnB1YkVuY29kZShoZXgpIHtcbiAgcmV0dXJuIGVuY29kZUJ5dGVzKFwibnB1YlwiLCAoMCwgaW1wb3J0X3V0aWxzNS5oZXhUb0J5dGVzKShoZXgpKTtcbn1cbmZ1bmN0aW9uIG5vdGVFbmNvZGUoaGV4KSB7XG4gIHJldHVybiBlbmNvZGVCeXRlcyhcIm5vdGVcIiwgKDAsIGltcG9ydF91dGlsczUuaGV4VG9CeXRlcykoaGV4KSk7XG59XG5mdW5jdGlvbiBlbmNvZGVCZWNoMzIocHJlZml4LCBkYXRhKSB7XG4gIGxldCB3b3JkcyA9IGltcG9ydF9iYXNlLmJlY2gzMi50b1dvcmRzKGRhdGEpO1xuICByZXR1cm4gaW1wb3J0X2Jhc2UuYmVjaDMyLmVuY29kZShwcmVmaXgsIHdvcmRzLCBCZWNoMzJNYXhTaXplKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUJ5dGVzKHByZWZpeCwgYnl0ZXMpIHtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihwcmVmaXgsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIG5wcm9maWxlRW5jb2RlKHByb2ZpbGUpIHtcbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFsoMCwgaW1wb3J0X3V0aWxzNS5oZXhUb0J5dGVzKShwcm9maWxlLnB1YmtleSldLFxuICAgIDE6IChwcm9maWxlLnJlbGF5cyB8fCBbXSkubWFwKCh1cmwpID0+IHV0ZjhFbmNvZGVyLmVuY29kZSh1cmwpKVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihcIm5wcm9maWxlXCIsIGRhdGEpO1xufVxuZnVuY3Rpb24gbmV2ZW50RW5jb2RlKGV2ZW50KSB7XG4gIGxldCBraW5kQXJyYXk7XG4gIGlmIChldmVudC5raW5kICE9PSB2b2lkIDApIHtcbiAgICBraW5kQXJyYXkgPSBpbnRlZ2VyVG9VaW50OEFycmF5KGV2ZW50LmtpbmQpO1xuICB9XG4gIGxldCBkYXRhID0gZW5jb2RlVExWKHtcbiAgICAwOiBbKDAsIGltcG9ydF91dGlsczUuaGV4VG9CeXRlcykoZXZlbnQuaWQpXSxcbiAgICAxOiAoZXZlbnQucmVsYXlzIHx8IFtdKS5tYXAoKHVybCkgPT4gdXRmOEVuY29kZXIuZW5jb2RlKHVybCkpLFxuICAgIDI6IGV2ZW50LmF1dGhvciA/IFsoMCwgaW1wb3J0X3V0aWxzNS5oZXhUb0J5dGVzKShldmVudC5hdXRob3IpXSA6IFtdLFxuICAgIDM6IGtpbmRBcnJheSA/IFtuZXcgVWludDhBcnJheShraW5kQXJyYXkpXSA6IFtdXG4gIH0pO1xuICByZXR1cm4gZW5jb2RlQmVjaDMyKFwibmV2ZW50XCIsIGRhdGEpO1xufVxuZnVuY3Rpb24gbmFkZHJFbmNvZGUoYWRkcikge1xuICBsZXQga2luZCA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgbmV3IERhdGFWaWV3KGtpbmQpLnNldFVpbnQzMigwLCBhZGRyLmtpbmQsIGZhbHNlKTtcbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFt1dGY4RW5jb2Rlci5lbmNvZGUoYWRkci5pZGVudGlmaWVyKV0sXG4gICAgMTogKGFkZHIucmVsYXlzIHx8IFtdKS5tYXAoKHVybCkgPT4gdXRmOEVuY29kZXIuZW5jb2RlKHVybCkpLFxuICAgIDI6IFsoMCwgaW1wb3J0X3V0aWxzNS5oZXhUb0J5dGVzKShhZGRyLnB1YmtleSldLFxuICAgIDM6IFtuZXcgVWludDhBcnJheShraW5kKV1cbiAgfSk7XG4gIHJldHVybiBlbmNvZGVCZWNoMzIoXCJuYWRkclwiLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVRMVih0bHYpIHtcbiAgbGV0IGVudHJpZXMgPSBbXTtcbiAgT2JqZWN0LmVudHJpZXModGx2KS5yZXZlcnNlKCkuZm9yRWFjaCgoW3QsIHZzXSkgPT4ge1xuICAgIHZzLmZvckVhY2goKHYpID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IG5ldyBVaW50OEFycmF5KHYubGVuZ3RoICsgMik7XG4gICAgICBlbnRyeS5zZXQoW3BhcnNlSW50KHQpXSwgMCk7XG4gICAgICBlbnRyeS5zZXQoW3YubGVuZ3RoXSwgMSk7XG4gICAgICBlbnRyeS5zZXQodiwgMik7XG4gICAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuICgwLCBpbXBvcnRfdXRpbHM1LmNvbmNhdEJ5dGVzKSguLi5lbnRyaWVzKTtcbn1cblxuLy8gcmVmZXJlbmNlcy50c1xudmFyIG1lbnRpb25SZWdleCA9IC9cXGJub3N0cjooKG5vdGV8bnB1YnxuYWRkcnxuZXZlbnR8bnByb2ZpbGUpMVxcdyspXFxifCNcXFsoXFxkKylcXF0vZztcbmZ1bmN0aW9uIHBhcnNlUmVmZXJlbmNlcyhldnQpIHtcbiAgbGV0IHJlZmVyZW5jZXMgPSBbXTtcbiAgZm9yIChsZXQgcmVmIG9mIGV2dC5jb250ZW50Lm1hdGNoQWxsKG1lbnRpb25SZWdleCkpIHtcbiAgICBpZiAocmVmWzJdKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgeyB0eXBlLCBkYXRhIH0gPSBkZWNvZGUocmVmWzFdKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm5wdWJcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBwcm9maWxlOiB7IHB1YmtleTogZGF0YSwgcmVsYXlzOiBbXSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibnByb2ZpbGVcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBwcm9maWxlOiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibm90ZVwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIGV2ZW50OiB7IGlkOiBkYXRhLCByZWxheXM6IFtdIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJuZXZlbnRcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBldmVudDogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5hZGRyXCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgYWRkcmVzczogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmWzNdKSB7XG4gICAgICBsZXQgaWR4ID0gcGFyc2VJbnQocmVmWzNdLCAxMCk7XG4gICAgICBsZXQgdGFnID0gZXZ0LnRhZ3NbaWR4XTtcbiAgICAgIGlmICghdGFnKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHN3aXRjaCAodGFnWzBdKSB7XG4gICAgICAgIGNhc2UgXCJwXCI6IHtcbiAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgcHJvZmlsZTogeyBwdWJrZXk6IHRhZ1sxXSwgcmVsYXlzOiB0YWdbMl0gPyBbdGFnWzJdXSA6IFtdIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZVwiOiB7XG4gICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgIGV2ZW50OiB7IGlkOiB0YWdbMV0sIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImFcIjoge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgW2tpbmQsIHB1YmtleSwgaWRlbnRpZmllcl0gPSB0YWdbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBhZGRyZXNzOiB7XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgICAgICAga2luZDogcGFyc2VJbnQoa2luZCwgMTApLFxuICAgICAgICAgICAgICAgIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZmVyZW5jZXM7XG59XG5cbi8vIG5pcDA0LnRzXG52YXIgbmlwMDRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMDRfZXhwb3J0cywge1xuICBkZWNyeXB0OiAoKSA9PiBkZWNyeXB0LFxuICBlbmNyeXB0OiAoKSA9PiBlbmNyeXB0XG59KTtcbnZhciBpbXBvcnRfdXRpbHM3ID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG52YXIgaW1wb3J0X3NlY3AyNTZrMTIgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIik7XG52YXIgaW1wb3J0X2FlcyA9IHJlcXVpcmUoXCJAbm9ibGUvY2lwaGVycy9hZXNcIik7XG52YXIgaW1wb3J0X2Jhc2UyID0gcmVxdWlyZShcIkBzY3VyZS9iYXNlXCIpO1xuZnVuY3Rpb24gZW5jcnlwdChzZWNyZXRLZXksIHB1YmtleSwgdGV4dCkge1xuICBjb25zdCBwcml2a2V5ID0gc2VjcmV0S2V5IGluc3RhbmNlb2YgVWludDhBcnJheSA/ICgwLCBpbXBvcnRfdXRpbHM3LmJ5dGVzVG9IZXgpKHNlY3JldEtleSkgOiBzZWNyZXRLZXk7XG4gIGNvbnN0IGtleSA9IGltcG9ydF9zZWNwMjU2azEyLnNlY3AyNTZrMS5nZXRTaGFyZWRTZWNyZXQocHJpdmtleSwgXCIwMlwiICsgcHVia2V5KTtcbiAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGdldE5vcm1hbGl6ZWRYKGtleSk7XG4gIGxldCBpdiA9IFVpbnQ4QXJyYXkuZnJvbSgoMCwgaW1wb3J0X3V0aWxzNy5yYW5kb21CeXRlcykoMTYpKTtcbiAgbGV0IHBsYWludGV4dCA9IHV0ZjhFbmNvZGVyLmVuY29kZSh0ZXh0KTtcbiAgbGV0IGNpcGhlcnRleHQgPSAoMCwgaW1wb3J0X2Flcy5jYmMpKG5vcm1hbGl6ZWRLZXksIGl2KS5lbmNyeXB0KHBsYWludGV4dCk7XG4gIGxldCBjdGI2NCA9IGltcG9ydF9iYXNlMi5iYXNlNjQuZW5jb2RlKG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQpKTtcbiAgbGV0IGl2YjY0ID0gaW1wb3J0X2Jhc2UyLmJhc2U2NC5lbmNvZGUobmV3IFVpbnQ4QXJyYXkoaXYuYnVmZmVyKSk7XG4gIHJldHVybiBgJHtjdGI2NH0/aXY9JHtpdmI2NH1gO1xufVxuZnVuY3Rpb24gZGVjcnlwdChzZWNyZXRLZXksIHB1YmtleSwgZGF0YSkge1xuICBjb25zdCBwcml2a2V5ID0gc2VjcmV0S2V5IGluc3RhbmNlb2YgVWludDhBcnJheSA/ICgwLCBpbXBvcnRfdXRpbHM3LmJ5dGVzVG9IZXgpKHNlY3JldEtleSkgOiBzZWNyZXRLZXk7XG4gIGxldCBbY3RiNjQsIGl2YjY0XSA9IGRhdGEuc3BsaXQoXCI/aXY9XCIpO1xuICBsZXQga2V5ID0gaW1wb3J0X3NlY3AyNTZrMTIuc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldChwcml2a2V5LCBcIjAyXCIgKyBwdWJrZXkpO1xuICBsZXQgbm9ybWFsaXplZEtleSA9IGdldE5vcm1hbGl6ZWRYKGtleSk7XG4gIGxldCBpdiA9IGltcG9ydF9iYXNlMi5iYXNlNjQuZGVjb2RlKGl2YjY0KTtcbiAgbGV0IGNpcGhlcnRleHQgPSBpbXBvcnRfYmFzZTIuYmFzZTY0LmRlY29kZShjdGI2NCk7XG4gIGxldCBwbGFpbnRleHQgPSAoMCwgaW1wb3J0X2Flcy5jYmMpKG5vcm1hbGl6ZWRLZXksIGl2KS5kZWNyeXB0KGNpcGhlcnRleHQpO1xuICByZXR1cm4gdXRmOERlY29kZXIuZGVjb2RlKHBsYWludGV4dCk7XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkWChrZXkpIHtcbiAgcmV0dXJuIGtleS5zbGljZSgxLCAzMyk7XG59XG5cbi8vIG5pcDA1LnRzXG52YXIgbmlwMDVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMDVfZXhwb3J0cywge1xuICBOSVAwNV9SRUdFWDogKCkgPT4gTklQMDVfUkVHRVgsXG4gIGlzTmlwMDU6ICgpID0+IGlzTmlwMDUsXG4gIGlzVmFsaWQ6ICgpID0+IGlzVmFsaWQsXG4gIHF1ZXJ5UHJvZmlsZTogKCkgPT4gcXVlcnlQcm9maWxlLFxuICBzZWFyY2hEb21haW46ICgpID0+IHNlYXJjaERvbWFpbixcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvblxufSk7XG52YXIgTklQMDVfUkVHRVggPSAvXig/OihbXFx3ListXSspQCk/KFtcXHdfLV0rKFxcLltcXHdfLV0rKSspJC87XG52YXIgaXNOaXAwNSA9ICh2YWx1ZSkgPT4gTklQMDVfUkVHRVgudGVzdCh2YWx1ZSB8fCBcIlwiKTtcbnZhciBfZmV0Y2g7XG50cnkge1xuICBfZmV0Y2ggPSBmZXRjaDtcbn0gY2F0Y2ggKF8pIHtcbiAgbnVsbDtcbn1cbmZ1bmN0aW9uIHVzZUZldGNoSW1wbGVtZW50YXRpb24oZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2ggPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VhcmNoRG9tYWluKGRvbWFpbiwgcXVlcnkgPSBcIlwiKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vJHtkb21haW59Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke3F1ZXJ5fWA7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgX2ZldGNoKHVybCwgeyByZWRpcmVjdDogXCJtYW51YWxcIiB9KTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIldyb25nIHJlc3BvbnNlIGNvZGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiBqc29uLm5hbWVzO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBxdWVyeVByb2ZpbGUoZnVsbG5hbWUpIHtcbiAgY29uc3QgbWF0Y2ggPSBmdWxsbmFtZS5tYXRjaChOSVAwNV9SRUdFWCk7XG4gIGlmICghbWF0Y2gpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IFssIG5hbWUgPSBcIl9cIiwgZG9tYWluXSA9IG1hdGNoO1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9ub3N0ci5qc29uP25hbWU9JHtuYW1lfWA7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgX2ZldGNoKHVybCwgeyByZWRpcmVjdDogXCJtYW51YWxcIiB9KTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIldyb25nIHJlc3BvbnNlIGNvZGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGNvbnN0IHB1YmtleSA9IGpzb24ubmFtZXNbbmFtZV07XG4gICAgcmV0dXJuIHB1YmtleSA/IHsgcHVia2V5LCByZWxheXM6IGpzb24ucmVsYXlzPy5bcHVia2V5XSB9IDogbnVsbDtcbiAgfSBjYXRjaCAoX2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaXNWYWxpZChwdWJrZXksIG5pcDA1KSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHF1ZXJ5UHJvZmlsZShuaXAwNSk7XG4gIHJldHVybiByZXMgPyByZXMucHVia2V5ID09PSBwdWJrZXkgOiBmYWxzZTtcbn1cblxuLy8gbmlwMTAudHNcbnZhciBuaXAxMF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxMF9leHBvcnRzLCB7XG4gIHBhcnNlOiAoKSA9PiBwYXJzZVxufSk7XG5mdW5jdGlvbiBwYXJzZShldmVudCkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgcmVwbHk6IHZvaWQgMCxcbiAgICByb290OiB2b2lkIDAsXG4gICAgbWVudGlvbnM6IFtdLFxuICAgIHByb2ZpbGVzOiBbXSxcbiAgICBxdW90ZXM6IFtdXG4gIH07XG4gIGxldCBtYXliZVBhcmVudDtcbiAgbGV0IG1heWJlUm9vdDtcbiAgZm9yIChsZXQgaTIgPSBldmVudC50YWdzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICBjb25zdCB0YWcgPSBldmVudC50YWdzW2kyXTtcbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbMV0pIHtcbiAgICAgIGNvbnN0IFtfLCBlVGFnRXZlbnRJZCwgZVRhZ1JlbGF5VXJsLCBlVGFnTWFya2VyLCBlVGFnQXV0aG9yXSA9IHRhZztcbiAgICAgIGNvbnN0IGV2ZW50UG9pbnRlciA9IHtcbiAgICAgICAgaWQ6IGVUYWdFdmVudElkLFxuICAgICAgICByZWxheXM6IGVUYWdSZWxheVVybCA/IFtlVGFnUmVsYXlVcmxdIDogW10sXG4gICAgICAgIGF1dGhvcjogZVRhZ0F1dGhvclxuICAgICAgfTtcbiAgICAgIGlmIChlVGFnTWFya2VyID09PSBcInJvb3RcIikge1xuICAgICAgICByZXN1bHQucm9vdCA9IGV2ZW50UG9pbnRlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZVRhZ01hcmtlciA9PT0gXCJyZXBseVwiKSB7XG4gICAgICAgIHJlc3VsdC5yZXBseSA9IGV2ZW50UG9pbnRlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZVRhZ01hcmtlciA9PT0gXCJtZW50aW9uXCIpIHtcbiAgICAgICAgcmVzdWx0Lm1lbnRpb25zLnB1c2goZXZlbnRQb2ludGVyKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIW1heWJlUGFyZW50KSB7XG4gICAgICAgIG1heWJlUGFyZW50ID0gZXZlbnRQb2ludGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF5YmVSb290ID0gZXZlbnRQb2ludGVyO1xuICAgICAgfVxuICAgICAgcmVzdWx0Lm1lbnRpb25zLnB1c2goZXZlbnRQb2ludGVyKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodGFnWzBdID09PSBcInFcIiAmJiB0YWdbMV0pIHtcbiAgICAgIGNvbnN0IFtfLCBlVGFnRXZlbnRJZCwgZVRhZ1JlbGF5VXJsXSA9IHRhZztcbiAgICAgIHJlc3VsdC5xdW90ZXMucHVzaCh7XG4gICAgICAgIGlkOiBlVGFnRXZlbnRJZCxcbiAgICAgICAgcmVsYXlzOiBlVGFnUmVsYXlVcmwgPyBbZVRhZ1JlbGF5VXJsXSA6IFtdXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIgJiYgdGFnWzFdKSB7XG4gICAgICByZXN1bHQucHJvZmlsZXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogdGFnWzFdLFxuICAgICAgICByZWxheXM6IHRhZ1syXSA/IFt0YWdbMl1dIDogW11cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG4gIGlmICghcmVzdWx0LnJvb3QpIHtcbiAgICByZXN1bHQucm9vdCA9IG1heWJlUm9vdCB8fCBtYXliZVBhcmVudCB8fCByZXN1bHQucmVwbHk7XG4gIH1cbiAgaWYgKCFyZXN1bHQucmVwbHkpIHtcbiAgICByZXN1bHQucmVwbHkgPSBtYXliZVBhcmVudCB8fCByZXN1bHQucm9vdDtcbiAgfVxuICA7XG4gIFtyZXN1bHQucmVwbHksIHJlc3VsdC5yb290XS5mb3JFYWNoKChyZWYpID0+IHtcbiAgICBpZiAoIXJlZilcbiAgICAgIHJldHVybjtcbiAgICBsZXQgaWR4ID0gcmVzdWx0Lm1lbnRpb25zLmluZGV4T2YocmVmKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgcmVzdWx0Lm1lbnRpb25zLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgICBpZiAocmVmLmF1dGhvcikge1xuICAgICAgbGV0IGF1dGhvciA9IHJlc3VsdC5wcm9maWxlcy5maW5kKChwKSA9PiBwLnB1YmtleSA9PT0gcmVmLmF1dGhvcik7XG4gICAgICBpZiAoYXV0aG9yICYmIGF1dGhvci5yZWxheXMpIHtcbiAgICAgICAgaWYgKCFyZWYucmVsYXlzKSB7XG4gICAgICAgICAgcmVmLnJlbGF5cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGF1dGhvci5yZWxheXMuZm9yRWFjaCgodXJsKSA9PiB7XG4gICAgICAgICAgaWYgKHJlZi5yZWxheXM/LmluZGV4T2YodXJsKSA9PT0gLTEpXG4gICAgICAgICAgICByZWYucmVsYXlzLnB1c2godXJsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF1dGhvci5yZWxheXMgPSByZWYucmVsYXlzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJlc3VsdC5tZW50aW9ucy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICBpZiAocmVmLmF1dGhvcikge1xuICAgICAgbGV0IGF1dGhvciA9IHJlc3VsdC5wcm9maWxlcy5maW5kKChwKSA9PiBwLnB1YmtleSA9PT0gcmVmLmF1dGhvcik7XG4gICAgICBpZiAoYXV0aG9yICYmIGF1dGhvci5yZWxheXMpIHtcbiAgICAgICAgaWYgKCFyZWYucmVsYXlzKSB7XG4gICAgICAgICAgcmVmLnJlbGF5cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGF1dGhvci5yZWxheXMuZm9yRWFjaCgodXJsKSA9PiB7XG4gICAgICAgICAgaWYgKHJlZi5yZWxheXMuaW5kZXhPZih1cmwpID09PSAtMSlcbiAgICAgICAgICAgIHJlZi5yZWxheXMucHVzaCh1cmwpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXV0aG9yLnJlbGF5cyA9IHJlZi5yZWxheXM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gbmlwMTEudHNcbnZhciBuaXAxMV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxMV9leHBvcnRzLCB7XG4gIGZldGNoUmVsYXlJbmZvcm1hdGlvbjogKCkgPT4gZmV0Y2hSZWxheUluZm9ybWF0aW9uLFxuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uMlxufSk7XG52YXIgX2ZldGNoMjtcbnRyeSB7XG4gIF9mZXRjaDIgPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjIoZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2gyID0gZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVsYXlJbmZvcm1hdGlvbih1cmwpIHtcbiAgcmV0dXJuIGF3YWl0IChhd2FpdCBmZXRjaCh1cmwucmVwbGFjZShcIndzOi8vXCIsIFwiaHR0cDovL1wiKS5yZXBsYWNlKFwid3NzOi8vXCIsIFwiaHR0cHM6Ly9cIiksIHtcbiAgICBoZWFkZXJzOiB7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9ub3N0citqc29uXCIgfVxuICB9KSkuanNvbigpO1xufVxuXG4vLyBuaXAxMy50c1xudmFyIG5pcDEzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDEzX2V4cG9ydHMsIHtcbiAgZmFzdEV2ZW50SGFzaDogKCkgPT4gZmFzdEV2ZW50SGFzaCxcbiAgZ2V0UG93OiAoKSA9PiBnZXRQb3csXG4gIG1pbmVQb3c6ICgpID0+IG1pbmVQb3dcbn0pO1xudmFyIGltcG9ydF91dGlsczkgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbnZhciBpbXBvcnRfc2hhMjU2MiA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiKTtcbmZ1bmN0aW9uIGdldFBvdyhoZXgpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IDY0OyBpMiArPSA4KSB7XG4gICAgY29uc3QgbmliYmxlID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyhpMiwgaTIgKyA4KSwgMTYpO1xuICAgIGlmIChuaWJibGUgPT09IDApIHtcbiAgICAgIGNvdW50ICs9IDMyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCArPSBNYXRoLmNsejMyKG5pYmJsZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gbWluZVBvdyh1bnNpZ25lZCwgZGlmZmljdWx0eSkge1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCBldmVudCA9IHVuc2lnbmVkO1xuICBjb25zdCB0YWcgPSBbXCJub25jZVwiLCBjb3VudC50b1N0cmluZygpLCBkaWZmaWN1bHR5LnRvU3RyaW5nKCldO1xuICBldmVudC50YWdzLnB1c2godGFnKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBub3cyID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDFlMyk7XG4gICAgaWYgKG5vdzIgIT09IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICAgIGV2ZW50LmNyZWF0ZWRfYXQgPSBub3cyO1xuICAgIH1cbiAgICB0YWdbMV0gPSAoKytjb3VudCkudG9TdHJpbmcoKTtcbiAgICBldmVudC5pZCA9IGZhc3RFdmVudEhhc2goZXZlbnQpO1xuICAgIGlmIChnZXRQb3coZXZlbnQuaWQpID49IGRpZmZpY3VsdHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiBmYXN0RXZlbnRIYXNoKGV2dCkge1xuICByZXR1cm4gKDAsIGltcG9ydF91dGlsczkuYnl0ZXNUb0hleCkoXG4gICAgKDAsIGltcG9ydF9zaGEyNTYyLnNoYTI1NikodXRmOEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KFswLCBldnQucHVia2V5LCBldnQuY3JlYXRlZF9hdCwgZXZ0LmtpbmQsIGV2dC50YWdzLCBldnQuY29udGVudF0pKSlcbiAgKTtcbn1cblxuLy8gbmlwMTcudHNcbnZhciBuaXAxN19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxN19leHBvcnRzLCB7XG4gIHVud3JhcEV2ZW50OiAoKSA9PiB1bndyYXBFdmVudDIsXG4gIHVud3JhcE1hbnlFdmVudHM6ICgpID0+IHVud3JhcE1hbnlFdmVudHMyLFxuICB3cmFwRXZlbnQ6ICgpID0+IHdyYXBFdmVudDIsXG4gIHdyYXBNYW55RXZlbnRzOiAoKSA9PiB3cmFwTWFueUV2ZW50czJcbn0pO1xuXG4vLyBuaXA1OS50c1xudmFyIG5pcDU5X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDU5X2V4cG9ydHMsIHtcbiAgY3JlYXRlUnVtb3I6ICgpID0+IGNyZWF0ZVJ1bW9yLFxuICBjcmVhdGVTZWFsOiAoKSA9PiBjcmVhdGVTZWFsLFxuICBjcmVhdGVXcmFwOiAoKSA9PiBjcmVhdGVXcmFwLFxuICB1bndyYXBFdmVudDogKCkgPT4gdW53cmFwRXZlbnQsXG4gIHVud3JhcE1hbnlFdmVudHM6ICgpID0+IHVud3JhcE1hbnlFdmVudHMsXG4gIHdyYXBFdmVudDogKCkgPT4gd3JhcEV2ZW50LFxuICB3cmFwTWFueUV2ZW50czogKCkgPT4gd3JhcE1hbnlFdmVudHNcbn0pO1xuXG4vLyBuaXA0NC50c1xudmFyIG5pcDQ0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDQ0X2V4cG9ydHMsIHtcbiAgZGVjcnlwdDogKCkgPT4gZGVjcnlwdDIsXG4gIGVuY3J5cHQ6ICgpID0+IGVuY3J5cHQyLFxuICBnZXRDb252ZXJzYXRpb25LZXk6ICgpID0+IGdldENvbnZlcnNhdGlvbktleSxcbiAgdjI6ICgpID0+IHYyXG59KTtcbnZhciBpbXBvcnRfY2hhY2hhID0gcmVxdWlyZShcIkBub2JsZS9jaXBoZXJzL2NoYWNoYVwiKTtcbnZhciBpbXBvcnRfdXRpbHMxMSA9IHJlcXVpcmUoXCJAbm9ibGUvY2lwaGVycy91dGlsc1wiKTtcbnZhciBpbXBvcnRfc2VjcDI1NmsxMyA9IHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiKTtcbnZhciBpbXBvcnRfaGtkZiA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2hrZGZcIik7XG52YXIgaW1wb3J0X2htYWMgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9obWFjXCIpO1xudmFyIGltcG9ydF9zaGEyNTYzID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xudmFyIGltcG9ydF91dGlsczEyID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG52YXIgaW1wb3J0X2Jhc2UzID0gcmVxdWlyZShcIkBzY3VyZS9iYXNlXCIpO1xudmFyIG1pblBsYWludGV4dFNpemUgPSAxO1xudmFyIG1heFBsYWludGV4dFNpemUgPSA2NTUzNTtcbmZ1bmN0aW9uIGdldENvbnZlcnNhdGlvbktleShwcml2a2V5QSwgcHVia2V5Qikge1xuICBjb25zdCBzaGFyZWRYID0gaW1wb3J0X3NlY3AyNTZrMTMuc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldChwcml2a2V5QSwgXCIwMlwiICsgcHVia2V5Qikuc3ViYXJyYXkoMSwgMzMpO1xuICByZXR1cm4gKDAsIGltcG9ydF9oa2RmLmV4dHJhY3QpKGltcG9ydF9zaGEyNTYzLnNoYTI1Niwgc2hhcmVkWCwgXCJuaXA0NC12MlwiKTtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VLZXlzKGNvbnZlcnNhdGlvbktleSwgbm9uY2UpIHtcbiAgY29uc3Qga2V5cyA9ICgwLCBpbXBvcnRfaGtkZi5leHBhbmQpKGltcG9ydF9zaGEyNTYzLnNoYTI1NiwgY29udmVyc2F0aW9uS2V5LCBub25jZSwgNzYpO1xuICByZXR1cm4ge1xuICAgIGNoYWNoYV9rZXk6IGtleXMuc3ViYXJyYXkoMCwgMzIpLFxuICAgIGNoYWNoYV9ub25jZToga2V5cy5zdWJhcnJheSgzMiwgNDQpLFxuICAgIGhtYWNfa2V5OiBrZXlzLnN1YmFycmF5KDQ0LCA3NilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGNQYWRkZWRMZW4obGVuKSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobGVuKSB8fCBsZW4gPCAxKVxuICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIGlmIChsZW4gPD0gMzIpXG4gICAgcmV0dXJuIDMyO1xuICBjb25zdCBuZXh0UG93ZXIgPSAxIDw8IE1hdGguZmxvb3IoTWF0aC5sb2cyKGxlbiAtIDEpKSArIDE7XG4gIGNvbnN0IGNodW5rID0gbmV4dFBvd2VyIDw9IDI1NiA/IDMyIDogbmV4dFBvd2VyIC8gODtcbiAgcmV0dXJuIGNodW5rICogKE1hdGguZmxvb3IoKGxlbiAtIDEpIC8gY2h1bmspICsgMSk7XG59XG5mdW5jdGlvbiB3cml0ZVUxNkJFKG51bSkge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkgfHwgbnVtIDwgbWluUGxhaW50ZXh0U2l6ZSB8fCBudW0gPiBtYXhQbGFpbnRleHRTaXplKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemU6IG11c3QgYmUgYmV0d2VlbiAxIGFuZCA2NTUzNSBieXRlc1wiKTtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMik7XG4gIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyKS5zZXRVaW50MTYoMCwgbnVtLCBmYWxzZSk7XG4gIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBwYWQocGxhaW50ZXh0KSB7XG4gIGNvbnN0IHVucGFkZGVkID0gdXRmOEVuY29kZXIuZW5jb2RlKHBsYWludGV4dCk7XG4gIGNvbnN0IHVucGFkZGVkTGVuID0gdW5wYWRkZWQubGVuZ3RoO1xuICBjb25zdCBwcmVmaXggPSB3cml0ZVUxNkJFKHVucGFkZGVkTGVuKTtcbiAgY29uc3Qgc3VmZml4ID0gbmV3IFVpbnQ4QXJyYXkoY2FsY1BhZGRlZExlbih1bnBhZGRlZExlbikgLSB1bnBhZGRlZExlbik7XG4gIHJldHVybiAoMCwgaW1wb3J0X3V0aWxzMTIuY29uY2F0Qnl0ZXMpKHByZWZpeCwgdW5wYWRkZWQsIHN1ZmZpeCk7XG59XG5mdW5jdGlvbiB1bnBhZChwYWRkZWQpIHtcbiAgY29uc3QgdW5wYWRkZWRMZW4gPSBuZXcgRGF0YVZpZXcocGFkZGVkLmJ1ZmZlcikuZ2V0VWludDE2KDApO1xuICBjb25zdCB1bnBhZGRlZCA9IHBhZGRlZC5zdWJhcnJheSgyLCAyICsgdW5wYWRkZWRMZW4pO1xuICBpZiAodW5wYWRkZWRMZW4gPCBtaW5QbGFpbnRleHRTaXplIHx8IHVucGFkZGVkTGVuID4gbWF4UGxhaW50ZXh0U2l6ZSB8fCB1bnBhZGRlZC5sZW5ndGggIT09IHVucGFkZGVkTGVuIHx8IHBhZGRlZC5sZW5ndGggIT09IDIgKyBjYWxjUGFkZGVkTGVuKHVucGFkZGVkTGVuKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhZGRpbmdcIik7XG4gIHJldHVybiB1dGY4RGVjb2Rlci5kZWNvZGUodW5wYWRkZWQpO1xufVxuZnVuY3Rpb24gaG1hY0FhZChrZXksIG1lc3NhZ2UsIGFhZCkge1xuICBpZiAoYWFkLmxlbmd0aCAhPT0gMzIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQUFEIGFzc29jaWF0ZWQgZGF0YSBtdXN0IGJlIDMyIGJ5dGVzXCIpO1xuICBjb25zdCBjb21iaW5lZCA9ICgwLCBpbXBvcnRfdXRpbHMxMi5jb25jYXRCeXRlcykoYWFkLCBtZXNzYWdlKTtcbiAgcmV0dXJuICgwLCBpbXBvcnRfaG1hYy5obWFjKShpbXBvcnRfc2hhMjU2My5zaGEyNTYsIGtleSwgY29tYmluZWQpO1xufVxuZnVuY3Rpb24gZGVjb2RlUGF5bG9hZChwYXlsb2FkKSB7XG4gIGlmICh0eXBlb2YgcGF5bG9hZCAhPT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXlsb2FkIG11c3QgYmUgYSB2YWxpZCBzdHJpbmdcIik7XG4gIGNvbnN0IHBsZW4gPSBwYXlsb2FkLmxlbmd0aDtcbiAgaWYgKHBsZW4gPCAxMzIgfHwgcGxlbiA+IDg3NDcyKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF5bG9hZCBsZW5ndGg6IFwiICsgcGxlbik7XG4gIGlmIChwYXlsb2FkWzBdID09PSBcIiNcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGVuY3J5cHRpb24gdmVyc2lvblwiKTtcbiAgbGV0IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IGltcG9ydF9iYXNlMy5iYXNlNjQuZGVjb2RlKHBheWxvYWQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmFzZTY0OiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICB9XG4gIGNvbnN0IGRsZW4gPSBkYXRhLmxlbmd0aDtcbiAgaWYgKGRsZW4gPCA5OSB8fCBkbGVuID4gNjU2MDMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhIGxlbmd0aDogXCIgKyBkbGVuKTtcbiAgY29uc3QgdmVycyA9IGRhdGFbMF07XG4gIGlmICh2ZXJzICE9PSAyKVxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gZW5jcnlwdGlvbiB2ZXJzaW9uIFwiICsgdmVycyk7XG4gIHJldHVybiB7XG4gICAgbm9uY2U6IGRhdGEuc3ViYXJyYXkoMSwgMzMpLFxuICAgIGNpcGhlcnRleHQ6IGRhdGEuc3ViYXJyYXkoMzMsIC0zMiksXG4gICAgbWFjOiBkYXRhLnN1YmFycmF5KC0zMilcbiAgfTtcbn1cbmZ1bmN0aW9uIGVuY3J5cHQyKHBsYWludGV4dCwgY29udmVyc2F0aW9uS2V5LCBub25jZSA9ICgwLCBpbXBvcnRfdXRpbHMxMi5yYW5kb21CeXRlcykoMzIpKSB7XG4gIGNvbnN0IHsgY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBobWFjX2tleSB9ID0gZ2V0TWVzc2FnZUtleXMoY29udmVyc2F0aW9uS2V5LCBub25jZSk7XG4gIGNvbnN0IHBhZGRlZCA9IHBhZChwbGFpbnRleHQpO1xuICBjb25zdCBjaXBoZXJ0ZXh0ID0gKDAsIGltcG9ydF9jaGFjaGEuY2hhY2hhMjApKGNoYWNoYV9rZXksIGNoYWNoYV9ub25jZSwgcGFkZGVkKTtcbiAgY29uc3QgbWFjID0gaG1hY0FhZChobWFjX2tleSwgY2lwaGVydGV4dCwgbm9uY2UpO1xuICByZXR1cm4gaW1wb3J0X2Jhc2UzLmJhc2U2NC5lbmNvZGUoKDAsIGltcG9ydF91dGlsczEyLmNvbmNhdEJ5dGVzKShuZXcgVWludDhBcnJheShbMl0pLCBub25jZSwgY2lwaGVydGV4dCwgbWFjKSk7XG59XG5mdW5jdGlvbiBkZWNyeXB0MihwYXlsb2FkLCBjb252ZXJzYXRpb25LZXkpIHtcbiAgY29uc3QgeyBub25jZSwgY2lwaGVydGV4dCwgbWFjIH0gPSBkZWNvZGVQYXlsb2FkKHBheWxvYWQpO1xuICBjb25zdCB7IGNoYWNoYV9rZXksIGNoYWNoYV9ub25jZSwgaG1hY19rZXkgfSA9IGdldE1lc3NhZ2VLZXlzKGNvbnZlcnNhdGlvbktleSwgbm9uY2UpO1xuICBjb25zdCBjYWxjdWxhdGVkTWFjID0gaG1hY0FhZChobWFjX2tleSwgY2lwaGVydGV4dCwgbm9uY2UpO1xuICBpZiAoISgwLCBpbXBvcnRfdXRpbHMxMS5lcXVhbEJ5dGVzKShjYWxjdWxhdGVkTWFjLCBtYWMpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTUFDXCIpO1xuICBjb25zdCBwYWRkZWQgPSAoMCwgaW1wb3J0X2NoYWNoYS5jaGFjaGEyMCkoY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBjaXBoZXJ0ZXh0KTtcbiAgcmV0dXJuIHVucGFkKHBhZGRlZCk7XG59XG52YXIgdjIgPSB7XG4gIHV0aWxzOiB7XG4gICAgZ2V0Q29udmVyc2F0aW9uS2V5LFxuICAgIGNhbGNQYWRkZWRMZW5cbiAgfSxcbiAgZW5jcnlwdDogZW5jcnlwdDIsXG4gIGRlY3J5cHQ6IGRlY3J5cHQyXG59O1xuXG4vLyBuaXA1OS50c1xudmFyIFRXT19EQVlTID0gMiAqIDI0ICogNjAgKiA2MDtcbnZhciBub3cgPSAoKSA9PiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMpO1xudmFyIHJhbmRvbU5vdyA9ICgpID0+IE1hdGgucm91bmQobm93KCkgLSBNYXRoLnJhbmRvbSgpICogVFdPX0RBWVMpO1xudmFyIG5pcDQ0Q29udmVyc2F0aW9uS2V5ID0gKHByaXZhdGVLZXksIHB1YmxpY0tleSkgPT4gZ2V0Q29udmVyc2F0aW9uS2V5KHByaXZhdGVLZXksIHB1YmxpY0tleSk7XG52YXIgbmlwNDRFbmNyeXB0ID0gKGRhdGEsIHByaXZhdGVLZXksIHB1YmxpY0tleSkgPT4gZW5jcnlwdDIoSlNPTi5zdHJpbmdpZnkoZGF0YSksIG5pcDQ0Q29udmVyc2F0aW9uS2V5KHByaXZhdGVLZXksIHB1YmxpY0tleSkpO1xudmFyIG5pcDQ0RGVjcnlwdCA9IChkYXRhLCBwcml2YXRlS2V5KSA9PiBKU09OLnBhcnNlKGRlY3J5cHQyKGRhdGEuY29udGVudCwgbmlwNDRDb252ZXJzYXRpb25LZXkocHJpdmF0ZUtleSwgZGF0YS5wdWJrZXkpKSk7XG5mdW5jdGlvbiBjcmVhdGVSdW1vcihldmVudCwgcHJpdmF0ZUtleSkge1xuICBjb25zdCBydW1vciA9IHtcbiAgICBjcmVhdGVkX2F0OiBub3coKSxcbiAgICBjb250ZW50OiBcIlwiLFxuICAgIHRhZ3M6IFtdLFxuICAgIC4uLmV2ZW50LFxuICAgIHB1YmtleTogZ2V0UHVibGljS2V5KHByaXZhdGVLZXkpXG4gIH07XG4gIHJ1bW9yLmlkID0gZ2V0RXZlbnRIYXNoKHJ1bW9yKTtcbiAgcmV0dXJuIHJ1bW9yO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VhbChydW1vciwgcHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KSB7XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IFNlYWwsXG4gICAgICBjb250ZW50OiBuaXA0NEVuY3J5cHQocnVtb3IsIHByaXZhdGVLZXksIHJlY2lwaWVudFB1YmxpY0tleSksXG4gICAgICBjcmVhdGVkX2F0OiByYW5kb21Ob3coKSxcbiAgICAgIHRhZ3M6IFtdXG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59XG5mdW5jdGlvbiBjcmVhdGVXcmFwKHNlYWwsIHJlY2lwaWVudFB1YmxpY0tleSkge1xuICBjb25zdCByYW5kb21LZXkgPSBnZW5lcmF0ZVNlY3JldEtleSgpO1xuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBHaWZ0V3JhcCxcbiAgICAgIGNvbnRlbnQ6IG5pcDQ0RW5jcnlwdChzZWFsLCByYW5kb21LZXksIHJlY2lwaWVudFB1YmxpY0tleSksXG4gICAgICBjcmVhdGVkX2F0OiByYW5kb21Ob3coKSxcbiAgICAgIHRhZ3M6IFtbXCJwXCIsIHJlY2lwaWVudFB1YmxpY0tleV1dXG4gICAgfSxcbiAgICByYW5kb21LZXlcbiAgKTtcbn1cbmZ1bmN0aW9uIHdyYXBFdmVudChldmVudCwgc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KSB7XG4gIGNvbnN0IHJ1bW9yID0gY3JlYXRlUnVtb3IoZXZlbnQsIHNlbmRlclByaXZhdGVLZXkpO1xuICBjb25zdCBzZWFsID0gY3JlYXRlU2VhbChydW1vciwgc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KTtcbiAgcmV0dXJuIGNyZWF0ZVdyYXAoc2VhbCwgcmVjaXBpZW50UHVibGljS2V5KTtcbn1cbmZ1bmN0aW9uIHdyYXBNYW55RXZlbnRzKGV2ZW50LCBzZW5kZXJQcml2YXRlS2V5LCByZWNpcGllbnRzUHVibGljS2V5cykge1xuICBpZiAoIXJlY2lwaWVudHNQdWJsaWNLZXlzIHx8IHJlY2lwaWVudHNQdWJsaWNLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSByZWNpcGllbnQgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGNvbnN0IHNlbmRlclB1YmxpY0tleSA9IGdldFB1YmxpY0tleShzZW5kZXJQcml2YXRlS2V5KTtcbiAgY29uc3Qgd3JhcHBlZHMgPSBbd3JhcEV2ZW50KGV2ZW50LCBzZW5kZXJQcml2YXRlS2V5LCBzZW5kZXJQdWJsaWNLZXkpXTtcbiAgcmVjaXBpZW50c1B1YmxpY0tleXMuZm9yRWFjaCgocmVjaXBpZW50UHVibGljS2V5KSA9PiB7XG4gICAgd3JhcHBlZHMucHVzaCh3cmFwRXZlbnQoZXZlbnQsIHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudFB1YmxpY0tleSkpO1xuICB9KTtcbiAgcmV0dXJuIHdyYXBwZWRzO1xufVxuZnVuY3Rpb24gdW53cmFwRXZlbnQod3JhcCwgcmVjaXBpZW50UHJpdmF0ZUtleSkge1xuICBjb25zdCB1bndyYXBwZWRTZWFsID0gbmlwNDREZWNyeXB0KHdyYXAsIHJlY2lwaWVudFByaXZhdGVLZXkpO1xuICByZXR1cm4gbmlwNDREZWNyeXB0KHVud3JhcHBlZFNlYWwsIHJlY2lwaWVudFByaXZhdGVLZXkpO1xufVxuZnVuY3Rpb24gdW53cmFwTWFueUV2ZW50cyh3cmFwcGVkRXZlbnRzLCByZWNpcGllbnRQcml2YXRlS2V5KSB7XG4gIGxldCB1bndyYXBwZWRFdmVudHMgPSBbXTtcbiAgd3JhcHBlZEV2ZW50cy5mb3JFYWNoKChlKSA9PiB7XG4gICAgdW53cmFwcGVkRXZlbnRzLnB1c2godW53cmFwRXZlbnQoZSwgcmVjaXBpZW50UHJpdmF0ZUtleSkpO1xuICB9KTtcbiAgdW53cmFwcGVkRXZlbnRzLnNvcnQoKGEsIGIpID0+IGEuY3JlYXRlZF9hdCAtIGIuY3JlYXRlZF9hdCk7XG4gIHJldHVybiB1bndyYXBwZWRFdmVudHM7XG59XG5cbi8vIG5pcDE3LnRzXG5mdW5jdGlvbiBjcmVhdGVFdmVudChyZWNpcGllbnRzLCBtZXNzYWdlLCBjb252ZXJzYXRpb25UaXRsZSwgcmVwbHlUbykge1xuICBjb25zdCBiYXNlRXZlbnQgPSB7XG4gICAgY3JlYXRlZF9hdDogTWF0aC5jZWlsKERhdGUubm93KCkgLyAxZTMpLFxuICAgIGtpbmQ6IFByaXZhdGVEaXJlY3RNZXNzYWdlLFxuICAgIHRhZ3M6IFtdLFxuICAgIGNvbnRlbnQ6IG1lc3NhZ2VcbiAgfTtcbiAgY29uc3QgcmVjaXBpZW50c0FycmF5ID0gQXJyYXkuaXNBcnJheShyZWNpcGllbnRzKSA/IHJlY2lwaWVudHMgOiBbcmVjaXBpZW50c107XG4gIHJlY2lwaWVudHNBcnJheS5mb3JFYWNoKCh7IHB1YmxpY0tleSwgcmVsYXlVcmwgfSkgPT4ge1xuICAgIGJhc2VFdmVudC50YWdzLnB1c2gocmVsYXlVcmwgPyBbXCJwXCIsIHB1YmxpY0tleSwgcmVsYXlVcmxdIDogW1wicFwiLCBwdWJsaWNLZXldKTtcbiAgfSk7XG4gIGlmIChyZXBseVRvKSB7XG4gICAgYmFzZUV2ZW50LnRhZ3MucHVzaChbXCJlXCIsIHJlcGx5VG8uZXZlbnRJZCwgcmVwbHlUby5yZWxheVVybCB8fCBcIlwiLCBcInJlcGx5XCJdKTtcbiAgfVxuICBpZiAoY29udmVyc2F0aW9uVGl0bGUpIHtcbiAgICBiYXNlRXZlbnQudGFncy5wdXNoKFtcInN1YmplY3RcIiwgY29udmVyc2F0aW9uVGl0bGVdKTtcbiAgfVxuICByZXR1cm4gYmFzZUV2ZW50O1xufVxuZnVuY3Rpb24gd3JhcEV2ZW50MihzZW5kZXJQcml2YXRlS2V5LCByZWNpcGllbnQsIG1lc3NhZ2UsIGNvbnZlcnNhdGlvblRpdGxlLCByZXBseVRvKSB7XG4gIGNvbnN0IGV2ZW50ID0gY3JlYXRlRXZlbnQocmVjaXBpZW50LCBtZXNzYWdlLCBjb252ZXJzYXRpb25UaXRsZSwgcmVwbHlUbyk7XG4gIHJldHVybiB3cmFwRXZlbnQoZXZlbnQsIHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudC5wdWJsaWNLZXkpO1xufVxuZnVuY3Rpb24gd3JhcE1hbnlFdmVudHMyKHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudHMsIG1lc3NhZ2UsIGNvbnZlcnNhdGlvblRpdGxlLCByZXBseVRvKSB7XG4gIGlmICghcmVjaXBpZW50cyB8fCByZWNpcGllbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSByZWNpcGllbnQgaXMgcmVxdWlyZWQuXCIpO1xuICB9XG4gIGNvbnN0IHNlbmRlclB1YmxpY0tleSA9IGdldFB1YmxpY0tleShzZW5kZXJQcml2YXRlS2V5KTtcbiAgcmV0dXJuIFt7IHB1YmxpY0tleTogc2VuZGVyUHVibGljS2V5IH0sIC4uLnJlY2lwaWVudHNdLm1hcChcbiAgICAocmVjaXBpZW50KSA9PiB3cmFwRXZlbnQyKHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudCwgbWVzc2FnZSwgY29udmVyc2F0aW9uVGl0bGUsIHJlcGx5VG8pXG4gICk7XG59XG52YXIgdW53cmFwRXZlbnQyID0gdW53cmFwRXZlbnQ7XG52YXIgdW53cmFwTWFueUV2ZW50czIgPSB1bndyYXBNYW55RXZlbnRzO1xuXG4vLyBuaXAxOC50c1xudmFyIG5pcDE4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDE4X2V4cG9ydHMsIHtcbiAgZmluaXNoUmVwb3N0RXZlbnQ6ICgpID0+IGZpbmlzaFJlcG9zdEV2ZW50LFxuICBnZXRSZXBvc3RlZEV2ZW50OiAoKSA9PiBnZXRSZXBvc3RlZEV2ZW50LFxuICBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlcjogKCkgPT4gZ2V0UmVwb3N0ZWRFdmVudFBvaW50ZXJcbn0pO1xuZnVuY3Rpb24gZmluaXNoUmVwb3N0RXZlbnQodCwgcmVwb3N0ZWQsIHJlbGF5VXJsLCBwcml2YXRlS2V5KSB7XG4gIGxldCBraW5kO1xuICBjb25zdCB0YWdzID0gWy4uLnQudGFncyA/PyBbXSwgW1wiZVwiLCByZXBvc3RlZC5pZCwgcmVsYXlVcmxdLCBbXCJwXCIsIHJlcG9zdGVkLnB1YmtleV1dO1xuICBpZiAocmVwb3N0ZWQua2luZCA9PT0gU2hvcnRUZXh0Tm90ZSkge1xuICAgIGtpbmQgPSBSZXBvc3Q7XG4gIH0gZWxzZSB7XG4gICAga2luZCA9IEdlbmVyaWNSZXBvc3Q7XG4gICAgdGFncy5wdXNoKFtcImtcIiwgU3RyaW5nKHJlcG9zdGVkLmtpbmQpXSk7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZCxcbiAgICAgIHRhZ3MsXG4gICAgICBjb250ZW50OiB0LmNvbnRlbnQgPT09IFwiXCIgfHwgcmVwb3N0ZWQudGFncz8uZmluZCgodGFnKSA9PiB0YWdbMF0gPT09IFwiLVwiKSA/IFwiXCIgOiBKU09OLnN0cmluZ2lmeShyZXBvc3RlZCksXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFJlcG9zdGVkRXZlbnRQb2ludGVyKGV2ZW50KSB7XG4gIGlmICghW1JlcG9zdCwgR2VuZXJpY1JlcG9zdF0uaW5jbHVkZXMoZXZlbnQua2luZCkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBsYXN0RVRhZztcbiAgbGV0IGxhc3RQVGFnO1xuICBmb3IgKGxldCBpMiA9IGV2ZW50LnRhZ3MubGVuZ3RoIC0gMTsgaTIgPj0gMCAmJiAobGFzdEVUYWcgPT09IHZvaWQgMCB8fCBsYXN0UFRhZyA9PT0gdm9pZCAwKTsgaTItLSkge1xuICAgIGNvbnN0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICh0YWcubGVuZ3RoID49IDIpIHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIGxhc3RFVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdEVUYWcgPSB0YWc7XG4gICAgICB9IGVsc2UgaWYgKHRhZ1swXSA9PT0gXCJwXCIgJiYgbGFzdFBUYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBsYXN0UFRhZyA9IHRhZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGxhc3RFVGFnID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgaWQ6IGxhc3RFVGFnWzFdLFxuICAgIHJlbGF5czogW2xhc3RFVGFnWzJdLCBsYXN0UFRhZz8uWzJdXS5maWx0ZXIoKHgpID0+IHR5cGVvZiB4ID09PSBcInN0cmluZ1wiKSxcbiAgICBhdXRob3I6IGxhc3RQVGFnPy5bMV1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlcG9zdGVkRXZlbnQoZXZlbnQsIHsgc2tpcFZlcmlmaWNhdGlvbiB9ID0ge30pIHtcbiAgY29uc3QgcG9pbnRlciA9IGdldFJlcG9zdGVkRXZlbnRQb2ludGVyKGV2ZW50KTtcbiAgaWYgKHBvaW50ZXIgPT09IHZvaWQgMCB8fCBldmVudC5jb250ZW50ID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgcmVwb3N0ZWRFdmVudDtcbiAgdHJ5IHtcbiAgICByZXBvc3RlZEV2ZW50ID0gSlNPTi5wYXJzZShldmVudC5jb250ZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChyZXBvc3RlZEV2ZW50LmlkICE9PSBwb2ludGVyLmlkKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAoIXNraXBWZXJpZmljYXRpb24gJiYgIXZlcmlmeUV2ZW50KHJlcG9zdGVkRXZlbnQpKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gcmVwb3N0ZWRFdmVudDtcbn1cblxuLy8gbmlwMjEudHNcbnZhciBuaXAyMV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyMV9leHBvcnRzLCB7XG4gIE5PU1RSX1VSSV9SRUdFWDogKCkgPT4gTk9TVFJfVVJJX1JFR0VYLFxuICBwYXJzZTogKCkgPT4gcGFyc2UyLFxuICB0ZXN0OiAoKSA9PiB0ZXN0XG59KTtcbnZhciBOT1NUUl9VUklfUkVHRVggPSBuZXcgUmVnRXhwKGBub3N0cjooJHtCRUNIMzJfUkVHRVguc291cmNlfSlgKTtcbmZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBuZXcgUmVnRXhwKGBeJHtOT1NUUl9VUklfUkVHRVguc291cmNlfSRgKS50ZXN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlMih1cmkpIHtcbiAgY29uc3QgbWF0Y2ggPSB1cmkubWF0Y2gobmV3IFJlZ0V4cChgXiR7Tk9TVFJfVVJJX1JFR0VYLnNvdXJjZX0kYCkpO1xuICBpZiAoIW1hdGNoKVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBOb3N0ciBVUkk6ICR7dXJpfWApO1xuICByZXR1cm4ge1xuICAgIHVyaTogbWF0Y2hbMF0sXG4gICAgdmFsdWU6IG1hdGNoWzFdLFxuICAgIGRlY29kZWQ6IGRlY29kZShtYXRjaFsxXSlcbiAgfTtcbn1cblxuLy8gbmlwMjUudHNcbnZhciBuaXAyNV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyNV9leHBvcnRzLCB7XG4gIGZpbmlzaFJlYWN0aW9uRXZlbnQ6ICgpID0+IGZpbmlzaFJlYWN0aW9uRXZlbnQsXG4gIGdldFJlYWN0ZWRFdmVudFBvaW50ZXI6ICgpID0+IGdldFJlYWN0ZWRFdmVudFBvaW50ZXJcbn0pO1xuZnVuY3Rpb24gZmluaXNoUmVhY3Rpb25FdmVudCh0LCByZWFjdGVkLCBwcml2YXRlS2V5KSB7XG4gIGNvbnN0IGluaGVyaXRlZFRhZ3MgPSByZWFjdGVkLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZy5sZW5ndGggPj0gMiAmJiAodGFnWzBdID09PSBcImVcIiB8fCB0YWdbMF0gPT09IFwicFwiKSk7XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIC4uLnQsXG4gICAgICBraW5kOiBSZWFjdGlvbixcbiAgICAgIHRhZ3M6IFsuLi50LnRhZ3MgPz8gW10sIC4uLmluaGVyaXRlZFRhZ3MsIFtcImVcIiwgcmVhY3RlZC5pZF0sIFtcInBcIiwgcmVhY3RlZC5wdWJrZXldXSxcbiAgICAgIGNvbnRlbnQ6IHQuY29udGVudCA/PyBcIitcIlxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufVxuZnVuY3Rpb24gZ2V0UmVhY3RlZEV2ZW50UG9pbnRlcihldmVudCkge1xuICBpZiAoZXZlbnQua2luZCAhPT0gUmVhY3Rpb24pIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBsYXN0RVRhZztcbiAgbGV0IGxhc3RQVGFnO1xuICBmb3IgKGxldCBpMiA9IGV2ZW50LnRhZ3MubGVuZ3RoIC0gMTsgaTIgPj0gMCAmJiAobGFzdEVUYWcgPT09IHZvaWQgMCB8fCBsYXN0UFRhZyA9PT0gdm9pZCAwKTsgaTItLSkge1xuICAgIGNvbnN0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICh0YWcubGVuZ3RoID49IDIpIHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIGxhc3RFVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdEVUYWcgPSB0YWc7XG4gICAgICB9IGVsc2UgaWYgKHRhZ1swXSA9PT0gXCJwXCIgJiYgbGFzdFBUYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBsYXN0UFRhZyA9IHRhZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGxhc3RFVGFnID09PSB2b2lkIDAgfHwgbGFzdFBUYWcgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpZDogbGFzdEVUYWdbMV0sXG4gICAgcmVsYXlzOiBbbGFzdEVUYWdbMl0sIGxhc3RQVGFnWzJdXS5maWx0ZXIoKHgpID0+IHggIT09IHZvaWQgMCksXG4gICAgYXV0aG9yOiBsYXN0UFRhZ1sxXVxuICB9O1xufVxuXG4vLyBuaXAyNy50c1xudmFyIG5pcDI3X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDI3X2V4cG9ydHMsIHtcbiAgcGFyc2U6ICgpID0+IHBhcnNlM1xufSk7XG52YXIgbm9DaGFyYWN0ZXIgPSAvXFxXL207XG52YXIgbm9VUkxDaGFyYWN0ZXIgPSAvXFxXIHxcXFckfCR8LHwgL207XG5mdW5jdGlvbiogcGFyc2UzKGNvbnRlbnQpIHtcbiAgY29uc3QgbWF4ID0gY29udGVudC5sZW5ndGg7XG4gIGxldCBwcmV2SW5kZXggPSAwO1xuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBtYXgpIHtcbiAgICBsZXQgdSA9IGNvbnRlbnQuaW5kZXhPZihcIjpcIiwgaW5kZXgpO1xuICAgIGlmICh1ID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChjb250ZW50LnN1YnN0cmluZyh1IC0gNSwgdSkgPT09IFwibm9zdHJcIikge1xuICAgICAgY29uc3QgbSA9IGNvbnRlbnQuc3Vic3RyaW5nKHUgKyA2MCkubWF0Y2gobm9DaGFyYWN0ZXIpO1xuICAgICAgY29uc3QgZW5kID0gbSA/IHUgKyA2MCArIG0uaW5kZXggOiBtYXg7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgcG9pbnRlcjtcbiAgICAgICAgbGV0IHsgZGF0YSwgdHlwZSB9ID0gZGVjb2RlKGNvbnRlbnQuc3Vic3RyaW5nKHUgKyAxLCBlbmQpKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm5wdWJcIjpcbiAgICAgICAgICAgIHBvaW50ZXIgPSB7IHB1YmtleTogZGF0YSB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm5zZWNcIjpcbiAgICAgICAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgICAgICAgaW5kZXggPSBlbmQgKyAxO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHBvaW50ZXIgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2SW5kZXggIT09IHUgLSA1KSB7XG4gICAgICAgICAgeWllbGQgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudC5zdWJzdHJpbmcocHJldkluZGV4LCB1IC0gNSkgfTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB7IHR5cGU6IFwicmVmZXJlbmNlXCIsIHBvaW50ZXIgfTtcbiAgICAgICAgaW5kZXggPSBlbmQ7XG4gICAgICAgIHByZXZJbmRleCA9IGluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgaW5kZXggPSB1ICsgMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250ZW50LnN1YnN0cmluZyh1IC0gNSwgdSkgPT09IFwiaHR0cHNcIiB8fCBjb250ZW50LnN1YnN0cmluZyh1IC0gNCwgdSkgPT09IFwiaHR0cFwiKSB7XG4gICAgICBjb25zdCBtID0gY29udGVudC5zdWJzdHJpbmcodSArIDQpLm1hdGNoKG5vVVJMQ2hhcmFjdGVyKTtcbiAgICAgIGNvbnN0IGVuZCA9IG0gPyB1ICsgNCArIG0uaW5kZXggOiBtYXg7XG4gICAgICBjb25zdCBwcmVmaXhMZW4gPSBjb250ZW50W3UgLSAxXSA9PT0gXCJzXCIgPyA1IDogNDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCB1cmwgPSBuZXcgVVJMKGNvbnRlbnQuc3Vic3RyaW5nKHUgLSBwcmVmaXhMZW4sIGVuZCkpO1xuICAgICAgICBpZiAodXJsLmhvc3RuYW1lLmluZGV4T2YoXCIuXCIpID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdXJsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2SW5kZXggIT09IHUgLSBwcmVmaXhMZW4pIHtcbiAgICAgICAgICB5aWVsZCB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjb250ZW50LnN1YnN0cmluZyhwcmV2SW5kZXgsIHUgLSBwcmVmaXhMZW4pIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi5wbmdcIikgfHwgdXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLmpwZ1wiKSB8fCB1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIuanBlZ1wiKSB8fCB1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIuZ2lmXCIpIHx8IHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi53ZWJwXCIpKSB7XG4gICAgICAgICAgeWllbGQgeyB0eXBlOiBcImltYWdlXCIsIHVybDogdXJsLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICBpbmRleCA9IGVuZDtcbiAgICAgICAgICBwcmV2SW5kZXggPSBpbmRleDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLm1wNFwiKSB8fCB1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIuYXZpXCIpIHx8IHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi53ZWJtXCIpIHx8IHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi5ta3ZcIikpIHtcbiAgICAgICAgICB5aWVsZCB7IHR5cGU6IFwidmlkZW9cIiwgdXJsOiB1cmwudG9TdHJpbmcoKSB9O1xuICAgICAgICAgIGluZGV4ID0gZW5kO1xuICAgICAgICAgIHByZXZJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIubXAzXCIpIHx8IHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi5hYWNcIikgfHwgdXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLm9nZ1wiKSB8fCB1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIub3B1c1wiKSkge1xuICAgICAgICAgIHlpZWxkIHsgdHlwZTogXCJhdWRpb1wiLCB1cmw6IHVybC50b1N0cmluZygpIH07XG4gICAgICAgICAgaW5kZXggPSBlbmQ7XG4gICAgICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgeyB0eXBlOiBcInVybFwiLCB1cmw6IHVybC50b1N0cmluZygpIH07XG4gICAgICAgIGluZGV4ID0gZW5kO1xuICAgICAgICBwcmV2SW5kZXggPSBpbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgIGluZGV4ID0gZW5kICsgMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250ZW50LnN1YnN0cmluZyh1IC0gMywgdSkgPT09IFwid3NzXCIgfHwgY29udGVudC5zdWJzdHJpbmcodSAtIDIsIHUpID09PSBcIndzXCIpIHtcbiAgICAgIGNvbnN0IG0gPSBjb250ZW50LnN1YnN0cmluZyh1ICsgNCkubWF0Y2gobm9VUkxDaGFyYWN0ZXIpO1xuICAgICAgY29uc3QgZW5kID0gbSA/IHUgKyA0ICsgbS5pbmRleCA6IG1heDtcbiAgICAgIGNvbnN0IHByZWZpeExlbiA9IGNvbnRlbnRbdSAtIDFdID09PSBcInNcIiA/IDMgOiAyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHVybCA9IG5ldyBVUkwoY29udGVudC5zdWJzdHJpbmcodSAtIHByZWZpeExlbiwgZW5kKSk7XG4gICAgICAgIGlmICh1cmwuaG9zdG5hbWUuaW5kZXhPZihcIi5cIikgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB3cyB1cmxcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gdSAtIHByZWZpeExlbikge1xuICAgICAgICAgIHlpZWxkIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGNvbnRlbnQuc3Vic3RyaW5nKHByZXZJbmRleCwgdSAtIHByZWZpeExlbikgfTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB7IHR5cGU6IFwicmVsYXlcIiwgdXJsOiB1cmwudG9TdHJpbmcoKSB9O1xuICAgICAgICBpbmRleCA9IGVuZDtcbiAgICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICBpbmRleCA9IGVuZCArIDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCA9IHUgKyAxO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG4gIGlmIChwcmV2SW5kZXggIT09IG1heCkge1xuICAgIHlpZWxkIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGNvbnRlbnQuc3Vic3RyaW5nKHByZXZJbmRleCkgfTtcbiAgfVxufVxuXG4vLyBuaXAyOC50c1xudmFyIG5pcDI4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDI4X2V4cG9ydHMsIHtcbiAgY2hhbm5lbENyZWF0ZUV2ZW50OiAoKSA9PiBjaGFubmVsQ3JlYXRlRXZlbnQsXG4gIGNoYW5uZWxIaWRlTWVzc2FnZUV2ZW50OiAoKSA9PiBjaGFubmVsSGlkZU1lc3NhZ2VFdmVudCxcbiAgY2hhbm5lbE1lc3NhZ2VFdmVudDogKCkgPT4gY2hhbm5lbE1lc3NhZ2VFdmVudCxcbiAgY2hhbm5lbE1ldGFkYXRhRXZlbnQ6ICgpID0+IGNoYW5uZWxNZXRhZGF0YUV2ZW50LFxuICBjaGFubmVsTXV0ZVVzZXJFdmVudDogKCkgPT4gY2hhbm5lbE11dGVVc2VyRXZlbnRcbn0pO1xudmFyIGNoYW5uZWxDcmVhdGVFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGxldCBjb250ZW50O1xuICBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250ZW50ID0gdC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbENyZWF0aW9uLFxuICAgICAgdGFnczogWy4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNZXRhZGF0YUV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTWV0YWRhdGEsXG4gICAgICB0YWdzOiBbW1wiZVwiLCB0LmNoYW5uZWxfY3JlYXRlX2V2ZW50X2lkXSwgLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn07XG52YXIgY2hhbm5lbE1lc3NhZ2VFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGNvbnN0IHRhZ3MgPSBbW1wiZVwiLCB0LmNoYW5uZWxfY3JlYXRlX2V2ZW50X2lkLCB0LnJlbGF5X3VybCwgXCJyb290XCJdXTtcbiAgaWYgKHQucmVwbHlfdG9fY2hhbm5lbF9tZXNzYWdlX2V2ZW50X2lkKSB7XG4gICAgdGFncy5wdXNoKFtcImVcIiwgdC5yZXBseV90b19jaGFubmVsX21lc3NhZ2VfZXZlbnRfaWQsIHQucmVsYXlfdXJsLCBcInJlcGx5XCJdKTtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTWVzc2FnZSxcbiAgICAgIHRhZ3M6IFsuLi50YWdzLCAuLi50LnRhZ3MgPz8gW11dLFxuICAgICAgY29udGVudDogdC5jb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxIaWRlTWVzc2FnZUV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsSGlkZU1lc3NhZ2UsXG4gICAgICB0YWdzOiBbW1wiZVwiLCB0LmNoYW5uZWxfbWVzc2FnZV9ldmVudF9pZF0sIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNdXRlVXNlckV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTXV0ZVVzZXIsXG4gICAgICB0YWdzOiBbW1wicFwiLCB0LnB1YmtleV90b19tdXRlXSwgLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn07XG5cbi8vIG5pcDMwLnRzXG52YXIgbmlwMzBfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMzBfZXhwb3J0cywge1xuICBFTU9KSV9TSE9SVENPREVfUkVHRVg6ICgpID0+IEVNT0pJX1NIT1JUQ09ERV9SRUdFWCxcbiAgbWF0Y2hBbGw6ICgpID0+IG1hdGNoQWxsLFxuICByZWdleDogKCkgPT4gcmVnZXgsXG4gIHJlcGxhY2VBbGw6ICgpID0+IHJlcGxhY2VBbGxcbn0pO1xudmFyIEVNT0pJX1NIT1JUQ09ERV9SRUdFWCA9IC86KFxcdyspOi87XG52YXIgcmVnZXggPSAoKSA9PiBuZXcgUmVnRXhwKGBcXFxcQiR7RU1PSklfU0hPUlRDT0RFX1JFR0VYLnNvdXJjZX1cXFxcQmAsIFwiZ1wiKTtcbmZ1bmN0aW9uKiBtYXRjaEFsbChjb250ZW50KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoQWxsKHJlZ2V4KCkpO1xuICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgW3Nob3J0Y29kZSwgbmFtZV0gPSBtYXRjaDtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgc2hvcnRjb2RlLFxuICAgICAgICBuYW1lLFxuICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsXG4gICAgICAgIGVuZDogbWF0Y2guaW5kZXggKyBzaG9ydGNvZGUubGVuZ3RoXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXBsYWNlQWxsKGNvbnRlbnQsIHJlcGxhY2VyKSB7XG4gIHJldHVybiBjb250ZW50LnJlcGxhY2VBbGwocmVnZXgoKSwgKHNob3J0Y29kZSwgbmFtZSkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlcih7XG4gICAgICBzaG9ydGNvZGUsXG4gICAgICBuYW1lXG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBuaXAzOS50c1xudmFyIG5pcDM5X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDM5X2V4cG9ydHMsIHtcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjMsXG4gIHZhbGlkYXRlR2l0aHViOiAoKSA9PiB2YWxpZGF0ZUdpdGh1YlxufSk7XG52YXIgX2ZldGNoMztcbnRyeSB7XG4gIF9mZXRjaDMgPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjMoZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2gzID0gZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlR2l0aHViKHB1YmtleSwgdXNlcm5hbWUsIHByb29mKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlcyA9IGF3YWl0IChhd2FpdCBfZmV0Y2gzKGBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8ke3VzZXJuYW1lfS8ke3Byb29mfS9yYXdgKSkudGV4dCgpO1xuICAgIHJldHVybiByZXMgPT09IGBWZXJpZnlpbmcgdGhhdCBJIGNvbnRyb2wgdGhlIGZvbGxvd2luZyBOb3N0ciBwdWJsaWMga2V5OiAke3B1YmtleX1gO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIG5pcDQ3LnRzXG52YXIgbmlwNDdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNDdfZXhwb3J0cywge1xuICBtYWtlTndjUmVxdWVzdEV2ZW50OiAoKSA9PiBtYWtlTndjUmVxdWVzdEV2ZW50LFxuICBwYXJzZUNvbm5lY3Rpb25TdHJpbmc6ICgpID0+IHBhcnNlQ29ubmVjdGlvblN0cmluZ1xufSk7XG5mdW5jdGlvbiBwYXJzZUNvbm5lY3Rpb25TdHJpbmcoY29ubmVjdGlvblN0cmluZykge1xuICBjb25zdCB7IHBhdGhuYW1lLCBzZWFyY2hQYXJhbXMgfSA9IG5ldyBVUkwoY29ubmVjdGlvblN0cmluZyk7XG4gIGNvbnN0IHB1YmtleSA9IHBhdGhuYW1lO1xuICBjb25zdCByZWxheSA9IHNlYXJjaFBhcmFtcy5nZXQoXCJyZWxheVwiKTtcbiAgY29uc3Qgc2VjcmV0ID0gc2VhcmNoUGFyYW1zLmdldChcInNlY3JldFwiKTtcbiAgaWYgKCFwdWJrZXkgfHwgIXJlbGF5IHx8ICFzZWNyZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNvbm5lY3Rpb24gc3RyaW5nXCIpO1xuICB9XG4gIHJldHVybiB7IHB1YmtleSwgcmVsYXksIHNlY3JldCB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbWFrZU53Y1JlcXVlc3RFdmVudChwdWJrZXksIHNlY3JldEtleSwgaW52b2ljZSkge1xuICBjb25zdCBjb250ZW50ID0ge1xuICAgIG1ldGhvZDogXCJwYXlfaW52b2ljZVwiLFxuICAgIHBhcmFtczoge1xuICAgICAgaW52b2ljZVxuICAgIH1cbiAgfTtcbiAgY29uc3QgZW5jcnlwdGVkQ29udGVudCA9IGF3YWl0IGVuY3J5cHQoc2VjcmV0S2V5LCBwdWJrZXksIEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpKTtcbiAgY29uc3QgZXZlbnRUZW1wbGF0ZSA9IHtcbiAgICBraW5kOiBOV0NXYWxsZXRSZXF1ZXN0LFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDFlMyksXG4gICAgY29udGVudDogZW5jcnlwdGVkQ29udGVudCxcbiAgICB0YWdzOiBbW1wicFwiLCBwdWJrZXldXVxuICB9O1xuICByZXR1cm4gZmluYWxpemVFdmVudChldmVudFRlbXBsYXRlLCBzZWNyZXRLZXkpO1xufVxuXG4vLyBuaXA1NC50c1xudmFyIG5pcDU0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDU0X2V4cG9ydHMsIHtcbiAgbm9ybWFsaXplSWRlbnRpZmllcjogKCkgPT4gbm9ybWFsaXplSWRlbnRpZmllclxufSk7XG5mdW5jdGlvbiBub3JtYWxpemVJZGVudGlmaWVyKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIG5hbWUgPSBuYW1lLm5vcm1hbGl6ZShcIk5GS0NcIik7XG4gIHJldHVybiBBcnJheS5mcm9tKG5hbWUpLm1hcCgoY2hhcikgPT4ge1xuICAgIGlmICgvXFxwe0xldHRlcn0vdS50ZXN0KGNoYXIpIHx8IC9cXHB7TnVtYmVyfS91LnRlc3QoY2hhcikpIHtcbiAgICAgIHJldHVybiBjaGFyO1xuICAgIH1cbiAgICByZXR1cm4gXCItXCI7XG4gIH0pLmpvaW4oXCJcIik7XG59XG5cbi8vIG5pcDU3LnRzXG52YXIgbmlwNTdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNTdfZXhwb3J0cywge1xuICBnZXRaYXBFbmRwb2ludDogKCkgPT4gZ2V0WmFwRW5kcG9pbnQsXG4gIG1ha2VaYXBSZWNlaXB0OiAoKSA9PiBtYWtlWmFwUmVjZWlwdCxcbiAgbWFrZVphcFJlcXVlc3Q6ICgpID0+IG1ha2VaYXBSZXF1ZXN0LFxuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uNCxcbiAgdmFsaWRhdGVaYXBSZXF1ZXN0OiAoKSA9PiB2YWxpZGF0ZVphcFJlcXVlc3Rcbn0pO1xudmFyIGltcG9ydF9iYXNlNCA9IHJlcXVpcmUoXCJAc2N1cmUvYmFzZVwiKTtcbnZhciBfZmV0Y2g0O1xudHJ5IHtcbiAgX2ZldGNoNCA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiB1c2VGZXRjaEltcGxlbWVudGF0aW9uNChmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaDQgPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0WmFwRW5kcG9pbnQobWV0YWRhdGEpIHtcbiAgdHJ5IHtcbiAgICBsZXQgbG51cmwgPSBcIlwiO1xuICAgIGxldCB7IGx1ZDA2LCBsdWQxNiB9ID0gSlNPTi5wYXJzZShtZXRhZGF0YS5jb250ZW50KTtcbiAgICBpZiAobHVkMDYpIHtcbiAgICAgIGxldCB7IHdvcmRzIH0gPSBpbXBvcnRfYmFzZTQuYmVjaDMyLmRlY29kZShsdWQwNiwgMWUzKTtcbiAgICAgIGxldCBkYXRhID0gaW1wb3J0X2Jhc2U0LmJlY2gzMi5mcm9tV29yZHMod29yZHMpO1xuICAgICAgbG51cmwgPSB1dGY4RGVjb2Rlci5kZWNvZGUoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChsdWQxNikge1xuICAgICAgbGV0IFtuYW1lLCBkb21haW5dID0gbHVkMTYuc3BsaXQoXCJAXCIpO1xuICAgICAgbG51cmwgPSBuZXcgVVJMKGAvLndlbGwta25vd24vbG51cmxwLyR7bmFtZX1gLCBgaHR0cHM6Ly8ke2RvbWFpbn1gKS50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHJlcyA9IGF3YWl0IF9mZXRjaDQobG51cmwpO1xuICAgIGxldCBib2R5ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBpZiAoYm9keS5hbGxvd3NOb3N0ciAmJiBib2R5Lm5vc3RyUHVia2V5KSB7XG4gICAgICByZXR1cm4gYm9keS5jYWxsYmFjaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZVphcFJlcXVlc3Qoe1xuICBwcm9maWxlLFxuICBldmVudCxcbiAgYW1vdW50LFxuICByZWxheXMsXG4gIGNvbW1lbnQgPSBcIlwiXG59KSB7XG4gIGlmICghYW1vdW50KVxuICAgIHRocm93IG5ldyBFcnJvcihcImFtb3VudCBub3QgZ2l2ZW5cIik7XG4gIGlmICghcHJvZmlsZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9maWxlIG5vdCBnaXZlblwiKTtcbiAgbGV0IHpyID0ge1xuICAgIGtpbmQ6IDk3MzQsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMWUzKSxcbiAgICBjb250ZW50OiBjb21tZW50LFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInBcIiwgcHJvZmlsZV0sXG4gICAgICBbXCJhbW91bnRcIiwgYW1vdW50LnRvU3RyaW5nKCldLFxuICAgICAgW1wicmVsYXlzXCIsIC4uLnJlbGF5c11cbiAgICBdXG4gIH07XG4gIGlmIChldmVudCAmJiB0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICB6ci50YWdzLnB1c2goW1wiZVwiLCBldmVudF0pO1xuICB9XG4gIGlmIChldmVudCAmJiB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoaXNSZXBsYWNlYWJsZUtpbmQoZXZlbnQua2luZCkpIHtcbiAgICAgIGNvbnN0IGEgPSBbXCJhXCIsIGAke2V2ZW50LmtpbmR9OiR7ZXZlbnQucHVia2V5fTpgXTtcbiAgICAgIHpyLnRhZ3MucHVzaChhKTtcbiAgICB9IGVsc2UgaWYgKGlzQWRkcmVzc2FibGVLaW5kKGV2ZW50LmtpbmQpKSB7XG4gICAgICBsZXQgZCA9IGV2ZW50LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBcImRcIiAmJiB2KTtcbiAgICAgIGlmICghZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZCB0YWcgbm90IGZvdW5kIG9yIGlzIGVtcHR5XCIpO1xuICAgICAgY29uc3QgYSA9IFtcImFcIiwgYCR7ZXZlbnQua2luZH06JHtldmVudC5wdWJrZXl9OiR7ZFsxXX1gXTtcbiAgICAgIHpyLnRhZ3MucHVzaChhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHpyO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVaYXBSZXF1ZXN0KHphcFJlcXVlc3RTdHJpbmcpIHtcbiAgbGV0IHphcFJlcXVlc3Q7XG4gIHRyeSB7XG4gICAgemFwUmVxdWVzdCA9IEpTT04ucGFyc2UoemFwUmVxdWVzdFN0cmluZyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBcIkludmFsaWQgemFwIHJlcXVlc3QgSlNPTi5cIjtcbiAgfVxuICBpZiAoIXZhbGlkYXRlRXZlbnQoemFwUmVxdWVzdCkpXG4gICAgcmV0dXJuIFwiWmFwIHJlcXVlc3QgaXMgbm90IGEgdmFsaWQgTm9zdHIgZXZlbnQuXCI7XG4gIGlmICghdmVyaWZ5RXZlbnQoemFwUmVxdWVzdCkpXG4gICAgcmV0dXJuIFwiSW52YWxpZCBzaWduYXR1cmUgb24gemFwIHJlcXVlc3QuXCI7XG4gIGxldCBwID0gemFwUmVxdWVzdC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gXCJwXCIgJiYgdik7XG4gIGlmICghcClcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYSAncCcgdGFnLlwiO1xuICBpZiAoIXBbMV0ubWF0Y2goL15bYS1mMC05XXs2NH0kLykpXG4gICAgcmV0dXJuIFwiWmFwIHJlcXVlc3QgJ3AnIHRhZyBpcyBub3QgdmFsaWQgaGV4LlwiO1xuICBsZXQgZSA9IHphcFJlcXVlc3QudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IFwiZVwiICYmIHYpO1xuICBpZiAoZSAmJiAhZVsxXS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCAnZScgdGFnIGlzIG5vdCB2YWxpZCBoZXguXCI7XG4gIGxldCByZWxheXMgPSB6YXBSZXF1ZXN0LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBcInJlbGF5c1wiICYmIHYpO1xuICBpZiAoIXJlbGF5cylcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYSAncmVsYXlzJyB0YWcuXCI7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZVphcFJlY2VpcHQoe1xuICB6YXBSZXF1ZXN0LFxuICBwcmVpbWFnZSxcbiAgYm9sdDExLFxuICBwYWlkQXRcbn0pIHtcbiAgbGV0IHpyID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0KTtcbiAgbGV0IHRhZ3NGcm9tWmFwUmVxdWVzdCA9IHpyLnRhZ3MuZmlsdGVyKChbdF0pID0+IHQgPT09IFwiZVwiIHx8IHQgPT09IFwicFwiIHx8IHQgPT09IFwiYVwiKTtcbiAgbGV0IHphcCA9IHtcbiAgICBraW5kOiA5NzM1LFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGgucm91bmQocGFpZEF0LmdldFRpbWUoKSAvIDFlMyksXG4gICAgY29udGVudDogXCJcIixcbiAgICB0YWdzOiBbLi4udGFnc0Zyb21aYXBSZXF1ZXN0LCBbXCJQXCIsIHpyLnB1YmtleV0sIFtcImJvbHQxMVwiLCBib2x0MTFdLCBbXCJkZXNjcmlwdGlvblwiLCB6YXBSZXF1ZXN0XV1cbiAgfTtcbiAgaWYgKHByZWltYWdlKSB7XG4gICAgemFwLnRhZ3MucHVzaChbXCJwcmVpbWFnZVwiLCBwcmVpbWFnZV0pO1xuICB9XG4gIHJldHVybiB6YXA7XG59XG5cbi8vIG5pcDk4LnRzXG52YXIgbmlwOThfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwOThfZXhwb3J0cywge1xuICBnZXRUb2tlbjogKCkgPT4gZ2V0VG9rZW4sXG4gIGhhc2hQYXlsb2FkOiAoKSA9PiBoYXNoUGF5bG9hZCxcbiAgdW5wYWNrRXZlbnRGcm9tVG9rZW46ICgpID0+IHVucGFja0V2ZW50RnJvbVRva2VuLFxuICB2YWxpZGF0ZUV2ZW50OiAoKSA9PiB2YWxpZGF0ZUV2ZW50MixcbiAgdmFsaWRhdGVFdmVudEtpbmQ6ICgpID0+IHZhbGlkYXRlRXZlbnRLaW5kLFxuICB2YWxpZGF0ZUV2ZW50TWV0aG9kVGFnOiAoKSA9PiB2YWxpZGF0ZUV2ZW50TWV0aG9kVGFnLFxuICB2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZzogKCkgPT4gdmFsaWRhdGVFdmVudFBheWxvYWRUYWcsXG4gIHZhbGlkYXRlRXZlbnRUaW1lc3RhbXA6ICgpID0+IHZhbGlkYXRlRXZlbnRUaW1lc3RhbXAsXG4gIHZhbGlkYXRlRXZlbnRVcmxUYWc6ICgpID0+IHZhbGlkYXRlRXZlbnRVcmxUYWcsXG4gIHZhbGlkYXRlVG9rZW46ICgpID0+IHZhbGlkYXRlVG9rZW5cbn0pO1xudmFyIGltcG9ydF9zaGEyNTY0ID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xudmFyIGltcG9ydF91dGlsczE1ID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG52YXIgaW1wb3J0X2Jhc2U1ID0gcmVxdWlyZShcIkBzY3VyZS9iYXNlXCIpO1xudmFyIF9hdXRob3JpemF0aW9uU2NoZW1lID0gXCJOb3N0ciBcIjtcbmFzeW5jIGZ1bmN0aW9uIGdldFRva2VuKGxvZ2luVXJsLCBodHRwTWV0aG9kLCBzaWduLCBpbmNsdWRlQXV0aG9yaXphdGlvblNjaGVtZSA9IGZhbHNlLCBwYXlsb2FkKSB7XG4gIGNvbnN0IGV2ZW50ID0ge1xuICAgIGtpbmQ6IEhUVFBBdXRoLFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInVcIiwgbG9naW5VcmxdLFxuICAgICAgW1wibWV0aG9kXCIsIGh0dHBNZXRob2RdXG4gICAgXSxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKSxcbiAgICBjb250ZW50OiBcIlwiXG4gIH07XG4gIGlmIChwYXlsb2FkKSB7XG4gICAgZXZlbnQudGFncy5wdXNoKFtcInBheWxvYWRcIiwgaGFzaFBheWxvYWQocGF5bG9hZCldKTtcbiAgfVxuICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IHNpZ24oZXZlbnQpO1xuICBjb25zdCBhdXRob3JpemF0aW9uU2NoZW1lID0gaW5jbHVkZUF1dGhvcml6YXRpb25TY2hlbWUgPyBfYXV0aG9yaXphdGlvblNjaGVtZSA6IFwiXCI7XG4gIHJldHVybiBhdXRob3JpemF0aW9uU2NoZW1lICsgaW1wb3J0X2Jhc2U1LmJhc2U2NC5lbmNvZGUodXRmOEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHNpZ25lZEV2ZW50KSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVUb2tlbih0b2tlbiwgdXJsLCBtZXRob2QpIHtcbiAgY29uc3QgZXZlbnQgPSBhd2FpdCB1bnBhY2tFdmVudEZyb21Ub2tlbih0b2tlbikuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICBjb25zdCB2YWxpZCA9IGF3YWl0IHZhbGlkYXRlRXZlbnQyKGV2ZW50LCB1cmwsIG1ldGhvZCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICByZXR1cm4gdmFsaWQ7XG59XG5hc3luYyBmdW5jdGlvbiB1bnBhY2tFdmVudEZyb21Ub2tlbih0b2tlbikge1xuICBpZiAoIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB0b2tlblwiKTtcbiAgfVxuICB0b2tlbiA9IHRva2VuLnJlcGxhY2UoX2F1dGhvcml6YXRpb25TY2hlbWUsIFwiXCIpO1xuICBjb25zdCBldmVudEI2NCA9IHV0ZjhEZWNvZGVyLmRlY29kZShpbXBvcnRfYmFzZTUuYmFzZTY0LmRlY29kZSh0b2tlbikpO1xuICBpZiAoIWV2ZW50QjY0IHx8IGV2ZW50QjY0Lmxlbmd0aCA9PT0gMCB8fCAhZXZlbnRCNjQuc3RhcnRzV2l0aChcIntcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRva2VuXCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50ID0gSlNPTi5wYXJzZShldmVudEI2NCk7XG4gIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRUaW1lc3RhbXAoZXZlbnQpIHtcbiAgaWYgKCFldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKSAtIGV2ZW50LmNyZWF0ZWRfYXQgPCA2MDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRLaW5kKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5raW5kID09PSBIVFRQQXV0aDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRVcmxUYWcoZXZlbnQsIHVybCkge1xuICBjb25zdCB1cmxUYWcgPSBldmVudC50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwidVwiKTtcbiAgaWYgKCF1cmxUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHVybFRhZy5sZW5ndGggPiAwICYmIHVybFRhZ1sxXSA9PT0gdXJsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFdmVudE1ldGhvZFRhZyhldmVudCwgbWV0aG9kKSB7XG4gIGNvbnN0IG1ldGhvZFRhZyA9IGV2ZW50LnRhZ3MuZmluZCgodCkgPT4gdFswXSA9PT0gXCJtZXRob2RcIik7XG4gIGlmICghbWV0aG9kVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBtZXRob2RUYWcubGVuZ3RoID4gMCAmJiBtZXRob2RUYWdbMV0udG9Mb3dlckNhc2UoKSA9PT0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBoYXNoUGF5bG9hZChwYXlsb2FkKSB7XG4gIGNvbnN0IGhhc2ggPSAoMCwgaW1wb3J0X3NoYTI1NjQuc2hhMjU2KSh1dGY4RW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpKTtcbiAgcmV0dXJuICgwLCBpbXBvcnRfdXRpbHMxNS5ieXRlc1RvSGV4KShoYXNoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRQYXlsb2FkVGFnKGV2ZW50LCBwYXlsb2FkKSB7XG4gIGNvbnN0IHBheWxvYWRUYWcgPSBldmVudC50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwicGF5bG9hZFwiKTtcbiAgaWYgKCFwYXlsb2FkVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHBheWxvYWRIYXNoID0gaGFzaFBheWxvYWQocGF5bG9hZCk7XG4gIHJldHVybiBwYXlsb2FkVGFnLmxlbmd0aCA+IDAgJiYgcGF5bG9hZFRhZ1sxXSA9PT0gcGF5bG9hZEhhc2g7XG59XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUV2ZW50MihldmVudCwgdXJsLCBtZXRob2QsIGJvZHkpIHtcbiAgaWYgKCF2ZXJpZnlFdmVudChldmVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCBzaWduYXR1cmUgaW52YWxpZFwiKTtcbiAgfVxuICBpZiAoIXZhbGlkYXRlRXZlbnRLaW5kKGV2ZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIGtpbmQgaW52YWxpZFwiKTtcbiAgfVxuICBpZiAoIXZhbGlkYXRlRXZlbnRUaW1lc3RhbXAoZXZlbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgY3JlYXRlZF9hdCB0aW1lc3RhbXAgaW52YWxpZFwiKTtcbiAgfVxuICBpZiAoIXZhbGlkYXRlRXZlbnRVcmxUYWcoZXZlbnQsIHVybCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCB1cmwgdGFnIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50TWV0aG9kVGFnKGV2ZW50LCBtZXRob2QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgbWV0aG9kIHRhZyBpbnZhbGlkXCIpO1xuICB9XG4gIGlmIChCb29sZWFuKGJvZHkpICYmIHR5cGVvZiBib2R5ID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKGJvZHkpLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoIXZhbGlkYXRlRXZlbnRQYXlsb2FkVGFnKGV2ZW50LCBib2R5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgcGF5bG9hZCB0YWcgZG9lcyBub3QgbWF0Y2ggcmVxdWVzdCBib2R5IGhhc2hcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/lib/cjs/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/lib/esm/index.js":
/*!****************************************************!*\
  !*** ../node_modules/nostr-tools/lib/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Relay: () => (/* binding */ Relay),\n/* harmony export */   SimplePool: () => (/* binding */ SimplePool),\n/* harmony export */   finalizeEvent: () => (/* binding */ finalizeEvent),\n/* harmony export */   fj: () => (/* binding */ fakejson_exports),\n/* harmony export */   generateSecretKey: () => (/* binding */ generateSecretKey),\n/* harmony export */   getEventHash: () => (/* binding */ getEventHash),\n/* harmony export */   getFilterLimit: () => (/* binding */ getFilterLimit),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   kinds: () => (/* binding */ kinds_exports),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   matchFilters: () => (/* binding */ matchFilters),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   nip04: () => (/* binding */ nip04_exports),\n/* harmony export */   nip05: () => (/* binding */ nip05_exports),\n/* harmony export */   nip10: () => (/* binding */ nip10_exports),\n/* harmony export */   nip11: () => (/* binding */ nip11_exports),\n/* harmony export */   nip13: () => (/* binding */ nip13_exports),\n/* harmony export */   nip17: () => (/* binding */ nip17_exports),\n/* harmony export */   nip18: () => (/* binding */ nip18_exports),\n/* harmony export */   nip19: () => (/* binding */ nip19_exports),\n/* harmony export */   nip21: () => (/* binding */ nip21_exports),\n/* harmony export */   nip25: () => (/* binding */ nip25_exports),\n/* harmony export */   nip27: () => (/* binding */ nip27_exports),\n/* harmony export */   nip28: () => (/* binding */ nip28_exports),\n/* harmony export */   nip30: () => (/* binding */ nip30_exports),\n/* harmony export */   nip39: () => (/* binding */ nip39_exports),\n/* harmony export */   nip42: () => (/* binding */ nip42_exports),\n/* harmony export */   nip44: () => (/* binding */ nip44_exports),\n/* harmony export */   nip47: () => (/* binding */ nip47_exports),\n/* harmony export */   nip54: () => (/* binding */ nip54_exports),\n/* harmony export */   nip57: () => (/* binding */ nip57_exports),\n/* harmony export */   nip59: () => (/* binding */ nip59_exports),\n/* harmony export */   nip98: () => (/* binding */ nip98_exports),\n/* harmony export */   parseReferences: () => (/* binding */ parseReferences),\n/* harmony export */   serializeEvent: () => (/* binding */ serializeEvent),\n/* harmony export */   sortEvents: () => (/* binding */ sortEvents),\n/* harmony export */   utils: () => (/* binding */ utils_exports),\n/* harmony export */   validateEvent: () => (/* binding */ validateEvent),\n/* harmony export */   verifiedSymbol: () => (/* binding */ verifiedSymbol),\n/* harmony export */   verifyEvent: () => (/* binding */ verifyEvent)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scure/base */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/ciphers/aes */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/aes.js\");\n/* harmony import */ var _noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/ciphers/chacha */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/chacha.js\");\n/* harmony import */ var _noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/ciphers/utils */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/utils.js\");\n/* harmony import */ var _noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/hkdf */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js\");\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// pure.ts\n\n\n\n// core.ts\nvar verifiedSymbol = Symbol(\"verified\");\nvar isRecord = (obj) => obj instanceof Object;\nfunction validateEvent(event) {\n  if (!isRecord(event))\n    return false;\n  if (typeof event.kind !== \"number\")\n    return false;\n  if (typeof event.content !== \"string\")\n    return false;\n  if (typeof event.created_at !== \"number\")\n    return false;\n  if (typeof event.pubkey !== \"string\")\n    return false;\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/))\n    return false;\n  if (!Array.isArray(event.tags))\n    return false;\n  for (let i2 = 0; i2 < event.tags.length; i2++) {\n    let tag = event.tags[i2];\n    if (!Array.isArray(tag))\n      return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\")\n        return false;\n    }\n  }\n  return true;\n}\nfunction sortEvents(events) {\n  return events.sort((a, b) => {\n    if (a.created_at !== b.created_at) {\n      return b.created_at - a.created_at;\n    }\n    return a.id.localeCompare(b.id);\n  });\n}\n\n// pure.ts\n\n\n// utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Queue: () => Queue,\n  QueueNode: () => QueueNode,\n  binarySearch: () => binarySearch,\n  insertEventIntoAscendingList: () => insertEventIntoAscendingList,\n  insertEventIntoDescendingList: () => insertEventIntoDescendingList,\n  normalizeURL: () => normalizeURL,\n  utf8Decoder: () => utf8Decoder,\n  utf8Encoder: () => utf8Encoder\n});\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nvar utf8Encoder = new TextEncoder();\nfunction normalizeURL(url) {\n  if (url.indexOf(\"://\") === -1)\n    url = \"wss://\" + url;\n  let p = new URL(url);\n  p.pathname = p.pathname.replace(/\\/+/g, \"/\");\n  if (p.pathname.endsWith(\"/\"))\n    p.pathname = p.pathname.slice(0, -1);\n  if (p.port === \"80\" && p.protocol === \"ws:\" || p.port === \"443\" && p.protocol === \"wss:\")\n    p.port = \"\";\n  p.searchParams.sort();\n  p.hash = \"\";\n  return p.toString();\n}\nfunction insertEventIntoDescendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return b.created_at - event.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction insertEventIntoAscendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return event.created_at - b.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction binarySearch(arr, compare) {\n  let start = 0;\n  let end = arr.length - 1;\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n    const cmp = compare(arr[mid]);\n    if (cmp === 0) {\n      return [mid, true];\n    }\n    if (cmp < 0) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n  return [start, false];\n}\nvar QueueNode = class {\n  value;\n  next = null;\n  prev = null;\n  constructor(message) {\n    this.value = message;\n  }\n};\nvar Queue = class {\n  first;\n  last;\n  constructor() {\n    this.first = null;\n    this.last = null;\n  }\n  enqueue(value) {\n    const newNode = new QueueNode(value);\n    if (!this.last) {\n      this.first = newNode;\n      this.last = newNode;\n    } else if (this.last === this.first) {\n      this.last = newNode;\n      this.last.prev = this.first;\n      this.first.next = newNode;\n    } else {\n      newNode.prev = this.last;\n      this.last.next = newNode;\n      this.last = newNode;\n    }\n    return true;\n  }\n  dequeue() {\n    if (!this.first)\n      return null;\n    if (this.first === this.last) {\n      const target2 = this.first;\n      this.first = null;\n      this.last = null;\n      return target2.value;\n    }\n    const target = this.first;\n    this.first = target.next;\n    return target.value;\n  }\n};\n\n// pure.ts\nvar JS = class {\n  generateSecretKey() {\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.utils.randomPrivateKey();\n  }\n  getPublicKey(secretKey) {\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.getPublicKey(secretKey));\n  }\n  finalizeEvent(t, secretKey) {\n    const event = t;\n    event.pubkey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.getPublicKey(secretKey));\n    event.id = getEventHash(event);\n    event.sig = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.sign(getEventHash(event), secretKey));\n    event[verifiedSymbol] = true;\n    return event;\n  }\n  verifyEvent(event) {\n    if (typeof event[verifiedSymbol] === \"boolean\")\n      return event[verifiedSymbol];\n    const hash = getEventHash(event);\n    if (hash !== event.id) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n    try {\n      const valid = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.verify(event.sig, hash, event.pubkey);\n      event[verifiedSymbol] = valid;\n      return valid;\n    } catch (err) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n  }\n};\nfunction serializeEvent(evt) {\n  if (!validateEvent(evt))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);\n}\nfunction getEventHash(event) {\n  let eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(serializeEvent(event)));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(eventHash);\n}\nvar i = new JS();\nvar generateSecretKey = i.generateSecretKey;\nvar getPublicKey = i.getPublicKey;\nvar finalizeEvent = i.finalizeEvent;\nvar verifyEvent = i.verifyEvent;\n\n// kinds.ts\nvar kinds_exports = {};\n__export(kinds_exports, {\n  Application: () => Application,\n  BadgeAward: () => BadgeAward,\n  BadgeDefinition: () => BadgeDefinition,\n  BlockedRelaysList: () => BlockedRelaysList,\n  BookmarkList: () => BookmarkList,\n  Bookmarksets: () => Bookmarksets,\n  Calendar: () => Calendar,\n  CalendarEventRSVP: () => CalendarEventRSVP,\n  ChannelCreation: () => ChannelCreation,\n  ChannelHideMessage: () => ChannelHideMessage,\n  ChannelMessage: () => ChannelMessage,\n  ChannelMetadata: () => ChannelMetadata,\n  ChannelMuteUser: () => ChannelMuteUser,\n  ClassifiedListing: () => ClassifiedListing,\n  ClientAuth: () => ClientAuth,\n  CommunitiesList: () => CommunitiesList,\n  CommunityDefinition: () => CommunityDefinition,\n  CommunityPostApproval: () => CommunityPostApproval,\n  Contacts: () => Contacts,\n  CreateOrUpdateProduct: () => CreateOrUpdateProduct,\n  CreateOrUpdateStall: () => CreateOrUpdateStall,\n  Curationsets: () => Curationsets,\n  Date: () => Date2,\n  DirectMessageRelaysList: () => DirectMessageRelaysList,\n  DraftClassifiedListing: () => DraftClassifiedListing,\n  DraftLong: () => DraftLong,\n  Emojisets: () => Emojisets,\n  EncryptedDirectMessage: () => EncryptedDirectMessage,\n  EventDeletion: () => EventDeletion,\n  FileMetadata: () => FileMetadata,\n  FileServerPreference: () => FileServerPreference,\n  Followsets: () => Followsets,\n  GenericRepost: () => GenericRepost,\n  Genericlists: () => Genericlists,\n  GiftWrap: () => GiftWrap,\n  HTTPAuth: () => HTTPAuth,\n  Handlerinformation: () => Handlerinformation,\n  Handlerrecommendation: () => Handlerrecommendation,\n  Highlights: () => Highlights,\n  InterestsList: () => InterestsList,\n  Interestsets: () => Interestsets,\n  JobFeedback: () => JobFeedback,\n  JobRequest: () => JobRequest,\n  JobResult: () => JobResult,\n  Label: () => Label,\n  LightningPubRPC: () => LightningPubRPC,\n  LiveChatMessage: () => LiveChatMessage,\n  LiveEvent: () => LiveEvent,\n  LongFormArticle: () => LongFormArticle,\n  Metadata: () => Metadata,\n  Mutelist: () => Mutelist,\n  NWCWalletInfo: () => NWCWalletInfo,\n  NWCWalletRequest: () => NWCWalletRequest,\n  NWCWalletResponse: () => NWCWalletResponse,\n  NostrConnect: () => NostrConnect,\n  OpenTimestamps: () => OpenTimestamps,\n  Pinlist: () => Pinlist,\n  PrivateDirectMessage: () => PrivateDirectMessage,\n  ProblemTracker: () => ProblemTracker,\n  ProfileBadges: () => ProfileBadges,\n  PublicChatsList: () => PublicChatsList,\n  Reaction: () => Reaction,\n  RecommendRelay: () => RecommendRelay,\n  RelayList: () => RelayList,\n  Relaysets: () => Relaysets,\n  Report: () => Report,\n  Reporting: () => Reporting,\n  Repost: () => Repost,\n  Seal: () => Seal,\n  SearchRelaysList: () => SearchRelaysList,\n  ShortTextNote: () => ShortTextNote,\n  Time: () => Time,\n  UserEmojiList: () => UserEmojiList,\n  UserStatuses: () => UserStatuses,\n  Zap: () => Zap,\n  ZapGoal: () => ZapGoal,\n  ZapRequest: () => ZapRequest,\n  classifyKind: () => classifyKind,\n  isAddressableKind: () => isAddressableKind,\n  isEphemeralKind: () => isEphemeralKind,\n  isKind: () => isKind,\n  isParameterizedReplaceableKind: () => isParameterizedReplaceableKind,\n  isRegularKind: () => isRegularKind,\n  isReplaceableKind: () => isReplaceableKind\n});\nfunction isRegularKind(kind) {\n  return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);\n}\nfunction isReplaceableKind(kind) {\n  return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;\n}\nfunction isEphemeralKind(kind) {\n  return 2e4 <= kind && kind < 3e4;\n}\nfunction isAddressableKind(kind) {\n  return 3e4 <= kind && kind < 4e4;\n}\nvar isParameterizedReplaceableKind = isAddressableKind;\nfunction classifyKind(kind) {\n  if (isRegularKind(kind))\n    return \"regular\";\n  if (isReplaceableKind(kind))\n    return \"replaceable\";\n  if (isEphemeralKind(kind))\n    return \"ephemeral\";\n  if (isAddressableKind(kind))\n    return \"parameterized\";\n  return \"unknown\";\n}\nfunction isKind(event, kind) {\n  const kindAsArray = kind instanceof Array ? kind : [kind];\n  return validateEvent(event) && kindAsArray.includes(event.kind) || false;\n}\nvar Metadata = 0;\nvar ShortTextNote = 1;\nvar RecommendRelay = 2;\nvar Contacts = 3;\nvar EncryptedDirectMessage = 4;\nvar EventDeletion = 5;\nvar Repost = 6;\nvar Reaction = 7;\nvar BadgeAward = 8;\nvar Seal = 13;\nvar PrivateDirectMessage = 14;\nvar GenericRepost = 16;\nvar ChannelCreation = 40;\nvar ChannelMetadata = 41;\nvar ChannelMessage = 42;\nvar ChannelHideMessage = 43;\nvar ChannelMuteUser = 44;\nvar OpenTimestamps = 1040;\nvar GiftWrap = 1059;\nvar FileMetadata = 1063;\nvar LiveChatMessage = 1311;\nvar ProblemTracker = 1971;\nvar Report = 1984;\nvar Reporting = 1984;\nvar Label = 1985;\nvar CommunityPostApproval = 4550;\nvar JobRequest = 5999;\nvar JobResult = 6999;\nvar JobFeedback = 7e3;\nvar ZapGoal = 9041;\nvar ZapRequest = 9734;\nvar Zap = 9735;\nvar Highlights = 9802;\nvar Mutelist = 1e4;\nvar Pinlist = 10001;\nvar RelayList = 10002;\nvar BookmarkList = 10003;\nvar CommunitiesList = 10004;\nvar PublicChatsList = 10005;\nvar BlockedRelaysList = 10006;\nvar SearchRelaysList = 10007;\nvar InterestsList = 10015;\nvar UserEmojiList = 10030;\nvar DirectMessageRelaysList = 10050;\nvar FileServerPreference = 10096;\nvar NWCWalletInfo = 13194;\nvar LightningPubRPC = 21e3;\nvar ClientAuth = 22242;\nvar NWCWalletRequest = 23194;\nvar NWCWalletResponse = 23195;\nvar NostrConnect = 24133;\nvar HTTPAuth = 27235;\nvar Followsets = 3e4;\nvar Genericlists = 30001;\nvar Relaysets = 30002;\nvar Bookmarksets = 30003;\nvar Curationsets = 30004;\nvar ProfileBadges = 30008;\nvar BadgeDefinition = 30009;\nvar Interestsets = 30015;\nvar CreateOrUpdateStall = 30017;\nvar CreateOrUpdateProduct = 30018;\nvar LongFormArticle = 30023;\nvar DraftLong = 30024;\nvar Emojisets = 30030;\nvar Application = 30078;\nvar LiveEvent = 30311;\nvar UserStatuses = 30315;\nvar ClassifiedListing = 30402;\nvar DraftClassifiedListing = 30403;\nvar Date2 = 31922;\nvar Time = 31923;\nvar Calendar = 31924;\nvar CalendarEventRSVP = 31925;\nvar Handlerrecommendation = 31989;\nvar Handlerinformation = 31990;\nvar CommunityDefinition = 34550;\n\n// filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (let f in filter) {\n    if (f[0] === \"#\") {\n      let tagName = f.slice(1);\n      let values = filter[`#${tagName}`];\n      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1))\n        return false;\n    }\n  }\n  if (filter.since && event.created_at < filter.since)\n    return false;\n  if (filter.until && event.created_at > filter.until)\n    return false;\n  return true;\n}\nfunction matchFilters(filters, event) {\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    if (matchFilter(filters[i2], event)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction mergeFilters(...filters) {\n  let result = {};\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    let filter = filters[i2];\n    Object.entries(filter).forEach(([property, values]) => {\n      if (property === \"kinds\" || property === \"ids\" || property === \"authors\" || property[0] === \"#\") {\n        result[property] = result[property] || [];\n        for (let v = 0; v < values.length; v++) {\n          let value = values[v];\n          if (!result[property].includes(value))\n            result[property].push(value);\n        }\n      }\n    });\n    if (filter.limit && (!result.limit || filter.limit > result.limit))\n      result.limit = filter.limit;\n    if (filter.until && (!result.until || filter.until > result.until))\n      result.until = filter.until;\n    if (filter.since && (!result.since || filter.since < result.since))\n      result.since = filter.since;\n  }\n  return result;\n}\nfunction getFilterLimit(filter) {\n  if (filter.ids && !filter.ids.length)\n    return 0;\n  if (filter.kinds && !filter.kinds.length)\n    return 0;\n  if (filter.authors && !filter.authors.length)\n    return 0;\n  for (const [key, value] of Object.entries(filter)) {\n    if (key[0] === \"#\" && Array.isArray(value) && !value.length)\n      return 0;\n  }\n  return Math.min(\n    Math.max(0, filter.limit ?? Infinity),\n    filter.ids?.length ?? Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isReplaceableKind(kind)) ? filter.authors.length * filter.kinds.length : Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isAddressableKind(kind)) && filter[\"#d\"]?.length ? filter.authors.length * filter.kinds.length * filter[\"#d\"].length : Infinity\n  );\n}\n\n// fakejson.ts\nvar fakejson_exports = {};\n__export(fakejson_exports, {\n  getHex64: () => getHex64,\n  getInt: () => getInt,\n  getSubscriptionId: () => getSubscriptionId,\n  matchEventId: () => matchEventId,\n  matchEventKind: () => matchEventKind,\n  matchEventPubkey: () => matchEventPubkey\n});\nfunction getHex64(json, field) {\n  let len = field.length + 3;\n  let idx = json.indexOf(`\"${field}\":`) + len;\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1;\n  return json.slice(s, s + 64);\n}\nfunction getInt(json, field) {\n  let len = field.length;\n  let idx = json.indexOf(`\"${field}\":`) + len + 3;\n  let sliced = json.slice(idx);\n  let end = Math.min(sliced.indexOf(\",\"), sliced.indexOf(\"}\"));\n  return parseInt(sliced.slice(0, end), 10);\n}\nfunction getSubscriptionId(json) {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`);\n  if (idx === -1)\n    return null;\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`);\n  if (pstart === -1)\n    return null;\n  let start = idx + 7 + 1 + pstart;\n  let pend = json.slice(start + 1, 80).indexOf(`\"`);\n  if (pend === -1)\n    return null;\n  let end = start + 1 + pend;\n  return json.slice(start + 1, end);\n}\nfunction matchEventId(json, id) {\n  return id === getHex64(json, \"id\");\n}\nfunction matchEventPubkey(json, pubkey) {\n  return pubkey === getHex64(json, \"pubkey\");\n}\nfunction matchEventKind(json, kind) {\n  return kind === getInt(json, \"kind\");\n}\n\n// nip42.ts\nvar nip42_exports = {};\n__export(nip42_exports, {\n  makeAuthEvent: () => makeAuthEvent\n});\nfunction makeAuthEvent(relayURL, challenge) {\n  return {\n    kind: ClientAuth,\n    created_at: Math.floor(Date.now() / 1e3),\n    tags: [\n      [\"relay\", relayURL],\n      [\"challenge\", challenge]\n    ],\n    content: \"\"\n  };\n}\n\n// helpers.ts\nasync function yieldThread() {\n  return new Promise((resolve) => {\n    const ch = new MessageChannel();\n    const handler = () => {\n      ch.port1.removeEventListener(\"message\", handler);\n      resolve();\n    };\n    ch.port1.addEventListener(\"message\", handler);\n    ch.port2.postMessage(0);\n    ch.port1.start();\n  });\n}\nvar alwaysTrue = (t) => {\n  t[verifiedSymbol] = true;\n  return true;\n};\n\n// abstract-relay.ts\nvar AbstractRelay = class {\n  url;\n  _connected = false;\n  onclose = null;\n  onnotice = (msg) => console.debug(`NOTICE from ${this.url}: ${msg}`);\n  _onauth = null;\n  baseEoseTimeout = 4400;\n  connectionTimeout = 4400;\n  publishTimeout = 4400;\n  openSubs = /* @__PURE__ */ new Map();\n  connectionTimeoutHandle;\n  connectionPromise;\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  ws;\n  incomingMessageQueue = new Queue();\n  queueRunning = false;\n  challenge;\n  authPromise;\n  serial = 0;\n  verifyEvent;\n  _WebSocket;\n  constructor(url, opts) {\n    this.url = normalizeURL(url);\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation || WebSocket;\n  }\n  static async connect(url, opts) {\n    const relay = new AbstractRelay(url, opts);\n    await relay.connect();\n    return relay;\n  }\n  closeAllSubscriptions(reason) {\n    for (let [_, sub] of this.openSubs) {\n      sub.close(reason);\n    }\n    this.openSubs.clear();\n    for (let [_, ep] of this.openEventPublishes) {\n      ep.reject(new Error(reason));\n    }\n    this.openEventPublishes.clear();\n    for (let [_, cr] of this.openCountRequests) {\n      cr.reject(new Error(reason));\n    }\n    this.openCountRequests.clear();\n  }\n  get connected() {\n    return this._connected;\n  }\n  async connect() {\n    if (this.connectionPromise)\n      return this.connectionPromise;\n    this.challenge = void 0;\n    this.authPromise = void 0;\n    this.connectionPromise = new Promise((resolve, reject) => {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        reject(\"connection timed out\");\n        this.connectionPromise = void 0;\n        this.onclose?.();\n        this.closeAllSubscriptions(\"relay connection timed out\");\n      }, this.connectionTimeout);\n      try {\n        this.ws = new this._WebSocket(this.url);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      this.ws.onopen = () => {\n        clearTimeout(this.connectionTimeoutHandle);\n        this._connected = true;\n        resolve();\n      };\n      this.ws.onerror = (ev) => {\n        reject(ev.message || \"websocket error\");\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection errored\");\n        }\n      };\n      this.ws.onclose = async () => {\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection closed\");\n        }\n      };\n      this.ws.onmessage = this._onmessage.bind(this);\n    });\n    return this.connectionPromise;\n  }\n  async runQueue() {\n    this.queueRunning = true;\n    while (true) {\n      if (false === this.handleNext()) {\n        break;\n      }\n      await yieldThread();\n    }\n    this.queueRunning = false;\n  }\n  handleNext() {\n    const json = this.incomingMessageQueue.dequeue();\n    if (!json) {\n      return false;\n    }\n    const subid = getSubscriptionId(json);\n    if (subid) {\n      const so = this.openSubs.get(subid);\n      if (!so) {\n        return;\n      }\n      const id = getHex64(json, \"id\");\n      const alreadyHave = so.alreadyHaveEvent?.(id);\n      so.receivedEvent?.(this, id);\n      if (alreadyHave) {\n        return;\n      }\n    }\n    try {\n      let data = JSON.parse(json);\n      switch (data[0]) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(data[1]);\n          const event = data[2];\n          if (this.verifyEvent(event) && matchFilters(so.filters, event)) {\n            so.onevent(event);\n          }\n          return;\n        }\n        case \"COUNT\": {\n          const id = data[1];\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(data[1]);\n          if (!so)\n            return;\n          so.receivedEose();\n          return;\n        }\n        case \"OK\": {\n          const id = data[1];\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          if (ep) {\n            clearTimeout(ep.timeout);\n            if (ok)\n              ep.resolve(reason);\n            else\n              ep.reject(new Error(reason));\n            this.openEventPublishes.delete(id);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const id = data[1];\n          const so = this.openSubs.get(id);\n          if (!so)\n            return;\n          so.closed = true;\n          so.close(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onnotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.challenge = data[1];\n          this.authPromise = void 0;\n          this._onauth?.(data[1]);\n          return;\n        }\n      }\n    } catch (err) {\n      return;\n    }\n  }\n  async send(message) {\n    if (!this.connectionPromise)\n      throw new Error(\"sending on closed connection\");\n    this.connectionPromise.then(() => {\n      this.ws?.send(message);\n    });\n  }\n  async auth(signAuthEvent) {\n    if (!this.challenge)\n      throw new Error(\"can't perform auth, no challenge was received\");\n    if (this.authPromise)\n      return this.authPromise;\n    const evt = await signAuthEvent(makeAuthEvent(this.url, this.challenge));\n    this.authPromise = new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        const ep = this.openEventPublishes.get(evt.id);\n        if (ep) {\n          ep.reject(new Error(\"auth timed out\"));\n          this.openEventPublishes.delete(evt.id);\n        }\n      }, this.publishTimeout);\n      this.openEventPublishes.set(evt.id, { resolve, reject, timeout });\n    });\n    this.send('[\"AUTH\",' + JSON.stringify(evt) + \"]\");\n    return this.authPromise;\n  }\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => {\n        const ep = this.openEventPublishes.get(event.id);\n        if (ep) {\n          ep.reject(new Error(\"publish timed out\"));\n          this.openEventPublishes.delete(event.id);\n        }\n      }, this.publishTimeout);\n      this.openEventPublishes.set(event.id, { resolve, reject, timeout });\n    });\n    this.send('[\"EVENT\",' + JSON.stringify(event) + \"]\");\n    return ret;\n  }\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || \"count:\" + this.serial;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send('[\"COUNT\",\"' + id + '\",' + JSON.stringify(filters).substring(1));\n    return ret;\n  }\n  subscribe(filters, params) {\n    const subscription = this.prepareSubscription(filters, params);\n    subscription.fire();\n    return subscription;\n  }\n  prepareSubscription(filters, params) {\n    this.serial++;\n    const id = params.id || (params.label ? params.label + \":\" : \"sub:\") + this.serial;\n    const subscription = new Subscription(this, id, filters, params);\n    this.openSubs.set(id, subscription);\n    return subscription;\n  }\n  close() {\n    this.closeAllSubscriptions(\"relay connection closed by us\");\n    this._connected = false;\n    this.ws?.close();\n  }\n  _onmessage(ev) {\n    this.incomingMessageQueue.enqueue(ev.data);\n    if (!this.queueRunning) {\n      this.runQueue();\n    }\n  }\n};\nvar Subscription = class {\n  relay;\n  id;\n  closed = false;\n  eosed = false;\n  filters;\n  alreadyHaveEvent;\n  receivedEvent;\n  onevent;\n  oneose;\n  onclose;\n  eoseTimeout;\n  eoseTimeoutHandle;\n  constructor(relay, id, filters, params) {\n    this.relay = relay;\n    this.filters = filters;\n    this.id = id;\n    this.alreadyHaveEvent = params.alreadyHaveEvent;\n    this.receivedEvent = params.receivedEvent;\n    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;\n    this.oneose = params.oneose;\n    this.onclose = params.onclose;\n    this.onevent = params.onevent || ((event) => {\n      console.warn(\n        `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,\n        event\n      );\n    });\n  }\n  fire() {\n    this.relay.send('[\"REQ\",\"' + this.id + '\",' + JSON.stringify(this.filters).substring(1));\n    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);\n  }\n  receivedEose() {\n    if (this.eosed)\n      return;\n    clearTimeout(this.eoseTimeoutHandle);\n    this.eosed = true;\n    this.oneose?.();\n  }\n  close(reason = \"closed by caller\") {\n    if (!this.closed && this.relay.connected) {\n      this.relay.send('[\"CLOSE\",' + JSON.stringify(this.id) + \"]\");\n      this.closed = true;\n    }\n    this.relay.openSubs.delete(this.id);\n    this.onclose?.(reason);\n  }\n};\n\n// relay.ts\nvar _WebSocket;\ntry {\n  _WebSocket = WebSocket;\n} catch {\n}\nvar Relay = class extends AbstractRelay {\n  constructor(url) {\n    super(url, { verifyEvent, websocketImplementation: _WebSocket });\n  }\n  static async connect(url) {\n    const relay = new Relay(url);\n    await relay.connect();\n    return relay;\n  }\n};\n\n// abstract-pool.ts\nvar AbstractSimplePool = class {\n  relays = /* @__PURE__ */ new Map();\n  seenOn = /* @__PURE__ */ new Map();\n  trackRelays = false;\n  verifyEvent;\n  trustedRelayURLs = /* @__PURE__ */ new Set();\n  _WebSocket;\n  constructor(opts) {\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation;\n  }\n  async ensureRelay(url, params) {\n    url = normalizeURL(url);\n    let relay = this.relays.get(url);\n    if (!relay) {\n      relay = new AbstractRelay(url, {\n        verifyEvent: this.trustedRelayURLs.has(url) ? alwaysTrue : this.verifyEvent,\n        websocketImplementation: this._WebSocket\n      });\n      if (params?.connectionTimeout)\n        relay.connectionTimeout = params.connectionTimeout;\n      this.relays.set(url, relay);\n    }\n    await relay.connect();\n    return relay;\n  }\n  close(relays) {\n    relays.map(normalizeURL).forEach((url) => {\n      this.relays.get(url)?.close();\n    });\n  }\n  subscribe(relays, filter, params) {\n    return this.subscribeMap(\n      relays.map((url) => ({ url, filter })),\n      params\n    );\n  }\n  subscribeMany(relays, filters, params) {\n    return this.subscribeMap(\n      relays.flatMap((url) => filters.map((filter) => ({ url, filter }))),\n      params\n    );\n  }\n  subscribeMap(requests, params) {\n    if (this.trackRelays) {\n      params.receivedEvent = (relay, id) => {\n        let set = this.seenOn.get(id);\n        if (!set) {\n          set = /* @__PURE__ */ new Set();\n          this.seenOn.set(id, set);\n        }\n        set.add(relay);\n      };\n    }\n    const _knownIds = /* @__PURE__ */ new Set();\n    const subs = [];\n    const eosesReceived = [];\n    let handleEose = (i2) => {\n      if (eosesReceived[i2])\n        return;\n      eosesReceived[i2] = true;\n      if (eosesReceived.filter((a) => a).length === requests.length) {\n        params.oneose?.();\n        handleEose = () => {\n        };\n      }\n    };\n    const closesReceived = [];\n    let handleClose = (i2, reason) => {\n      if (closesReceived[i2])\n        return;\n      handleEose(i2);\n      closesReceived[i2] = reason;\n      if (closesReceived.filter((a) => a).length === requests.length) {\n        params.onclose?.(closesReceived);\n        handleClose = () => {\n        };\n      }\n    };\n    const localAlreadyHaveEventHandler = (id) => {\n      if (params.alreadyHaveEvent?.(id)) {\n        return true;\n      }\n      const have = _knownIds.has(id);\n      _knownIds.add(id);\n      return have;\n    };\n    const allOpened = Promise.all(\n      requests.map(async ({ url, filter }, i2) => {\n        url = normalizeURL(url);\n        let relay;\n        try {\n          relay = await this.ensureRelay(url, {\n            connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0\n          });\n        } catch (err) {\n          handleClose(i2, err?.message || String(err));\n          return;\n        }\n        let subscription = relay.subscribe([filter], {\n          ...params,\n          oneose: () => handleEose(i2),\n          onclose: (reason) => {\n            if (reason.startsWith(\"auth-required:\") && params.doauth) {\n              relay.auth(params.doauth).then(() => {\n                relay.subscribe([filter], {\n                  ...params,\n                  oneose: () => handleEose(i2),\n                  onclose: (reason2) => {\n                    handleClose(i2, reason2);\n                  },\n                  alreadyHaveEvent: localAlreadyHaveEventHandler,\n                  eoseTimeout: params.maxWait\n                });\n              }).catch((err) => {\n                handleClose(i2, `auth was required and attempted, but failed with: ${err}`);\n              });\n            } else {\n              handleClose(i2, reason);\n            }\n          },\n          alreadyHaveEvent: localAlreadyHaveEventHandler,\n          eoseTimeout: params.maxWait\n        });\n        subs.push(subscription);\n      })\n    );\n    return {\n      async close() {\n        await allOpened;\n        subs.forEach((sub) => {\n          sub.close();\n        });\n      }\n    };\n  }\n  subscribeManyMap(requests, params) {\n    if (this.trackRelays) {\n      params.receivedEvent = (relay, id) => {\n        let set = this.seenOn.get(id);\n        if (!set) {\n          set = /* @__PURE__ */ new Set();\n          this.seenOn.set(id, set);\n        }\n        set.add(relay);\n      };\n    }\n    const _knownIds = /* @__PURE__ */ new Set();\n    const subs = [];\n    const relaysLength = Object.keys(requests).length;\n    const eosesReceived = [];\n    let handleEose = (i2) => {\n      if (eosesReceived[i2])\n        return;\n      eosesReceived[i2] = true;\n      if (eosesReceived.filter((a) => a).length === relaysLength) {\n        params.oneose?.();\n        handleEose = () => {\n        };\n      }\n    };\n    const closesReceived = [];\n    let handleClose = (i2, reason) => {\n      if (closesReceived[i2])\n        return;\n      handleEose(i2);\n      closesReceived[i2] = reason;\n      if (closesReceived.filter((a) => a).length === relaysLength) {\n        params.onclose?.(closesReceived);\n        handleClose = () => {\n        };\n      }\n    };\n    const localAlreadyHaveEventHandler = (id) => {\n      if (params.alreadyHaveEvent?.(id)) {\n        return true;\n      }\n      const have = _knownIds.has(id);\n      _knownIds.add(id);\n      return have;\n    };\n    const allOpened = Promise.all(\n      Object.entries(requests).map(async (req, i2, arr) => {\n        if (arr.indexOf(req) !== i2) {\n          handleClose(i2, \"duplicate url\");\n          return;\n        }\n        let [url, filters] = req;\n        url = normalizeURL(url);\n        let relay;\n        try {\n          relay = await this.ensureRelay(url, {\n            connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0\n          });\n        } catch (err) {\n          handleClose(i2, err?.message || String(err));\n          return;\n        }\n        let subscription = relay.subscribe(filters, {\n          ...params,\n          oneose: () => handleEose(i2),\n          onclose: (reason) => {\n            if (reason.startsWith(\"auth-required:\") && params.doauth) {\n              relay.auth(params.doauth).then(() => {\n                relay.subscribe(filters, {\n                  ...params,\n                  oneose: () => handleEose(i2),\n                  onclose: (reason2) => {\n                    handleClose(i2, reason2);\n                  },\n                  alreadyHaveEvent: localAlreadyHaveEventHandler,\n                  eoseTimeout: params.maxWait\n                });\n              }).catch((err) => {\n                handleClose(i2, `auth was required and attempted, but failed with: ${err}`);\n              });\n            } else {\n              handleClose(i2, reason);\n            }\n          },\n          alreadyHaveEvent: localAlreadyHaveEventHandler,\n          eoseTimeout: params.maxWait\n        });\n        subs.push(subscription);\n      })\n    );\n    return {\n      async close() {\n        await allOpened;\n        subs.forEach((sub) => {\n          sub.close();\n        });\n      }\n    };\n  }\n  subscribeEose(relays, filter, params) {\n    const subcloser = this.subscribe(relays, filter, {\n      ...params,\n      oneose() {\n        subcloser.close();\n      }\n    });\n    return subcloser;\n  }\n  subscribeManyEose(relays, filters, params) {\n    const subcloser = this.subscribeMany(relays, filters, {\n      ...params,\n      oneose() {\n        subcloser.close();\n      }\n    });\n    return subcloser;\n  }\n  async querySync(relays, filter, params) {\n    return new Promise(async (resolve) => {\n      const events = [];\n      this.subscribeEose(relays, filter, {\n        ...params,\n        onevent(event) {\n          events.push(event);\n        },\n        onclose(_) {\n          resolve(events);\n        }\n      });\n    });\n  }\n  async get(relays, filter, params) {\n    filter.limit = 1;\n    const events = await this.querySync(relays, filter, params);\n    events.sort((a, b) => b.created_at - a.created_at);\n    return events[0] || null;\n  }\n  publish(relays, event) {\n    return relays.map(normalizeURL).map(async (url, i2, arr) => {\n      if (arr.indexOf(url) !== i2) {\n        return Promise.reject(\"duplicate url\");\n      }\n      let r = await this.ensureRelay(url);\n      return r.publish(event).then((reason) => {\n        if (this.trackRelays) {\n          let set = this.seenOn.get(event.id);\n          if (!set) {\n            set = /* @__PURE__ */ new Set();\n            this.seenOn.set(event.id, set);\n          }\n          set.add(r);\n        }\n        return reason;\n      });\n    });\n  }\n  listConnectionStatus() {\n    const map = /* @__PURE__ */ new Map();\n    this.relays.forEach((relay, url) => map.set(url, relay.connected));\n    return map;\n  }\n  destroy() {\n    this.relays.forEach((conn) => conn.close());\n    this.relays = /* @__PURE__ */ new Map();\n  }\n};\n\n// pool.ts\nvar _WebSocket2;\ntry {\n  _WebSocket2 = WebSocket;\n} catch {\n}\nvar SimplePool = class extends AbstractSimplePool {\n  constructor() {\n    super({ verifyEvent, websocketImplementation: _WebSocket2 });\n  }\n};\n\n// nip19.ts\nvar nip19_exports = {};\n__export(nip19_exports, {\n  BECH32_REGEX: () => BECH32_REGEX,\n  Bech32MaxSize: () => Bech32MaxSize,\n  NostrTypeGuard: () => NostrTypeGuard,\n  decode: () => decode,\n  decodeNostrURI: () => decodeNostrURI,\n  encodeBytes: () => encodeBytes,\n  naddrEncode: () => naddrEncode,\n  neventEncode: () => neventEncode,\n  noteEncode: () => noteEncode,\n  nprofileEncode: () => nprofileEncode,\n  npubEncode: () => npubEncode,\n  nsecEncode: () => nsecEncode\n});\n\n\nvar NostrTypeGuard = {\n  isNProfile: (value) => /^nprofile1[a-z\\d]+$/.test(value || \"\"),\n  isNEvent: (value) => /^nevent1[a-z\\d]+$/.test(value || \"\"),\n  isNAddr: (value) => /^naddr1[a-z\\d]+$/.test(value || \"\"),\n  isNSec: (value) => /^nsec1[a-z\\d]{58}$/.test(value || \"\"),\n  isNPub: (value) => /^npub1[a-z\\d]{58}$/.test(value || \"\"),\n  isNote: (value) => /^note1[a-z\\d]+$/.test(value || \"\"),\n  isNcryptsec: (value) => /^ncryptsec1[a-z\\d]+$/.test(value || \"\")\n};\nvar Bech32MaxSize = 5e3;\nvar BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;\nfunction integerToUint8Array(number) {\n  const uint8Array = new Uint8Array(4);\n  uint8Array[0] = number >> 24 & 255;\n  uint8Array[1] = number >> 16 & 255;\n  uint8Array[2] = number >> 8 & 255;\n  uint8Array[3] = number & 255;\n  return uint8Array;\n}\nfunction decodeNostrURI(nip19code) {\n  try {\n    if (nip19code.startsWith(\"nostr:\"))\n      nip19code = nip19code.substring(6);\n    return decode(nip19code);\n  } catch (_err) {\n    return { type: \"invalid\", data: null };\n  }\n}\nfunction decode(nip19) {\n  let { prefix, words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(nip19, Bech32MaxSize);\n  let data = new Uint8Array(_scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words));\n  switch (prefix) {\n    case \"nprofile\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nprofile\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      return {\n        type: \"nprofile\",\n        data: {\n          pubkey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nevent\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nevent\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      if (tlv[2] && tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (tlv[3] && tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"nevent\",\n        data: {\n          id: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0] ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[2][0]) : void 0,\n          kind: tlv[3]?.[0] ? parseInt((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[3][0]), 16) : void 0\n        }\n      };\n    }\n    case \"naddr\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for naddr\");\n      if (!tlv[2]?.[0])\n        throw new Error(\"missing TLV 2 for naddr\");\n      if (tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (!tlv[3]?.[0])\n        throw new Error(\"missing TLV 3 for naddr\");\n      if (tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"naddr\",\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[2][0]),\n          kind: parseInt((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nsec\":\n      return { type: prefix, data };\n    case \"npub\":\n    case \"note\":\n      return { type: prefix, data: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(data) };\n    default:\n      throw new Error(`unknown prefix ${prefix}`);\n  }\n}\nfunction parseTLV(data) {\n  let result = {};\n  let rest = data;\n  while (rest.length > 0) {\n    let t = rest[0];\n    let l = rest[1];\n    let v = rest.slice(2, 2 + l);\n    rest = rest.slice(2 + l);\n    if (v.length < l)\n      throw new Error(`not enough data to read on TLV ${t}`);\n    result[t] = result[t] || [];\n    result[t].push(v);\n  }\n  return result;\n}\nfunction nsecEncode(key) {\n  return encodeBytes(\"nsec\", key);\n}\nfunction npubEncode(hex) {\n  return encodeBytes(\"npub\", (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex));\n}\nfunction noteEncode(hex) {\n  return encodeBytes(\"note\", (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex));\n}\nfunction encodeBech32(prefix, data) {\n  let words = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.toWords(data);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.encode(prefix, words, Bech32MaxSize);\n}\nfunction encodeBytes(prefix, bytes) {\n  return encodeBech32(prefix, bytes);\n}\nfunction nprofileEncode(profile) {\n  let data = encodeTLV({\n    0: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(profile.pubkey)],\n    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))\n  });\n  return encodeBech32(\"nprofile\", data);\n}\nfunction neventEncode(event) {\n  let kindArray;\n  if (event.kind !== void 0) {\n    kindArray = integerToUint8Array(event.kind);\n  }\n  let data = encodeTLV({\n    0: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(event.id)],\n    1: (event.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: event.author ? [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(event.author)] : [],\n    3: kindArray ? [new Uint8Array(kindArray)] : []\n  });\n  return encodeBech32(\"nevent\", data);\n}\nfunction naddrEncode(addr) {\n  let kind = new ArrayBuffer(4);\n  new DataView(kind).setUint32(0, addr.kind, false);\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(addr.pubkey)],\n    3: [new Uint8Array(kind)]\n  });\n  return encodeBech32(\"naddr\", data);\n}\nfunction encodeTLV(tlv) {\n  let entries = [];\n  Object.entries(tlv).reverse().forEach(([t, vs]) => {\n    vs.forEach((v) => {\n      let entry = new Uint8Array(v.length + 2);\n      entry.set([parseInt(t)], 0);\n      entry.set([v.length], 1);\n      entry.set(v, 2);\n      entries.push(entry);\n    });\n  });\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...entries);\n}\n\n// references.ts\nvar mentionRegex = /\\bnostr:((note|npub|naddr|nevent|nprofile)1\\w+)\\b|#\\[(\\d+)\\]/g;\nfunction parseReferences(evt) {\n  let references = [];\n  for (let ref of evt.content.matchAll(mentionRegex)) {\n    if (ref[2]) {\n      try {\n        let { type, data } = decode(ref[1]);\n        switch (type) {\n          case \"npub\": {\n            references.push({\n              text: ref[0],\n              profile: { pubkey: data, relays: [] }\n            });\n            break;\n          }\n          case \"nprofile\": {\n            references.push({\n              text: ref[0],\n              profile: data\n            });\n            break;\n          }\n          case \"note\": {\n            references.push({\n              text: ref[0],\n              event: { id: data, relays: [] }\n            });\n            break;\n          }\n          case \"nevent\": {\n            references.push({\n              text: ref[0],\n              event: data\n            });\n            break;\n          }\n          case \"naddr\": {\n            references.push({\n              text: ref[0],\n              address: data\n            });\n            break;\n          }\n        }\n      } catch (err) {\n      }\n    } else if (ref[3]) {\n      let idx = parseInt(ref[3], 10);\n      let tag = evt.tags[idx];\n      if (!tag)\n        continue;\n      switch (tag[0]) {\n        case \"p\": {\n          references.push({\n            text: ref[0],\n            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"e\": {\n          references.push({\n            text: ref[0],\n            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"a\": {\n          try {\n            let [kind, pubkey, identifier] = tag[1].split(\":\");\n            references.push({\n              text: ref[0],\n              address: {\n                identifier,\n                pubkey,\n                kind: parseInt(kind, 10),\n                relays: tag[2] ? [tag[2]] : []\n              }\n            });\n          } catch (err) {\n          }\n          break;\n        }\n      }\n    }\n  }\n  return references;\n}\n\n// nip04.ts\nvar nip04_exports = {};\n__export(nip04_exports, {\n  decrypt: () => decrypt,\n  encrypt: () => encrypt\n});\n\n\n\n\nfunction encrypt(secretKey, pubkey, text) {\n  const privkey = secretKey instanceof Uint8Array ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(secretKey) : secretKey;\n  const key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  const normalizedKey = getNormalizedX(key);\n  let iv = Uint8Array.from((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(16));\n  let plaintext = utf8Encoder.encode(text);\n  let ciphertext = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__.cbc)(normalizedKey, iv).encrypt(plaintext);\n  let ctb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(ciphertext));\n  let ivb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(iv.buffer));\n  return `${ctb64}?iv=${ivb64}`;\n}\nfunction decrypt(secretKey, pubkey, data) {\n  const privkey = secretKey instanceof Uint8Array ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(secretKey) : secretKey;\n  let [ctb64, ivb64] = data.split(\"?iv=\");\n  let key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  let normalizedKey = getNormalizedX(key);\n  let iv = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ivb64);\n  let ciphertext = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ctb64);\n  let plaintext = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__.cbc)(normalizedKey, iv).decrypt(ciphertext);\n  return utf8Decoder.decode(plaintext);\n}\nfunction getNormalizedX(key) {\n  return key.slice(1, 33);\n}\n\n// nip05.ts\nvar nip05_exports = {};\n__export(nip05_exports, {\n  NIP05_REGEX: () => NIP05_REGEX,\n  isNip05: () => isNip05,\n  isValid: () => isValid,\n  queryProfile: () => queryProfile,\n  searchDomain: () => searchDomain,\n  useFetchImplementation: () => useFetchImplementation\n});\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w_-]+(\\.[\\w_-]+)+)$/;\nvar isNip05 = (value) => NIP05_REGEX.test(value || \"\");\nvar _fetch;\ntry {\n  _fetch = fetch;\n} catch (_) {\n  null;\n}\nfunction useFetchImplementation(fetchImplementation) {\n  _fetch = fetchImplementation;\n}\nasync function searchDomain(domain, query = \"\") {\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${query}`;\n    const res = await _fetch(url, { redirect: \"manual\" });\n    if (res.status !== 200) {\n      throw Error(\"Wrong response code\");\n    }\n    const json = await res.json();\n    return json.names;\n  } catch (_) {\n    return {};\n  }\n}\nasync function queryProfile(fullname) {\n  const match = fullname.match(NIP05_REGEX);\n  if (!match)\n    return null;\n  const [, name = \"_\", domain] = match;\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${name}`;\n    const res = await _fetch(url, { redirect: \"manual\" });\n    if (res.status !== 200) {\n      throw Error(\"Wrong response code\");\n    }\n    const json = await res.json();\n    const pubkey = json.names[name];\n    return pubkey ? { pubkey, relays: json.relays?.[pubkey] } : null;\n  } catch (_e) {\n    return null;\n  }\n}\nasync function isValid(pubkey, nip05) {\n  const res = await queryProfile(nip05);\n  return res ? res.pubkey === pubkey : false;\n}\n\n// nip10.ts\nvar nip10_exports = {};\n__export(nip10_exports, {\n  parse: () => parse\n});\nfunction parse(event) {\n  const result = {\n    reply: void 0,\n    root: void 0,\n    mentions: [],\n    profiles: [],\n    quotes: []\n  };\n  let maybeParent;\n  let maybeRoot;\n  for (let i2 = event.tags.length - 1; i2 >= 0; i2--) {\n    const tag = event.tags[i2];\n    if (tag[0] === \"e\" && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl, eTagMarker, eTagAuthor] = tag;\n      const eventPointer = {\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : [],\n        author: eTagAuthor\n      };\n      if (eTagMarker === \"root\") {\n        result.root = eventPointer;\n        continue;\n      }\n      if (eTagMarker === \"reply\") {\n        result.reply = eventPointer;\n        continue;\n      }\n      if (eTagMarker === \"mention\") {\n        result.mentions.push(eventPointer);\n        continue;\n      }\n      if (!maybeParent) {\n        maybeParent = eventPointer;\n      } else {\n        maybeRoot = eventPointer;\n      }\n      result.mentions.push(eventPointer);\n      continue;\n    }\n    if (tag[0] === \"q\" && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl] = tag;\n      result.quotes.push({\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : []\n      });\n    }\n    if (tag[0] === \"p\" && tag[1]) {\n      result.profiles.push({\n        pubkey: tag[1],\n        relays: tag[2] ? [tag[2]] : []\n      });\n      continue;\n    }\n  }\n  if (!result.root) {\n    result.root = maybeRoot || maybeParent || result.reply;\n  }\n  if (!result.reply) {\n    result.reply = maybeParent || result.root;\n  }\n  ;\n  [result.reply, result.root].forEach((ref) => {\n    if (!ref)\n      return;\n    let idx = result.mentions.indexOf(ref);\n    if (idx !== -1) {\n      result.mentions.splice(idx, 1);\n    }\n    if (ref.author) {\n      let author = result.profiles.find((p) => p.pubkey === ref.author);\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = [];\n        }\n        author.relays.forEach((url) => {\n          if (ref.relays?.indexOf(url) === -1)\n            ref.relays.push(url);\n        });\n        author.relays = ref.relays;\n      }\n    }\n  });\n  result.mentions.forEach((ref) => {\n    if (ref.author) {\n      let author = result.profiles.find((p) => p.pubkey === ref.author);\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = [];\n        }\n        author.relays.forEach((url) => {\n          if (ref.relays.indexOf(url) === -1)\n            ref.relays.push(url);\n        });\n        author.relays = ref.relays;\n      }\n    }\n  });\n  return result;\n}\n\n// nip11.ts\nvar nip11_exports = {};\n__export(nip11_exports, {\n  fetchRelayInformation: () => fetchRelayInformation,\n  useFetchImplementation: () => useFetchImplementation2\n});\nvar _fetch2;\ntry {\n  _fetch2 = fetch;\n} catch {\n}\nfunction useFetchImplementation2(fetchImplementation) {\n  _fetch2 = fetchImplementation;\n}\nasync function fetchRelayInformation(url) {\n  return await (await fetch(url.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\"), {\n    headers: { Accept: \"application/nostr+json\" }\n  })).json();\n}\n\n// nip13.ts\nvar nip13_exports = {};\n__export(nip13_exports, {\n  fastEventHash: () => fastEventHash,\n  getPow: () => getPow,\n  minePow: () => minePow\n});\n\n\nfunction getPow(hex) {\n  let count = 0;\n  for (let i2 = 0; i2 < 64; i2 += 8) {\n    const nibble = parseInt(hex.substring(i2, i2 + 8), 16);\n    if (nibble === 0) {\n      count += 32;\n    } else {\n      count += Math.clz32(nibble);\n      break;\n    }\n  }\n  return count;\n}\nfunction minePow(unsigned, difficulty) {\n  let count = 0;\n  const event = unsigned;\n  const tag = [\"nonce\", count.toString(), difficulty.toString()];\n  event.tags.push(tag);\n  while (true) {\n    const now2 = Math.floor(new Date().getTime() / 1e3);\n    if (now2 !== event.created_at) {\n      count = 0;\n      event.created_at = now2;\n    }\n    tag[1] = (++count).toString();\n    event.id = fastEventHash(event);\n    if (getPow(event.id) >= difficulty) {\n      break;\n    }\n  }\n  return event;\n}\nfunction fastEventHash(evt) {\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(\n    (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])))\n  );\n}\n\n// nip17.ts\nvar nip17_exports = {};\n__export(nip17_exports, {\n  unwrapEvent: () => unwrapEvent2,\n  unwrapManyEvents: () => unwrapManyEvents2,\n  wrapEvent: () => wrapEvent2,\n  wrapManyEvents: () => wrapManyEvents2\n});\n\n// nip59.ts\nvar nip59_exports = {};\n__export(nip59_exports, {\n  createRumor: () => createRumor,\n  createSeal: () => createSeal,\n  createWrap: () => createWrap,\n  unwrapEvent: () => unwrapEvent,\n  unwrapManyEvents: () => unwrapManyEvents,\n  wrapEvent: () => wrapEvent,\n  wrapManyEvents: () => wrapManyEvents\n});\n\n// nip44.ts\nvar nip44_exports = {};\n__export(nip44_exports, {\n  decrypt: () => decrypt2,\n  encrypt: () => encrypt2,\n  getConversationKey: () => getConversationKey,\n  v2: () => v2\n});\n\n\n\n\n\n\n\n\nvar minPlaintextSize = 1;\nvar maxPlaintextSize = 65535;\nfunction getConversationKey(privkeyA, pubkeyB) {\n  const sharedX = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkeyA, \"02\" + pubkeyB).subarray(1, 33);\n  return (0,_noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__.extract)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, sharedX, \"nip44-v2\");\n}\nfunction getMessageKeys(conversationKey, nonce) {\n  const keys = (0,_noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__.expand)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, conversationKey, nonce, 76);\n  return {\n    chacha_key: keys.subarray(0, 32),\n    chacha_nonce: keys.subarray(32, 44),\n    hmac_key: keys.subarray(44, 76)\n  };\n}\nfunction calcPaddedLen(len) {\n  if (!Number.isSafeInteger(len) || len < 1)\n    throw new Error(\"expected positive integer\");\n  if (len <= 32)\n    return 32;\n  const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;\n  const chunk = nextPower <= 256 ? 32 : nextPower / 8;\n  return chunk * (Math.floor((len - 1) / chunk) + 1);\n}\nfunction writeU16BE(num) {\n  if (!Number.isSafeInteger(num) || num < minPlaintextSize || num > maxPlaintextSize)\n    throw new Error(\"invalid plaintext size: must be between 1 and 65535 bytes\");\n  const arr = new Uint8Array(2);\n  new DataView(arr.buffer).setUint16(0, num, false);\n  return arr;\n}\nfunction pad(plaintext) {\n  const unpadded = utf8Encoder.encode(plaintext);\n  const unpaddedLen = unpadded.length;\n  const prefix = writeU16BE(unpaddedLen);\n  const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen);\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(prefix, unpadded, suffix);\n}\nfunction unpad(padded) {\n  const unpaddedLen = new DataView(padded.buffer).getUint16(0);\n  const unpadded = padded.subarray(2, 2 + unpaddedLen);\n  if (unpaddedLen < minPlaintextSize || unpaddedLen > maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen(unpaddedLen))\n    throw new Error(\"invalid padding\");\n  return utf8Decoder.decode(unpadded);\n}\nfunction hmacAad(key, message, aad) {\n  if (aad.length !== 32)\n    throw new Error(\"AAD associated data must be 32 bytes\");\n  const combined = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(aad, message);\n  return (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__.hmac)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, key, combined);\n}\nfunction decodePayload(payload) {\n  if (typeof payload !== \"string\")\n    throw new Error(\"payload must be a valid string\");\n  const plen = payload.length;\n  if (plen < 132 || plen > 87472)\n    throw new Error(\"invalid payload length: \" + plen);\n  if (payload[0] === \"#\")\n    throw new Error(\"unknown encryption version\");\n  let data;\n  try {\n    data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(payload);\n  } catch (error) {\n    throw new Error(\"invalid base64: \" + error.message);\n  }\n  const dlen = data.length;\n  if (dlen < 99 || dlen > 65603)\n    throw new Error(\"invalid data length: \" + dlen);\n  const vers = data[0];\n  if (vers !== 2)\n    throw new Error(\"unknown encryption version \" + vers);\n  return {\n    nonce: data.subarray(1, 33),\n    ciphertext: data.subarray(33, -32),\n    mac: data.subarray(-32)\n  };\n}\nfunction encrypt2(plaintext, conversationKey, nonce = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(32)) {\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const padded = pad(plaintext);\n  const ciphertext = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__.chacha20)(chacha_key, chacha_nonce, padded);\n  const mac = hmacAad(hmac_key, ciphertext, nonce);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(new Uint8Array([2]), nonce, ciphertext, mac));\n}\nfunction decrypt2(payload, conversationKey) {\n  const { nonce, ciphertext, mac } = decodePayload(payload);\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const calculatedMac = hmacAad(hmac_key, ciphertext, nonce);\n  if (!(0,_noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__.equalBytes)(calculatedMac, mac))\n    throw new Error(\"invalid MAC\");\n  const padded = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__.chacha20)(chacha_key, chacha_nonce, ciphertext);\n  return unpad(padded);\n}\nvar v2 = {\n  utils: {\n    getConversationKey,\n    calcPaddedLen\n  },\n  encrypt: encrypt2,\n  decrypt: decrypt2\n};\n\n// nip59.ts\nvar TWO_DAYS = 2 * 24 * 60 * 60;\nvar now = () => Math.round(Date.now() / 1e3);\nvar randomNow = () => Math.round(now() - Math.random() * TWO_DAYS);\nvar nip44ConversationKey = (privateKey, publicKey) => getConversationKey(privateKey, publicKey);\nvar nip44Encrypt = (data, privateKey, publicKey) => encrypt2(JSON.stringify(data), nip44ConversationKey(privateKey, publicKey));\nvar nip44Decrypt = (data, privateKey) => JSON.parse(decrypt2(data.content, nip44ConversationKey(privateKey, data.pubkey)));\nfunction createRumor(event, privateKey) {\n  const rumor = {\n    created_at: now(),\n    content: \"\",\n    tags: [],\n    ...event,\n    pubkey: getPublicKey(privateKey)\n  };\n  rumor.id = getEventHash(rumor);\n  return rumor;\n}\nfunction createSeal(rumor, privateKey, recipientPublicKey) {\n  return finalizeEvent(\n    {\n      kind: Seal,\n      content: nip44Encrypt(rumor, privateKey, recipientPublicKey),\n      created_at: randomNow(),\n      tags: []\n    },\n    privateKey\n  );\n}\nfunction createWrap(seal, recipientPublicKey) {\n  const randomKey = generateSecretKey();\n  return finalizeEvent(\n    {\n      kind: GiftWrap,\n      content: nip44Encrypt(seal, randomKey, recipientPublicKey),\n      created_at: randomNow(),\n      tags: [[\"p\", recipientPublicKey]]\n    },\n    randomKey\n  );\n}\nfunction wrapEvent(event, senderPrivateKey, recipientPublicKey) {\n  const rumor = createRumor(event, senderPrivateKey);\n  const seal = createSeal(rumor, senderPrivateKey, recipientPublicKey);\n  return createWrap(seal, recipientPublicKey);\n}\nfunction wrapManyEvents(event, senderPrivateKey, recipientsPublicKeys) {\n  if (!recipientsPublicKeys || recipientsPublicKeys.length === 0) {\n    throw new Error(\"At least one recipient is required.\");\n  }\n  const senderPublicKey = getPublicKey(senderPrivateKey);\n  const wrappeds = [wrapEvent(event, senderPrivateKey, senderPublicKey)];\n  recipientsPublicKeys.forEach((recipientPublicKey) => {\n    wrappeds.push(wrapEvent(event, senderPrivateKey, recipientPublicKey));\n  });\n  return wrappeds;\n}\nfunction unwrapEvent(wrap, recipientPrivateKey) {\n  const unwrappedSeal = nip44Decrypt(wrap, recipientPrivateKey);\n  return nip44Decrypt(unwrappedSeal, recipientPrivateKey);\n}\nfunction unwrapManyEvents(wrappedEvents, recipientPrivateKey) {\n  let unwrappedEvents = [];\n  wrappedEvents.forEach((e) => {\n    unwrappedEvents.push(unwrapEvent(e, recipientPrivateKey));\n  });\n  unwrappedEvents.sort((a, b) => a.created_at - b.created_at);\n  return unwrappedEvents;\n}\n\n// nip17.ts\nfunction createEvent(recipients, message, conversationTitle, replyTo) {\n  const baseEvent = {\n    created_at: Math.ceil(Date.now() / 1e3),\n    kind: PrivateDirectMessage,\n    tags: [],\n    content: message\n  };\n  const recipientsArray = Array.isArray(recipients) ? recipients : [recipients];\n  recipientsArray.forEach(({ publicKey, relayUrl }) => {\n    baseEvent.tags.push(relayUrl ? [\"p\", publicKey, relayUrl] : [\"p\", publicKey]);\n  });\n  if (replyTo) {\n    baseEvent.tags.push([\"e\", replyTo.eventId, replyTo.relayUrl || \"\", \"reply\"]);\n  }\n  if (conversationTitle) {\n    baseEvent.tags.push([\"subject\", conversationTitle]);\n  }\n  return baseEvent;\n}\nfunction wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo) {\n  const event = createEvent(recipient, message, conversationTitle, replyTo);\n  return wrapEvent(event, senderPrivateKey, recipient.publicKey);\n}\nfunction wrapManyEvents2(senderPrivateKey, recipients, message, conversationTitle, replyTo) {\n  if (!recipients || recipients.length === 0) {\n    throw new Error(\"At least one recipient is required.\");\n  }\n  const senderPublicKey = getPublicKey(senderPrivateKey);\n  return [{ publicKey: senderPublicKey }, ...recipients].map(\n    (recipient) => wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo)\n  );\n}\nvar unwrapEvent2 = unwrapEvent;\nvar unwrapManyEvents2 = unwrapManyEvents;\n\n// nip18.ts\nvar nip18_exports = {};\n__export(nip18_exports, {\n  finishRepostEvent: () => finishRepostEvent,\n  getRepostedEvent: () => getRepostedEvent,\n  getRepostedEventPointer: () => getRepostedEventPointer\n});\nfunction finishRepostEvent(t, reposted, relayUrl, privateKey) {\n  let kind;\n  const tags = [...t.tags ?? [], [\"e\", reposted.id, relayUrl], [\"p\", reposted.pubkey]];\n  if (reposted.kind === ShortTextNote) {\n    kind = Repost;\n  } else {\n    kind = GenericRepost;\n    tags.push([\"k\", String(reposted.kind)]);\n  }\n  return finalizeEvent(\n    {\n      kind,\n      tags,\n      content: t.content === \"\" || reposted.tags?.find((tag) => tag[0] === \"-\") ? \"\" : JSON.stringify(reposted),\n      created_at: t.created_at\n    },\n    privateKey\n  );\n}\nfunction getRepostedEventPointer(event) {\n  if (![Repost, GenericRepost].includes(event.kind)) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag?.[2]].filter((x) => typeof x === \"string\"),\n    author: lastPTag?.[1]\n  };\n}\nfunction getRepostedEvent(event, { skipVerification } = {}) {\n  const pointer = getRepostedEventPointer(event);\n  if (pointer === void 0 || event.content === \"\") {\n    return void 0;\n  }\n  let repostedEvent;\n  try {\n    repostedEvent = JSON.parse(event.content);\n  } catch (error) {\n    return void 0;\n  }\n  if (repostedEvent.id !== pointer.id) {\n    return void 0;\n  }\n  if (!skipVerification && !verifyEvent(repostedEvent)) {\n    return void 0;\n  }\n  return repostedEvent;\n}\n\n// nip21.ts\nvar nip21_exports = {};\n__export(nip21_exports, {\n  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,\n  parse: () => parse2,\n  test: () => test\n});\nvar NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);\nfunction test(value) {\n  return typeof value === \"string\" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);\n}\nfunction parse2(uri) {\n  const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));\n  if (!match)\n    throw new Error(`Invalid Nostr URI: ${uri}`);\n  return {\n    uri: match[0],\n    value: match[1],\n    decoded: decode(match[1])\n  };\n}\n\n// nip25.ts\nvar nip25_exports = {};\n__export(nip25_exports, {\n  finishReactionEvent: () => finishReactionEvent,\n  getReactedEventPointer: () => getReactedEventPointer\n});\nfunction finishReactionEvent(t, reacted, privateKey) {\n  const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === \"e\" || tag[0] === \"p\"));\n  return finalizeEvent(\n    {\n      ...t,\n      kind: Reaction,\n      tags: [...t.tags ?? [], ...inheritedTags, [\"e\", reacted.id], [\"p\", reacted.pubkey]],\n      content: t.content ?? \"+\"\n    },\n    privateKey\n  );\n}\nfunction getReactedEventPointer(event) {\n  if (event.kind !== Reaction) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0 || lastPTag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag[2]].filter((x) => x !== void 0),\n    author: lastPTag[1]\n  };\n}\n\n// nip27.ts\nvar nip27_exports = {};\n__export(nip27_exports, {\n  parse: () => parse3\n});\nvar noCharacter = /\\W/m;\nvar noURLCharacter = /\\W |\\W$|$|,| /m;\nfunction* parse3(content) {\n  const max = content.length;\n  let prevIndex = 0;\n  let index = 0;\n  while (index < max) {\n    let u = content.indexOf(\":\", index);\n    if (u === -1) {\n      break;\n    }\n    if (content.substring(u - 5, u) === \"nostr\") {\n      const m = content.substring(u + 60).match(noCharacter);\n      const end = m ? u + 60 + m.index : max;\n      try {\n        let pointer;\n        let { data, type } = decode(content.substring(u + 1, end));\n        switch (type) {\n          case \"npub\":\n            pointer = { pubkey: data };\n            break;\n          case \"nsec\":\n          case \"note\":\n            index = end + 1;\n            continue;\n          default:\n            pointer = data;\n        }\n        if (prevIndex !== u - 5) {\n          yield { type: \"text\", text: content.substring(prevIndex, u - 5) };\n        }\n        yield { type: \"reference\", pointer };\n        index = end;\n        prevIndex = index;\n        continue;\n      } catch (_err) {\n        index = u + 1;\n        continue;\n      }\n    } else if (content.substring(u - 5, u) === \"https\" || content.substring(u - 4, u) === \"http\") {\n      const m = content.substring(u + 4).match(noURLCharacter);\n      const end = m ? u + 4 + m.index : max;\n      const prefixLen = content[u - 1] === \"s\" ? 5 : 4;\n      try {\n        let url = new URL(content.substring(u - prefixLen, end));\n        if (url.hostname.indexOf(\".\") === -1) {\n          throw new Error(\"invalid url\");\n        }\n        if (prevIndex !== u - prefixLen) {\n          yield { type: \"text\", text: content.substring(prevIndex, u - prefixLen) };\n        }\n        if (url.pathname.endsWith(\".png\") || url.pathname.endsWith(\".jpg\") || url.pathname.endsWith(\".jpeg\") || url.pathname.endsWith(\".gif\") || url.pathname.endsWith(\".webp\")) {\n          yield { type: \"image\", url: url.toString() };\n          index = end;\n          prevIndex = index;\n          continue;\n        }\n        if (url.pathname.endsWith(\".mp4\") || url.pathname.endsWith(\".avi\") || url.pathname.endsWith(\".webm\") || url.pathname.endsWith(\".mkv\")) {\n          yield { type: \"video\", url: url.toString() };\n          index = end;\n          prevIndex = index;\n          continue;\n        }\n        if (url.pathname.endsWith(\".mp3\") || url.pathname.endsWith(\".aac\") || url.pathname.endsWith(\".ogg\") || url.pathname.endsWith(\".opus\")) {\n          yield { type: \"audio\", url: url.toString() };\n          index = end;\n          prevIndex = index;\n          continue;\n        }\n        yield { type: \"url\", url: url.toString() };\n        index = end;\n        prevIndex = index;\n        continue;\n      } catch (_err) {\n        index = end + 1;\n        continue;\n      }\n    } else if (content.substring(u - 3, u) === \"wss\" || content.substring(u - 2, u) === \"ws\") {\n      const m = content.substring(u + 4).match(noURLCharacter);\n      const end = m ? u + 4 + m.index : max;\n      const prefixLen = content[u - 1] === \"s\" ? 3 : 2;\n      try {\n        let url = new URL(content.substring(u - prefixLen, end));\n        if (url.hostname.indexOf(\".\") === -1) {\n          throw new Error(\"invalid ws url\");\n        }\n        if (prevIndex !== u - prefixLen) {\n          yield { type: \"text\", text: content.substring(prevIndex, u - prefixLen) };\n        }\n        yield { type: \"relay\", url: url.toString() };\n        index = end;\n        prevIndex = index;\n        continue;\n      } catch (_err) {\n        index = end + 1;\n        continue;\n      }\n    } else {\n      index = u + 1;\n      continue;\n    }\n  }\n  if (prevIndex !== max) {\n    yield { type: \"text\", text: content.substring(prevIndex) };\n  }\n}\n\n// nip28.ts\nvar nip28_exports = {};\n__export(nip28_exports, {\n  channelCreateEvent: () => channelCreateEvent,\n  channelHideMessageEvent: () => channelHideMessageEvent,\n  channelMessageEvent: () => channelMessageEvent,\n  channelMetadataEvent: () => channelMetadataEvent,\n  channelMuteUserEvent: () => channelMuteUserEvent\n});\nvar channelCreateEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelCreation,\n      tags: [...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMetadataEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMetadata,\n      tags: [[\"e\", t.channel_create_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMessageEvent = (t, privateKey) => {\n  const tags = [[\"e\", t.channel_create_event_id, t.relay_url, \"root\"]];\n  if (t.reply_to_channel_message_event_id) {\n    tags.push([\"e\", t.reply_to_channel_message_event_id, t.relay_url, \"reply\"]);\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMessage,\n      tags: [...tags, ...t.tags ?? []],\n      content: t.content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelHideMessageEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelHideMessage,\n      tags: [[\"e\", t.channel_message_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMuteUserEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMuteUser,\n      tags: [[\"p\", t.pubkey_to_mute], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\n\n// nip30.ts\nvar nip30_exports = {};\n__export(nip30_exports, {\n  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,\n  matchAll: () => matchAll,\n  regex: () => regex,\n  replaceAll: () => replaceAll\n});\nvar EMOJI_SHORTCODE_REGEX = /:(\\w+):/;\nvar regex = () => new RegExp(`\\\\B${EMOJI_SHORTCODE_REGEX.source}\\\\B`, \"g\");\nfunction* matchAll(content) {\n  const matches = content.matchAll(regex());\n  for (const match of matches) {\n    try {\n      const [shortcode, name] = match;\n      yield {\n        shortcode,\n        name,\n        start: match.index,\n        end: match.index + shortcode.length\n      };\n    } catch (_e) {\n    }\n  }\n}\nfunction replaceAll(content, replacer) {\n  return content.replaceAll(regex(), (shortcode, name) => {\n    return replacer({\n      shortcode,\n      name\n    });\n  });\n}\n\n// nip39.ts\nvar nip39_exports = {};\n__export(nip39_exports, {\n  useFetchImplementation: () => useFetchImplementation3,\n  validateGithub: () => validateGithub\n});\nvar _fetch3;\ntry {\n  _fetch3 = fetch;\n} catch {\n}\nfunction useFetchImplementation3(fetchImplementation) {\n  _fetch3 = fetchImplementation;\n}\nasync function validateGithub(pubkey, username, proof) {\n  try {\n    let res = await (await _fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();\n    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;\n  } catch (_) {\n    return false;\n  }\n}\n\n// nip47.ts\nvar nip47_exports = {};\n__export(nip47_exports, {\n  makeNwcRequestEvent: () => makeNwcRequestEvent,\n  parseConnectionString: () => parseConnectionString\n});\nfunction parseConnectionString(connectionString) {\n  const { pathname, searchParams } = new URL(connectionString);\n  const pubkey = pathname;\n  const relay = searchParams.get(\"relay\");\n  const secret = searchParams.get(\"secret\");\n  if (!pubkey || !relay || !secret) {\n    throw new Error(\"invalid connection string\");\n  }\n  return { pubkey, relay, secret };\n}\nasync function makeNwcRequestEvent(pubkey, secretKey, invoice) {\n  const content = {\n    method: \"pay_invoice\",\n    params: {\n      invoice\n    }\n  };\n  const encryptedContent = await encrypt(secretKey, pubkey, JSON.stringify(content));\n  const eventTemplate = {\n    kind: NWCWalletRequest,\n    created_at: Math.round(Date.now() / 1e3),\n    content: encryptedContent,\n    tags: [[\"p\", pubkey]]\n  };\n  return finalizeEvent(eventTemplate, secretKey);\n}\n\n// nip54.ts\nvar nip54_exports = {};\n__export(nip54_exports, {\n  normalizeIdentifier: () => normalizeIdentifier\n});\nfunction normalizeIdentifier(name) {\n  name = name.trim().toLowerCase();\n  name = name.normalize(\"NFKC\");\n  return Array.from(name).map((char) => {\n    if (/\\p{Letter}/u.test(char) || /\\p{Number}/u.test(char)) {\n      return char;\n    }\n    return \"-\";\n  }).join(\"\");\n}\n\n// nip57.ts\nvar nip57_exports = {};\n__export(nip57_exports, {\n  getZapEndpoint: () => getZapEndpoint,\n  makeZapReceipt: () => makeZapReceipt,\n  makeZapRequest: () => makeZapRequest,\n  useFetchImplementation: () => useFetchImplementation4,\n  validateZapRequest: () => validateZapRequest\n});\n\nvar _fetch4;\ntry {\n  _fetch4 = fetch;\n} catch {\n}\nfunction useFetchImplementation4(fetchImplementation) {\n  _fetch4 = fetchImplementation;\n}\nasync function getZapEndpoint(metadata) {\n  try {\n    let lnurl = \"\";\n    let { lud06, lud16 } = JSON.parse(metadata.content);\n    if (lud06) {\n      let { words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(lud06, 1e3);\n      let data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words);\n      lnurl = utf8Decoder.decode(data);\n    } else if (lud16) {\n      let [name, domain] = lud16.split(\"@\");\n      lnurl = new URL(`/.well-known/lnurlp/${name}`, `https://${domain}`).toString();\n    } else {\n      return null;\n    }\n    let res = await _fetch4(lnurl);\n    let body = await res.json();\n    if (body.allowsNostr && body.nostrPubkey) {\n      return body.callback;\n    }\n  } catch (err) {\n  }\n  return null;\n}\nfunction makeZapRequest({\n  profile,\n  event,\n  amount,\n  relays,\n  comment = \"\"\n}) {\n  if (!amount)\n    throw new Error(\"amount not given\");\n  if (!profile)\n    throw new Error(\"profile not given\");\n  let zr = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1e3),\n    content: comment,\n    tags: [\n      [\"p\", profile],\n      [\"amount\", amount.toString()],\n      [\"relays\", ...relays]\n    ]\n  };\n  if (event && typeof event === \"string\") {\n    zr.tags.push([\"e\", event]);\n  }\n  if (event && typeof event === \"object\") {\n    if (isReplaceableKind(event.kind)) {\n      const a = [\"a\", `${event.kind}:${event.pubkey}:`];\n      zr.tags.push(a);\n    } else if (isAddressableKind(event.kind)) {\n      let d = event.tags.find(([t, v]) => t === \"d\" && v);\n      if (!d)\n        throw new Error(\"d tag not found or is empty\");\n      const a = [\"a\", `${event.kind}:${event.pubkey}:${d[1]}`];\n      zr.tags.push(a);\n    }\n  }\n  return zr;\n}\nfunction validateZapRequest(zapRequestString) {\n  let zapRequest;\n  try {\n    zapRequest = JSON.parse(zapRequestString);\n  } catch (err) {\n    return \"Invalid zap request JSON.\";\n  }\n  if (!validateEvent(zapRequest))\n    return \"Zap request is not a valid Nostr event.\";\n  if (!verifyEvent(zapRequest))\n    return \"Invalid signature on zap request.\";\n  let p = zapRequest.tags.find(([t, v]) => t === \"p\" && v);\n  if (!p)\n    return \"Zap request doesn't have a 'p' tag.\";\n  if (!p[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'p' tag is not valid hex.\";\n  let e = zapRequest.tags.find(([t, v]) => t === \"e\" && v);\n  if (e && !e[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'e' tag is not valid hex.\";\n  let relays = zapRequest.tags.find(([t, v]) => t === \"relays\" && v);\n  if (!relays)\n    return \"Zap request doesn't have a 'relays' tag.\";\n  return null;\n}\nfunction makeZapReceipt({\n  zapRequest,\n  preimage,\n  bolt11,\n  paidAt\n}) {\n  let zr = JSON.parse(zapRequest);\n  let tagsFromZapRequest = zr.tags.filter(([t]) => t === \"e\" || t === \"p\" || t === \"a\");\n  let zap = {\n    kind: 9735,\n    created_at: Math.round(paidAt.getTime() / 1e3),\n    content: \"\",\n    tags: [...tagsFromZapRequest, [\"P\", zr.pubkey], [\"bolt11\", bolt11], [\"description\", zapRequest]]\n  };\n  if (preimage) {\n    zap.tags.push([\"preimage\", preimage]);\n  }\n  return zap;\n}\n\n// nip98.ts\nvar nip98_exports = {};\n__export(nip98_exports, {\n  getToken: () => getToken,\n  hashPayload: () => hashPayload,\n  unpackEventFromToken: () => unpackEventFromToken,\n  validateEvent: () => validateEvent2,\n  validateEventKind: () => validateEventKind,\n  validateEventMethodTag: () => validateEventMethodTag,\n  validateEventPayloadTag: () => validateEventPayloadTag,\n  validateEventTimestamp: () => validateEventTimestamp,\n  validateEventUrlTag: () => validateEventUrlTag,\n  validateToken: () => validateToken\n});\n\n\n\nvar _authorizationScheme = \"Nostr \";\nasync function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false, payload) {\n  const event = {\n    kind: HTTPAuth,\n    tags: [\n      [\"u\", loginUrl],\n      [\"method\", httpMethod]\n    ],\n    created_at: Math.round(new Date().getTime() / 1e3),\n    content: \"\"\n  };\n  if (payload) {\n    event.tags.push([\"payload\", hashPayload(payload)]);\n  }\n  const signedEvent = await sign(event);\n  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : \"\";\n  return authorizationScheme + _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));\n}\nasync function validateToken(token, url, method) {\n  const event = await unpackEventFromToken(token).catch((error) => {\n    throw error;\n  });\n  const valid = await validateEvent2(event, url, method).catch((error) => {\n    throw error;\n  });\n  return valid;\n}\nasync function unpackEventFromToken(token) {\n  if (!token) {\n    throw new Error(\"Missing token\");\n  }\n  token = token.replace(_authorizationScheme, \"\");\n  const eventB64 = utf8Decoder.decode(_scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(token));\n  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith(\"{\")) {\n    throw new Error(\"Invalid token\");\n  }\n  const event = JSON.parse(eventB64);\n  return event;\n}\nfunction validateEventTimestamp(event) {\n  if (!event.created_at) {\n    return false;\n  }\n  return Math.round(new Date().getTime() / 1e3) - event.created_at < 60;\n}\nfunction validateEventKind(event) {\n  return event.kind === HTTPAuth;\n}\nfunction validateEventUrlTag(event, url) {\n  const urlTag = event.tags.find((t) => t[0] === \"u\");\n  if (!urlTag) {\n    return false;\n  }\n  return urlTag.length > 0 && urlTag[1] === url;\n}\nfunction validateEventMethodTag(event, method) {\n  const methodTag = event.tags.find((t) => t[0] === \"method\");\n  if (!methodTag) {\n    return false;\n  }\n  return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();\n}\nfunction hashPayload(payload) {\n  const hash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(JSON.stringify(payload)));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(hash);\n}\nfunction validateEventPayloadTag(event, payload) {\n  const payloadTag = event.tags.find((t) => t[0] === \"payload\");\n  if (!payloadTag) {\n    return false;\n  }\n  const payloadHash = hashPayload(payload);\n  return payloadTag.length > 0 && payloadTag[1] === payloadHash;\n}\nasync function validateEvent2(event, url, method, body) {\n  if (!verifyEvent(event)) {\n    throw new Error(\"Invalid nostr event, signature invalid\");\n  }\n  if (!validateEventKind(event)) {\n    throw new Error(\"Invalid nostr event, kind invalid\");\n  }\n  if (!validateEventTimestamp(event)) {\n    throw new Error(\"Invalid nostr event, created_at timestamp invalid\");\n  }\n  if (!validateEventUrlTag(event, url)) {\n    throw new Error(\"Invalid nostr event, url tag invalid\");\n  }\n  if (!validateEventMethodTag(event, method)) {\n    throw new Error(\"Invalid nostr event, method tag invalid\");\n  }\n  if (Boolean(body) && typeof body === \"object\" && Object.keys(body).length > 0) {\n    if (!validateEventPayloadTag(event, body)) {\n      throw new Error(\"Invalid nostr event, payload tag does not match request body hash\");\n    }\n  }\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNrRDtBQUNEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEdBQUc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUM4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVywrREFBVSxDQUFDLDREQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBVSxDQUFDLDREQUFPO0FBQ3JDO0FBQ0EsZ0JBQWdCLCtEQUFVLENBQUMsNERBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFPO0FBQzNCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBTTtBQUN4QixTQUFTLCtEQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTLElBQUksSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsNENBQTRDLDBCQUEwQjtBQUN0RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEMsMEJBQTBCO0FB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LFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1DQUFtQyw2QkFBNkI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsU0FBUyxHQUFH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QTtBQTBDRSIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL2xpYi9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gcHVyZS50c1xuaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5cbi8vIGNvcmUudHNcbnZhciB2ZXJpZmllZFN5bWJvbCA9IFN5bWJvbChcInZlcmlmaWVkXCIpO1xudmFyIGlzUmVjb3JkID0gKG9iaikgPT4gb2JqIGluc3RhbmNlb2YgT2JqZWN0O1xuZnVuY3Rpb24gdmFsaWRhdGVFdmVudChldmVudCkge1xuICBpZiAoIWlzUmVjb3JkKGV2ZW50KSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQua2luZCAhPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQuY29udGVudCAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQuY3JlYXRlZF9hdCAhPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQucHVia2V5ICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCFldmVudC5wdWJrZXkubWF0Y2goL15bYS1mMC05XXs2NH0kLykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXZlbnQudGFncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZXZlbnQudGFncy5sZW5ndGg7IGkyKyspIHtcbiAgICBsZXQgdGFnID0gZXZlbnQudGFnc1tpMl07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRhZykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWcubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnW2pdID09PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc29ydEV2ZW50cyhldmVudHMpIHtcbiAgcmV0dXJuIGV2ZW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgaWYgKGEuY3JlYXRlZF9hdCAhPT0gYi5jcmVhdGVkX2F0KSB7XG4gICAgICByZXR1cm4gYi5jcmVhdGVkX2F0IC0gYS5jcmVhdGVkX2F0O1xuICAgIH1cbiAgICByZXR1cm4gYS5pZC5sb2NhbGVDb21wYXJlKGIuaWQpO1xuICB9KTtcbn1cblxuLy8gcHVyZS50c1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5cbi8vIHV0aWxzLnRzXG52YXIgdXRpbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbHNfZXhwb3J0cywge1xuICBRdWV1ZTogKCkgPT4gUXVldWUsXG4gIFF1ZXVlTm9kZTogKCkgPT4gUXVldWVOb2RlLFxuICBiaW5hcnlTZWFyY2g6ICgpID0+IGJpbmFyeVNlYXJjaCxcbiAgaW5zZXJ0RXZlbnRJbnRvQXNjZW5kaW5nTGlzdDogKCkgPT4gaW5zZXJ0RXZlbnRJbnRvQXNjZW5kaW5nTGlzdCxcbiAgaW5zZXJ0RXZlbnRJbnRvRGVzY2VuZGluZ0xpc3Q6ICgpID0+IGluc2VydEV2ZW50SW50b0Rlc2NlbmRpbmdMaXN0LFxuICBub3JtYWxpemVVUkw6ICgpID0+IG5vcm1hbGl6ZVVSTCxcbiAgdXRmOERlY29kZXI6ICgpID0+IHV0ZjhEZWNvZGVyLFxuICB1dGY4RW5jb2RlcjogKCkgPT4gdXRmOEVuY29kZXJcbn0pO1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG52YXIgdXRmOEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVSTCh1cmwpIHtcbiAgaWYgKHVybC5pbmRleE9mKFwiOi8vXCIpID09PSAtMSlcbiAgICB1cmwgPSBcIndzczovL1wiICsgdXJsO1xuICBsZXQgcCA9IG5ldyBVUkwodXJsKTtcbiAgcC5wYXRobmFtZSA9IHAucGF0aG5hbWUucmVwbGFjZSgvXFwvKy9nLCBcIi9cIik7XG4gIGlmIChwLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSlcbiAgICBwLnBhdGhuYW1lID0gcC5wYXRobmFtZS5zbGljZSgwLCAtMSk7XG4gIGlmIChwLnBvcnQgPT09IFwiODBcIiAmJiBwLnByb3RvY29sID09PSBcIndzOlwiIHx8IHAucG9ydCA9PT0gXCI0NDNcIiAmJiBwLnByb3RvY29sID09PSBcIndzczpcIilcbiAgICBwLnBvcnQgPSBcIlwiO1xuICBwLnNlYXJjaFBhcmFtcy5zb3J0KCk7XG4gIHAuaGFzaCA9IFwiXCI7XG4gIHJldHVybiBwLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBpbnNlcnRFdmVudEludG9EZXNjZW5kaW5nTGlzdChzb3J0ZWRBcnJheSwgZXZlbnQpIHtcbiAgY29uc3QgW2lkeCwgZm91bmRdID0gYmluYXJ5U2VhcmNoKHNvcnRlZEFycmF5LCAoYikgPT4ge1xuICAgIGlmIChldmVudC5pZCA9PT0gYi5pZClcbiAgICAgIHJldHVybiAwO1xuICAgIGlmIChldmVudC5jcmVhdGVkX2F0ID09PSBiLmNyZWF0ZWRfYXQpXG4gICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIGIuY3JlYXRlZF9hdCAtIGV2ZW50LmNyZWF0ZWRfYXQ7XG4gIH0pO1xuICBpZiAoIWZvdW5kKSB7XG4gICAgc29ydGVkQXJyYXkuc3BsaWNlKGlkeCwgMCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBzb3J0ZWRBcnJheTtcbn1cbmZ1bmN0aW9uIGluc2VydEV2ZW50SW50b0FzY2VuZGluZ0xpc3Qoc29ydGVkQXJyYXksIGV2ZW50KSB7XG4gIGNvbnN0IFtpZHgsIGZvdW5kXSA9IGJpbmFyeVNlYXJjaChzb3J0ZWRBcnJheSwgKGIpID0+IHtcbiAgICBpZiAoZXZlbnQuaWQgPT09IGIuaWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBpZiAoZXZlbnQuY3JlYXRlZF9hdCA9PT0gYi5jcmVhdGVkX2F0KVxuICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiBldmVudC5jcmVhdGVkX2F0IC0gYi5jcmVhdGVkX2F0O1xuICB9KTtcbiAgaWYgKCFmb3VuZCkge1xuICAgIHNvcnRlZEFycmF5LnNwbGljZShpZHgsIDAsIGV2ZW50KTtcbiAgfVxuICByZXR1cm4gc29ydGVkQXJyYXk7XG59XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2goYXJyLCBjb21wYXJlKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgIGNvbnN0IGNtcCA9IGNvbXBhcmUoYXJyW21pZF0pO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHJldHVybiBbbWlkLCB0cnVlXTtcbiAgICB9XG4gICAgaWYgKGNtcCA8IDApIHtcbiAgICAgIGVuZCA9IG1pZCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gbWlkICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtzdGFydCwgZmFsc2VdO1xufVxudmFyIFF1ZXVlTm9kZSA9IGNsYXNzIHtcbiAgdmFsdWU7XG4gIG5leHQgPSBudWxsO1xuICBwcmV2ID0gbnVsbDtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHRoaXMudmFsdWUgPSBtZXNzYWdlO1xuICB9XG59O1xudmFyIFF1ZXVlID0gY2xhc3Mge1xuICBmaXJzdDtcbiAgbGFzdDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5maXJzdCA9IG51bGw7XG4gICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgfVxuICBlbnF1ZXVlKHZhbHVlKSB7XG4gICAgY29uc3QgbmV3Tm9kZSA9IG5ldyBRdWV1ZU5vZGUodmFsdWUpO1xuICAgIGlmICghdGhpcy5sYXN0KSB7XG4gICAgICB0aGlzLmZpcnN0ID0gbmV3Tm9kZTtcbiAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxhc3QgPT09IHRoaXMuZmlyc3QpIHtcbiAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QucHJldiA9IHRoaXMuZmlyc3Q7XG4gICAgICB0aGlzLmZpcnN0Lm5leHQgPSBuZXdOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOb2RlLnByZXYgPSB0aGlzLmxhc3Q7XG4gICAgICB0aGlzLmxhc3QubmV4dCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QgPSBuZXdOb2RlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZXF1ZXVlKCkge1xuICAgIGlmICghdGhpcy5maXJzdClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh0aGlzLmZpcnN0ID09PSB0aGlzLmxhc3QpIHtcbiAgICAgIGNvbnN0IHRhcmdldDIgPSB0aGlzLmZpcnN0O1xuICAgICAgdGhpcy5maXJzdCA9IG51bGw7XG4gICAgICB0aGlzLmxhc3QgPSBudWxsO1xuICAgICAgcmV0dXJuIHRhcmdldDIudmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZmlyc3Q7XG4gICAgdGhpcy5maXJzdCA9IHRhcmdldC5uZXh0O1xuICAgIHJldHVybiB0YXJnZXQudmFsdWU7XG4gIH1cbn07XG5cbi8vIHB1cmUudHNcbnZhciBKUyA9IGNsYXNzIHtcbiAgZ2VuZXJhdGVTZWNyZXRLZXkoKSB7XG4gICAgcmV0dXJuIHNjaG5vcnIudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICB9XG4gIGdldFB1YmxpY0tleShzZWNyZXRLZXkpIHtcbiAgICByZXR1cm4gYnl0ZXNUb0hleChzY2hub3JyLmdldFB1YmxpY0tleShzZWNyZXRLZXkpKTtcbiAgfVxuICBmaW5hbGl6ZUV2ZW50KHQsIHNlY3JldEtleSkge1xuICAgIGNvbnN0IGV2ZW50ID0gdDtcbiAgICBldmVudC5wdWJrZXkgPSBieXRlc1RvSGV4KHNjaG5vcnIuZ2V0UHVibGljS2V5KHNlY3JldEtleSkpO1xuICAgIGV2ZW50LmlkID0gZ2V0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBldmVudC5zaWcgPSBieXRlc1RvSGV4KHNjaG5vcnIuc2lnbihnZXRFdmVudEhhc2goZXZlbnQpLCBzZWNyZXRLZXkpKTtcbiAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSB0cnVlO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICB2ZXJpZnlFdmVudChldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID09PSBcImJvb2xlYW5cIilcbiAgICAgIHJldHVybiBldmVudFt2ZXJpZmllZFN5bWJvbF07XG4gICAgY29uc3QgaGFzaCA9IGdldEV2ZW50SGFzaChldmVudCk7XG4gICAgaWYgKGhhc2ggIT09IGV2ZW50LmlkKSB7XG4gICAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZhbGlkID0gc2Nobm9yci52ZXJpZnkoZXZlbnQuc2lnLCBoYXNoLCBldmVudC5wdWJrZXkpO1xuICAgICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gdmFsaWQ7XG4gICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBzZXJpYWxpemVFdmVudChldnQpIHtcbiAgaWYgKCF2YWxpZGF0ZUV2ZW50KGV2dCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3Qgc2VyaWFsaXplIGV2ZW50IHdpdGggd3Jvbmcgb3IgbWlzc2luZyBwcm9wZXJ0aWVzXCIpO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoWzAsIGV2dC5wdWJrZXksIGV2dC5jcmVhdGVkX2F0LCBldnQua2luZCwgZXZ0LnRhZ3MsIGV2dC5jb250ZW50XSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudEhhc2goZXZlbnQpIHtcbiAgbGV0IGV2ZW50SGFzaCA9IHNoYTI1Nih1dGY4RW5jb2Rlci5lbmNvZGUoc2VyaWFsaXplRXZlbnQoZXZlbnQpKSk7XG4gIHJldHVybiBieXRlc1RvSGV4KGV2ZW50SGFzaCk7XG59XG52YXIgaSA9IG5ldyBKUygpO1xudmFyIGdlbmVyYXRlU2VjcmV0S2V5ID0gaS5nZW5lcmF0ZVNlY3JldEtleTtcbnZhciBnZXRQdWJsaWNLZXkgPSBpLmdldFB1YmxpY0tleTtcbnZhciBmaW5hbGl6ZUV2ZW50ID0gaS5maW5hbGl6ZUV2ZW50O1xudmFyIHZlcmlmeUV2ZW50ID0gaS52ZXJpZnlFdmVudDtcblxuLy8ga2luZHMudHNcbnZhciBraW5kc19leHBvcnRzID0ge307XG5fX2V4cG9ydChraW5kc19leHBvcnRzLCB7XG4gIEFwcGxpY2F0aW9uOiAoKSA9PiBBcHBsaWNhdGlvbixcbiAgQmFkZ2VBd2FyZDogKCkgPT4gQmFkZ2VBd2FyZCxcbiAgQmFkZ2VEZWZpbml0aW9uOiAoKSA9PiBCYWRnZURlZmluaXRpb24sXG4gIEJsb2NrZWRSZWxheXNMaXN0OiAoKSA9PiBCbG9ja2VkUmVsYXlzTGlzdCxcbiAgQm9va21hcmtMaXN0OiAoKSA9PiBCb29rbWFya0xpc3QsXG4gIEJvb2ttYXJrc2V0czogKCkgPT4gQm9va21hcmtzZXRzLFxuICBDYWxlbmRhcjogKCkgPT4gQ2FsZW5kYXIsXG4gIENhbGVuZGFyRXZlbnRSU1ZQOiAoKSA9PiBDYWxlbmRhckV2ZW50UlNWUCxcbiAgQ2hhbm5lbENyZWF0aW9uOiAoKSA9PiBDaGFubmVsQ3JlYXRpb24sXG4gIENoYW5uZWxIaWRlTWVzc2FnZTogKCkgPT4gQ2hhbm5lbEhpZGVNZXNzYWdlLFxuICBDaGFubmVsTWVzc2FnZTogKCkgPT4gQ2hhbm5lbE1lc3NhZ2UsXG4gIENoYW5uZWxNZXRhZGF0YTogKCkgPT4gQ2hhbm5lbE1ldGFkYXRhLFxuICBDaGFubmVsTXV0ZVVzZXI6ICgpID0+IENoYW5uZWxNdXRlVXNlcixcbiAgQ2xhc3NpZmllZExpc3Rpbmc6ICgpID0+IENsYXNzaWZpZWRMaXN0aW5nLFxuICBDbGllbnRBdXRoOiAoKSA9PiBDbGllbnRBdXRoLFxuICBDb21tdW5pdGllc0xpc3Q6ICgpID0+IENvbW11bml0aWVzTGlzdCxcbiAgQ29tbXVuaXR5RGVmaW5pdGlvbjogKCkgPT4gQ29tbXVuaXR5RGVmaW5pdGlvbixcbiAgQ29tbXVuaXR5UG9zdEFwcHJvdmFsOiAoKSA9PiBDb21tdW5pdHlQb3N0QXBwcm92YWwsXG4gIENvbnRhY3RzOiAoKSA9PiBDb250YWN0cyxcbiAgQ3JlYXRlT3JVcGRhdGVQcm9kdWN0OiAoKSA9PiBDcmVhdGVPclVwZGF0ZVByb2R1Y3QsXG4gIENyZWF0ZU9yVXBkYXRlU3RhbGw6ICgpID0+IENyZWF0ZU9yVXBkYXRlU3RhbGwsXG4gIEN1cmF0aW9uc2V0czogKCkgPT4gQ3VyYXRpb25zZXRzLFxuICBEYXRlOiAoKSA9PiBEYXRlMixcbiAgRGlyZWN0TWVzc2FnZVJlbGF5c0xpc3Q6ICgpID0+IERpcmVjdE1lc3NhZ2VSZWxheXNMaXN0LFxuICBEcmFmdENsYXNzaWZpZWRMaXN0aW5nOiAoKSA9PiBEcmFmdENsYXNzaWZpZWRMaXN0aW5nLFxuICBEcmFmdExvbmc6ICgpID0+IERyYWZ0TG9uZyxcbiAgRW1vamlzZXRzOiAoKSA9PiBFbW9qaXNldHMsXG4gIEVuY3J5cHRlZERpcmVjdE1lc3NhZ2U6ICgpID0+IEVuY3J5cHRlZERpcmVjdE1lc3NhZ2UsXG4gIEV2ZW50RGVsZXRpb246ICgpID0+IEV2ZW50RGVsZXRpb24sXG4gIEZpbGVNZXRhZGF0YTogKCkgPT4gRmlsZU1ldGFkYXRhLFxuICBGaWxlU2VydmVyUHJlZmVyZW5jZTogKCkgPT4gRmlsZVNlcnZlclByZWZlcmVuY2UsXG4gIEZvbGxvd3NldHM6ICgpID0+IEZvbGxvd3NldHMsXG4gIEdlbmVyaWNSZXBvc3Q6ICgpID0+IEdlbmVyaWNSZXBvc3QsXG4gIEdlbmVyaWNsaXN0czogKCkgPT4gR2VuZXJpY2xpc3RzLFxuICBHaWZ0V3JhcDogKCkgPT4gR2lmdFdyYXAsXG4gIEhUVFBBdXRoOiAoKSA9PiBIVFRQQXV0aCxcbiAgSGFuZGxlcmluZm9ybWF0aW9uOiAoKSA9PiBIYW5kbGVyaW5mb3JtYXRpb24sXG4gIEhhbmRsZXJyZWNvbW1lbmRhdGlvbjogKCkgPT4gSGFuZGxlcnJlY29tbWVuZGF0aW9uLFxuICBIaWdobGlnaHRzOiAoKSA9PiBIaWdobGlnaHRzLFxuICBJbnRlcmVzdHNMaXN0OiAoKSA9PiBJbnRlcmVzdHNMaXN0LFxuICBJbnRlcmVzdHNldHM6ICgpID0+IEludGVyZXN0c2V0cyxcbiAgSm9iRmVlZGJhY2s6ICgpID0+IEpvYkZlZWRiYWNrLFxuICBKb2JSZXF1ZXN0OiAoKSA9PiBKb2JSZXF1ZXN0LFxuICBKb2JSZXN1bHQ6ICgpID0+IEpvYlJlc3VsdCxcbiAgTGFiZWw6ICgpID0+IExhYmVsLFxuICBMaWdodG5pbmdQdWJSUEM6ICgpID0+IExpZ2h0bmluZ1B1YlJQQyxcbiAgTGl2ZUNoYXRNZXNzYWdlOiAoKSA9PiBMaXZlQ2hhdE1lc3NhZ2UsXG4gIExpdmVFdmVudDogKCkgPT4gTGl2ZUV2ZW50LFxuICBMb25nRm9ybUFydGljbGU6ICgpID0+IExvbmdGb3JtQXJ0aWNsZSxcbiAgTWV0YWRhdGE6ICgpID0+IE1ldGFkYXRhLFxuICBNdXRlbGlzdDogKCkgPT4gTXV0ZWxpc3QsXG4gIE5XQ1dhbGxldEluZm86ICgpID0+IE5XQ1dhbGxldEluZm8sXG4gIE5XQ1dhbGxldFJlcXVlc3Q6ICgpID0+IE5XQ1dhbGxldFJlcXVlc3QsXG4gIE5XQ1dhbGxldFJlc3BvbnNlOiAoKSA9PiBOV0NXYWxsZXRSZXNwb25zZSxcbiAgTm9zdHJDb25uZWN0OiAoKSA9PiBOb3N0ckNvbm5lY3QsXG4gIE9wZW5UaW1lc3RhbXBzOiAoKSA9PiBPcGVuVGltZXN0YW1wcyxcbiAgUGlubGlzdDogKCkgPT4gUGlubGlzdCxcbiAgUHJpdmF0ZURpcmVjdE1lc3NhZ2U6ICgpID0+IFByaXZhdGVEaXJlY3RNZXNzYWdlLFxuICBQcm9ibGVtVHJhY2tlcjogKCkgPT4gUHJvYmxlbVRyYWNrZXIsXG4gIFByb2ZpbGVCYWRnZXM6ICgpID0+IFByb2ZpbGVCYWRnZXMsXG4gIFB1YmxpY0NoYXRzTGlzdDogKCkgPT4gUHVibGljQ2hhdHNMaXN0LFxuICBSZWFjdGlvbjogKCkgPT4gUmVhY3Rpb24sXG4gIFJlY29tbWVuZFJlbGF5OiAoKSA9PiBSZWNvbW1lbmRSZWxheSxcbiAgUmVsYXlMaXN0OiAoKSA9PiBSZWxheUxpc3QsXG4gIFJlbGF5c2V0czogKCkgPT4gUmVsYXlzZXRzLFxuICBSZXBvcnQ6ICgpID0+IFJlcG9ydCxcbiAgUmVwb3J0aW5nOiAoKSA9PiBSZXBvcnRpbmcsXG4gIFJlcG9zdDogKCkgPT4gUmVwb3N0LFxuICBTZWFsOiAoKSA9PiBTZWFsLFxuICBTZWFyY2hSZWxheXNMaXN0OiAoKSA9PiBTZWFyY2hSZWxheXNMaXN0LFxuICBTaG9ydFRleHROb3RlOiAoKSA9PiBTaG9ydFRleHROb3RlLFxuICBUaW1lOiAoKSA9PiBUaW1lLFxuICBVc2VyRW1vamlMaXN0OiAoKSA9PiBVc2VyRW1vamlMaXN0LFxuICBVc2VyU3RhdHVzZXM6ICgpID0+IFVzZXJTdGF0dXNlcyxcbiAgWmFwOiAoKSA9PiBaYXAsXG4gIFphcEdvYWw6ICgpID0+IFphcEdvYWwsXG4gIFphcFJlcXVlc3Q6ICgpID0+IFphcFJlcXVlc3QsXG4gIGNsYXNzaWZ5S2luZDogKCkgPT4gY2xhc3NpZnlLaW5kLFxuICBpc0FkZHJlc3NhYmxlS2luZDogKCkgPT4gaXNBZGRyZXNzYWJsZUtpbmQsXG4gIGlzRXBoZW1lcmFsS2luZDogKCkgPT4gaXNFcGhlbWVyYWxLaW5kLFxuICBpc0tpbmQ6ICgpID0+IGlzS2luZCxcbiAgaXNQYXJhbWV0ZXJpemVkUmVwbGFjZWFibGVLaW5kOiAoKSA9PiBpc1BhcmFtZXRlcml6ZWRSZXBsYWNlYWJsZUtpbmQsXG4gIGlzUmVndWxhcktpbmQ6ICgpID0+IGlzUmVndWxhcktpbmQsXG4gIGlzUmVwbGFjZWFibGVLaW5kOiAoKSA9PiBpc1JlcGxhY2VhYmxlS2luZFxufSk7XG5mdW5jdGlvbiBpc1JlZ3VsYXJLaW5kKGtpbmQpIHtcbiAgcmV0dXJuIDFlMyA8PSBraW5kICYmIGtpbmQgPCAxZTQgfHwgWzEsIDIsIDQsIDUsIDYsIDcsIDgsIDE2LCA0MCwgNDEsIDQyLCA0MywgNDRdLmluY2x1ZGVzKGtpbmQpO1xufVxuZnVuY3Rpb24gaXNSZXBsYWNlYWJsZUtpbmQoa2luZCkge1xuICByZXR1cm4gWzAsIDNdLmluY2x1ZGVzKGtpbmQpIHx8IDFlNCA8PSBraW5kICYmIGtpbmQgPCAyZTQ7XG59XG5mdW5jdGlvbiBpc0VwaGVtZXJhbEtpbmQoa2luZCkge1xuICByZXR1cm4gMmU0IDw9IGtpbmQgJiYga2luZCA8IDNlNDtcbn1cbmZ1bmN0aW9uIGlzQWRkcmVzc2FibGVLaW5kKGtpbmQpIHtcbiAgcmV0dXJuIDNlNCA8PSBraW5kICYmIGtpbmQgPCA0ZTQ7XG59XG52YXIgaXNQYXJhbWV0ZXJpemVkUmVwbGFjZWFibGVLaW5kID0gaXNBZGRyZXNzYWJsZUtpbmQ7XG5mdW5jdGlvbiBjbGFzc2lmeUtpbmQoa2luZCkge1xuICBpZiAoaXNSZWd1bGFyS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJyZWd1bGFyXCI7XG4gIGlmIChpc1JlcGxhY2VhYmxlS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJyZXBsYWNlYWJsZVwiO1xuICBpZiAoaXNFcGhlbWVyYWxLaW5kKGtpbmQpKVxuICAgIHJldHVybiBcImVwaGVtZXJhbFwiO1xuICBpZiAoaXNBZGRyZXNzYWJsZUtpbmQoa2luZCkpXG4gICAgcmV0dXJuIFwicGFyYW1ldGVyaXplZFwiO1xuICByZXR1cm4gXCJ1bmtub3duXCI7XG59XG5mdW5jdGlvbiBpc0tpbmQoZXZlbnQsIGtpbmQpIHtcbiAgY29uc3Qga2luZEFzQXJyYXkgPSBraW5kIGluc3RhbmNlb2YgQXJyYXkgPyBraW5kIDogW2tpbmRdO1xuICByZXR1cm4gdmFsaWRhdGVFdmVudChldmVudCkgJiYga2luZEFzQXJyYXkuaW5jbHVkZXMoZXZlbnQua2luZCkgfHwgZmFsc2U7XG59XG52YXIgTWV0YWRhdGEgPSAwO1xudmFyIFNob3J0VGV4dE5vdGUgPSAxO1xudmFyIFJlY29tbWVuZFJlbGF5ID0gMjtcbnZhciBDb250YWN0cyA9IDM7XG52YXIgRW5jcnlwdGVkRGlyZWN0TWVzc2FnZSA9IDQ7XG52YXIgRXZlbnREZWxldGlvbiA9IDU7XG52YXIgUmVwb3N0ID0gNjtcbnZhciBSZWFjdGlvbiA9IDc7XG52YXIgQmFkZ2VBd2FyZCA9IDg7XG52YXIgU2VhbCA9IDEzO1xudmFyIFByaXZhdGVEaXJlY3RNZXNzYWdlID0gMTQ7XG52YXIgR2VuZXJpY1JlcG9zdCA9IDE2O1xudmFyIENoYW5uZWxDcmVhdGlvbiA9IDQwO1xudmFyIENoYW5uZWxNZXRhZGF0YSA9IDQxO1xudmFyIENoYW5uZWxNZXNzYWdlID0gNDI7XG52YXIgQ2hhbm5lbEhpZGVNZXNzYWdlID0gNDM7XG52YXIgQ2hhbm5lbE11dGVVc2VyID0gNDQ7XG52YXIgT3BlblRpbWVzdGFtcHMgPSAxMDQwO1xudmFyIEdpZnRXcmFwID0gMTA1OTtcbnZhciBGaWxlTWV0YWRhdGEgPSAxMDYzO1xudmFyIExpdmVDaGF0TWVzc2FnZSA9IDEzMTE7XG52YXIgUHJvYmxlbVRyYWNrZXIgPSAxOTcxO1xudmFyIFJlcG9ydCA9IDE5ODQ7XG52YXIgUmVwb3J0aW5nID0gMTk4NDtcbnZhciBMYWJlbCA9IDE5ODU7XG52YXIgQ29tbXVuaXR5UG9zdEFwcHJvdmFsID0gNDU1MDtcbnZhciBKb2JSZXF1ZXN0ID0gNTk5OTtcbnZhciBKb2JSZXN1bHQgPSA2OTk5O1xudmFyIEpvYkZlZWRiYWNrID0gN2UzO1xudmFyIFphcEdvYWwgPSA5MDQxO1xudmFyIFphcFJlcXVlc3QgPSA5NzM0O1xudmFyIFphcCA9IDk3MzU7XG52YXIgSGlnaGxpZ2h0cyA9IDk4MDI7XG52YXIgTXV0ZWxpc3QgPSAxZTQ7XG52YXIgUGlubGlzdCA9IDEwMDAxO1xudmFyIFJlbGF5TGlzdCA9IDEwMDAyO1xudmFyIEJvb2ttYXJrTGlzdCA9IDEwMDAzO1xudmFyIENvbW11bml0aWVzTGlzdCA9IDEwMDA0O1xudmFyIFB1YmxpY0NoYXRzTGlzdCA9IDEwMDA1O1xudmFyIEJsb2NrZWRSZWxheXNMaXN0ID0gMTAwMDY7XG52YXIgU2VhcmNoUmVsYXlzTGlzdCA9IDEwMDA3O1xudmFyIEludGVyZXN0c0xpc3QgPSAxMDAxNTtcbnZhciBVc2VyRW1vamlMaXN0ID0gMTAwMzA7XG52YXIgRGlyZWN0TWVzc2FnZVJlbGF5c0xpc3QgPSAxMDA1MDtcbnZhciBGaWxlU2VydmVyUHJlZmVyZW5jZSA9IDEwMDk2O1xudmFyIE5XQ1dhbGxldEluZm8gPSAxMzE5NDtcbnZhciBMaWdodG5pbmdQdWJSUEMgPSAyMWUzO1xudmFyIENsaWVudEF1dGggPSAyMjI0MjtcbnZhciBOV0NXYWxsZXRSZXF1ZXN0ID0gMjMxOTQ7XG52YXIgTldDV2FsbGV0UmVzcG9uc2UgPSAyMzE5NTtcbnZhciBOb3N0ckNvbm5lY3QgPSAyNDEzMztcbnZhciBIVFRQQXV0aCA9IDI3MjM1O1xudmFyIEZvbGxvd3NldHMgPSAzZTQ7XG52YXIgR2VuZXJpY2xpc3RzID0gMzAwMDE7XG52YXIgUmVsYXlzZXRzID0gMzAwMDI7XG52YXIgQm9va21hcmtzZXRzID0gMzAwMDM7XG52YXIgQ3VyYXRpb25zZXRzID0gMzAwMDQ7XG52YXIgUHJvZmlsZUJhZGdlcyA9IDMwMDA4O1xudmFyIEJhZGdlRGVmaW5pdGlvbiA9IDMwMDA5O1xudmFyIEludGVyZXN0c2V0cyA9IDMwMDE1O1xudmFyIENyZWF0ZU9yVXBkYXRlU3RhbGwgPSAzMDAxNztcbnZhciBDcmVhdGVPclVwZGF0ZVByb2R1Y3QgPSAzMDAxODtcbnZhciBMb25nRm9ybUFydGljbGUgPSAzMDAyMztcbnZhciBEcmFmdExvbmcgPSAzMDAyNDtcbnZhciBFbW9qaXNldHMgPSAzMDAzMDtcbnZhciBBcHBsaWNhdGlvbiA9IDMwMDc4O1xudmFyIExpdmVFdmVudCA9IDMwMzExO1xudmFyIFVzZXJTdGF0dXNlcyA9IDMwMzE1O1xudmFyIENsYXNzaWZpZWRMaXN0aW5nID0gMzA0MDI7XG52YXIgRHJhZnRDbGFzc2lmaWVkTGlzdGluZyA9IDMwNDAzO1xudmFyIERhdGUyID0gMzE5MjI7XG52YXIgVGltZSA9IDMxOTIzO1xudmFyIENhbGVuZGFyID0gMzE5MjQ7XG52YXIgQ2FsZW5kYXJFdmVudFJTVlAgPSAzMTkyNTtcbnZhciBIYW5kbGVycmVjb21tZW5kYXRpb24gPSAzMTk4OTtcbnZhciBIYW5kbGVyaW5mb3JtYXRpb24gPSAzMTk5MDtcbnZhciBDb21tdW5pdHlEZWZpbml0aW9uID0gMzQ1NTA7XG5cbi8vIGZpbHRlci50c1xuZnVuY3Rpb24gbWF0Y2hGaWx0ZXIoZmlsdGVyLCBldmVudCkge1xuICBpZiAoZmlsdGVyLmlkcyAmJiBmaWx0ZXIuaWRzLmluZGV4T2YoZXZlbnQuaWQpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmlsdGVyLmtpbmRzICYmIGZpbHRlci5raW5kcy5pbmRleE9mKGV2ZW50LmtpbmQpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmlsdGVyLmF1dGhvcnMgJiYgZmlsdGVyLmF1dGhvcnMuaW5kZXhPZihldmVudC5wdWJrZXkpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBmIGluIGZpbHRlcikge1xuICAgIGlmIChmWzBdID09PSBcIiNcIikge1xuICAgICAgbGV0IHRhZ05hbWUgPSBmLnNsaWNlKDEpO1xuICAgICAgbGV0IHZhbHVlcyA9IGZpbHRlcltgIyR7dGFnTmFtZX1gXTtcbiAgICAgIGlmICh2YWx1ZXMgJiYgIWV2ZW50LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBmLnNsaWNlKDEpICYmIHZhbHVlcy5pbmRleE9mKHYpICE9PSAtMSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpbHRlci5zaW5jZSAmJiBldmVudC5jcmVhdGVkX2F0IDwgZmlsdGVyLnNpbmNlKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGZpbHRlci51bnRpbCAmJiBldmVudC5jcmVhdGVkX2F0ID4gZmlsdGVyLnVudGlsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtYXRjaEZpbHRlcnMoZmlsdGVycywgZXZlbnQpIHtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGZpbHRlcnMubGVuZ3RoOyBpMisrKSB7XG4gICAgaWYgKG1hdGNoRmlsdGVyKGZpbHRlcnNbaTJdLCBldmVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBtZXJnZUZpbHRlcnMoLi4uZmlsdGVycykge1xuICBsZXQgcmVzdWx0ID0ge307XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBmaWx0ZXJzLmxlbmd0aDsgaTIrKykge1xuICAgIGxldCBmaWx0ZXIgPSBmaWx0ZXJzW2kyXTtcbiAgICBPYmplY3QuZW50cmllcyhmaWx0ZXIpLmZvckVhY2goKFtwcm9wZXJ0eSwgdmFsdWVzXSkgPT4ge1xuICAgICAgaWYgKHByb3BlcnR5ID09PSBcImtpbmRzXCIgfHwgcHJvcGVydHkgPT09IFwiaWRzXCIgfHwgcHJvcGVydHkgPT09IFwiYXV0aG9yc1wiIHx8IHByb3BlcnR5WzBdID09PSBcIiNcIikge1xuICAgICAgICByZXN1bHRbcHJvcGVydHldID0gcmVzdWx0W3Byb3BlcnR5XSB8fCBbXTtcbiAgICAgICAgZm9yIChsZXQgdiA9IDA7IHYgPCB2YWx1ZXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSB2YWx1ZXNbdl07XG4gICAgICAgICAgaWYgKCFyZXN1bHRbcHJvcGVydHldLmluY2x1ZGVzKHZhbHVlKSlcbiAgICAgICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZmlsdGVyLmxpbWl0ICYmICghcmVzdWx0LmxpbWl0IHx8IGZpbHRlci5saW1pdCA+IHJlc3VsdC5saW1pdCkpXG4gICAgICByZXN1bHQubGltaXQgPSBmaWx0ZXIubGltaXQ7XG4gICAgaWYgKGZpbHRlci51bnRpbCAmJiAoIXJlc3VsdC51bnRpbCB8fCBmaWx0ZXIudW50aWwgPiByZXN1bHQudW50aWwpKVxuICAgICAgcmVzdWx0LnVudGlsID0gZmlsdGVyLnVudGlsO1xuICAgIGlmIChmaWx0ZXIuc2luY2UgJiYgKCFyZXN1bHQuc2luY2UgfHwgZmlsdGVyLnNpbmNlIDwgcmVzdWx0LnNpbmNlKSlcbiAgICAgIHJlc3VsdC5zaW5jZSA9IGZpbHRlci5zaW5jZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0RmlsdGVyTGltaXQoZmlsdGVyKSB7XG4gIGlmIChmaWx0ZXIuaWRzICYmICFmaWx0ZXIuaWRzLmxlbmd0aClcbiAgICByZXR1cm4gMDtcbiAgaWYgKGZpbHRlci5raW5kcyAmJiAhZmlsdGVyLmtpbmRzLmxlbmd0aClcbiAgICByZXR1cm4gMDtcbiAgaWYgKGZpbHRlci5hdXRob3JzICYmICFmaWx0ZXIuYXV0aG9ycy5sZW5ndGgpXG4gICAgcmV0dXJuIDA7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpbHRlcikpIHtcbiAgICBpZiAoa2V5WzBdID09PSBcIiNcIiAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAhdmFsdWUubGVuZ3RoKVxuICAgICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKFxuICAgIE1hdGgubWF4KDAsIGZpbHRlci5saW1pdCA/PyBJbmZpbml0eSksXG4gICAgZmlsdGVyLmlkcz8ubGVuZ3RoID8/IEluZmluaXR5LFxuICAgIGZpbHRlci5hdXRob3JzPy5sZW5ndGggJiYgZmlsdGVyLmtpbmRzPy5ldmVyeSgoa2luZCkgPT4gaXNSZXBsYWNlYWJsZUtpbmQoa2luZCkpID8gZmlsdGVyLmF1dGhvcnMubGVuZ3RoICogZmlsdGVyLmtpbmRzLmxlbmd0aCA6IEluZmluaXR5LFxuICAgIGZpbHRlci5hdXRob3JzPy5sZW5ndGggJiYgZmlsdGVyLmtpbmRzPy5ldmVyeSgoa2luZCkgPT4gaXNBZGRyZXNzYWJsZUtpbmQoa2luZCkpICYmIGZpbHRlcltcIiNkXCJdPy5sZW5ndGggPyBmaWx0ZXIuYXV0aG9ycy5sZW5ndGggKiBmaWx0ZXIua2luZHMubGVuZ3RoICogZmlsdGVyW1wiI2RcIl0ubGVuZ3RoIDogSW5maW5pdHlcbiAgKTtcbn1cblxuLy8gZmFrZWpzb24udHNcbnZhciBmYWtlanNvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChmYWtlanNvbl9leHBvcnRzLCB7XG4gIGdldEhleDY0OiAoKSA9PiBnZXRIZXg2NCxcbiAgZ2V0SW50OiAoKSA9PiBnZXRJbnQsXG4gIGdldFN1YnNjcmlwdGlvbklkOiAoKSA9PiBnZXRTdWJzY3JpcHRpb25JZCxcbiAgbWF0Y2hFdmVudElkOiAoKSA9PiBtYXRjaEV2ZW50SWQsXG4gIG1hdGNoRXZlbnRLaW5kOiAoKSA9PiBtYXRjaEV2ZW50S2luZCxcbiAgbWF0Y2hFdmVudFB1YmtleTogKCkgPT4gbWF0Y2hFdmVudFB1YmtleVxufSk7XG5mdW5jdGlvbiBnZXRIZXg2NChqc29uLCBmaWVsZCkge1xuICBsZXQgbGVuID0gZmllbGQubGVuZ3RoICsgMztcbiAgbGV0IGlkeCA9IGpzb24uaW5kZXhPZihgXCIke2ZpZWxkfVwiOmApICsgbGVuO1xuICBsZXQgcyA9IGpzb24uc2xpY2UoaWR4KS5pbmRleE9mKGBcImApICsgaWR4ICsgMTtcbiAgcmV0dXJuIGpzb24uc2xpY2UocywgcyArIDY0KTtcbn1cbmZ1bmN0aW9uIGdldEludChqc29uLCBmaWVsZCkge1xuICBsZXQgbGVuID0gZmllbGQubGVuZ3RoO1xuICBsZXQgaWR4ID0ganNvbi5pbmRleE9mKGBcIiR7ZmllbGR9XCI6YCkgKyBsZW4gKyAzO1xuICBsZXQgc2xpY2VkID0ganNvbi5zbGljZShpZHgpO1xuICBsZXQgZW5kID0gTWF0aC5taW4oc2xpY2VkLmluZGV4T2YoXCIsXCIpLCBzbGljZWQuaW5kZXhPZihcIn1cIikpO1xuICByZXR1cm4gcGFyc2VJbnQoc2xpY2VkLnNsaWNlKDAsIGVuZCksIDEwKTtcbn1cbmZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvbklkKGpzb24pIHtcbiAgbGV0IGlkeCA9IGpzb24uc2xpY2UoMCwgMjIpLmluZGV4T2YoYFwiRVZFTlRcImApO1xuICBpZiAoaWR4ID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHBzdGFydCA9IGpzb24uc2xpY2UoaWR4ICsgNyArIDEpLmluZGV4T2YoYFwiYCk7XG4gIGlmIChwc3RhcnQgPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgc3RhcnQgPSBpZHggKyA3ICsgMSArIHBzdGFydDtcbiAgbGV0IHBlbmQgPSBqc29uLnNsaWNlKHN0YXJ0ICsgMSwgODApLmluZGV4T2YoYFwiYCk7XG4gIGlmIChwZW5kID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IGVuZCA9IHN0YXJ0ICsgMSArIHBlbmQ7XG4gIHJldHVybiBqc29uLnNsaWNlKHN0YXJ0ICsgMSwgZW5kKTtcbn1cbmZ1bmN0aW9uIG1hdGNoRXZlbnRJZChqc29uLCBpZCkge1xuICByZXR1cm4gaWQgPT09IGdldEhleDY0KGpzb24sIFwiaWRcIik7XG59XG5mdW5jdGlvbiBtYXRjaEV2ZW50UHVia2V5KGpzb24sIHB1YmtleSkge1xuICByZXR1cm4gcHVia2V5ID09PSBnZXRIZXg2NChqc29uLCBcInB1YmtleVwiKTtcbn1cbmZ1bmN0aW9uIG1hdGNoRXZlbnRLaW5kKGpzb24sIGtpbmQpIHtcbiAgcmV0dXJuIGtpbmQgPT09IGdldEludChqc29uLCBcImtpbmRcIik7XG59XG5cbi8vIG5pcDQyLnRzXG52YXIgbmlwNDJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNDJfZXhwb3J0cywge1xuICBtYWtlQXV0aEV2ZW50OiAoKSA9PiBtYWtlQXV0aEV2ZW50XG59KTtcbmZ1bmN0aW9uIG1ha2VBdXRoRXZlbnQocmVsYXlVUkwsIGNoYWxsZW5nZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IENsaWVudEF1dGgsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSxcbiAgICB0YWdzOiBbXG4gICAgICBbXCJyZWxheVwiLCByZWxheVVSTF0sXG4gICAgICBbXCJjaGFsbGVuZ2VcIiwgY2hhbGxlbmdlXVxuICAgIF0sXG4gICAgY29udGVudDogXCJcIlxuICB9O1xufVxuXG4vLyBoZWxwZXJzLnRzXG5hc3luYyBmdW5jdGlvbiB5aWVsZFRocmVhZCgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgY2ggPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY2gucG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBjaC5wb3J0MS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICBjaC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICBjaC5wb3J0MS5zdGFydCgpO1xuICB9KTtcbn1cbnZhciBhbHdheXNUcnVlID0gKHQpID0+IHtcbiAgdFt2ZXJpZmllZFN5bWJvbF0gPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIGFic3RyYWN0LXJlbGF5LnRzXG52YXIgQWJzdHJhY3RSZWxheSA9IGNsYXNzIHtcbiAgdXJsO1xuICBfY29ubmVjdGVkID0gZmFsc2U7XG4gIG9uY2xvc2UgPSBudWxsO1xuICBvbm5vdGljZSA9IChtc2cpID0+IGNvbnNvbGUuZGVidWcoYE5PVElDRSBmcm9tICR7dGhpcy51cmx9OiAke21zZ31gKTtcbiAgX29uYXV0aCA9IG51bGw7XG4gIGJhc2VFb3NlVGltZW91dCA9IDQ0MDA7XG4gIGNvbm5lY3Rpb25UaW1lb3V0ID0gNDQwMDtcbiAgcHVibGlzaFRpbWVvdXQgPSA0NDAwO1xuICBvcGVuU3VicyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlO1xuICBjb25uZWN0aW9uUHJvbWlzZTtcbiAgb3BlbkNvdW50UmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvcGVuRXZlbnRQdWJsaXNoZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB3cztcbiAgaW5jb21pbmdNZXNzYWdlUXVldWUgPSBuZXcgUXVldWUoKTtcbiAgcXVldWVSdW5uaW5nID0gZmFsc2U7XG4gIGNoYWxsZW5nZTtcbiAgYXV0aFByb21pc2U7XG4gIHNlcmlhbCA9IDA7XG4gIHZlcmlmeUV2ZW50O1xuICBfV2ViU29ja2V0O1xuICBjb25zdHJ1Y3Rvcih1cmwsIG9wdHMpIHtcbiAgICB0aGlzLnVybCA9IG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgIHRoaXMudmVyaWZ5RXZlbnQgPSBvcHRzLnZlcmlmeUV2ZW50O1xuICAgIHRoaXMuX1dlYlNvY2tldCA9IG9wdHMud2Vic29ja2V0SW1wbGVtZW50YXRpb24gfHwgV2ViU29ja2V0O1xuICB9XG4gIHN0YXRpYyBhc3luYyBjb25uZWN0KHVybCwgb3B0cykge1xuICAgIGNvbnN0IHJlbGF5ID0gbmV3IEFic3RyYWN0UmVsYXkodXJsLCBvcHRzKTtcbiAgICBhd2FpdCByZWxheS5jb25uZWN0KCk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIGNsb3NlQWxsU3Vic2NyaXB0aW9ucyhyZWFzb24pIHtcbiAgICBmb3IgKGxldCBbXywgc3ViXSBvZiB0aGlzLm9wZW5TdWJzKSB7XG4gICAgICBzdWIuY2xvc2UocmVhc29uKTtcbiAgICB9XG4gICAgdGhpcy5vcGVuU3Vicy5jbGVhcigpO1xuICAgIGZvciAobGV0IFtfLCBlcF0gb2YgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMpIHtcbiAgICAgIGVwLnJlamVjdChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgfVxuICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmNsZWFyKCk7XG4gICAgZm9yIChsZXQgW18sIGNyXSBvZiB0aGlzLm9wZW5Db3VudFJlcXVlc3RzKSB7XG4gICAgICBjci5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgIH1cbiAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmNsZWFyKCk7XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGVkO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvblByb21pc2UpXG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uUHJvbWlzZTtcbiAgICB0aGlzLmNoYWxsZW5nZSA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dGhQcm9taXNlID0gdm9pZCAwO1xuICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChcImNvbm5lY3Rpb24gdGltZWQgb3V0XCIpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9uY2xvc2U/LigpO1xuICAgICAgICB0aGlzLmNsb3NlQWxsU3Vic2NyaXB0aW9ucyhcInJlbGF5IGNvbm5lY3Rpb24gdGltZWQgb3V0XCIpO1xuICAgICAgfSwgdGhpcy5jb25uZWN0aW9uVGltZW91dCk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLndzID0gbmV3IHRoaXMuX1dlYlNvY2tldCh0aGlzLnVybCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uVGltZW91dEhhbmRsZSk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLndzLm9uZXJyb3IgPSAoZXYpID0+IHtcbiAgICAgICAgcmVqZWN0KGV2Lm1lc3NhZ2UgfHwgXCJ3ZWJzb2NrZXQgZXJyb3JcIik7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGVycm9yZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndzLm9uY2xvc2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGNsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5fb25tZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gIH1cbiAgYXN5bmMgcnVuUXVldWUoKSB7XG4gICAgdGhpcy5xdWV1ZVJ1bm5pbmcgPSB0cnVlO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IHRoaXMuaGFuZGxlTmV4dCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYXdhaXQgeWllbGRUaHJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5xdWV1ZVJ1bm5pbmcgPSBmYWxzZTtcbiAgfVxuICBoYW5kbGVOZXh0KCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmluY29taW5nTWVzc2FnZVF1ZXVlLmRlcXVldWUoKTtcbiAgICBpZiAoIWpzb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc3ViaWQgPSBnZXRTdWJzY3JpcHRpb25JZChqc29uKTtcbiAgICBpZiAoc3ViaWQpIHtcbiAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoc3ViaWQpO1xuICAgICAgaWYgKCFzbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpZCA9IGdldEhleDY0KGpzb24sIFwiaWRcIik7XG4gICAgICBjb25zdCBhbHJlYWR5SGF2ZSA9IHNvLmFscmVhZHlIYXZlRXZlbnQ/LihpZCk7XG4gICAgICBzby5yZWNlaXZlZEV2ZW50Py4odGhpcywgaWQpO1xuICAgICAgaWYgKGFscmVhZHlIYXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgIHN3aXRjaCAoZGF0YVswXSkge1xuICAgICAgICBjYXNlIFwiRVZFTlRcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoZGF0YVsxXSk7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBkYXRhWzJdO1xuICAgICAgICAgIGlmICh0aGlzLnZlcmlmeUV2ZW50KGV2ZW50KSAmJiBtYXRjaEZpbHRlcnMoc28uZmlsdGVycywgZXZlbnQpKSB7XG4gICAgICAgICAgICBzby5vbmV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDT1VOVFwiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IGNyID0gdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjcikge1xuICAgICAgICAgICAgY3IucmVzb2x2ZShwYXlsb2FkLmNvdW50KTtcbiAgICAgICAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuZGVsZXRlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJFT1NFXCI6IHtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGRhdGFbMV0pO1xuICAgICAgICAgIGlmICghc28pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgc28ucmVjZWl2ZWRFb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPS1wiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IG9rID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBkYXRhWzNdO1xuICAgICAgICAgIGNvbnN0IGVwID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoZXApIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChlcC50aW1lb3V0KTtcbiAgICAgICAgICAgIGlmIChvaylcbiAgICAgICAgICAgICAgZXAucmVzb2x2ZShyZWFzb24pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBlcC5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDTE9TRURcIjoge1xuICAgICAgICAgIGNvbnN0IGlkID0gZGF0YVsxXTtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoIXNvKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHNvLmNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgc28uY2xvc2UoZGF0YVsyXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJOT1RJQ0VcIjpcbiAgICAgICAgICB0aGlzLm9ubm90aWNlKGRhdGFbMV0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcIkFVVEhcIjoge1xuICAgICAgICAgIHRoaXMuY2hhbGxlbmdlID0gZGF0YVsxXTtcbiAgICAgICAgICB0aGlzLmF1dGhQcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMuX29uYXV0aD8uKGRhdGFbMV0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBhc3luYyBzZW5kKG1lc3NhZ2UpIHtcbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvblByb21pc2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZW5kaW5nIG9uIGNsb3NlZCBjb25uZWN0aW9uXCIpO1xuICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLndzPy5zZW5kKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGF1dGgoc2lnbkF1dGhFdmVudCkge1xuICAgIGlmICghdGhpcy5jaGFsbGVuZ2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBwZXJmb3JtIGF1dGgsIG5vIGNoYWxsZW5nZSB3YXMgcmVjZWl2ZWRcIik7XG4gICAgaWYgKHRoaXMuYXV0aFByb21pc2UpXG4gICAgICByZXR1cm4gdGhpcy5hdXRoUHJvbWlzZTtcbiAgICBjb25zdCBldnQgPSBhd2FpdCBzaWduQXV0aEV2ZW50KG1ha2VBdXRoRXZlbnQodGhpcy51cmwsIHRoaXMuY2hhbGxlbmdlKSk7XG4gICAgdGhpcy5hdXRoUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZXAgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoZXZ0LmlkKTtcbiAgICAgICAgaWYgKGVwKSB7XG4gICAgICAgICAgZXAucmVqZWN0KG5ldyBFcnJvcihcImF1dGggdGltZWQgb3V0XCIpKTtcbiAgICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5kZWxldGUoZXZ0LmlkKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5wdWJsaXNoVGltZW91dCk7XG4gICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoZXZ0LmlkLCB7IHJlc29sdmUsIHJlamVjdCwgdGltZW91dCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkFVVEhcIiwnICsgSlNPTi5zdHJpbmdpZnkoZXZ0KSArIFwiXVwiKTtcbiAgICByZXR1cm4gdGhpcy5hdXRoUHJvbWlzZTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBlcCA9IHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmdldChldmVudC5pZCk7XG4gICAgICAgIGlmIChlcCkge1xuICAgICAgICAgIGVwLnJlamVjdChuZXcgRXJyb3IoXCJwdWJsaXNoIHRpbWVkIG91dFwiKSk7XG4gICAgICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZGVsZXRlKGV2ZW50LmlkKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5wdWJsaXNoVGltZW91dCk7XG4gICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoZXZlbnQuaWQsIHsgcmVzb2x2ZSwgcmVqZWN0LCB0aW1lb3V0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZCgnW1wiRVZFTlRcIiwnICsgSlNPTi5zdHJpbmdpZnkoZXZlbnQpICsgXCJdXCIpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgYXN5bmMgY291bnQoZmlsdGVycywgcGFyYW1zKSB7XG4gICAgdGhpcy5zZXJpYWwrKztcbiAgICBjb25zdCBpZCA9IHBhcmFtcz8uaWQgfHwgXCJjb3VudDpcIiArIHRoaXMuc2VyaWFsO1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuc2V0KGlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkNPVU5UXCIsXCInICsgaWQgKyAnXCIsJyArIEpTT04uc3RyaW5naWZ5KGZpbHRlcnMpLnN1YnN0cmluZygxKSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBzdWJzY3JpYmUoZmlsdGVycywgcGFyYW1zKSB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5wcmVwYXJlU3Vic2NyaXB0aW9uKGZpbHRlcnMsIHBhcmFtcyk7XG4gICAgc3Vic2NyaXB0aW9uLmZpcmUoKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9XG4gIHByZXBhcmVTdWJzY3JpcHRpb24oZmlsdGVycywgcGFyYW1zKSB7XG4gICAgdGhpcy5zZXJpYWwrKztcbiAgICBjb25zdCBpZCA9IHBhcmFtcy5pZCB8fCAocGFyYW1zLmxhYmVsID8gcGFyYW1zLmxhYmVsICsgXCI6XCIgOiBcInN1YjpcIikgKyB0aGlzLnNlcmlhbDtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMsIGlkLCBmaWx0ZXJzLCBwYXJhbXMpO1xuICAgIHRoaXMub3BlblN1YnMuc2V0KGlkLCBzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGNsb3NlZCBieSB1c1wiKTtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLndzPy5jbG9zZSgpO1xuICB9XG4gIF9vbm1lc3NhZ2UoZXYpIHtcbiAgICB0aGlzLmluY29taW5nTWVzc2FnZVF1ZXVlLmVucXVldWUoZXYuZGF0YSk7XG4gICAgaWYgKCF0aGlzLnF1ZXVlUnVubmluZykge1xuICAgICAgdGhpcy5ydW5RdWV1ZSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBTdWJzY3JpcHRpb24gPSBjbGFzcyB7XG4gIHJlbGF5O1xuICBpZDtcbiAgY2xvc2VkID0gZmFsc2U7XG4gIGVvc2VkID0gZmFsc2U7XG4gIGZpbHRlcnM7XG4gIGFscmVhZHlIYXZlRXZlbnQ7XG4gIHJlY2VpdmVkRXZlbnQ7XG4gIG9uZXZlbnQ7XG4gIG9uZW9zZTtcbiAgb25jbG9zZTtcbiAgZW9zZVRpbWVvdXQ7XG4gIGVvc2VUaW1lb3V0SGFuZGxlO1xuICBjb25zdHJ1Y3RvcihyZWxheSwgaWQsIGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMucmVsYXkgPSByZWxheTtcbiAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmFscmVhZHlIYXZlRXZlbnQgPSBwYXJhbXMuYWxyZWFkeUhhdmVFdmVudDtcbiAgICB0aGlzLnJlY2VpdmVkRXZlbnQgPSBwYXJhbXMucmVjZWl2ZWRFdmVudDtcbiAgICB0aGlzLmVvc2VUaW1lb3V0ID0gcGFyYW1zLmVvc2VUaW1lb3V0IHx8IHJlbGF5LmJhc2VFb3NlVGltZW91dDtcbiAgICB0aGlzLm9uZW9zZSA9IHBhcmFtcy5vbmVvc2U7XG4gICAgdGhpcy5vbmNsb3NlID0gcGFyYW1zLm9uY2xvc2U7XG4gICAgdGhpcy5vbmV2ZW50ID0gcGFyYW1zLm9uZXZlbnQgfHwgKChldmVudCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgb25ldmVudCgpIGNhbGxiYWNrIG5vdCBkZWZpbmVkIGZvciBzdWJzY3JpcHRpb24gJyR7dGhpcy5pZH0nIGluIHJlbGF5ICR7dGhpcy5yZWxheS51cmx9LiBldmVudCByZWNlaXZlZDpgLFxuICAgICAgICBldmVudFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBmaXJlKCkge1xuICAgIHRoaXMucmVsYXkuc2VuZCgnW1wiUkVRXCIsXCInICsgdGhpcy5pZCArICdcIiwnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5maWx0ZXJzKS5zdWJzdHJpbmcoMSkpO1xuICAgIHRoaXMuZW9zZVRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KHRoaXMucmVjZWl2ZWRFb3NlLmJpbmQodGhpcyksIHRoaXMuZW9zZVRpbWVvdXQpO1xuICB9XG4gIHJlY2VpdmVkRW9zZSgpIHtcbiAgICBpZiAodGhpcy5lb3NlZClcbiAgICAgIHJldHVybjtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5lb3NlVGltZW91dEhhbmRsZSk7XG4gICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgdGhpcy5vbmVvc2U/LigpO1xuICB9XG4gIGNsb3NlKHJlYXNvbiA9IFwiY2xvc2VkIGJ5IGNhbGxlclwiKSB7XG4gICAgaWYgKCF0aGlzLmNsb3NlZCAmJiB0aGlzLnJlbGF5LmNvbm5lY3RlZCkge1xuICAgICAgdGhpcy5yZWxheS5zZW5kKCdbXCJDTE9TRVwiLCcgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmlkKSArIFwiXVwiKTtcbiAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5yZWxheS5vcGVuU3Vicy5kZWxldGUodGhpcy5pZCk7XG4gICAgdGhpcy5vbmNsb3NlPy4ocmVhc29uKTtcbiAgfVxufTtcblxuLy8gcmVsYXkudHNcbnZhciBfV2ViU29ja2V0O1xudHJ5IHtcbiAgX1dlYlNvY2tldCA9IFdlYlNvY2tldDtcbn0gY2F0Y2gge1xufVxudmFyIFJlbGF5ID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFJlbGF5IHtcbiAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgc3VwZXIodXJsLCB7IHZlcmlmeUV2ZW50LCB3ZWJzb2NrZXRJbXBsZW1lbnRhdGlvbjogX1dlYlNvY2tldCB9KTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY29ubmVjdCh1cmwpIHtcbiAgICBjb25zdCByZWxheSA9IG5ldyBSZWxheSh1cmwpO1xuICAgIGF3YWl0IHJlbGF5LmNvbm5lY3QoKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbn07XG5cbi8vIGFic3RyYWN0LXBvb2wudHNcbnZhciBBYnN0cmFjdFNpbXBsZVBvb2wgPSBjbGFzcyB7XG4gIHJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHNlZW5PbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHRyYWNrUmVsYXlzID0gZmFsc2U7XG4gIHZlcmlmeUV2ZW50O1xuICB0cnVzdGVkUmVsYXlVUkxzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgX1dlYlNvY2tldDtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMudmVyaWZ5RXZlbnQgPSBvcHRzLnZlcmlmeUV2ZW50O1xuICAgIHRoaXMuX1dlYlNvY2tldCA9IG9wdHMud2Vic29ja2V0SW1wbGVtZW50YXRpb247XG4gIH1cbiAgYXN5bmMgZW5zdXJlUmVsYXkodXJsLCBwYXJhbXMpIHtcbiAgICB1cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICBsZXQgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQodXJsKTtcbiAgICBpZiAoIXJlbGF5KSB7XG4gICAgICByZWxheSA9IG5ldyBBYnN0cmFjdFJlbGF5KHVybCwge1xuICAgICAgICB2ZXJpZnlFdmVudDogdGhpcy50cnVzdGVkUmVsYXlVUkxzLmhhcyh1cmwpID8gYWx3YXlzVHJ1ZSA6IHRoaXMudmVyaWZ5RXZlbnQsXG4gICAgICAgIHdlYnNvY2tldEltcGxlbWVudGF0aW9uOiB0aGlzLl9XZWJTb2NrZXRcbiAgICAgIH0pO1xuICAgICAgaWYgKHBhcmFtcz8uY29ubmVjdGlvblRpbWVvdXQpXG4gICAgICAgIHJlbGF5LmNvbm5lY3Rpb25UaW1lb3V0ID0gcGFyYW1zLmNvbm5lY3Rpb25UaW1lb3V0O1xuICAgICAgdGhpcy5yZWxheXMuc2V0KHVybCwgcmVsYXkpO1xuICAgIH1cbiAgICBhd2FpdCByZWxheS5jb25uZWN0KCk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIGNsb3NlKHJlbGF5cykge1xuICAgIHJlbGF5cy5tYXAobm9ybWFsaXplVVJMKS5mb3JFYWNoKCh1cmwpID0+IHtcbiAgICAgIHRoaXMucmVsYXlzLmdldCh1cmwpPy5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIHN1YnNjcmliZShyZWxheXMsIGZpbHRlciwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlTWFwKFxuICAgICAgcmVsYXlzLm1hcCgodXJsKSA9PiAoeyB1cmwsIGZpbHRlciB9KSksXG4gICAgICBwYXJhbXNcbiAgICApO1xuICB9XG4gIHN1YnNjcmliZU1hbnkocmVsYXlzLCBmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmVNYXAoXG4gICAgICByZWxheXMuZmxhdE1hcCgodXJsKSA9PiBmaWx0ZXJzLm1hcCgoZmlsdGVyKSA9PiAoeyB1cmwsIGZpbHRlciB9KSkpLFxuICAgICAgcGFyYW1zXG4gICAgKTtcbiAgfVxuICBzdWJzY3JpYmVNYXAocmVxdWVzdHMsIHBhcmFtcykge1xuICAgIGlmICh0aGlzLnRyYWNrUmVsYXlzKSB7XG4gICAgICBwYXJhbXMucmVjZWl2ZWRFdmVudCA9IChyZWxheSwgaWQpID0+IHtcbiAgICAgICAgbGV0IHNldCA9IHRoaXMuc2Vlbk9uLmdldChpZCk7XG4gICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICB0aGlzLnNlZW5Pbi5zZXQoaWQsIHNldCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0LmFkZChyZWxheSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBfa25vd25JZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHN1YnMgPSBbXTtcbiAgICBjb25zdCBlb3Nlc1JlY2VpdmVkID0gW107XG4gICAgbGV0IGhhbmRsZUVvc2UgPSAoaTIpID0+IHtcbiAgICAgIGlmIChlb3Nlc1JlY2VpdmVkW2kyXSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZW9zZXNSZWNlaXZlZFtpMl0gPSB0cnVlO1xuICAgICAgaWYgKGVvc2VzUmVjZWl2ZWQuZmlsdGVyKChhKSA9PiBhKS5sZW5ndGggPT09IHJlcXVlc3RzLmxlbmd0aCkge1xuICAgICAgICBwYXJhbXMub25lb3NlPy4oKTtcbiAgICAgICAgaGFuZGxlRW9zZSA9ICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsb3Nlc1JlY2VpdmVkID0gW107XG4gICAgbGV0IGhhbmRsZUNsb3NlID0gKGkyLCByZWFzb24pID0+IHtcbiAgICAgIGlmIChjbG9zZXNSZWNlaXZlZFtpMl0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGhhbmRsZUVvc2UoaTIpO1xuICAgICAgY2xvc2VzUmVjZWl2ZWRbaTJdID0gcmVhc29uO1xuICAgICAgaWYgKGNsb3Nlc1JlY2VpdmVkLmZpbHRlcigoYSkgPT4gYSkubGVuZ3RoID09PSByZXF1ZXN0cy5sZW5ndGgpIHtcbiAgICAgICAgcGFyYW1zLm9uY2xvc2U/LihjbG9zZXNSZWNlaXZlZCk7XG4gICAgICAgIGhhbmRsZUNsb3NlID0gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbG9jYWxBbHJlYWR5SGF2ZUV2ZW50SGFuZGxlciA9IChpZCkgPT4ge1xuICAgICAgaWYgKHBhcmFtcy5hbHJlYWR5SGF2ZUV2ZW50Py4oaWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaGF2ZSA9IF9rbm93bklkcy5oYXMoaWQpO1xuICAgICAgX2tub3duSWRzLmFkZChpZCk7XG4gICAgICByZXR1cm4gaGF2ZTtcbiAgICB9O1xuICAgIGNvbnN0IGFsbE9wZW5lZCA9IFByb21pc2UuYWxsKFxuICAgICAgcmVxdWVzdHMubWFwKGFzeW5jICh7IHVybCwgZmlsdGVyIH0sIGkyKSA9PiB7XG4gICAgICAgIHVybCA9IG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgICAgICBsZXQgcmVsYXk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVsYXkgPSBhd2FpdCB0aGlzLmVuc3VyZVJlbGF5KHVybCwge1xuICAgICAgICAgICAgY29ubmVjdGlvblRpbWVvdXQ6IHBhcmFtcy5tYXhXYWl0ID8gTWF0aC5tYXgocGFyYW1zLm1heFdhaXQgKiAwLjgsIHBhcmFtcy5tYXhXYWl0IC0gMWUzKSA6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgZXJyPy5tZXNzYWdlIHx8IFN0cmluZyhlcnIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IHJlbGF5LnN1YnNjcmliZShbZmlsdGVyXSwge1xuICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICBvbmVvc2U6ICgpID0+IGhhbmRsZUVvc2UoaTIpLFxuICAgICAgICAgIG9uY2xvc2U6IChyZWFzb24pID0+IHtcbiAgICAgICAgICAgIGlmIChyZWFzb24uc3RhcnRzV2l0aChcImF1dGgtcmVxdWlyZWQ6XCIpICYmIHBhcmFtcy5kb2F1dGgpIHtcbiAgICAgICAgICAgICAgcmVsYXkuYXV0aChwYXJhbXMuZG9hdXRoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZWxheS5zdWJzY3JpYmUoW2ZpbHRlcl0sIHtcbiAgICAgICAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgICAgICAgIG9uZW9zZTogKCkgPT4gaGFuZGxlRW9zZShpMiksXG4gICAgICAgICAgICAgICAgICBvbmNsb3NlOiAocmVhc29uMikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgcmVhc29uMik7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgYWxyZWFkeUhhdmVFdmVudDogbG9jYWxBbHJlYWR5SGF2ZUV2ZW50SGFuZGxlcixcbiAgICAgICAgICAgICAgICAgIGVvc2VUaW1lb3V0OiBwYXJhbXMubWF4V2FpdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2xvc2UoaTIsIGBhdXRoIHdhcyByZXF1aXJlZCBhbmQgYXR0ZW1wdGVkLCBidXQgZmFpbGVkIHdpdGg6ICR7ZXJyfWApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCByZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWxyZWFkeUhhdmVFdmVudDogbG9jYWxBbHJlYWR5SGF2ZUV2ZW50SGFuZGxlcixcbiAgICAgICAgICBlb3NlVGltZW91dDogcGFyYW1zLm1heFdhaXRcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgYXdhaXQgYWxsT3BlbmVkO1xuICAgICAgICBzdWJzLmZvckVhY2goKHN1YikgPT4ge1xuICAgICAgICAgIHN1Yi5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHN1YnNjcmliZU1hbnlNYXAocmVxdWVzdHMsIHBhcmFtcykge1xuICAgIGlmICh0aGlzLnRyYWNrUmVsYXlzKSB7XG4gICAgICBwYXJhbXMucmVjZWl2ZWRFdmVudCA9IChyZWxheSwgaWQpID0+IHtcbiAgICAgICAgbGV0IHNldCA9IHRoaXMuc2Vlbk9uLmdldChpZCk7XG4gICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICB0aGlzLnNlZW5Pbi5zZXQoaWQsIHNldCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0LmFkZChyZWxheSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBfa25vd25JZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHN1YnMgPSBbXTtcbiAgICBjb25zdCByZWxheXNMZW5ndGggPSBPYmplY3Qua2V5cyhyZXF1ZXN0cykubGVuZ3RoO1xuICAgIGNvbnN0IGVvc2VzUmVjZWl2ZWQgPSBbXTtcbiAgICBsZXQgaGFuZGxlRW9zZSA9IChpMikgPT4ge1xuICAgICAgaWYgKGVvc2VzUmVjZWl2ZWRbaTJdKVxuICAgICAgICByZXR1cm47XG4gICAgICBlb3Nlc1JlY2VpdmVkW2kyXSA9IHRydWU7XG4gICAgICBpZiAoZW9zZXNSZWNlaXZlZC5maWx0ZXIoKGEpID0+IGEpLmxlbmd0aCA9PT0gcmVsYXlzTGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5vbmVvc2U/LigpO1xuICAgICAgICBoYW5kbGVFb3NlID0gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2xvc2VzUmVjZWl2ZWQgPSBbXTtcbiAgICBsZXQgaGFuZGxlQ2xvc2UgPSAoaTIsIHJlYXNvbikgPT4ge1xuICAgICAgaWYgKGNsb3Nlc1JlY2VpdmVkW2kyXSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaGFuZGxlRW9zZShpMik7XG4gICAgICBjbG9zZXNSZWNlaXZlZFtpMl0gPSByZWFzb247XG4gICAgICBpZiAoY2xvc2VzUmVjZWl2ZWQuZmlsdGVyKChhKSA9PiBhKS5sZW5ndGggPT09IHJlbGF5c0xlbmd0aCkge1xuICAgICAgICBwYXJhbXMub25jbG9zZT8uKGNsb3Nlc1JlY2VpdmVkKTtcbiAgICAgICAgaGFuZGxlQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2NhbEFscmVhZHlIYXZlRXZlbnRIYW5kbGVyID0gKGlkKSA9PiB7XG4gICAgICBpZiAocGFyYW1zLmFscmVhZHlIYXZlRXZlbnQ/LihpZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBoYXZlID0gX2tub3duSWRzLmhhcyhpZCk7XG4gICAgICBfa25vd25JZHMuYWRkKGlkKTtcbiAgICAgIHJldHVybiBoYXZlO1xuICAgIH07XG4gICAgY29uc3QgYWxsT3BlbmVkID0gUHJvbWlzZS5hbGwoXG4gICAgICBPYmplY3QuZW50cmllcyhyZXF1ZXN0cykubWFwKGFzeW5jIChyZXEsIGkyLCBhcnIpID0+IHtcbiAgICAgICAgaWYgKGFyci5pbmRleE9mKHJlcSkgIT09IGkyKSB7XG4gICAgICAgICAgaGFuZGxlQ2xvc2UoaTIsIFwiZHVwbGljYXRlIHVybFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFt1cmwsIGZpbHRlcnNdID0gcmVxO1xuICAgICAgICB1cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICAgICAgbGV0IHJlbGF5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlbGF5ID0gYXdhaXQgdGhpcy5lbnN1cmVSZWxheSh1cmwsIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25UaW1lb3V0OiBwYXJhbXMubWF4V2FpdCA/IE1hdGgubWF4KHBhcmFtcy5tYXhXYWl0ICogMC44LCBwYXJhbXMubWF4V2FpdCAtIDFlMykgOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaGFuZGxlQ2xvc2UoaTIsIGVycj8ubWVzc2FnZSB8fCBTdHJpbmcoZXJyKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJzY3JpcHRpb24gPSByZWxheS5zdWJzY3JpYmUoZmlsdGVycywge1xuICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICBvbmVvc2U6ICgpID0+IGhhbmRsZUVvc2UoaTIpLFxuICAgICAgICAgIG9uY2xvc2U6IChyZWFzb24pID0+IHtcbiAgICAgICAgICAgIGlmIChyZWFzb24uc3RhcnRzV2l0aChcImF1dGgtcmVxdWlyZWQ6XCIpICYmIHBhcmFtcy5kb2F1dGgpIHtcbiAgICAgICAgICAgICAgcmVsYXkuYXV0aChwYXJhbXMuZG9hdXRoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZWxheS5zdWJzY3JpYmUoZmlsdGVycywge1xuICAgICAgICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgICAgICAgb25lb3NlOiAoKSA9PiBoYW5kbGVFb3NlKGkyKSxcbiAgICAgICAgICAgICAgICAgIG9uY2xvc2U6IChyZWFzb24yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCByZWFzb24yKTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBhbHJlYWR5SGF2ZUV2ZW50OiBsb2NhbEFscmVhZHlIYXZlRXZlbnRIYW5kbGVyLFxuICAgICAgICAgICAgICAgICAgZW9zZVRpbWVvdXQ6IHBhcmFtcy5tYXhXYWl0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgYGF1dGggd2FzIHJlcXVpcmVkIGFuZCBhdHRlbXB0ZWQsIGJ1dCBmYWlsZWQgd2l0aDogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaGFuZGxlQ2xvc2UoaTIsIHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbHJlYWR5SGF2ZUV2ZW50OiBsb2NhbEFscmVhZHlIYXZlRXZlbnRIYW5kbGVyLFxuICAgICAgICAgIGVvc2VUaW1lb3V0OiBwYXJhbXMubWF4V2FpdFxuICAgICAgICB9KTtcbiAgICAgICAgc3Vicy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBhd2FpdCBhbGxPcGVuZWQ7XG4gICAgICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICAgICAgc3ViLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3Vic2NyaWJlRW9zZShyZWxheXMsIGZpbHRlciwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc3ViY2xvc2VyID0gdGhpcy5zdWJzY3JpYmUocmVsYXlzLCBmaWx0ZXIsIHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG9uZW9zZSgpIHtcbiAgICAgICAgc3ViY2xvc2VyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN1YmNsb3NlcjtcbiAgfVxuICBzdWJzY3JpYmVNYW55RW9zZShyZWxheXMsIGZpbHRlcnMsIHBhcmFtcykge1xuICAgIGNvbnN0IHN1YmNsb3NlciA9IHRoaXMuc3Vic2NyaWJlTWFueShyZWxheXMsIGZpbHRlcnMsIHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG9uZW9zZSgpIHtcbiAgICAgICAgc3ViY2xvc2VyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN1YmNsb3NlcjtcbiAgfVxuICBhc3luYyBxdWVyeVN5bmMocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgZXZlbnRzID0gW107XG4gICAgICB0aGlzLnN1YnNjcmliZUVvc2UocmVsYXlzLCBmaWx0ZXIsIHtcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICBvbmV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBvbmNsb3NlKF8pIHtcbiAgICAgICAgICByZXNvbHZlKGV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldChyZWxheXMsIGZpbHRlciwgcGFyYW1zKSB7XG4gICAgZmlsdGVyLmxpbWl0ID0gMTtcbiAgICBjb25zdCBldmVudHMgPSBhd2FpdCB0aGlzLnF1ZXJ5U3luYyhyZWxheXMsIGZpbHRlciwgcGFyYW1zKTtcbiAgICBldmVudHMuc29ydCgoYSwgYikgPT4gYi5jcmVhdGVkX2F0IC0gYS5jcmVhdGVkX2F0KTtcbiAgICByZXR1cm4gZXZlbnRzWzBdIHx8IG51bGw7XG4gIH1cbiAgcHVibGlzaChyZWxheXMsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHJlbGF5cy5tYXAobm9ybWFsaXplVVJMKS5tYXAoYXN5bmMgKHVybCwgaTIsIGFycikgPT4ge1xuICAgICAgaWYgKGFyci5pbmRleE9mKHVybCkgIT09IGkyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcImR1cGxpY2F0ZSB1cmxcIik7XG4gICAgICB9XG4gICAgICBsZXQgciA9IGF3YWl0IHRoaXMuZW5zdXJlUmVsYXkodXJsKTtcbiAgICAgIHJldHVybiByLnB1Ymxpc2goZXZlbnQpLnRoZW4oKHJlYXNvbikgPT4ge1xuICAgICAgICBpZiAodGhpcy50cmFja1JlbGF5cykge1xuICAgICAgICAgIGxldCBzZXQgPSB0aGlzLnNlZW5Pbi5nZXQoZXZlbnQuaWQpO1xuICAgICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgICBzZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgdGhpcy5zZWVuT24uc2V0KGV2ZW50LmlkLCBzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXQuYWRkKHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWFzb247XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBsaXN0Q29ubmVjdGlvblN0YXR1cygpIHtcbiAgICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucmVsYXlzLmZvckVhY2goKHJlbGF5LCB1cmwpID0+IG1hcC5zZXQodXJsLCByZWxheS5jb25uZWN0ZWQpKTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZWxheXMuZm9yRWFjaCgoY29ubikgPT4gY29ubi5jbG9zZSgpKTtcbiAgICB0aGlzLnJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbn07XG5cbi8vIHBvb2wudHNcbnZhciBfV2ViU29ja2V0MjtcbnRyeSB7XG4gIF9XZWJTb2NrZXQyID0gV2ViU29ja2V0O1xufSBjYXRjaCB7XG59XG52YXIgU2ltcGxlUG9vbCA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RTaW1wbGVQb29sIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoeyB2ZXJpZnlFdmVudCwgd2Vic29ja2V0SW1wbGVtZW50YXRpb246IF9XZWJTb2NrZXQyIH0pO1xuICB9XG59O1xuXG4vLyBuaXAxOS50c1xudmFyIG5pcDE5X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDE5X2V4cG9ydHMsIHtcbiAgQkVDSDMyX1JFR0VYOiAoKSA9PiBCRUNIMzJfUkVHRVgsXG4gIEJlY2gzMk1heFNpemU6ICgpID0+IEJlY2gzMk1heFNpemUsXG4gIE5vc3RyVHlwZUd1YXJkOiAoKSA9PiBOb3N0clR5cGVHdWFyZCxcbiAgZGVjb2RlOiAoKSA9PiBkZWNvZGUsXG4gIGRlY29kZU5vc3RyVVJJOiAoKSA9PiBkZWNvZGVOb3N0clVSSSxcbiAgZW5jb2RlQnl0ZXM6ICgpID0+IGVuY29kZUJ5dGVzLFxuICBuYWRkckVuY29kZTogKCkgPT4gbmFkZHJFbmNvZGUsXG4gIG5ldmVudEVuY29kZTogKCkgPT4gbmV2ZW50RW5jb2RlLFxuICBub3RlRW5jb2RlOiAoKSA9PiBub3RlRW5jb2RlLFxuICBucHJvZmlsZUVuY29kZTogKCkgPT4gbnByb2ZpbGVFbmNvZGUsXG4gIG5wdWJFbmNvZGU6ICgpID0+IG5wdWJFbmNvZGUsXG4gIG5zZWNFbmNvZGU6ICgpID0+IG5zZWNFbmNvZGVcbn0pO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4MiwgY29uY2F0Qnl0ZXMsIGhleFRvQnl0ZXMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHsgYmVjaDMyIH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG52YXIgTm9zdHJUeXBlR3VhcmQgPSB7XG4gIGlzTlByb2ZpbGU6ICh2YWx1ZSkgPT4gL15ucHJvZmlsZTFbYS16XFxkXSskLy50ZXN0KHZhbHVlIHx8IFwiXCIpLFxuICBpc05FdmVudDogKHZhbHVlKSA9PiAvXm5ldmVudDFbYS16XFxkXSskLy50ZXN0KHZhbHVlIHx8IFwiXCIpLFxuICBpc05BZGRyOiAodmFsdWUpID0+IC9ebmFkZHIxW2EtelxcZF0rJC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNOU2VjOiAodmFsdWUpID0+IC9ebnNlYzFbYS16XFxkXXs1OH0kLy50ZXN0KHZhbHVlIHx8IFwiXCIpLFxuICBpc05QdWI6ICh2YWx1ZSkgPT4gL15ucHViMVthLXpcXGRdezU4fSQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTm90ZTogKHZhbHVlKSA9PiAvXm5vdGUxW2EtelxcZF0rJC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNOY3J5cHRzZWM6ICh2YWx1ZSkgPT4gL15uY3J5cHRzZWMxW2EtelxcZF0rJC8udGVzdCh2YWx1ZSB8fCBcIlwiKVxufTtcbnZhciBCZWNoMzJNYXhTaXplID0gNWUzO1xudmFyIEJFQ0gzMl9SRUdFWCA9IC9bXFx4MjEtXFx4N0VdezEsODN9MVswMjM0NTY3ODlhY2RlZmdoamtsbW5wcXJzdHV2d3h5el17Nix9LztcbmZ1bmN0aW9uIGludGVnZXJUb1VpbnQ4QXJyYXkobnVtYmVyKSB7XG4gIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgdWludDhBcnJheVswXSA9IG51bWJlciA+PiAyNCAmIDI1NTtcbiAgdWludDhBcnJheVsxXSA9IG51bWJlciA+PiAxNiAmIDI1NTtcbiAgdWludDhBcnJheVsyXSA9IG51bWJlciA+PiA4ICYgMjU1O1xuICB1aW50OEFycmF5WzNdID0gbnVtYmVyICYgMjU1O1xuICByZXR1cm4gdWludDhBcnJheTtcbn1cbmZ1bmN0aW9uIGRlY29kZU5vc3RyVVJJKG5pcDE5Y29kZSkge1xuICB0cnkge1xuICAgIGlmIChuaXAxOWNvZGUuc3RhcnRzV2l0aChcIm5vc3RyOlwiKSlcbiAgICAgIG5pcDE5Y29kZSA9IG5pcDE5Y29kZS5zdWJzdHJpbmcoNik7XG4gICAgcmV0dXJuIGRlY29kZShuaXAxOWNvZGUpO1xuICB9IGNhdGNoIChfZXJyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJpbnZhbGlkXCIsIGRhdGE6IG51bGwgfTtcbiAgfVxufVxuZnVuY3Rpb24gZGVjb2RlKG5pcDE5KSB7XG4gIGxldCB7IHByZWZpeCwgd29yZHMgfSA9IGJlY2gzMi5kZWNvZGUobmlwMTksIEJlY2gzMk1heFNpemUpO1xuICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJlY2gzMi5mcm9tV29yZHMod29yZHMpKTtcbiAgc3dpdGNoIChwcmVmaXgpIHtcbiAgICBjYXNlIFwibnByb2ZpbGVcIjoge1xuICAgICAgbGV0IHRsdiA9IHBhcnNlVExWKGRhdGEpO1xuICAgICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbnByb2ZpbGVcIik7XG4gICAgICBpZiAodGx2WzBdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAwIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibnByb2ZpbGVcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHB1YmtleTogYnl0ZXNUb0hleDIodGx2WzBdWzBdKSxcbiAgICAgICAgICByZWxheXM6IHRsdlsxXSA/IHRsdlsxXS5tYXAoKGQpID0+IHV0ZjhEZWNvZGVyLmRlY29kZShkKSkgOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibmV2ZW50XCI6IHtcbiAgICAgIGxldCB0bHYgPSBwYXJzZVRMVihkYXRhKTtcbiAgICAgIGlmICghdGx2WzBdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5ldmVudFwiKTtcbiAgICAgIGlmICh0bHZbMF1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDAgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKHRsdlsyXSAmJiB0bHZbMl1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDIgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKHRsdlszXSAmJiB0bHZbM11bMF0ubGVuZ3RoICE9PSA0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMyBzaG91bGQgYmUgNCBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibmV2ZW50XCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZDogYnl0ZXNUb0hleDIodGx2WzBdWzBdKSxcbiAgICAgICAgICByZWxheXM6IHRsdlsxXSA/IHRsdlsxXS5tYXAoKGQpID0+IHV0ZjhEZWNvZGVyLmRlY29kZShkKSkgOiBbXSxcbiAgICAgICAgICBhdXRob3I6IHRsdlsyXT8uWzBdID8gYnl0ZXNUb0hleDIodGx2WzJdWzBdKSA6IHZvaWQgMCxcbiAgICAgICAgICBraW5kOiB0bHZbM10/LlswXSA/IHBhcnNlSW50KGJ5dGVzVG9IZXgyKHRsdlszXVswXSksIDE2KSA6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibmFkZHJcIjoge1xuICAgICAgbGV0IHRsdiA9IHBhcnNlVExWKGRhdGEpO1xuICAgICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAoIXRsdlsyXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAyIGZvciBuYWRkclwiKTtcbiAgICAgIGlmICh0bHZbMl1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDIgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKCF0bHZbM10/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMyBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAodGx2WzNdWzBdLmxlbmd0aCAhPT0gNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDMgc2hvdWxkIGJlIDQgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5hZGRyXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZGVudGlmaWVyOiB1dGY4RGVjb2Rlci5kZWNvZGUodGx2WzBdWzBdKSxcbiAgICAgICAgICBwdWJrZXk6IGJ5dGVzVG9IZXgyKHRsdlsyXVswXSksXG4gICAgICAgICAga2luZDogcGFyc2VJbnQoYnl0ZXNUb0hleDIodGx2WzNdWzBdKSwgMTYpLFxuICAgICAgICAgIHJlbGF5czogdGx2WzFdID8gdGx2WzFdLm1hcCgoZCkgPT4gdXRmOERlY29kZXIuZGVjb2RlKGQpKSA6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuc2VjXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBwcmVmaXgsIGRhdGEgfTtcbiAgICBjYXNlIFwibnB1YlwiOlxuICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBwcmVmaXgsIGRhdGE6IGJ5dGVzVG9IZXgyKGRhdGEpIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBwcmVmaXggJHtwcmVmaXh9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVExWKGRhdGEpIHtcbiAgbGV0IHJlc3VsdCA9IHt9O1xuICBsZXQgcmVzdCA9IGRhdGE7XG4gIHdoaWxlIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICBsZXQgdCA9IHJlc3RbMF07XG4gICAgbGV0IGwgPSByZXN0WzFdO1xuICAgIGxldCB2ID0gcmVzdC5zbGljZSgyLCAyICsgbCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMiArIGwpO1xuICAgIGlmICh2Lmxlbmd0aCA8IGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBlbm91Z2ggZGF0YSB0byByZWFkIG9uIFRMViAke3R9YCk7XG4gICAgcmVzdWx0W3RdID0gcmVzdWx0W3RdIHx8IFtdO1xuICAgIHJlc3VsdFt0XS5wdXNoKHYpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBuc2VjRW5jb2RlKGtleSkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJuc2VjXCIsIGtleSk7XG59XG5mdW5jdGlvbiBucHViRW5jb2RlKGhleCkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJucHViXCIsIGhleFRvQnl0ZXMoaGV4KSk7XG59XG5mdW5jdGlvbiBub3RlRW5jb2RlKGhleCkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJub3RlXCIsIGhleFRvQnl0ZXMoaGV4KSk7XG59XG5mdW5jdGlvbiBlbmNvZGVCZWNoMzIocHJlZml4LCBkYXRhKSB7XG4gIGxldCB3b3JkcyA9IGJlY2gzMi50b1dvcmRzKGRhdGEpO1xuICByZXR1cm4gYmVjaDMyLmVuY29kZShwcmVmaXgsIHdvcmRzLCBCZWNoMzJNYXhTaXplKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUJ5dGVzKHByZWZpeCwgYnl0ZXMpIHtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihwcmVmaXgsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIG5wcm9maWxlRW5jb2RlKHByb2ZpbGUpIHtcbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFtoZXhUb0J5dGVzKHByb2ZpbGUucHVia2V5KV0sXG4gICAgMTogKHByb2ZpbGUucmVsYXlzIHx8IFtdKS5tYXAoKHVybCkgPT4gdXRmOEVuY29kZXIuZW5jb2RlKHVybCkpXG4gIH0pO1xuICByZXR1cm4gZW5jb2RlQmVjaDMyKFwibnByb2ZpbGVcIiwgZGF0YSk7XG59XG5mdW5jdGlvbiBuZXZlbnRFbmNvZGUoZXZlbnQpIHtcbiAgbGV0IGtpbmRBcnJheTtcbiAgaWYgKGV2ZW50LmtpbmQgIT09IHZvaWQgMCkge1xuICAgIGtpbmRBcnJheSA9IGludGVnZXJUb1VpbnQ4QXJyYXkoZXZlbnQua2luZCk7XG4gIH1cbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFtoZXhUb0J5dGVzKGV2ZW50LmlkKV0sXG4gICAgMTogKGV2ZW50LnJlbGF5cyB8fCBbXSkubWFwKCh1cmwpID0+IHV0ZjhFbmNvZGVyLmVuY29kZSh1cmwpKSxcbiAgICAyOiBldmVudC5hdXRob3IgPyBbaGV4VG9CeXRlcyhldmVudC5hdXRob3IpXSA6IFtdLFxuICAgIDM6IGtpbmRBcnJheSA/IFtuZXcgVWludDhBcnJheShraW5kQXJyYXkpXSA6IFtdXG4gIH0pO1xuICByZXR1cm4gZW5jb2RlQmVjaDMyKFwibmV2ZW50XCIsIGRhdGEpO1xufVxuZnVuY3Rpb24gbmFkZHJFbmNvZGUoYWRkcikge1xuICBsZXQga2luZCA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgbmV3IERhdGFWaWV3KGtpbmQpLnNldFVpbnQzMigwLCBhZGRyLmtpbmQsIGZhbHNlKTtcbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFt1dGY4RW5jb2Rlci5lbmNvZGUoYWRkci5pZGVudGlmaWVyKV0sXG4gICAgMTogKGFkZHIucmVsYXlzIHx8IFtdKS5tYXAoKHVybCkgPT4gdXRmOEVuY29kZXIuZW5jb2RlKHVybCkpLFxuICAgIDI6IFtoZXhUb0J5dGVzKGFkZHIucHVia2V5KV0sXG4gICAgMzogW25ldyBVaW50OEFycmF5KGtpbmQpXVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihcIm5hZGRyXCIsIGRhdGEpO1xufVxuZnVuY3Rpb24gZW5jb2RlVExWKHRsdikge1xuICBsZXQgZW50cmllcyA9IFtdO1xuICBPYmplY3QuZW50cmllcyh0bHYpLnJldmVyc2UoKS5mb3JFYWNoKChbdCwgdnNdKSA9PiB7XG4gICAgdnMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgbGV0IGVudHJ5ID0gbmV3IFVpbnQ4QXJyYXkodi5sZW5ndGggKyAyKTtcbiAgICAgIGVudHJ5LnNldChbcGFyc2VJbnQodCldLCAwKTtcbiAgICAgIGVudHJ5LnNldChbdi5sZW5ndGhdLCAxKTtcbiAgICAgIGVudHJ5LnNldCh2LCAyKTtcbiAgICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4uZW50cmllcyk7XG59XG5cbi8vIHJlZmVyZW5jZXMudHNcbnZhciBtZW50aW9uUmVnZXggPSAvXFxibm9zdHI6KChub3RlfG5wdWJ8bmFkZHJ8bmV2ZW50fG5wcm9maWxlKTFcXHcrKVxcYnwjXFxbKFxcZCspXFxdL2c7XG5mdW5jdGlvbiBwYXJzZVJlZmVyZW5jZXMoZXZ0KSB7XG4gIGxldCByZWZlcmVuY2VzID0gW107XG4gIGZvciAobGV0IHJlZiBvZiBldnQuY29udGVudC5tYXRjaEFsbChtZW50aW9uUmVnZXgpKSB7XG4gICAgaWYgKHJlZlsyXSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHsgdHlwZSwgZGF0YSB9ID0gZGVjb2RlKHJlZlsxXSk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJucHViXCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgcHJvZmlsZTogeyBwdWJrZXk6IGRhdGEsIHJlbGF5czogW10gfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5wcm9maWxlXCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgcHJvZmlsZTogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5vdGVcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBldmVudDogeyBpZDogZGF0YSwgcmVsYXlzOiBbXSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibmV2ZW50XCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgZXZlbnQ6IGRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJuYWRkclwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIGFkZHJlc3M6IGRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZlszXSkge1xuICAgICAgbGV0IGlkeCA9IHBhcnNlSW50KHJlZlszXSwgMTApO1xuICAgICAgbGV0IHRhZyA9IGV2dC50YWdzW2lkeF07XG4gICAgICBpZiAoIXRhZylcbiAgICAgICAgY29udGludWU7XG4gICAgICBzd2l0Y2ggKHRhZ1swXSkge1xuICAgICAgICBjYXNlIFwicFwiOiB7XG4gICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgIHByb2ZpbGU6IHsgcHVia2V5OiB0YWdbMV0sIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVcIjoge1xuICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICBldmVudDogeyBpZDogdGFnWzFdLCByZWxheXM6IHRhZ1syXSA/IFt0YWdbMl1dIDogW10gfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhXCI6IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IFtraW5kLCBwdWJrZXksIGlkZW50aWZpZXJdID0gdGFnWzFdLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgYWRkcmVzczoge1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgcHVia2V5LFxuICAgICAgICAgICAgICAgIGtpbmQ6IHBhcnNlSW50KGtpbmQsIDEwKSxcbiAgICAgICAgICAgICAgICByZWxheXM6IHRhZ1syXSA/IFt0YWdbMl1dIDogW11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZWZlcmVuY2VzO1xufVxuXG4vLyBuaXAwNC50c1xudmFyIG5pcDA0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDA0X2V4cG9ydHMsIHtcbiAgZGVjcnlwdDogKCkgPT4gZGVjcnlwdCxcbiAgZW5jcnlwdDogKCkgPT4gZW5jcnlwdFxufSk7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXgzLCByYW5kb21CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGNiYyB9IGZyb20gXCJAbm9ibGUvY2lwaGVycy9hZXNcIjtcbmltcG9ydCB7IGJhc2U2NCB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xuZnVuY3Rpb24gZW5jcnlwdChzZWNyZXRLZXksIHB1YmtleSwgdGV4dCkge1xuICBjb25zdCBwcml2a2V5ID0gc2VjcmV0S2V5IGluc3RhbmNlb2YgVWludDhBcnJheSA/IGJ5dGVzVG9IZXgzKHNlY3JldEtleSkgOiBzZWNyZXRLZXk7XG4gIGNvbnN0IGtleSA9IHNlY3AyNTZrMS5nZXRTaGFyZWRTZWNyZXQocHJpdmtleSwgXCIwMlwiICsgcHVia2V5KTtcbiAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGdldE5vcm1hbGl6ZWRYKGtleSk7XG4gIGxldCBpdiA9IFVpbnQ4QXJyYXkuZnJvbShyYW5kb21CeXRlcygxNikpO1xuICBsZXQgcGxhaW50ZXh0ID0gdXRmOEVuY29kZXIuZW5jb2RlKHRleHQpO1xuICBsZXQgY2lwaGVydGV4dCA9IGNiYyhub3JtYWxpemVkS2V5LCBpdikuZW5jcnlwdChwbGFpbnRleHQpO1xuICBsZXQgY3RiNjQgPSBiYXNlNjQuZW5jb2RlKG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQpKTtcbiAgbGV0IGl2YjY0ID0gYmFzZTY0LmVuY29kZShuZXcgVWludDhBcnJheShpdi5idWZmZXIpKTtcbiAgcmV0dXJuIGAke2N0YjY0fT9pdj0ke2l2YjY0fWA7XG59XG5mdW5jdGlvbiBkZWNyeXB0KHNlY3JldEtleSwgcHVia2V5LCBkYXRhKSB7XG4gIGNvbnN0IHByaXZrZXkgPSBzZWNyZXRLZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gYnl0ZXNUb0hleDMoc2VjcmV0S2V5KSA6IHNlY3JldEtleTtcbiAgbGV0IFtjdGI2NCwgaXZiNjRdID0gZGF0YS5zcGxpdChcIj9pdj1cIik7XG4gIGxldCBrZXkgPSBzZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KHByaXZrZXksIFwiMDJcIiArIHB1YmtleSk7XG4gIGxldCBub3JtYWxpemVkS2V5ID0gZ2V0Tm9ybWFsaXplZFgoa2V5KTtcbiAgbGV0IGl2ID0gYmFzZTY0LmRlY29kZShpdmI2NCk7XG4gIGxldCBjaXBoZXJ0ZXh0ID0gYmFzZTY0LmRlY29kZShjdGI2NCk7XG4gIGxldCBwbGFpbnRleHQgPSBjYmMobm9ybWFsaXplZEtleSwgaXYpLmRlY3J5cHQoY2lwaGVydGV4dCk7XG4gIHJldHVybiB1dGY4RGVjb2Rlci5kZWNvZGUocGxhaW50ZXh0KTtcbn1cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRYKGtleSkge1xuICByZXR1cm4ga2V5LnNsaWNlKDEsIDMzKTtcbn1cblxuLy8gbmlwMDUudHNcbnZhciBuaXAwNV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAwNV9leHBvcnRzLCB7XG4gIE5JUDA1X1JFR0VYOiAoKSA9PiBOSVAwNV9SRUdFWCxcbiAgaXNOaXAwNTogKCkgPT4gaXNOaXAwNSxcbiAgaXNWYWxpZDogKCkgPT4gaXNWYWxpZCxcbiAgcXVlcnlQcm9maWxlOiAoKSA9PiBxdWVyeVByb2ZpbGUsXG4gIHNlYXJjaERvbWFpbjogKCkgPT4gc2VhcmNoRG9tYWluLFxuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uXG59KTtcbnZhciBOSVAwNV9SRUdFWCA9IC9eKD86KFtcXHcuKy1dKylAKT8oW1xcd18tXSsoXFwuW1xcd18tXSspKykkLztcbnZhciBpc05pcDA1ID0gKHZhbHVlKSA9PiBOSVAwNV9SRUdFWC50ZXN0KHZhbHVlIHx8IFwiXCIpO1xudmFyIF9mZXRjaDtcbnRyeSB7XG4gIF9mZXRjaCA9IGZldGNoO1xufSBjYXRjaCAoXykge1xuICBudWxsO1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbihmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaCA9IGZldGNoSW1wbGVtZW50YXRpb247XG59XG5hc3luYyBmdW5jdGlvbiBzZWFyY2hEb21haW4oZG9tYWluLCBxdWVyeSA9IFwiXCIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly8ke2RvbWFpbn0vLndlbGwta25vd24vbm9zdHIuanNvbj9uYW1lPSR7cXVlcnl9YDtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBfZmV0Y2godXJsLCB7IHJlZGlyZWN0OiBcIm1hbnVhbFwiIH0pO1xuICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IEVycm9yKFwiV3JvbmcgcmVzcG9uc2UgY29kZVwiKTtcbiAgICB9XG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIGpzb24ubmFtZXM7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHF1ZXJ5UHJvZmlsZShmdWxsbmFtZSkge1xuICBjb25zdCBtYXRjaCA9IGZ1bGxuYW1lLm1hdGNoKE5JUDA1X1JFR0VYKTtcbiAgaWYgKCFtYXRjaClcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgWywgbmFtZSA9IFwiX1wiLCBkb21haW5dID0gbWF0Y2g7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vJHtkb21haW59Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke25hbWV9YDtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBfZmV0Y2godXJsLCB7IHJlZGlyZWN0OiBcIm1hbnVhbFwiIH0pO1xuICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IEVycm9yKFwiV3JvbmcgcmVzcG9uc2UgY29kZVwiKTtcbiAgICB9XG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3QgcHVia2V5ID0ganNvbi5uYW1lc1tuYW1lXTtcbiAgICByZXR1cm4gcHVia2V5ID8geyBwdWJrZXksIHJlbGF5czoganNvbi5yZWxheXM/LltwdWJrZXldIH0gOiBudWxsO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBpc1ZhbGlkKHB1YmtleSwgbmlwMDUpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcXVlcnlQcm9maWxlKG5pcDA1KTtcbiAgcmV0dXJuIHJlcyA/IHJlcy5wdWJrZXkgPT09IHB1YmtleSA6IGZhbHNlO1xufVxuXG4vLyBuaXAxMC50c1xudmFyIG5pcDEwX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDEwX2V4cG9ydHMsIHtcbiAgcGFyc2U6ICgpID0+IHBhcnNlXG59KTtcbmZ1bmN0aW9uIHBhcnNlKGV2ZW50KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICByZXBseTogdm9pZCAwLFxuICAgIHJvb3Q6IHZvaWQgMCxcbiAgICBtZW50aW9uczogW10sXG4gICAgcHJvZmlsZXM6IFtdLFxuICAgIHF1b3RlczogW11cbiAgfTtcbiAgbGV0IG1heWJlUGFyZW50O1xuICBsZXQgbWF5YmVSb290O1xuICBmb3IgKGxldCBpMiA9IGV2ZW50LnRhZ3MubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgIGNvbnN0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIHRhZ1sxXSkge1xuICAgICAgY29uc3QgW18sIGVUYWdFdmVudElkLCBlVGFnUmVsYXlVcmwsIGVUYWdNYXJrZXIsIGVUYWdBdXRob3JdID0gdGFnO1xuICAgICAgY29uc3QgZXZlbnRQb2ludGVyID0ge1xuICAgICAgICBpZDogZVRhZ0V2ZW50SWQsXG4gICAgICAgIHJlbGF5czogZVRhZ1JlbGF5VXJsID8gW2VUYWdSZWxheVVybF0gOiBbXSxcbiAgICAgICAgYXV0aG9yOiBlVGFnQXV0aG9yXG4gICAgICB9O1xuICAgICAgaWYgKGVUYWdNYXJrZXIgPT09IFwicm9vdFwiKSB7XG4gICAgICAgIHJlc3VsdC5yb290ID0gZXZlbnRQb2ludGVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlVGFnTWFya2VyID09PSBcInJlcGx5XCIpIHtcbiAgICAgICAgcmVzdWx0LnJlcGx5ID0gZXZlbnRQb2ludGVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlVGFnTWFya2VyID09PSBcIm1lbnRpb25cIikge1xuICAgICAgICByZXN1bHQubWVudGlvbnMucHVzaChldmVudFBvaW50ZXIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF5YmVQYXJlbnQpIHtcbiAgICAgICAgbWF5YmVQYXJlbnQgPSBldmVudFBvaW50ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXliZVJvb3QgPSBldmVudFBvaW50ZXI7XG4gICAgICB9XG4gICAgICByZXN1bHQubWVudGlvbnMucHVzaChldmVudFBvaW50ZXIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0YWdbMF0gPT09IFwicVwiICYmIHRhZ1sxXSkge1xuICAgICAgY29uc3QgW18sIGVUYWdFdmVudElkLCBlVGFnUmVsYXlVcmxdID0gdGFnO1xuICAgICAgcmVzdWx0LnF1b3Rlcy5wdXNoKHtcbiAgICAgICAgaWQ6IGVUYWdFdmVudElkLFxuICAgICAgICByZWxheXM6IGVUYWdSZWxheVVybCA/IFtlVGFnUmVsYXlVcmxdIDogW11cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGFnWzBdID09PSBcInBcIiAmJiB0YWdbMV0pIHtcbiAgICAgIHJlc3VsdC5wcm9maWxlcy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiB0YWdbMV0sXG4gICAgICAgIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyZXN1bHQucm9vdCkge1xuICAgIHJlc3VsdC5yb290ID0gbWF5YmVSb290IHx8IG1heWJlUGFyZW50IHx8IHJlc3VsdC5yZXBseTtcbiAgfVxuICBpZiAoIXJlc3VsdC5yZXBseSkge1xuICAgIHJlc3VsdC5yZXBseSA9IG1heWJlUGFyZW50IHx8IHJlc3VsdC5yb290O1xuICB9XG4gIDtcbiAgW3Jlc3VsdC5yZXBseSwgcmVzdWx0LnJvb3RdLmZvckVhY2goKHJlZikgPT4ge1xuICAgIGlmICghcmVmKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBpZHggPSByZXN1bHQubWVudGlvbnMuaW5kZXhPZihyZWYpO1xuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICByZXN1bHQubWVudGlvbnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuICAgIGlmIChyZWYuYXV0aG9yKSB7XG4gICAgICBsZXQgYXV0aG9yID0gcmVzdWx0LnByb2ZpbGVzLmZpbmQoKHApID0+IHAucHVia2V5ID09PSByZWYuYXV0aG9yKTtcbiAgICAgIGlmIChhdXRob3IgJiYgYXV0aG9yLnJlbGF5cykge1xuICAgICAgICBpZiAoIXJlZi5yZWxheXMpIHtcbiAgICAgICAgICByZWYucmVsYXlzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYXV0aG9yLnJlbGF5cy5mb3JFYWNoKCh1cmwpID0+IHtcbiAgICAgICAgICBpZiAocmVmLnJlbGF5cz8uaW5kZXhPZih1cmwpID09PSAtMSlcbiAgICAgICAgICAgIHJlZi5yZWxheXMucHVzaCh1cmwpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXV0aG9yLnJlbGF5cyA9IHJlZi5yZWxheXM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmVzdWx0Lm1lbnRpb25zLmZvckVhY2goKHJlZikgPT4ge1xuICAgIGlmIChyZWYuYXV0aG9yKSB7XG4gICAgICBsZXQgYXV0aG9yID0gcmVzdWx0LnByb2ZpbGVzLmZpbmQoKHApID0+IHAucHVia2V5ID09PSByZWYuYXV0aG9yKTtcbiAgICAgIGlmIChhdXRob3IgJiYgYXV0aG9yLnJlbGF5cykge1xuICAgICAgICBpZiAoIXJlZi5yZWxheXMpIHtcbiAgICAgICAgICByZWYucmVsYXlzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYXV0aG9yLnJlbGF5cy5mb3JFYWNoKCh1cmwpID0+IHtcbiAgICAgICAgICBpZiAocmVmLnJlbGF5cy5pbmRleE9mKHVybCkgPT09IC0xKVxuICAgICAgICAgICAgcmVmLnJlbGF5cy5wdXNoKHVybCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhdXRob3IucmVsYXlzID0gcmVmLnJlbGF5cztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBuaXAxMS50c1xudmFyIG5pcDExX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDExX2V4cG9ydHMsIHtcbiAgZmV0Y2hSZWxheUluZm9ybWF0aW9uOiAoKSA9PiBmZXRjaFJlbGF5SW5mb3JtYXRpb24sXG4gIHVzZUZldGNoSW1wbGVtZW50YXRpb246ICgpID0+IHVzZUZldGNoSW1wbGVtZW50YXRpb24yXG59KTtcbnZhciBfZmV0Y2gyO1xudHJ5IHtcbiAgX2ZldGNoMiA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiB1c2VGZXRjaEltcGxlbWVudGF0aW9uMihmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaDIgPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZWxheUluZm9ybWF0aW9uKHVybCkge1xuICByZXR1cm4gYXdhaXQgKGF3YWl0IGZldGNoKHVybC5yZXBsYWNlKFwid3M6Ly9cIiwgXCJodHRwOi8vXCIpLnJlcGxhY2UoXCJ3c3M6Ly9cIiwgXCJodHRwczovL1wiKSwge1xuICAgIGhlYWRlcnM6IHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL25vc3RyK2pzb25cIiB9XG4gIH0pKS5qc29uKCk7XG59XG5cbi8vIG5pcDEzLnRzXG52YXIgbmlwMTNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMTNfZXhwb3J0cywge1xuICBmYXN0RXZlbnRIYXNoOiAoKSA9PiBmYXN0RXZlbnRIYXNoLFxuICBnZXRQb3c6ICgpID0+IGdldFBvdyxcbiAgbWluZVBvdzogKCkgPT4gbWluZVBvd1xufSk7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXg0IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IHNoYTI1NiBhcyBzaGEyNTYyIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5mdW5jdGlvbiBnZXRQb3coaGV4KSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCA2NDsgaTIgKz0gOCkge1xuICAgIGNvbnN0IG5pYmJsZSA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoaTIsIGkyICsgOCksIDE2KTtcbiAgICBpZiAobmliYmxlID09PSAwKSB7XG4gICAgICBjb3VudCArPSAzMjtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgKz0gTWF0aC5jbHozMihuaWJibGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIG1pbmVQb3codW5zaWduZWQsIGRpZmZpY3VsdHkpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgY29uc3QgZXZlbnQgPSB1bnNpZ25lZDtcbiAgY29uc3QgdGFnID0gW1wibm9uY2VcIiwgY291bnQudG9TdHJpbmcoKSwgZGlmZmljdWx0eS50b1N0cmluZygpXTtcbiAgZXZlbnQudGFncy5wdXNoKHRhZyk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3Qgbm93MiA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxZTMpO1xuICAgIGlmIChub3cyICE9PSBldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgICBldmVudC5jcmVhdGVkX2F0ID0gbm93MjtcbiAgICB9XG4gICAgdGFnWzFdID0gKCsrY291bnQpLnRvU3RyaW5nKCk7XG4gICAgZXZlbnQuaWQgPSBmYXN0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBpZiAoZ2V0UG93KGV2ZW50LmlkKSA+PSBkaWZmaWN1bHR5KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50O1xufVxuZnVuY3Rpb24gZmFzdEV2ZW50SGFzaChldnQpIHtcbiAgcmV0dXJuIGJ5dGVzVG9IZXg0KFxuICAgIHNoYTI1NjIodXRmOEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KFswLCBldnQucHVia2V5LCBldnQuY3JlYXRlZF9hdCwgZXZ0LmtpbmQsIGV2dC50YWdzLCBldnQuY29udGVudF0pKSlcbiAgKTtcbn1cblxuLy8gbmlwMTcudHNcbnZhciBuaXAxN19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxN19leHBvcnRzLCB7XG4gIHVud3JhcEV2ZW50OiAoKSA9PiB1bndyYXBFdmVudDIsXG4gIHVud3JhcE1hbnlFdmVudHM6ICgpID0+IHVud3JhcE1hbnlFdmVudHMyLFxuICB3cmFwRXZlbnQ6ICgpID0+IHdyYXBFdmVudDIsXG4gIHdyYXBNYW55RXZlbnRzOiAoKSA9PiB3cmFwTWFueUV2ZW50czJcbn0pO1xuXG4vLyBuaXA1OS50c1xudmFyIG5pcDU5X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDU5X2V4cG9ydHMsIHtcbiAgY3JlYXRlUnVtb3I6ICgpID0+IGNyZWF0ZVJ1bW9yLFxuICBjcmVhdGVTZWFsOiAoKSA9PiBjcmVhdGVTZWFsLFxuICBjcmVhdGVXcmFwOiAoKSA9PiBjcmVhdGVXcmFwLFxuICB1bndyYXBFdmVudDogKCkgPT4gdW53cmFwRXZlbnQsXG4gIHVud3JhcE1hbnlFdmVudHM6ICgpID0+IHVud3JhcE1hbnlFdmVudHMsXG4gIHdyYXBFdmVudDogKCkgPT4gd3JhcEV2ZW50LFxuICB3cmFwTWFueUV2ZW50czogKCkgPT4gd3JhcE1hbnlFdmVudHNcbn0pO1xuXG4vLyBuaXA0NC50c1xudmFyIG5pcDQ0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDQ0X2V4cG9ydHMsIHtcbiAgZGVjcnlwdDogKCkgPT4gZGVjcnlwdDIsXG4gIGVuY3J5cHQ6ICgpID0+IGVuY3J5cHQyLFxuICBnZXRDb252ZXJzYXRpb25LZXk6ICgpID0+IGdldENvbnZlcnNhdGlvbktleSxcbiAgdjI6ICgpID0+IHYyXG59KTtcbmltcG9ydCB7IGNoYWNoYTIwIH0gZnJvbSBcIkBub2JsZS9jaXBoZXJzL2NoYWNoYVwiO1xuaW1wb3J0IHsgZXF1YWxCeXRlcyB9IGZyb20gXCJAbm9ibGUvY2lwaGVycy91dGlsc1wiO1xuaW1wb3J0IHsgc2VjcDI1NmsxIGFzIHNlY3AyNTZrMTIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGV4dHJhY3QgYXMgaGtkZl9leHRyYWN0LCBleHBhbmQgYXMgaGtkZl9leHBhbmQgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9oa2RmXCI7XG5pbXBvcnQgeyBobWFjIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvaG1hY1wiO1xuaW1wb3J0IHsgc2hhMjU2IGFzIHNoYTI1NjMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcbmltcG9ydCB7IGNvbmNhdEJ5dGVzIGFzIGNvbmNhdEJ5dGVzMiwgcmFuZG9tQnl0ZXMgYXMgcmFuZG9tQnl0ZXMyIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IGJhc2U2NCBhcyBiYXNlNjQyIH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG52YXIgbWluUGxhaW50ZXh0U2l6ZSA9IDE7XG52YXIgbWF4UGxhaW50ZXh0U2l6ZSA9IDY1NTM1O1xuZnVuY3Rpb24gZ2V0Q29udmVyc2F0aW9uS2V5KHByaXZrZXlBLCBwdWJrZXlCKSB7XG4gIGNvbnN0IHNoYXJlZFggPSBzZWNwMjU2azEyLmdldFNoYXJlZFNlY3JldChwcml2a2V5QSwgXCIwMlwiICsgcHVia2V5Qikuc3ViYXJyYXkoMSwgMzMpO1xuICByZXR1cm4gaGtkZl9leHRyYWN0KHNoYTI1NjMsIHNoYXJlZFgsIFwibmlwNDQtdjJcIik7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlS2V5cyhjb252ZXJzYXRpb25LZXksIG5vbmNlKSB7XG4gIGNvbnN0IGtleXMgPSBoa2RmX2V4cGFuZChzaGEyNTYzLCBjb252ZXJzYXRpb25LZXksIG5vbmNlLCA3Nik7XG4gIHJldHVybiB7XG4gICAgY2hhY2hhX2tleToga2V5cy5zdWJhcnJheSgwLCAzMiksXG4gICAgY2hhY2hhX25vbmNlOiBrZXlzLnN1YmFycmF5KDMyLCA0NCksXG4gICAgaG1hY19rZXk6IGtleXMuc3ViYXJyYXkoNDQsIDc2KVxuICB9O1xufVxuZnVuY3Rpb24gY2FsY1BhZGRlZExlbihsZW4pIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihsZW4pIHx8IGxlbiA8IDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgaWYgKGxlbiA8PSAzMilcbiAgICByZXR1cm4gMzI7XG4gIGNvbnN0IG5leHRQb3dlciA9IDEgPDwgTWF0aC5mbG9vcihNYXRoLmxvZzIobGVuIC0gMSkpICsgMTtcbiAgY29uc3QgY2h1bmsgPSBuZXh0UG93ZXIgPD0gMjU2ID8gMzIgOiBuZXh0UG93ZXIgLyA4O1xuICByZXR1cm4gY2h1bmsgKiAoTWF0aC5mbG9vcigobGVuIC0gMSkgLyBjaHVuaykgKyAxKTtcbn1cbmZ1bmN0aW9uIHdyaXRlVTE2QkUobnVtKSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobnVtKSB8fCBudW0gPCBtaW5QbGFpbnRleHRTaXplIHx8IG51bSA+IG1heFBsYWludGV4dFNpemUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwbGFpbnRleHQgc2l6ZTogbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDY1NTM1IGJ5dGVzXCIpO1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgyKTtcbiAgbmV3IERhdGFWaWV3KGFyci5idWZmZXIpLnNldFVpbnQxNigwLCBudW0sIGZhbHNlKTtcbiAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIHBhZChwbGFpbnRleHQpIHtcbiAgY29uc3QgdW5wYWRkZWQgPSB1dGY4RW5jb2Rlci5lbmNvZGUocGxhaW50ZXh0KTtcbiAgY29uc3QgdW5wYWRkZWRMZW4gPSB1bnBhZGRlZC5sZW5ndGg7XG4gIGNvbnN0IHByZWZpeCA9IHdyaXRlVTE2QkUodW5wYWRkZWRMZW4pO1xuICBjb25zdCBzdWZmaXggPSBuZXcgVWludDhBcnJheShjYWxjUGFkZGVkTGVuKHVucGFkZGVkTGVuKSAtIHVucGFkZGVkTGVuKTtcbiAgcmV0dXJuIGNvbmNhdEJ5dGVzMihwcmVmaXgsIHVucGFkZGVkLCBzdWZmaXgpO1xufVxuZnVuY3Rpb24gdW5wYWQocGFkZGVkKSB7XG4gIGNvbnN0IHVucGFkZGVkTGVuID0gbmV3IERhdGFWaWV3KHBhZGRlZC5idWZmZXIpLmdldFVpbnQxNigwKTtcbiAgY29uc3QgdW5wYWRkZWQgPSBwYWRkZWQuc3ViYXJyYXkoMiwgMiArIHVucGFkZGVkTGVuKTtcbiAgaWYgKHVucGFkZGVkTGVuIDwgbWluUGxhaW50ZXh0U2l6ZSB8fCB1bnBhZGRlZExlbiA+IG1heFBsYWludGV4dFNpemUgfHwgdW5wYWRkZWQubGVuZ3RoICE9PSB1bnBhZGRlZExlbiB8fCBwYWRkZWQubGVuZ3RoICE9PSAyICsgY2FsY1BhZGRlZExlbih1bnBhZGRlZExlbikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYWRkaW5nXCIpO1xuICByZXR1cm4gdXRmOERlY29kZXIuZGVjb2RlKHVucGFkZGVkKTtcbn1cbmZ1bmN0aW9uIGhtYWNBYWQoa2V5LCBtZXNzYWdlLCBhYWQpIHtcbiAgaWYgKGFhZC5sZW5ndGggIT09IDMyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkFBRCBhc3NvY2lhdGVkIGRhdGEgbXVzdCBiZSAzMiBieXRlc1wiKTtcbiAgY29uc3QgY29tYmluZWQgPSBjb25jYXRCeXRlczIoYWFkLCBtZXNzYWdlKTtcbiAgcmV0dXJuIGhtYWMoc2hhMjU2Mywga2V5LCBjb21iaW5lZCk7XG59XG5mdW5jdGlvbiBkZWNvZGVQYXlsb2FkKHBheWxvYWQpIHtcbiAgaWYgKHR5cGVvZiBwYXlsb2FkICE9PSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcInBheWxvYWQgbXVzdCBiZSBhIHZhbGlkIHN0cmluZ1wiKTtcbiAgY29uc3QgcGxlbiA9IHBheWxvYWQubGVuZ3RoO1xuICBpZiAocGxlbiA8IDEzMiB8fCBwbGVuID4gODc0NzIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXlsb2FkIGxlbmd0aDogXCIgKyBwbGVuKTtcbiAgaWYgKHBheWxvYWRbMF0gPT09IFwiI1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gZW5jcnlwdGlvbiB2ZXJzaW9uXCIpO1xuICBsZXQgZGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhID0gYmFzZTY0Mi5kZWNvZGUocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiYXNlNjQ6IFwiICsgZXJyb3IubWVzc2FnZSk7XG4gIH1cbiAgY29uc3QgZGxlbiA9IGRhdGEubGVuZ3RoO1xuICBpZiAoZGxlbiA8IDk5IHx8IGRsZW4gPiA2NTYwMylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGRhdGEgbGVuZ3RoOiBcIiArIGRsZW4pO1xuICBjb25zdCB2ZXJzID0gZGF0YVswXTtcbiAgaWYgKHZlcnMgIT09IDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBlbmNyeXB0aW9uIHZlcnNpb24gXCIgKyB2ZXJzKTtcbiAgcmV0dXJuIHtcbiAgICBub25jZTogZGF0YS5zdWJhcnJheSgxLCAzMyksXG4gICAgY2lwaGVydGV4dDogZGF0YS5zdWJhcnJheSgzMywgLTMyKSxcbiAgICBtYWM6IGRhdGEuc3ViYXJyYXkoLTMyKVxuICB9O1xufVxuZnVuY3Rpb24gZW5jcnlwdDIocGxhaW50ZXh0LCBjb252ZXJzYXRpb25LZXksIG5vbmNlID0gcmFuZG9tQnl0ZXMyKDMyKSkge1xuICBjb25zdCB7IGNoYWNoYV9rZXksIGNoYWNoYV9ub25jZSwgaG1hY19rZXkgfSA9IGdldE1lc3NhZ2VLZXlzKGNvbnZlcnNhdGlvbktleSwgbm9uY2UpO1xuICBjb25zdCBwYWRkZWQgPSBwYWQocGxhaW50ZXh0KTtcbiAgY29uc3QgY2lwaGVydGV4dCA9IGNoYWNoYTIwKGNoYWNoYV9rZXksIGNoYWNoYV9ub25jZSwgcGFkZGVkKTtcbiAgY29uc3QgbWFjID0gaG1hY0FhZChobWFjX2tleSwgY2lwaGVydGV4dCwgbm9uY2UpO1xuICByZXR1cm4gYmFzZTY0Mi5lbmNvZGUoY29uY2F0Qnl0ZXMyKG5ldyBVaW50OEFycmF5KFsyXSksIG5vbmNlLCBjaXBoZXJ0ZXh0LCBtYWMpKTtcbn1cbmZ1bmN0aW9uIGRlY3J5cHQyKHBheWxvYWQsIGNvbnZlcnNhdGlvbktleSkge1xuICBjb25zdCB7IG5vbmNlLCBjaXBoZXJ0ZXh0LCBtYWMgfSA9IGRlY29kZVBheWxvYWQocGF5bG9hZCk7XG4gIGNvbnN0IHsgY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBobWFjX2tleSB9ID0gZ2V0TWVzc2FnZUtleXMoY29udmVyc2F0aW9uS2V5LCBub25jZSk7XG4gIGNvbnN0IGNhbGN1bGF0ZWRNYWMgPSBobWFjQWFkKGhtYWNfa2V5LCBjaXBoZXJ0ZXh0LCBub25jZSk7XG4gIGlmICghZXF1YWxCeXRlcyhjYWxjdWxhdGVkTWFjLCBtYWMpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTUFDXCIpO1xuICBjb25zdCBwYWRkZWQgPSBjaGFjaGEyMChjaGFjaGFfa2V5LCBjaGFjaGFfbm9uY2UsIGNpcGhlcnRleHQpO1xuICByZXR1cm4gdW5wYWQocGFkZGVkKTtcbn1cbnZhciB2MiA9IHtcbiAgdXRpbHM6IHtcbiAgICBnZXRDb252ZXJzYXRpb25LZXksXG4gICAgY2FsY1BhZGRlZExlblxuICB9LFxuICBlbmNyeXB0OiBlbmNyeXB0MixcbiAgZGVjcnlwdDogZGVjcnlwdDJcbn07XG5cbi8vIG5pcDU5LnRzXG52YXIgVFdPX0RBWVMgPSAyICogMjQgKiA2MCAqIDYwO1xudmFyIG5vdyA9ICgpID0+IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDFlMyk7XG52YXIgcmFuZG9tTm93ID0gKCkgPT4gTWF0aC5yb3VuZChub3coKSAtIE1hdGgucmFuZG9tKCkgKiBUV09fREFZUyk7XG52YXIgbmlwNDRDb252ZXJzYXRpb25LZXkgPSAocHJpdmF0ZUtleSwgcHVibGljS2V5KSA9PiBnZXRDb252ZXJzYXRpb25LZXkocHJpdmF0ZUtleSwgcHVibGljS2V5KTtcbnZhciBuaXA0NEVuY3J5cHQgPSAoZGF0YSwgcHJpdmF0ZUtleSwgcHVibGljS2V5KSA9PiBlbmNyeXB0MihKU09OLnN0cmluZ2lmeShkYXRhKSwgbmlwNDRDb252ZXJzYXRpb25LZXkocHJpdmF0ZUtleSwgcHVibGljS2V5KSk7XG52YXIgbmlwNDREZWNyeXB0ID0gKGRhdGEsIHByaXZhdGVLZXkpID0+IEpTT04ucGFyc2UoZGVjcnlwdDIoZGF0YS5jb250ZW50LCBuaXA0NENvbnZlcnNhdGlvbktleShwcml2YXRlS2V5LCBkYXRhLnB1YmtleSkpKTtcbmZ1bmN0aW9uIGNyZWF0ZVJ1bW9yKGV2ZW50LCBwcml2YXRlS2V5KSB7XG4gIGNvbnN0IHJ1bW9yID0ge1xuICAgIGNyZWF0ZWRfYXQ6IG5vdygpLFxuICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgdGFnczogW10sXG4gICAgLi4uZXZlbnQsXG4gICAgcHVia2V5OiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSlcbiAgfTtcbiAgcnVtb3IuaWQgPSBnZXRFdmVudEhhc2gocnVtb3IpO1xuICByZXR1cm4gcnVtb3I7XG59XG5mdW5jdGlvbiBjcmVhdGVTZWFsKHJ1bW9yLCBwcml2YXRlS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpIHtcbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogU2VhbCxcbiAgICAgIGNvbnRlbnQ6IG5pcDQ0RW5jcnlwdChydW1vciwgcHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KSxcbiAgICAgIGNyZWF0ZWRfYXQ6IHJhbmRvbU5vdygpLFxuICAgICAgdGFnczogW11cbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdyYXAoc2VhbCwgcmVjaXBpZW50UHVibGljS2V5KSB7XG4gIGNvbnN0IHJhbmRvbUtleSA9IGdlbmVyYXRlU2VjcmV0S2V5KCk7XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IEdpZnRXcmFwLFxuICAgICAgY29udGVudDogbmlwNDRFbmNyeXB0KHNlYWwsIHJhbmRvbUtleSwgcmVjaXBpZW50UHVibGljS2V5KSxcbiAgICAgIGNyZWF0ZWRfYXQ6IHJhbmRvbU5vdygpLFxuICAgICAgdGFnczogW1tcInBcIiwgcmVjaXBpZW50UHVibGljS2V5XV1cbiAgICB9LFxuICAgIHJhbmRvbUtleVxuICApO1xufVxuZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50LCBzZW5kZXJQcml2YXRlS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpIHtcbiAgY29uc3QgcnVtb3IgPSBjcmVhdGVSdW1vcihldmVudCwgc2VuZGVyUHJpdmF0ZUtleSk7XG4gIGNvbnN0IHNlYWwgPSBjcmVhdGVTZWFsKHJ1bW9yLCBzZW5kZXJQcml2YXRlS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpO1xuICByZXR1cm4gY3JlYXRlV3JhcChzZWFsLCByZWNpcGllbnRQdWJsaWNLZXkpO1xufVxuZnVuY3Rpb24gd3JhcE1hbnlFdmVudHMoZXZlbnQsIHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudHNQdWJsaWNLZXlzKSB7XG4gIGlmICghcmVjaXBpZW50c1B1YmxpY0tleXMgfHwgcmVjaXBpZW50c1B1YmxpY0tleXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIHJlY2lwaWVudCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgY29uc3Qgc2VuZGVyUHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHNlbmRlclByaXZhdGVLZXkpO1xuICBjb25zdCB3cmFwcGVkcyA9IFt3cmFwRXZlbnQoZXZlbnQsIHNlbmRlclByaXZhdGVLZXksIHNlbmRlclB1YmxpY0tleSldO1xuICByZWNpcGllbnRzUHVibGljS2V5cy5mb3JFYWNoKChyZWNpcGllbnRQdWJsaWNLZXkpID0+IHtcbiAgICB3cmFwcGVkcy5wdXNoKHdyYXBFdmVudChldmVudCwgc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KSk7XG4gIH0pO1xuICByZXR1cm4gd3JhcHBlZHM7XG59XG5mdW5jdGlvbiB1bndyYXBFdmVudCh3cmFwLCByZWNpcGllbnRQcml2YXRlS2V5KSB7XG4gIGNvbnN0IHVud3JhcHBlZFNlYWwgPSBuaXA0NERlY3J5cHQod3JhcCwgcmVjaXBpZW50UHJpdmF0ZUtleSk7XG4gIHJldHVybiBuaXA0NERlY3J5cHQodW53cmFwcGVkU2VhbCwgcmVjaXBpZW50UHJpdmF0ZUtleSk7XG59XG5mdW5jdGlvbiB1bndyYXBNYW55RXZlbnRzKHdyYXBwZWRFdmVudHMsIHJlY2lwaWVudFByaXZhdGVLZXkpIHtcbiAgbGV0IHVud3JhcHBlZEV2ZW50cyA9IFtdO1xuICB3cmFwcGVkRXZlbnRzLmZvckVhY2goKGUpID0+IHtcbiAgICB1bndyYXBwZWRFdmVudHMucHVzaCh1bndyYXBFdmVudChlLCByZWNpcGllbnRQcml2YXRlS2V5KSk7XG4gIH0pO1xuICB1bndyYXBwZWRFdmVudHMuc29ydCgoYSwgYikgPT4gYS5jcmVhdGVkX2F0IC0gYi5jcmVhdGVkX2F0KTtcbiAgcmV0dXJuIHVud3JhcHBlZEV2ZW50cztcbn1cblxuLy8gbmlwMTcudHNcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50KHJlY2lwaWVudHMsIG1lc3NhZ2UsIGNvbnZlcnNhdGlvblRpdGxlLCByZXBseVRvKSB7XG4gIGNvbnN0IGJhc2VFdmVudCA9IHtcbiAgICBjcmVhdGVkX2F0OiBNYXRoLmNlaWwoRGF0ZS5ub3coKSAvIDFlMyksXG4gICAga2luZDogUHJpdmF0ZURpcmVjdE1lc3NhZ2UsXG4gICAgdGFnczogW10sXG4gICAgY29udGVudDogbWVzc2FnZVxuICB9O1xuICBjb25zdCByZWNpcGllbnRzQXJyYXkgPSBBcnJheS5pc0FycmF5KHJlY2lwaWVudHMpID8gcmVjaXBpZW50cyA6IFtyZWNpcGllbnRzXTtcbiAgcmVjaXBpZW50c0FycmF5LmZvckVhY2goKHsgcHVibGljS2V5LCByZWxheVVybCB9KSA9PiB7XG4gICAgYmFzZUV2ZW50LnRhZ3MucHVzaChyZWxheVVybCA/IFtcInBcIiwgcHVibGljS2V5LCByZWxheVVybF0gOiBbXCJwXCIsIHB1YmxpY0tleV0pO1xuICB9KTtcbiAgaWYgKHJlcGx5VG8pIHtcbiAgICBiYXNlRXZlbnQudGFncy5wdXNoKFtcImVcIiwgcmVwbHlUby5ldmVudElkLCByZXBseVRvLnJlbGF5VXJsIHx8IFwiXCIsIFwicmVwbHlcIl0pO1xuICB9XG4gIGlmIChjb252ZXJzYXRpb25UaXRsZSkge1xuICAgIGJhc2VFdmVudC50YWdzLnB1c2goW1wic3ViamVjdFwiLCBjb252ZXJzYXRpb25UaXRsZV0pO1xuICB9XG4gIHJldHVybiBiYXNlRXZlbnQ7XG59XG5mdW5jdGlvbiB3cmFwRXZlbnQyKHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudCwgbWVzc2FnZSwgY29udmVyc2F0aW9uVGl0bGUsIHJlcGx5VG8pIHtcbiAgY29uc3QgZXZlbnQgPSBjcmVhdGVFdmVudChyZWNpcGllbnQsIG1lc3NhZ2UsIGNvbnZlcnNhdGlvblRpdGxlLCByZXBseVRvKTtcbiAgcmV0dXJuIHdyYXBFdmVudChldmVudCwgc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50LnB1YmxpY0tleSk7XG59XG5mdW5jdGlvbiB3cmFwTWFueUV2ZW50czIoc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50cywgbWVzc2FnZSwgY29udmVyc2F0aW9uVGl0bGUsIHJlcGx5VG8pIHtcbiAgaWYgKCFyZWNpcGllbnRzIHx8IHJlY2lwaWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIHJlY2lwaWVudCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgY29uc3Qgc2VuZGVyUHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHNlbmRlclByaXZhdGVLZXkpO1xuICByZXR1cm4gW3sgcHVibGljS2V5OiBzZW5kZXJQdWJsaWNLZXkgfSwgLi4ucmVjaXBpZW50c10ubWFwKFxuICAgIChyZWNpcGllbnQpID0+IHdyYXBFdmVudDIoc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50LCBtZXNzYWdlLCBjb252ZXJzYXRpb25UaXRsZSwgcmVwbHlUbylcbiAgKTtcbn1cbnZhciB1bndyYXBFdmVudDIgPSB1bndyYXBFdmVudDtcbnZhciB1bndyYXBNYW55RXZlbnRzMiA9IHVud3JhcE1hbnlFdmVudHM7XG5cbi8vIG5pcDE4LnRzXG52YXIgbmlwMThfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMThfZXhwb3J0cywge1xuICBmaW5pc2hSZXBvc3RFdmVudDogKCkgPT4gZmluaXNoUmVwb3N0RXZlbnQsXG4gIGdldFJlcG9zdGVkRXZlbnQ6ICgpID0+IGdldFJlcG9zdGVkRXZlbnQsXG4gIGdldFJlcG9zdGVkRXZlbnRQb2ludGVyOiAoKSA9PiBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlclxufSk7XG5mdW5jdGlvbiBmaW5pc2hSZXBvc3RFdmVudCh0LCByZXBvc3RlZCwgcmVsYXlVcmwsIHByaXZhdGVLZXkpIHtcbiAgbGV0IGtpbmQ7XG4gIGNvbnN0IHRhZ3MgPSBbLi4udC50YWdzID8/IFtdLCBbXCJlXCIsIHJlcG9zdGVkLmlkLCByZWxheVVybF0sIFtcInBcIiwgcmVwb3N0ZWQucHVia2V5XV07XG4gIGlmIChyZXBvc3RlZC5raW5kID09PSBTaG9ydFRleHROb3RlKSB7XG4gICAga2luZCA9IFJlcG9zdDtcbiAgfSBlbHNlIHtcbiAgICBraW5kID0gR2VuZXJpY1JlcG9zdDtcbiAgICB0YWdzLnB1c2goW1wia1wiLCBTdHJpbmcocmVwb3N0ZWQua2luZCldKTtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kLFxuICAgICAgdGFncyxcbiAgICAgIGNvbnRlbnQ6IHQuY29udGVudCA9PT0gXCJcIiB8fCByZXBvc3RlZC50YWdzPy5maW5kKCh0YWcpID0+IHRhZ1swXSA9PT0gXCItXCIpID8gXCJcIiA6IEpTT04uc3RyaW5naWZ5KHJlcG9zdGVkKSxcbiAgICAgIGNyZWF0ZWRfYXQ6IHQuY3JlYXRlZF9hdFxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufVxuZnVuY3Rpb24gZ2V0UmVwb3N0ZWRFdmVudFBvaW50ZXIoZXZlbnQpIHtcbiAgaWYgKCFbUmVwb3N0LCBHZW5lcmljUmVwb3N0XS5pbmNsdWRlcyhldmVudC5raW5kKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IGxhc3RFVGFnO1xuICBsZXQgbGFzdFBUYWc7XG4gIGZvciAobGV0IGkyID0gZXZlbnQudGFncy5sZW5ndGggLSAxOyBpMiA+PSAwICYmIChsYXN0RVRhZyA9PT0gdm9pZCAwIHx8IGxhc3RQVGFnID09PSB2b2lkIDApOyBpMi0tKSB7XG4gICAgY29uc3QgdGFnID0gZXZlbnQudGFnc1tpMl07XG4gICAgaWYgKHRhZy5sZW5ndGggPj0gMikge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgJiYgbGFzdEVUYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBsYXN0RVRhZyA9IHRhZztcbiAgICAgIH0gZWxzZSBpZiAodGFnWzBdID09PSBcInBcIiAmJiBsYXN0UFRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxhc3RQVGFnID0gdGFnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobGFzdEVUYWcgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpZDogbGFzdEVUYWdbMV0sXG4gICAgcmVsYXlzOiBbbGFzdEVUYWdbMl0sIGxhc3RQVGFnPy5bMl1dLmZpbHRlcigoeCkgPT4gdHlwZW9mIHggPT09IFwic3RyaW5nXCIpLFxuICAgIGF1dGhvcjogbGFzdFBUYWc/LlsxXVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVwb3N0ZWRFdmVudChldmVudCwgeyBza2lwVmVyaWZpY2F0aW9uIH0gPSB7fSkge1xuICBjb25zdCBwb2ludGVyID0gZ2V0UmVwb3N0ZWRFdmVudFBvaW50ZXIoZXZlbnQpO1xuICBpZiAocG9pbnRlciA9PT0gdm9pZCAwIHx8IGV2ZW50LmNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCByZXBvc3RlZEV2ZW50O1xuICB0cnkge1xuICAgIHJlcG9zdGVkRXZlbnQgPSBKU09OLnBhcnNlKGV2ZW50LmNvbnRlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHJlcG9zdGVkRXZlbnQuaWQgIT09IHBvaW50ZXIuaWQpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmICghc2tpcFZlcmlmaWNhdGlvbiAmJiAhdmVyaWZ5RXZlbnQocmVwb3N0ZWRFdmVudCkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiByZXBvc3RlZEV2ZW50O1xufVxuXG4vLyBuaXAyMS50c1xudmFyIG5pcDIxX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDIxX2V4cG9ydHMsIHtcbiAgTk9TVFJfVVJJX1JFR0VYOiAoKSA9PiBOT1NUUl9VUklfUkVHRVgsXG4gIHBhcnNlOiAoKSA9PiBwYXJzZTIsXG4gIHRlc3Q6ICgpID0+IHRlc3Rcbn0pO1xudmFyIE5PU1RSX1VSSV9SRUdFWCA9IG5ldyBSZWdFeHAoYG5vc3RyOigke0JFQ0gzMl9SRUdFWC5zb3VyY2V9KWApO1xuZnVuY3Rpb24gdGVzdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIG5ldyBSZWdFeHAoYF4ke05PU1RSX1VSSV9SRUdFWC5zb3VyY2V9JGApLnRlc3QodmFsdWUpO1xufVxuZnVuY3Rpb24gcGFyc2UyKHVyaSkge1xuICBjb25zdCBtYXRjaCA9IHVyaS5tYXRjaChuZXcgUmVnRXhwKGBeJHtOT1NUUl9VUklfUkVHRVguc291cmNlfSRgKSk7XG4gIGlmICghbWF0Y2gpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE5vc3RyIFVSSTogJHt1cml9YCk7XG4gIHJldHVybiB7XG4gICAgdXJpOiBtYXRjaFswXSxcbiAgICB2YWx1ZTogbWF0Y2hbMV0sXG4gICAgZGVjb2RlZDogZGVjb2RlKG1hdGNoWzFdKVxuICB9O1xufVxuXG4vLyBuaXAyNS50c1xudmFyIG5pcDI1X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDI1X2V4cG9ydHMsIHtcbiAgZmluaXNoUmVhY3Rpb25FdmVudDogKCkgPT4gZmluaXNoUmVhY3Rpb25FdmVudCxcbiAgZ2V0UmVhY3RlZEV2ZW50UG9pbnRlcjogKCkgPT4gZ2V0UmVhY3RlZEV2ZW50UG9pbnRlclxufSk7XG5mdW5jdGlvbiBmaW5pc2hSZWFjdGlvbkV2ZW50KHQsIHJlYWN0ZWQsIHByaXZhdGVLZXkpIHtcbiAgY29uc3QgaW5oZXJpdGVkVGFncyA9IHJlYWN0ZWQudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnLmxlbmd0aCA+PSAyICYmICh0YWdbMF0gPT09IFwiZVwiIHx8IHRhZ1swXSA9PT0gXCJwXCIpKTtcbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAgLi4udCxcbiAgICAgIGtpbmQ6IFJlYWN0aW9uLFxuICAgICAgdGFnczogWy4uLnQudGFncyA/PyBbXSwgLi4uaW5oZXJpdGVkVGFncywgW1wiZVwiLCByZWFjdGVkLmlkXSwgW1wicFwiLCByZWFjdGVkLnB1YmtleV1dLFxuICAgICAgY29udGVudDogdC5jb250ZW50ID8/IFwiK1wiXG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59XG5mdW5jdGlvbiBnZXRSZWFjdGVkRXZlbnRQb2ludGVyKGV2ZW50KSB7XG4gIGlmIChldmVudC5raW5kICE9PSBSZWFjdGlvbikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IGxhc3RFVGFnO1xuICBsZXQgbGFzdFBUYWc7XG4gIGZvciAobGV0IGkyID0gZXZlbnQudGFncy5sZW5ndGggLSAxOyBpMiA+PSAwICYmIChsYXN0RVRhZyA9PT0gdm9pZCAwIHx8IGxhc3RQVGFnID09PSB2b2lkIDApOyBpMi0tKSB7XG4gICAgY29uc3QgdGFnID0gZXZlbnQudGFnc1tpMl07XG4gICAgaWYgKHRhZy5sZW5ndGggPj0gMikge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgJiYgbGFzdEVUYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBsYXN0RVRhZyA9IHRhZztcbiAgICAgIH0gZWxzZSBpZiAodGFnWzBdID09PSBcInBcIiAmJiBsYXN0UFRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxhc3RQVGFnID0gdGFnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobGFzdEVUYWcgPT09IHZvaWQgMCB8fCBsYXN0UFRhZyA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlkOiBsYXN0RVRhZ1sxXSxcbiAgICByZWxheXM6IFtsYXN0RVRhZ1syXSwgbGFzdFBUYWdbMl1dLmZpbHRlcigoeCkgPT4geCAhPT0gdm9pZCAwKSxcbiAgICBhdXRob3I6IGxhc3RQVGFnWzFdXG4gIH07XG59XG5cbi8vIG5pcDI3LnRzXG52YXIgbmlwMjdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMjdfZXhwb3J0cywge1xuICBwYXJzZTogKCkgPT4gcGFyc2UzXG59KTtcbnZhciBub0NoYXJhY3RlciA9IC9cXFcvbTtcbnZhciBub1VSTENoYXJhY3RlciA9IC9cXFcgfFxcVyR8JHwsfCAvbTtcbmZ1bmN0aW9uKiBwYXJzZTMoY29udGVudCkge1xuICBjb25zdCBtYXggPSBjb250ZW50Lmxlbmd0aDtcbiAgbGV0IHByZXZJbmRleCA9IDA7XG4gIGxldCBpbmRleCA9IDA7XG4gIHdoaWxlIChpbmRleCA8IG1heCkge1xuICAgIGxldCB1ID0gY29udGVudC5pbmRleE9mKFwiOlwiLCBpbmRleCk7XG4gICAgaWYgKHUgPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGNvbnRlbnQuc3Vic3RyaW5nKHUgLSA1LCB1KSA9PT0gXCJub3N0clwiKSB7XG4gICAgICBjb25zdCBtID0gY29udGVudC5zdWJzdHJpbmcodSArIDYwKS5tYXRjaChub0NoYXJhY3Rlcik7XG4gICAgICBjb25zdCBlbmQgPSBtID8gdSArIDYwICsgbS5pbmRleCA6IG1heDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBwb2ludGVyO1xuICAgICAgICBsZXQgeyBkYXRhLCB0eXBlIH0gPSBkZWNvZGUoY29udGVudC5zdWJzdHJpbmcodSArIDEsIGVuZCkpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwibnB1YlwiOlxuICAgICAgICAgICAgcG9pbnRlciA9IHsgcHVia2V5OiBkYXRhIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibnNlY1wiOlxuICAgICAgICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICAgICAgICBpbmRleCA9IGVuZCArIDE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcG9pbnRlciA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gdSAtIDUpIHtcbiAgICAgICAgICB5aWVsZCB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBjb250ZW50LnN1YnN0cmluZyhwcmV2SW5kZXgsIHUgLSA1KSB9O1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHsgdHlwZTogXCJyZWZlcmVuY2VcIiwgcG9pbnRlciB9O1xuICAgICAgICBpbmRleCA9IGVuZDtcbiAgICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICBpbmRleCA9IHUgKyAxO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRlbnQuc3Vic3RyaW5nKHUgLSA1LCB1KSA9PT0gXCJodHRwc1wiIHx8IGNvbnRlbnQuc3Vic3RyaW5nKHUgLSA0LCB1KSA9PT0gXCJodHRwXCIpIHtcbiAgICAgIGNvbnN0IG0gPSBjb250ZW50LnN1YnN0cmluZyh1ICsgNCkubWF0Y2gobm9VUkxDaGFyYWN0ZXIpO1xuICAgICAgY29uc3QgZW5kID0gbSA/IHUgKyA0ICsgbS5pbmRleCA6IG1heDtcbiAgICAgIGNvbnN0IHByZWZpeExlbiA9IGNvbnRlbnRbdSAtIDFdID09PSBcInNcIiA/IDUgOiA0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHVybCA9IG5ldyBVUkwoY29udGVudC5zdWJzdHJpbmcodSAtIHByZWZpeExlbiwgZW5kKSk7XG4gICAgICAgIGlmICh1cmwuaG9zdG5hbWUuaW5kZXhPZihcIi5cIikgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1cmxcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gdSAtIHByZWZpeExlbikge1xuICAgICAgICAgIHlpZWxkIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGNvbnRlbnQuc3Vic3RyaW5nKHByZXZJbmRleCwgdSAtIHByZWZpeExlbikgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLnBuZ1wiKSB8fCB1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIuanBnXCIpIHx8IHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi5qcGVnXCIpIHx8IHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi5naWZcIikgfHwgdXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLndlYnBcIikpIHtcbiAgICAgICAgICB5aWVsZCB7IHR5cGU6IFwiaW1hZ2VcIiwgdXJsOiB1cmwudG9TdHJpbmcoKSB9O1xuICAgICAgICAgIGluZGV4ID0gZW5kO1xuICAgICAgICAgIHByZXZJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIubXA0XCIpIHx8IHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi5hdmlcIikgfHwgdXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLndlYm1cIikgfHwgdXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLm1rdlwiKSkge1xuICAgICAgICAgIHlpZWxkIHsgdHlwZTogXCJ2aWRlb1wiLCB1cmw6IHVybC50b1N0cmluZygpIH07XG4gICAgICAgICAgaW5kZXggPSBlbmQ7XG4gICAgICAgICAgcHJldkluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi5tcDNcIikgfHwgdXJsLnBhdGhuYW1lLmVuZHNXaXRoKFwiLmFhY1wiKSB8fCB1cmwucGF0aG5hbWUuZW5kc1dpdGgoXCIub2dnXCIpIHx8IHVybC5wYXRobmFtZS5lbmRzV2l0aChcIi5vcHVzXCIpKSB7XG4gICAgICAgICAgeWllbGQgeyB0eXBlOiBcImF1ZGlvXCIsIHVybDogdXJsLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICBpbmRleCA9IGVuZDtcbiAgICAgICAgICBwcmV2SW5kZXggPSBpbmRleDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB7IHR5cGU6IFwidXJsXCIsIHVybDogdXJsLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgaW5kZXggPSBlbmQ7XG4gICAgICAgIHByZXZJbmRleCA9IGluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgaW5kZXggPSBlbmQgKyAxO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRlbnQuc3Vic3RyaW5nKHUgLSAzLCB1KSA9PT0gXCJ3c3NcIiB8fCBjb250ZW50LnN1YnN0cmluZyh1IC0gMiwgdSkgPT09IFwid3NcIikge1xuICAgICAgY29uc3QgbSA9IGNvbnRlbnQuc3Vic3RyaW5nKHUgKyA0KS5tYXRjaChub1VSTENoYXJhY3Rlcik7XG4gICAgICBjb25zdCBlbmQgPSBtID8gdSArIDQgKyBtLmluZGV4IDogbWF4O1xuICAgICAgY29uc3QgcHJlZml4TGVuID0gY29udGVudFt1IC0gMV0gPT09IFwic1wiID8gMyA6IDI7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChjb250ZW50LnN1YnN0cmluZyh1IC0gcHJlZml4TGVuLCBlbmQpKTtcbiAgICAgICAgaWYgKHVybC5ob3N0bmFtZS5pbmRleE9mKFwiLlwiKSA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHdzIHVybFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkluZGV4ICE9PSB1IC0gcHJlZml4TGVuKSB7XG4gICAgICAgICAgeWllbGQgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudC5zdWJzdHJpbmcocHJldkluZGV4LCB1IC0gcHJlZml4TGVuKSB9O1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHsgdHlwZTogXCJyZWxheVwiLCB1cmw6IHVybC50b1N0cmluZygpIH07XG4gICAgICAgIGluZGV4ID0gZW5kO1xuICAgICAgICBwcmV2SW5kZXggPSBpbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGNhdGNoIChfZXJyKSB7XG4gICAgICAgIGluZGV4ID0gZW5kICsgMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gdSArIDE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHByZXZJbmRleCAhPT0gbWF4KSB7XG4gICAgeWllbGQgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudC5zdWJzdHJpbmcocHJldkluZGV4KSB9O1xuICB9XG59XG5cbi8vIG5pcDI4LnRzXG52YXIgbmlwMjhfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMjhfZXhwb3J0cywge1xuICBjaGFubmVsQ3JlYXRlRXZlbnQ6ICgpID0+IGNoYW5uZWxDcmVhdGVFdmVudCxcbiAgY2hhbm5lbEhpZGVNZXNzYWdlRXZlbnQ6ICgpID0+IGNoYW5uZWxIaWRlTWVzc2FnZUV2ZW50LFxuICBjaGFubmVsTWVzc2FnZUV2ZW50OiAoKSA9PiBjaGFubmVsTWVzc2FnZUV2ZW50LFxuICBjaGFubmVsTWV0YWRhdGFFdmVudDogKCkgPT4gY2hhbm5lbE1ldGFkYXRhRXZlbnQsXG4gIGNoYW5uZWxNdXRlVXNlckV2ZW50OiAoKSA9PiBjaGFubmVsTXV0ZVVzZXJFdmVudFxufSk7XG52YXIgY2hhbm5lbENyZWF0ZUV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsQ3JlYXRpb24sXG4gICAgICB0YWdzOiBbLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn07XG52YXIgY2hhbm5lbE1ldGFkYXRhRXZlbnQgPSAodCwgcHJpdmF0ZUtleSkgPT4ge1xuICBsZXQgY29udGVudDtcbiAgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodC5jb250ZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29udGVudCA9IHQuY29udGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IENoYW5uZWxNZXRhZGF0YSxcbiAgICAgIHRhZ3M6IFtbXCJlXCIsIHQuY2hhbm5lbF9jcmVhdGVfZXZlbnRfaWRdLCAuLi50LnRhZ3MgPz8gW11dLFxuICAgICAgY29udGVudCxcbiAgICAgIGNyZWF0ZWRfYXQ6IHQuY3JlYXRlZF9hdFxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufTtcbnZhciBjaGFubmVsTWVzc2FnZUV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgY29uc3QgdGFncyA9IFtbXCJlXCIsIHQuY2hhbm5lbF9jcmVhdGVfZXZlbnRfaWQsIHQucmVsYXlfdXJsLCBcInJvb3RcIl1dO1xuICBpZiAodC5yZXBseV90b19jaGFubmVsX21lc3NhZ2VfZXZlbnRfaWQpIHtcbiAgICB0YWdzLnB1c2goW1wiZVwiLCB0LnJlcGx5X3RvX2NoYW5uZWxfbWVzc2FnZV9ldmVudF9pZCwgdC5yZWxheV91cmwsIFwicmVwbHlcIl0pO1xuICB9XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IENoYW5uZWxNZXNzYWdlLFxuICAgICAgdGFnczogWy4uLnRhZ3MsIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50OiB0LmNvbnRlbnQsXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn07XG52YXIgY2hhbm5lbEhpZGVNZXNzYWdlRXZlbnQgPSAodCwgcHJpdmF0ZUtleSkgPT4ge1xuICBsZXQgY29udGVudDtcbiAgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodC5jb250ZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29udGVudCA9IHQuY29udGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IENoYW5uZWxIaWRlTWVzc2FnZSxcbiAgICAgIHRhZ3M6IFtbXCJlXCIsIHQuY2hhbm5lbF9tZXNzYWdlX2V2ZW50X2lkXSwgLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn07XG52YXIgY2hhbm5lbE11dGVVc2VyRXZlbnQgPSAodCwgcHJpdmF0ZUtleSkgPT4ge1xuICBsZXQgY29udGVudDtcbiAgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodC5jb250ZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29udGVudCA9IHQuY29udGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IENoYW5uZWxNdXRlVXNlcixcbiAgICAgIHRhZ3M6IFtbXCJwXCIsIHQucHVia2V5X3RvX211dGVdLCAuLi50LnRhZ3MgPz8gW11dLFxuICAgICAgY29udGVudCxcbiAgICAgIGNyZWF0ZWRfYXQ6IHQuY3JlYXRlZF9hdFxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufTtcblxuLy8gbmlwMzAudHNcbnZhciBuaXAzMF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAzMF9leHBvcnRzLCB7XG4gIEVNT0pJX1NIT1JUQ09ERV9SRUdFWDogKCkgPT4gRU1PSklfU0hPUlRDT0RFX1JFR0VYLFxuICBtYXRjaEFsbDogKCkgPT4gbWF0Y2hBbGwsXG4gIHJlZ2V4OiAoKSA9PiByZWdleCxcbiAgcmVwbGFjZUFsbDogKCkgPT4gcmVwbGFjZUFsbFxufSk7XG52YXIgRU1PSklfU0hPUlRDT0RFX1JFR0VYID0gLzooXFx3Kyk6LztcbnZhciByZWdleCA9ICgpID0+IG5ldyBSZWdFeHAoYFxcXFxCJHtFTU9KSV9TSE9SVENPREVfUkVHRVguc291cmNlfVxcXFxCYCwgXCJnXCIpO1xuZnVuY3Rpb24qIG1hdGNoQWxsKGNvbnRlbnQpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2hBbGwocmVnZXgoKSk7XG4gIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBbc2hvcnRjb2RlLCBuYW1lXSA9IG1hdGNoO1xuICAgICAgeWllbGQge1xuICAgICAgICBzaG9ydGNvZGUsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHN0YXJ0OiBtYXRjaC5pbmRleCxcbiAgICAgICAgZW5kOiBtYXRjaC5pbmRleCArIHNob3J0Y29kZS5sZW5ndGhcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlcGxhY2VBbGwoY29udGVudCwgcmVwbGFjZXIpIHtcbiAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUFsbChyZWdleCgpLCAoc2hvcnRjb2RlLCBuYW1lKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VyKHtcbiAgICAgIHNob3J0Y29kZSxcbiAgICAgIG5hbWVcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIG5pcDM5LnRzXG52YXIgbmlwMzlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMzlfZXhwb3J0cywge1xuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uMyxcbiAgdmFsaWRhdGVHaXRodWI6ICgpID0+IHZhbGlkYXRlR2l0aHViXG59KTtcbnZhciBfZmV0Y2gzO1xudHJ5IHtcbiAgX2ZldGNoMyA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiB1c2VGZXRjaEltcGxlbWVudGF0aW9uMyhmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaDMgPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVHaXRodWIocHVia2V5LCB1c2VybmFtZSwgcHJvb2YpIHtcbiAgdHJ5IHtcbiAgICBsZXQgcmVzID0gYXdhaXQgKGF3YWl0IF9mZXRjaDMoYGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLyR7dXNlcm5hbWV9LyR7cHJvb2Z9L3Jhd2ApKS50ZXh0KCk7XG4gICAgcmV0dXJuIHJlcyA9PT0gYFZlcmlmeWluZyB0aGF0IEkgY29udHJvbCB0aGUgZm9sbG93aW5nIE5vc3RyIHB1YmxpYyBrZXk6ICR7cHVia2V5fWA7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gbmlwNDcudHNcbnZhciBuaXA0N19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA0N19leHBvcnRzLCB7XG4gIG1ha2VOd2NSZXF1ZXN0RXZlbnQ6ICgpID0+IG1ha2VOd2NSZXF1ZXN0RXZlbnQsXG4gIHBhcnNlQ29ubmVjdGlvblN0cmluZzogKCkgPT4gcGFyc2VDb25uZWN0aW9uU3RyaW5nXG59KTtcbmZ1bmN0aW9uIHBhcnNlQ29ubmVjdGlvblN0cmluZyhjb25uZWN0aW9uU3RyaW5nKSB7XG4gIGNvbnN0IHsgcGF0aG5hbWUsIHNlYXJjaFBhcmFtcyB9ID0gbmV3IFVSTChjb25uZWN0aW9uU3RyaW5nKTtcbiAgY29uc3QgcHVia2V5ID0gcGF0aG5hbWU7XG4gIGNvbnN0IHJlbGF5ID0gc2VhcmNoUGFyYW1zLmdldChcInJlbGF5XCIpO1xuICBjb25zdCBzZWNyZXQgPSBzZWFyY2hQYXJhbXMuZ2V0KFwic2VjcmV0XCIpO1xuICBpZiAoIXB1YmtleSB8fCAhcmVsYXkgfHwgIXNlY3JldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY29ubmVjdGlvbiBzdHJpbmdcIik7XG4gIH1cbiAgcmV0dXJuIHsgcHVia2V5LCByZWxheSwgc2VjcmV0IH07XG59XG5hc3luYyBmdW5jdGlvbiBtYWtlTndjUmVxdWVzdEV2ZW50KHB1YmtleSwgc2VjcmV0S2V5LCBpbnZvaWNlKSB7XG4gIGNvbnN0IGNvbnRlbnQgPSB7XG4gICAgbWV0aG9kOiBcInBheV9pbnZvaWNlXCIsXG4gICAgcGFyYW1zOiB7XG4gICAgICBpbnZvaWNlXG4gICAgfVxuICB9O1xuICBjb25zdCBlbmNyeXB0ZWRDb250ZW50ID0gYXdhaXQgZW5jcnlwdChzZWNyZXRLZXksIHB1YmtleSwgSlNPTi5zdHJpbmdpZnkoY29udGVudCkpO1xuICBjb25zdCBldmVudFRlbXBsYXRlID0ge1xuICAgIGtpbmQ6IE5XQ1dhbGxldFJlcXVlc3QsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMWUzKSxcbiAgICBjb250ZW50OiBlbmNyeXB0ZWRDb250ZW50LFxuICAgIHRhZ3M6IFtbXCJwXCIsIHB1YmtleV1dXG4gIH07XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KGV2ZW50VGVtcGxhdGUsIHNlY3JldEtleSk7XG59XG5cbi8vIG5pcDU0LnRzXG52YXIgbmlwNTRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNTRfZXhwb3J0cywge1xuICBub3JtYWxpemVJZGVudGlmaWVyOiAoKSA9PiBub3JtYWxpemVJZGVudGlmaWVyXG59KTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUlkZW50aWZpZXIobmFtZSkge1xuICBuYW1lID0gbmFtZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgbmFtZSA9IG5hbWUubm9ybWFsaXplKFwiTkZLQ1wiKTtcbiAgcmV0dXJuIEFycmF5LmZyb20obmFtZSkubWFwKChjaGFyKSA9PiB7XG4gICAgaWYgKC9cXHB7TGV0dGVyfS91LnRlc3QoY2hhcikgfHwgL1xccHtOdW1iZXJ9L3UudGVzdChjaGFyKSkge1xuICAgICAgcmV0dXJuIGNoYXI7XG4gICAgfVxuICAgIHJldHVybiBcIi1cIjtcbiAgfSkuam9pbihcIlwiKTtcbn1cblxuLy8gbmlwNTcudHNcbnZhciBuaXA1N19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA1N19leHBvcnRzLCB7XG4gIGdldFphcEVuZHBvaW50OiAoKSA9PiBnZXRaYXBFbmRwb2ludCxcbiAgbWFrZVphcFJlY2VpcHQ6ICgpID0+IG1ha2VaYXBSZWNlaXB0LFxuICBtYWtlWmFwUmVxdWVzdDogKCkgPT4gbWFrZVphcFJlcXVlc3QsXG4gIHVzZUZldGNoSW1wbGVtZW50YXRpb246ICgpID0+IHVzZUZldGNoSW1wbGVtZW50YXRpb240LFxuICB2YWxpZGF0ZVphcFJlcXVlc3Q6ICgpID0+IHZhbGlkYXRlWmFwUmVxdWVzdFxufSk7XG5pbXBvcnQgeyBiZWNoMzIgYXMgYmVjaDMyMiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIF9mZXRjaDQ7XG50cnkge1xuICBfZmV0Y2g0ID0gZmV0Y2g7XG59IGNhdGNoIHtcbn1cbmZ1bmN0aW9uIHVzZUZldGNoSW1wbGVtZW50YXRpb240KGZldGNoSW1wbGVtZW50YXRpb24pIHtcbiAgX2ZldGNoNCA9IGZldGNoSW1wbGVtZW50YXRpb247XG59XG5hc3luYyBmdW5jdGlvbiBnZXRaYXBFbmRwb2ludChtZXRhZGF0YSkge1xuICB0cnkge1xuICAgIGxldCBsbnVybCA9IFwiXCI7XG4gICAgbGV0IHsgbHVkMDYsIGx1ZDE2IH0gPSBKU09OLnBhcnNlKG1ldGFkYXRhLmNvbnRlbnQpO1xuICAgIGlmIChsdWQwNikge1xuICAgICAgbGV0IHsgd29yZHMgfSA9IGJlY2gzMjIuZGVjb2RlKGx1ZDA2LCAxZTMpO1xuICAgICAgbGV0IGRhdGEgPSBiZWNoMzIyLmZyb21Xb3Jkcyh3b3Jkcyk7XG4gICAgICBsbnVybCA9IHV0ZjhEZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKGx1ZDE2KSB7XG4gICAgICBsZXQgW25hbWUsIGRvbWFpbl0gPSBsdWQxNi5zcGxpdChcIkBcIik7XG4gICAgICBsbnVybCA9IG5ldyBVUkwoYC8ud2VsbC1rbm93bi9sbnVybHAvJHtuYW1lfWAsIGBodHRwczovLyR7ZG9tYWlufWApLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgcmVzID0gYXdhaXQgX2ZldGNoNChsbnVybCk7XG4gICAgbGV0IGJvZHkgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGlmIChib2R5LmFsbG93c05vc3RyICYmIGJvZHkubm9zdHJQdWJrZXkpIHtcbiAgICAgIHJldHVybiBib2R5LmNhbGxiYWNrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYWtlWmFwUmVxdWVzdCh7XG4gIHByb2ZpbGUsXG4gIGV2ZW50LFxuICBhbW91bnQsXG4gIHJlbGF5cyxcbiAgY29tbWVudCA9IFwiXCJcbn0pIHtcbiAgaWYgKCFhbW91bnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYW1vdW50IG5vdCBnaXZlblwiKTtcbiAgaWYgKCFwcm9maWxlKVxuICAgIHRocm93IG5ldyBFcnJvcihcInByb2ZpbGUgbm90IGdpdmVuXCIpO1xuICBsZXQgenIgPSB7XG4gICAga2luZDogOTczNCxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMpLFxuICAgIGNvbnRlbnQ6IGNvbW1lbnQsXG4gICAgdGFnczogW1xuICAgICAgW1wicFwiLCBwcm9maWxlXSxcbiAgICAgIFtcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKV0sXG4gICAgICBbXCJyZWxheXNcIiwgLi4ucmVsYXlzXVxuICAgIF1cbiAgfTtcbiAgaWYgKGV2ZW50ICYmIHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHpyLnRhZ3MucHVzaChbXCJlXCIsIGV2ZW50XSk7XG4gIH1cbiAgaWYgKGV2ZW50ICYmIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChpc1JlcGxhY2VhYmxlS2luZChldmVudC5raW5kKSkge1xuICAgICAgY29uc3QgYSA9IFtcImFcIiwgYCR7ZXZlbnQua2luZH06JHtldmVudC5wdWJrZXl9OmBdO1xuICAgICAgenIudGFncy5wdXNoKGEpO1xuICAgIH0gZWxzZSBpZiAoaXNBZGRyZXNzYWJsZUtpbmQoZXZlbnQua2luZCkpIHtcbiAgICAgIGxldCBkID0gZXZlbnQudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IFwiZFwiICYmIHYpO1xuICAgICAgaWYgKCFkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkIHRhZyBub3QgZm91bmQgb3IgaXMgZW1wdHlcIik7XG4gICAgICBjb25zdCBhID0gW1wiYVwiLCBgJHtldmVudC5raW5kfToke2V2ZW50LnB1YmtleX06JHtkWzFdfWBdO1xuICAgICAgenIudGFncy5wdXNoKGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4genI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVphcFJlcXVlc3QoemFwUmVxdWVzdFN0cmluZykge1xuICBsZXQgemFwUmVxdWVzdDtcbiAgdHJ5IHtcbiAgICB6YXBSZXF1ZXN0ID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0U3RyaW5nKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFwiSW52YWxpZCB6YXAgcmVxdWVzdCBKU09OLlwiO1xuICB9XG4gIGlmICghdmFsaWRhdGVFdmVudCh6YXBSZXF1ZXN0KSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBpcyBub3QgYSB2YWxpZCBOb3N0ciBldmVudC5cIjtcbiAgaWYgKCF2ZXJpZnlFdmVudCh6YXBSZXF1ZXN0KSlcbiAgICByZXR1cm4gXCJJbnZhbGlkIHNpZ25hdHVyZSBvbiB6YXAgcmVxdWVzdC5cIjtcbiAgbGV0IHAgPSB6YXBSZXF1ZXN0LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBcInBcIiAmJiB2KTtcbiAgaWYgKCFwKVxuICAgIHJldHVybiBcIlphcCByZXF1ZXN0IGRvZXNuJ3QgaGF2ZSBhICdwJyB0YWcuXCI7XG4gIGlmICghcFsxXS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCAncCcgdGFnIGlzIG5vdCB2YWxpZCBoZXguXCI7XG4gIGxldCBlID0gemFwUmVxdWVzdC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gXCJlXCIgJiYgdik7XG4gIGlmIChlICYmICFlWzFdLm1hdGNoKC9eW2EtZjAtOV17NjR9JC8pKVxuICAgIHJldHVybiBcIlphcCByZXF1ZXN0ICdlJyB0YWcgaXMgbm90IHZhbGlkIGhleC5cIjtcbiAgbGV0IHJlbGF5cyA9IHphcFJlcXVlc3QudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IFwicmVsYXlzXCIgJiYgdik7XG4gIGlmICghcmVsYXlzKVxuICAgIHJldHVybiBcIlphcCByZXF1ZXN0IGRvZXNuJ3QgaGF2ZSBhICdyZWxheXMnIHRhZy5cIjtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYWtlWmFwUmVjZWlwdCh7XG4gIHphcFJlcXVlc3QsXG4gIHByZWltYWdlLFxuICBib2x0MTEsXG4gIHBhaWRBdFxufSkge1xuICBsZXQgenIgPSBKU09OLnBhcnNlKHphcFJlcXVlc3QpO1xuICBsZXQgdGFnc0Zyb21aYXBSZXF1ZXN0ID0genIudGFncy5maWx0ZXIoKFt0XSkgPT4gdCA9PT0gXCJlXCIgfHwgdCA9PT0gXCJwXCIgfHwgdCA9PT0gXCJhXCIpO1xuICBsZXQgemFwID0ge1xuICAgIGtpbmQ6IDk3MzUsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChwYWlkQXQuZ2V0VGltZSgpIC8gMWUzKSxcbiAgICBjb250ZW50OiBcIlwiLFxuICAgIHRhZ3M6IFsuLi50YWdzRnJvbVphcFJlcXVlc3QsIFtcIlBcIiwgenIucHVia2V5XSwgW1wiYm9sdDExXCIsIGJvbHQxMV0sIFtcImRlc2NyaXB0aW9uXCIsIHphcFJlcXVlc3RdXVxuICB9O1xuICBpZiAocHJlaW1hZ2UpIHtcbiAgICB6YXAudGFncy5wdXNoKFtcInByZWltYWdlXCIsIHByZWltYWdlXSk7XG4gIH1cbiAgcmV0dXJuIHphcDtcbn1cblxuLy8gbmlwOTgudHNcbnZhciBuaXA5OF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA5OF9leHBvcnRzLCB7XG4gIGdldFRva2VuOiAoKSA9PiBnZXRUb2tlbixcbiAgaGFzaFBheWxvYWQ6ICgpID0+IGhhc2hQYXlsb2FkLFxuICB1bnBhY2tFdmVudEZyb21Ub2tlbjogKCkgPT4gdW5wYWNrRXZlbnRGcm9tVG9rZW4sXG4gIHZhbGlkYXRlRXZlbnQ6ICgpID0+IHZhbGlkYXRlRXZlbnQyLFxuICB2YWxpZGF0ZUV2ZW50S2luZDogKCkgPT4gdmFsaWRhdGVFdmVudEtpbmQsXG4gIHZhbGlkYXRlRXZlbnRNZXRob2RUYWc6ICgpID0+IHZhbGlkYXRlRXZlbnRNZXRob2RUYWcsXG4gIHZhbGlkYXRlRXZlbnRQYXlsb2FkVGFnOiAoKSA9PiB2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyxcbiAgdmFsaWRhdGVFdmVudFRpbWVzdGFtcDogKCkgPT4gdmFsaWRhdGVFdmVudFRpbWVzdGFtcCxcbiAgdmFsaWRhdGVFdmVudFVybFRhZzogKCkgPT4gdmFsaWRhdGVFdmVudFVybFRhZyxcbiAgdmFsaWRhdGVUb2tlbjogKCkgPT4gdmFsaWRhdGVUb2tlblxufSk7XG5pbXBvcnQgeyBzaGEyNTYgYXMgc2hhMjU2NCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4NSB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBiYXNlNjQgYXMgYmFzZTY0MyB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIF9hdXRob3JpemF0aW9uU2NoZW1lID0gXCJOb3N0ciBcIjtcbmFzeW5jIGZ1bmN0aW9uIGdldFRva2VuKGxvZ2luVXJsLCBodHRwTWV0aG9kLCBzaWduLCBpbmNsdWRlQXV0aG9yaXphdGlvblNjaGVtZSA9IGZhbHNlLCBwYXlsb2FkKSB7XG4gIGNvbnN0IGV2ZW50ID0ge1xuICAgIGtpbmQ6IEhUVFBBdXRoLFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInVcIiwgbG9naW5VcmxdLFxuICAgICAgW1wibWV0aG9kXCIsIGh0dHBNZXRob2RdXG4gICAgXSxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKSxcbiAgICBjb250ZW50OiBcIlwiXG4gIH07XG4gIGlmIChwYXlsb2FkKSB7XG4gICAgZXZlbnQudGFncy5wdXNoKFtcInBheWxvYWRcIiwgaGFzaFBheWxvYWQocGF5bG9hZCldKTtcbiAgfVxuICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IHNpZ24oZXZlbnQpO1xuICBjb25zdCBhdXRob3JpemF0aW9uU2NoZW1lID0gaW5jbHVkZUF1dGhvcml6YXRpb25TY2hlbWUgPyBfYXV0aG9yaXphdGlvblNjaGVtZSA6IFwiXCI7XG4gIHJldHVybiBhdXRob3JpemF0aW9uU2NoZW1lICsgYmFzZTY0My5lbmNvZGUodXRmOEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHNpZ25lZEV2ZW50KSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVUb2tlbih0b2tlbiwgdXJsLCBtZXRob2QpIHtcbiAgY29uc3QgZXZlbnQgPSBhd2FpdCB1bnBhY2tFdmVudEZyb21Ub2tlbih0b2tlbikuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICBjb25zdCB2YWxpZCA9IGF3YWl0IHZhbGlkYXRlRXZlbnQyKGV2ZW50LCB1cmwsIG1ldGhvZCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICByZXR1cm4gdmFsaWQ7XG59XG5hc3luYyBmdW5jdGlvbiB1bnBhY2tFdmVudEZyb21Ub2tlbih0b2tlbikge1xuICBpZiAoIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB0b2tlblwiKTtcbiAgfVxuICB0b2tlbiA9IHRva2VuLnJlcGxhY2UoX2F1dGhvcml6YXRpb25TY2hlbWUsIFwiXCIpO1xuICBjb25zdCBldmVudEI2NCA9IHV0ZjhEZWNvZGVyLmRlY29kZShiYXNlNjQzLmRlY29kZSh0b2tlbikpO1xuICBpZiAoIWV2ZW50QjY0IHx8IGV2ZW50QjY0Lmxlbmd0aCA9PT0gMCB8fCAhZXZlbnRCNjQuc3RhcnRzV2l0aChcIntcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRva2VuXCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50ID0gSlNPTi5wYXJzZShldmVudEI2NCk7XG4gIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRUaW1lc3RhbXAoZXZlbnQpIHtcbiAgaWYgKCFldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKSAtIGV2ZW50LmNyZWF0ZWRfYXQgPCA2MDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRLaW5kKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5raW5kID09PSBIVFRQQXV0aDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRVcmxUYWcoZXZlbnQsIHVybCkge1xuICBjb25zdCB1cmxUYWcgPSBldmVudC50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwidVwiKTtcbiAgaWYgKCF1cmxUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHVybFRhZy5sZW5ndGggPiAwICYmIHVybFRhZ1sxXSA9PT0gdXJsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFdmVudE1ldGhvZFRhZyhldmVudCwgbWV0aG9kKSB7XG4gIGNvbnN0IG1ldGhvZFRhZyA9IGV2ZW50LnRhZ3MuZmluZCgodCkgPT4gdFswXSA9PT0gXCJtZXRob2RcIik7XG4gIGlmICghbWV0aG9kVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBtZXRob2RUYWcubGVuZ3RoID4gMCAmJiBtZXRob2RUYWdbMV0udG9Mb3dlckNhc2UoKSA9PT0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBoYXNoUGF5bG9hZChwYXlsb2FkKSB7XG4gIGNvbnN0IGhhc2ggPSBzaGEyNTY0KHV0ZjhFbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSkpO1xuICByZXR1cm4gYnl0ZXNUb0hleDUoaGFzaCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyhldmVudCwgcGF5bG9hZCkge1xuICBjb25zdCBwYXlsb2FkVGFnID0gZXZlbnQudGFncy5maW5kKCh0KSA9PiB0WzBdID09PSBcInBheWxvYWRcIik7XG4gIGlmICghcGF5bG9hZFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwYXlsb2FkSGFzaCA9IGhhc2hQYXlsb2FkKHBheWxvYWQpO1xuICByZXR1cm4gcGF5bG9hZFRhZy5sZW5ndGggPiAwICYmIHBheWxvYWRUYWdbMV0gPT09IHBheWxvYWRIYXNoO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVFdmVudDIoZXZlbnQsIHVybCwgbWV0aG9kLCBib2R5KSB7XG4gIGlmICghdmVyaWZ5RXZlbnQoZXZlbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgc2lnbmF0dXJlIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50S2luZChldmVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCBraW5kIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50VGltZXN0YW1wKGV2ZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIGNyZWF0ZWRfYXQgdGltZXN0YW1wIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50VXJsVGFnKGV2ZW50LCB1cmwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgdXJsIHRhZyBpbnZhbGlkXCIpO1xuICB9XG4gIGlmICghdmFsaWRhdGVFdmVudE1ldGhvZFRhZyhldmVudCwgbWV0aG9kKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIG1ldGhvZCB0YWcgaW52YWxpZFwiKTtcbiAgfVxuICBpZiAoQm9vbGVhbihib2R5KSAmJiB0eXBlb2YgYm9keSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhib2R5KS5sZW5ndGggPiAwKSB7XG4gICAgaWYgKCF2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyhldmVudCwgYm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIHBheWxvYWQgdGFnIGRvZXMgbm90IG1hdGNoIHJlcXVlc3QgYm9keSBoYXNoXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCB7XG4gIFJlbGF5LFxuICBTaW1wbGVQb29sLFxuICBmaW5hbGl6ZUV2ZW50LFxuICBmYWtlanNvbl9leHBvcnRzIGFzIGZqLFxuICBnZW5lcmF0ZVNlY3JldEtleSxcbiAgZ2V0RXZlbnRIYXNoLFxuICBnZXRGaWx0ZXJMaW1pdCxcbiAgZ2V0UHVibGljS2V5LFxuICBraW5kc19leHBvcnRzIGFzIGtpbmRzLFxuICBtYXRjaEZpbHRlcixcbiAgbWF0Y2hGaWx0ZXJzLFxuICBtZXJnZUZpbHRlcnMsXG4gIG5pcDA0X2V4cG9ydHMgYXMgbmlwMDQsXG4gIG5pcDA1X2V4cG9ydHMgYXMgbmlwMDUsXG4gIG5pcDEwX2V4cG9ydHMgYXMgbmlwMTAsXG4gIG5pcDExX2V4cG9ydHMgYXMgbmlwMTEsXG4gIG5pcDEzX2V4cG9ydHMgYXMgbmlwMTMsXG4gIG5pcDE3X2V4cG9ydHMgYXMgbmlwMTcsXG4gIG5pcDE4X2V4cG9ydHMgYXMgbmlwMTgsXG4gIG5pcDE5X2V4cG9ydHMgYXMgbmlwMTksXG4gIG5pcDIxX2V4cG9ydHMgYXMgbmlwMjEsXG4gIG5pcDI1X2V4cG9ydHMgYXMgbmlwMjUsXG4gIG5pcDI3X2V4cG9ydHMgYXMgbmlwMjcsXG4gIG5pcDI4X2V4cG9ydHMgYXMgbmlwMjgsXG4gIG5pcDMwX2V4cG9ydHMgYXMgbmlwMzAsXG4gIG5pcDM5X2V4cG9ydHMgYXMgbmlwMzksXG4gIG5pcDQyX2V4cG9ydHMgYXMgbmlwNDIsXG4gIG5pcDQ0X2V4cG9ydHMgYXMgbmlwNDQsXG4gIG5pcDQ3X2V4cG9ydHMgYXMgbmlwNDcsXG4gIG5pcDU0X2V4cG9ydHMgYXMgbmlwNTQsXG4gIG5pcDU3X2V4cG9ydHMgYXMgbmlwNTcsXG4gIG5pcDU5X2V4cG9ydHMgYXMgbmlwNTksXG4gIG5pcDk4X2V4cG9ydHMgYXMgbmlwOTgsXG4gIHBhcnNlUmVmZXJlbmNlcyxcbiAgc2VyaWFsaXplRXZlbnQsXG4gIHNvcnRFdmVudHMsXG4gIHV0aWxzX2V4cG9ydHMgYXMgdXRpbHMsXG4gIHZhbGlkYXRlRXZlbnQsXG4gIHZlcmlmaWVkU3ltYm9sLFxuICB2ZXJpZnlFdmVudFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_arx.js":
/*!***********************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/ciphers/_arx.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createCipher = exports.rotl = exports.sigma = void 0;\n// Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/utils.js\");\n/*\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | ctr(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | ctr(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | ctr(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n*/\n// We can't make top-level var depend on utils.utf8ToBytes\n// because it's not present in all envs. Creating a similar fn here\nconst _utf8ToBytes = (str) => Uint8Array.from(str.split('').map((c) => c.charCodeAt(0)));\nconst sigma16 = _utf8ToBytes('expand 16-byte k');\nconst sigma32 = _utf8ToBytes('expand 32-byte k');\nconst sigma16_32 = (0, utils_js_1.u32)(sigma16);\nconst sigma32_32 = (0, utils_js_1.u32)(sigma32);\nexports.sigma = sigma32_32.slice();\nfunction rotl(a, b) {\n    return (a << b) | (a >>> (32 - b));\n}\nexports.rotl = rotl;\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b) {\n    return b.byteOffset % 4 === 0;\n}\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\nconst U32_EMPTY = new Uint32Array();\nfunction runCipher(core, sigma, key, nonce, data, output, counter, rounds) {\n    const len = data.length;\n    const block = new Uint8Array(BLOCK_LEN);\n    const b32 = (0, utils_js_1.u32)(block);\n    // Make sure that buffers aligned to 4 bytes\n    const isAligned = isAligned32(data) && isAligned32(output);\n    const d32 = isAligned ? (0, utils_js_1.u32)(data) : U32_EMPTY;\n    const o32 = isAligned ? (0, utils_js_1.u32)(output) : U32_EMPTY;\n    for (let pos = 0; pos < len; counter++) {\n        core(sigma, key, nonce, b32, counter, rounds);\n        if (counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        const take = Math.min(BLOCK_LEN, len - pos);\n        // aligned to 4 bytes\n        if (isAligned && take === BLOCK_LEN) {\n            const pos32 = pos / 4;\n            if (pos % 4 !== 0)\n                throw new Error('arx: invalid block position');\n            for (let j = 0, posj; j < BLOCK_LEN32; j++) {\n                posj = pos32 + j;\n                o32[posj] = d32[posj] ^ b32[j];\n            }\n            pos += BLOCK_LEN;\n            continue;\n        }\n        for (let j = 0, posj; j < take; j++) {\n            posj = pos + j;\n            output[posj] = data[posj] ^ block[j];\n        }\n        pos += take;\n    }\n}\nfunction createCipher(core, opts) {\n    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = (0, utils_js_1.checkOpts)({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);\n    if (typeof core !== 'function')\n        throw new Error('core must be a function');\n    (0, _assert_js_1.number)(counterLength);\n    (0, _assert_js_1.number)(rounds);\n    (0, _assert_js_1.bool)(counterRight);\n    (0, _assert_js_1.bool)(allowShortKeys);\n    return (key, nonce, data, output, counter = 0) => {\n        (0, _assert_js_1.bytes)(key);\n        (0, _assert_js_1.bytes)(nonce);\n        (0, _assert_js_1.bytes)(data);\n        const len = data.length;\n        if (!output)\n            output = new Uint8Array(len);\n        (0, _assert_js_1.bytes)(output);\n        (0, _assert_js_1.number)(counter);\n        if (counter < 0 || counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        if (output.length < len)\n            throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n        const toClean = [];\n        // Key & sigma\n        // key=16 -> sigma16, k=key|key\n        // key=32 -> sigma32, k=key\n        let l = key.length, k, sigma;\n        if (l === 32) {\n            k = key.slice();\n            toClean.push(k);\n            sigma = sigma32_32;\n        }\n        else if (l === 16 && allowShortKeys) {\n            k = new Uint8Array(32);\n            k.set(key);\n            k.set(key, 16);\n            sigma = sigma16_32;\n            toClean.push(k);\n        }\n        else {\n            throw new Error(`arx: invalid 32-byte key, got length=${l}`);\n        }\n        // Nonce\n        // salsa20:      8   (8-byte counter)\n        // chacha20orig: 8   (8-byte counter)\n        // chacha20:     12  (4-byte counter)\n        // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n        // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n        // Align nonce to 4 bytes\n        if (!isAligned32(nonce)) {\n            nonce = nonce.slice();\n            toClean.push(nonce);\n        }\n        const k32 = (0, utils_js_1.u32)(k);\n        // hsalsa & hchacha: handle extended nonce\n        if (extendNonceFn) {\n            if (nonce.length !== 24)\n                throw new Error(`arx: extended nonce must be 24 bytes`);\n            extendNonceFn(sigma, k32, (0, utils_js_1.u32)(nonce.subarray(0, 16)), k32);\n            nonce = nonce.subarray(16);\n        }\n        // Handle nonce counter\n        const nonceNcLen = 16 - counterLength;\n        if (nonceNcLen !== nonce.length)\n            throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n        // Pad counter when nonce is 64 bit\n        if (nonceNcLen !== 12) {\n            const nc = new Uint8Array(12);\n            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n            nonce = nc;\n            toClean.push(nonce);\n        }\n        const n32 = (0, utils_js_1.u32)(nonce);\n        runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n        while (toClean.length > 0)\n            toClean.pop().fill(0);\n        return output;\n    };\n}\nexports.createCipher = createCipher;\n//# sourceMappingURL=_arx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL19hcnguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsWUFBWSxHQUFHLGFBQWE7QUFDbkQ7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyw0R0FBYztBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyx3R0FBWTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0IsK0JBQStCOztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxRUFBcUUsOEJBQThCLDBFQUEwRTtBQUN6TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYywwQkFBMEIsSUFBSTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsRUFBRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9fYXJ4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVDaXBoZXIgPSBleHBvcnRzLnJvdGwgPSBleHBvcnRzLnNpZ21hID0gdm9pZCAwO1xuLy8gQmFzaWMgdXRpbHMgZm9yIEFSWCAoYWRkLXJvdGF0ZS14b3IpIHNhbHNhIGFuZCBjaGFjaGEgY2lwaGVycy5cbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vKlxuUkZDODQzOSByZXF1aXJlcyBtdWx0aS1zdGVwIGNpcGhlciBzdHJlYW0sIHdoZXJlXG5hdXRoS2V5IHN0YXJ0cyB3aXRoIGNvdW50ZXI6IDAsIGFjdHVhbCBtc2cgd2l0aCBjb3VudGVyOiAxLlxuXG5Gb3IgdGhpcywgd2UgbmVlZCBhIHdheSB0byByZS11c2Ugbm9uY2UgLyBjb3VudGVyOlxuXG4gICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNoYWNoYSguLi4sIGNvdW50ZXIsIC4uLik7IC8vIGNvdW50ZXIgaXMgbm93IDFcbiAgICBjaGFjaGEoLi4uLCBjb3VudGVyLCAuLi4pOyAvLyBjb3VudGVyIGlzIG5vdyAyXG5cblRoaXMgaXMgY29tcGxpY2F0ZWQ6XG5cbi0gMzItYml0IGNvdW50ZXJzIGFyZSBlbm91Z2gsIG5vIG5lZWQgZm9yIDY0LWJpdDogbWF4IEFycmF5QnVmZmVyIHNpemUgaW4gSlMgaXMgNEdCXG4tIE9yaWdpbmFsIHBhcGVycyBkb24ndCBhbGxvdyBtdXRhdGluZyBjb3VudGVyc1xuLSBDb3VudGVyIG92ZXJmbG93IGlzIHVuZGVmaW5lZCBbXjFdXG4tIElkZWEgQTogYWxsb3cgcHJvdmlkaW5nIChub25jZSB8IGNvdW50ZXIpIGluc3RlYWQgb2YganVzdCBub25jZSwgcmUtdXNlIGl0XG4tIENhdmVhdDogQ2Fubm90IGJlIHJlLXVzZWQgdGhyb3VnaCBhbGwgY2FzZXM6XG4tICogY2hhY2hhIGhhcyAoY291bnRlciB8IG5vbmNlKVxuLSAqIHhjaGFjaGEgaGFzIChub25jZTE2IHwgY291bnRlciB8IG5vbmNlMTYpXG4tIElkZWEgQjogc2VwYXJhdGUgbm9uY2UgLyBjb3VudGVyIGFuZCBwcm92aWRlIHNlcGFyYXRlIEFQSSBmb3IgY291bnRlciByZS11c2Vcbi0gQ2F2ZWF0OiB0aGVyZSBhcmUgZGlmZmVyZW50IGNvdW50ZXIgc2l6ZXMgZGVwZW5kaW5nIG9uIGFuIGFsZ29yaXRobS5cbi0gc2Fsc2EgJiBjaGFjaGEgYWxzbyBkaWZmZXIgaW4gc3RydWN0dXJlcyBvZiBrZXkgJiBzaWdtYTpcbiAgc2Fsc2EyMDogICAgICBzWzBdIHwgayg0KSB8IHNbMV0gfCBub25jZSgyKSB8IGN0cigyKSB8IHNbMl0gfCBrKDQpIHwgc1szXVxuICBjaGFjaGE6ICAgICAgIHMoNCkgfCBrKDgpIHwgY3RyKDEpIHwgbm9uY2UoMylcbiAgY2hhY2hhMjBvcmlnOiBzKDQpIHwgayg4KSB8IGN0cigyKSB8IG5vbmNlKDIpXG4tIElkZWEgQzogaGVscGVyIG1ldGhvZCBzdWNoIGFzIGBzZXRTYWxzYVN0YXRlKGtleSwgbm9uY2UsIHNpZ21hLCBkYXRhKWBcbi0gQ2F2ZWF0OiB3ZSBjYW4ndCByZS11c2UgY291bnRlciBhcnJheVxuXG54Y2hhY2hhIFteMl0gdXNlcyB0aGUgc3Via2V5IGFuZCByZW1haW5pbmcgOCBieXRlIG5vbmNlIHdpdGggQ2hhQ2hhMjAgYXMgbm9ybWFsXG4ocHJlZml4ZWQgYnkgNCBOVUwgYnl0ZXMsIHNpbmNlIFtSRkM4NDM5XSBzcGVjaWZpZXMgYSAxMi1ieXRlIG5vbmNlKS5cblxuW14xXTogaHR0cHM6Ly9tYWlsYXJjaGl2ZS5pZXRmLm9yZy9hcmNoL21zZy9jZnJnL2dzT25USnpjYmdHNk9xRDhTYzBHTzVhUl90VS9cblteMl06IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXhjaGFjaGEjYXBwZW5kaXgtQS4yXG4qL1xuLy8gV2UgY2FuJ3QgbWFrZSB0b3AtbGV2ZWwgdmFyIGRlcGVuZCBvbiB1dGlscy51dGY4VG9CeXRlc1xuLy8gYmVjYXVzZSBpdCdzIG5vdCBwcmVzZW50IGluIGFsbCBlbnZzLiBDcmVhdGluZyBhIHNpbWlsYXIgZm4gaGVyZVxuY29uc3QgX3V0ZjhUb0J5dGVzID0gKHN0cikgPT4gVWludDhBcnJheS5mcm9tKHN0ci5zcGxpdCgnJykubWFwKChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbmNvbnN0IHNpZ21hMTYgPSBfdXRmOFRvQnl0ZXMoJ2V4cGFuZCAxNi1ieXRlIGsnKTtcbmNvbnN0IHNpZ21hMzIgPSBfdXRmOFRvQnl0ZXMoJ2V4cGFuZCAzMi1ieXRlIGsnKTtcbmNvbnN0IHNpZ21hMTZfMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHNpZ21hMTYpO1xuY29uc3Qgc2lnbWEzMl8zMiA9ICgwLCB1dGlsc19qc18xLnUzMikoc2lnbWEzMik7XG5leHBvcnRzLnNpZ21hID0gc2lnbWEzMl8zMi5zbGljZSgpO1xuZnVuY3Rpb24gcm90bChhLCBiKSB7XG4gICAgcmV0dXJuIChhIDw8IGIpIHwgKGEgPj4+ICgzMiAtIGIpKTtcbn1cbmV4cG9ydHMucm90bCA9IHJvdGw7XG4vLyBJcyBieXRlIGFycmF5IGFsaWduZWQgdG8gNCBieXRlIG9mZnNldCAodTMyKT9cbmZ1bmN0aW9uIGlzQWxpZ25lZDMyKGIpIHtcbiAgICByZXR1cm4gYi5ieXRlT2Zmc2V0ICUgNCA9PT0gMDtcbn1cbi8vIFNhbHNhIGFuZCBDaGFjaGEgYmxvY2sgbGVuZ3RoIGlzIGFsd2F5cyA1MTItYml0XG5jb25zdCBCTE9DS19MRU4gPSA2NDtcbmNvbnN0IEJMT0NLX0xFTjMyID0gMTY7XG4vLyBuZXcgVWludDMyQXJyYXkoWzIqKjMyXSkgICAvLyA9PiBVaW50MzJBcnJheSgxKSBbIDAgXVxuLy8gbmV3IFVpbnQzMkFycmF5KFsyKiozMi0xXSkgLy8gPT4gVWludDMyQXJyYXkoMSkgWyA0Mjk0OTY3Mjk1IF1cbmNvbnN0IE1BWF9DT1VOVEVSID0gMiAqKiAzMiAtIDE7XG5jb25zdCBVMzJfRU1QVFkgPSBuZXcgVWludDMyQXJyYXkoKTtcbmZ1bmN0aW9uIHJ1bkNpcGhlcihjb3JlLCBzaWdtYSwga2V5LCBub25jZSwgZGF0YSwgb3V0cHV0LCBjb3VudGVyLCByb3VuZHMpIHtcbiAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBibG9jayA9IG5ldyBVaW50OEFycmF5KEJMT0NLX0xFTik7XG4gICAgY29uc3QgYjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShibG9jayk7XG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgYnVmZmVycyBhbGlnbmVkIHRvIDQgYnl0ZXNcbiAgICBjb25zdCBpc0FsaWduZWQgPSBpc0FsaWduZWQzMihkYXRhKSAmJiBpc0FsaWduZWQzMihvdXRwdXQpO1xuICAgIGNvbnN0IGQzMiA9IGlzQWxpZ25lZCA/ICgwLCB1dGlsc19qc18xLnUzMikoZGF0YSkgOiBVMzJfRU1QVFk7XG4gICAgY29uc3QgbzMyID0gaXNBbGlnbmVkID8gKDAsIHV0aWxzX2pzXzEudTMyKShvdXRwdXQpIDogVTMyX0VNUFRZO1xuICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjsgY291bnRlcisrKSB7XG4gICAgICAgIGNvcmUoc2lnbWEsIGtleSwgbm9uY2UsIGIzMiwgY291bnRlciwgcm91bmRzKTtcbiAgICAgICAgaWYgKGNvdW50ZXIgPj0gTUFYX0NPVU5URVIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyeDogY291bnRlciBvdmVyZmxvdycpO1xuICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oQkxPQ0tfTEVOLCBsZW4gLSBwb3MpO1xuICAgICAgICAvLyBhbGlnbmVkIHRvIDQgYnl0ZXNcbiAgICAgICAgaWYgKGlzQWxpZ25lZCAmJiB0YWtlID09PSBCTE9DS19MRU4pIHtcbiAgICAgICAgICAgIGNvbnN0IHBvczMyID0gcG9zIC8gNDtcbiAgICAgICAgICAgIGlmIChwb3MgJSA0ICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJ4OiBpbnZhbGlkIGJsb2NrIHBvc2l0aW9uJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgcG9zajsgaiA8IEJMT0NLX0xFTjMyOyBqKyspIHtcbiAgICAgICAgICAgICAgICBwb3NqID0gcG9zMzIgKyBqO1xuICAgICAgICAgICAgICAgIG8zMltwb3NqXSA9IGQzMltwb3NqXSBeIGIzMltqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyArPSBCTE9DS19MRU47XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMCwgcG9zajsgaiA8IHRha2U7IGorKykge1xuICAgICAgICAgICAgcG9zaiA9IHBvcyArIGo7XG4gICAgICAgICAgICBvdXRwdXRbcG9zal0gPSBkYXRhW3Bvc2pdIF4gYmxvY2tbal07XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IHRha2U7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ2lwaGVyKGNvcmUsIG9wdHMpIHtcbiAgICBjb25zdCB7IGFsbG93U2hvcnRLZXlzLCBleHRlbmROb25jZUZuLCBjb3VudGVyTGVuZ3RoLCBjb3VudGVyUmlnaHQsIHJvdW5kcyB9ID0gKDAsIHV0aWxzX2pzXzEuY2hlY2tPcHRzKSh7IGFsbG93U2hvcnRLZXlzOiBmYWxzZSwgY291bnRlckxlbmd0aDogOCwgY291bnRlclJpZ2h0OiBmYWxzZSwgcm91bmRzOiAyMCB9LCBvcHRzKTtcbiAgICBpZiAodHlwZW9mIGNvcmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29yZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAoMCwgX2Fzc2VydF9qc18xLm51bWJlcikoY291bnRlckxlbmd0aCk7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5udW1iZXIpKHJvdW5kcyk7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5ib29sKShjb3VudGVyUmlnaHQpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYm9vbCkoYWxsb3dTaG9ydEtleXMpO1xuICAgIHJldHVybiAoa2V5LCBub25jZSwgZGF0YSwgb3V0cHV0LCBjb3VudGVyID0gMCkgPT4ge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShrZXkpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShub25jZSk7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKCFvdXRwdXQpXG4gICAgICAgICAgICBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShvdXRwdXQpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLm51bWJlcikoY291bnRlcik7XG4gICAgICAgIGlmIChjb3VudGVyIDwgMCB8fCBjb3VudGVyID49IE1BWF9DT1VOVEVSKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcng6IGNvdW50ZXIgb3ZlcmZsb3cnKTtcbiAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPCBsZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyeDogb3V0cHV0ICgke291dHB1dC5sZW5ndGh9KSBpcyBzaG9ydGVyIHRoYW4gZGF0YSAoJHtsZW59KWApO1xuICAgICAgICBjb25zdCB0b0NsZWFuID0gW107XG4gICAgICAgIC8vIEtleSAmIHNpZ21hXG4gICAgICAgIC8vIGtleT0xNiAtPiBzaWdtYTE2LCBrPWtleXxrZXlcbiAgICAgICAgLy8ga2V5PTMyIC0+IHNpZ21hMzIsIGs9a2V5XG4gICAgICAgIGxldCBsID0ga2V5Lmxlbmd0aCwgaywgc2lnbWE7XG4gICAgICAgIGlmIChsID09PSAzMikge1xuICAgICAgICAgICAgayA9IGtleS5zbGljZSgpO1xuICAgICAgICAgICAgdG9DbGVhbi5wdXNoKGspO1xuICAgICAgICAgICAgc2lnbWEgPSBzaWdtYTMyXzMyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGwgPT09IDE2ICYmIGFsbG93U2hvcnRLZXlzKSB7XG4gICAgICAgICAgICBrID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgICAgICAgICAgay5zZXQoa2V5KTtcbiAgICAgICAgICAgIGsuc2V0KGtleSwgMTYpO1xuICAgICAgICAgICAgc2lnbWEgPSBzaWdtYTE2XzMyO1xuICAgICAgICAgICAgdG9DbGVhbi5wdXNoKGspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IGludmFsaWQgMzItYnl0ZSBrZXksIGdvdCBsZW5ndGg9JHtsfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vbmNlXG4gICAgICAgIC8vIHNhbHNhMjA6ICAgICAgOCAgICg4LWJ5dGUgY291bnRlcilcbiAgICAgICAgLy8gY2hhY2hhMjBvcmlnOiA4ICAgKDgtYnl0ZSBjb3VudGVyKVxuICAgICAgICAvLyBjaGFjaGEyMDogICAgIDEyICAoNC1ieXRlIGNvdW50ZXIpXG4gICAgICAgIC8vIHhzYWxzYTIwOiAgICAgMjQgICgxNiAtPiBoc2Fsc2EsICA4IC0+IG9sZCBub25jZSlcbiAgICAgICAgLy8geGNoYWNoYTIwOiAgICAyNCAgKDE2IC0+IGhjaGFjaGEsIDggLT4gb2xkIG5vbmNlKVxuICAgICAgICAvLyBBbGlnbiBub25jZSB0byA0IGJ5dGVzXG4gICAgICAgIGlmICghaXNBbGlnbmVkMzIobm9uY2UpKSB7XG4gICAgICAgICAgICBub25jZSA9IG5vbmNlLnNsaWNlKCk7XG4gICAgICAgICAgICB0b0NsZWFuLnB1c2gobm9uY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGszMiA9ICgwLCB1dGlsc19qc18xLnUzMikoayk7XG4gICAgICAgIC8vIGhzYWxzYSAmIGhjaGFjaGE6IGhhbmRsZSBleHRlbmRlZCBub25jZVxuICAgICAgICBpZiAoZXh0ZW5kTm9uY2VGbikge1xuICAgICAgICAgICAgaWYgKG5vbmNlLmxlbmd0aCAhPT0gMjQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IGV4dGVuZGVkIG5vbmNlIG11c3QgYmUgMjQgYnl0ZXNgKTtcbiAgICAgICAgICAgIGV4dGVuZE5vbmNlRm4oc2lnbWEsIGszMiwgKDAsIHV0aWxzX2pzXzEudTMyKShub25jZS5zdWJhcnJheSgwLCAxNikpLCBrMzIpO1xuICAgICAgICAgICAgbm9uY2UgPSBub25jZS5zdWJhcnJheSgxNik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIG5vbmNlIGNvdW50ZXJcbiAgICAgICAgY29uc3Qgbm9uY2VOY0xlbiA9IDE2IC0gY291bnRlckxlbmd0aDtcbiAgICAgICAgaWYgKG5vbmNlTmNMZW4gIT09IG5vbmNlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXJ4OiBub25jZSBtdXN0IGJlICR7bm9uY2VOY0xlbn0gb3IgMTYgYnl0ZXNgKTtcbiAgICAgICAgLy8gUGFkIGNvdW50ZXIgd2hlbiBub25jZSBpcyA2NCBiaXRcbiAgICAgICAgaWYgKG5vbmNlTmNMZW4gIT09IDEyKSB7XG4gICAgICAgICAgICBjb25zdCBuYyA9IG5ldyBVaW50OEFycmF5KDEyKTtcbiAgICAgICAgICAgIG5jLnNldChub25jZSwgY291bnRlclJpZ2h0ID8gMCA6IDEyIC0gbm9uY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIG5vbmNlID0gbmM7XG4gICAgICAgICAgICB0b0NsZWFuLnB1c2gobm9uY2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG4zMiA9ICgwLCB1dGlsc19qc18xLnUzMikobm9uY2UpO1xuICAgICAgICBydW5DaXBoZXIoY29yZSwgc2lnbWEsIGszMiwgbjMyLCBkYXRhLCBvdXRwdXQsIGNvdW50ZXIsIHJvdW5kcyk7XG4gICAgICAgIHdoaWxlICh0b0NsZWFuLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB0b0NsZWFuLnBvcCgpLmZpbGwoMCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn1cbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gY3JlYXRlQ2lwaGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2FyeC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_arx.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_assert.js":
/*!**************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/ciphers/_assert.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\nexports.bool = bool;\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nexports.isBytes = isBytes;\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('hash must be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = { number, bool, bytes, hash, exists, output };\nexports[\"default\"] = assert;\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGNBQWMsR0FBRyxZQUFZLEdBQUcsYUFBYSxHQUFHLFlBQVksR0FBRyxjQUFjLEdBQUcsZUFBZTtBQUNoSDtBQUNBO0FBQ0EsMERBQTBELEVBQUU7QUFDNUQ7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFFBQVEsa0JBQWtCLFNBQVM7QUFDNUY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixJQUFJO0FBQ3JGO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvX2Fzc2VydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3V0cHV0ID0gZXhwb3J0cy5leGlzdHMgPSBleHBvcnRzLmhhc2ggPSBleHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5ib29sID0gZXhwb3J0cy5udW1iZXIgPSBleHBvcnRzLmlzQnl0ZXMgPSB2b2lkIDA7XG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgcG9zaXRpdmUgaW50ZWdlciBleHBlY3RlZCwgbm90ICR7bn1gKTtcbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYm9vbGVhbiBleHBlY3RlZCwgbm90ICR7Yn1gKTtcbn1cbmV4cG9ydHMuYm9vbCA9IGJvb2w7XG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5leHBvcnRzLmlzQnl0ZXMgPSBpc0J5dGVzO1xuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZXhwb3J0cy5ieXRlcyA9IGJ5dGVzO1xuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoIG11c3QgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmV4cG9ydHMuaGFzaCA9IGhhc2g7XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmV4cG9ydHMuZXhpc3RzID0gZXhpc3RzO1xuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydHMub3V0cHV0ID0gb3V0cHV0O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_poly1305.js":
/*!****************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/ciphers/_poly1305.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.poly1305 = exports.wrapConstructorWithKey = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/utils.js\");\n// Poly1305 is a fast and parallel secret-key message-authentication code.\n// https://cr.yp.to/mac.html, https://cr.yp.to/mac/poly1305-20050329.pdf\n// https://datatracker.ietf.org/doc/html/rfc8439\n// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna\nconst u8to16 = (a, i) => (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\nclass Poly1305 {\n    constructor(key) {\n        this.blockLen = 16;\n        this.outputLen = 16;\n        this.buffer = new Uint8Array(16);\n        this.r = new Uint16Array(10);\n        this.h = new Uint16Array(10);\n        this.pad = new Uint16Array(8);\n        this.pos = 0;\n        this.finished = false;\n        key = (0, utils_js_1.toBytes)(key);\n        (0, _assert_js_1.bytes)(key, 32);\n        const t0 = u8to16(key, 0);\n        const t1 = u8to16(key, 2);\n        const t2 = u8to16(key, 4);\n        const t3 = u8to16(key, 6);\n        const t4 = u8to16(key, 8);\n        const t5 = u8to16(key, 10);\n        const t6 = u8to16(key, 12);\n        const t7 = u8to16(key, 14);\n        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n        this.r[0] = t0 & 0x1fff;\n        this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n        this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n        this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n        this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n        this.r[5] = (t4 >>> 1) & 0x1ffe;\n        this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n        this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n        this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n        this.r[9] = (t7 >>> 5) & 0x007f;\n        for (let i = 0; i < 8; i++)\n            this.pad[i] = u8to16(key, 16 + 2 * i);\n    }\n    process(data, offset, isLast = false) {\n        const hibit = isLast ? 0 : 1 << 11;\n        const { h, r } = this;\n        const r0 = r[0];\n        const r1 = r[1];\n        const r2 = r[2];\n        const r3 = r[3];\n        const r4 = r[4];\n        const r5 = r[5];\n        const r6 = r[6];\n        const r7 = r[7];\n        const r8 = r[8];\n        const r9 = r[9];\n        const t0 = u8to16(data, offset + 0);\n        const t1 = u8to16(data, offset + 2);\n        const t2 = u8to16(data, offset + 4);\n        const t3 = u8to16(data, offset + 6);\n        const t4 = u8to16(data, offset + 8);\n        const t5 = u8to16(data, offset + 10);\n        const t6 = u8to16(data, offset + 12);\n        const t7 = u8to16(data, offset + 14);\n        let h0 = h[0] + (t0 & 0x1fff);\n        let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n        let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n        let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n        let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n        let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n        let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n        let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n        let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n        let h9 = h[9] + ((t7 >>> 5) | hibit);\n        let c = 0;\n        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n        c = d0 >>> 13;\n        d0 &= 0x1fff;\n        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n        c += d0 >>> 13;\n        d0 &= 0x1fff;\n        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n        c = d1 >>> 13;\n        d1 &= 0x1fff;\n        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n        c += d1 >>> 13;\n        d1 &= 0x1fff;\n        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n        c = d2 >>> 13;\n        d2 &= 0x1fff;\n        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n        c += d2 >>> 13;\n        d2 &= 0x1fff;\n        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n        c = d3 >>> 13;\n        d3 &= 0x1fff;\n        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n        c += d3 >>> 13;\n        d3 &= 0x1fff;\n        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n        c = d4 >>> 13;\n        d4 &= 0x1fff;\n        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n        c += d4 >>> 13;\n        d4 &= 0x1fff;\n        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n        c = d5 >>> 13;\n        d5 &= 0x1fff;\n        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n        c += d5 >>> 13;\n        d5 &= 0x1fff;\n        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n        c = d6 >>> 13;\n        d6 &= 0x1fff;\n        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n        c += d6 >>> 13;\n        d6 &= 0x1fff;\n        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n        c = d7 >>> 13;\n        d7 &= 0x1fff;\n        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n        c += d7 >>> 13;\n        d7 &= 0x1fff;\n        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n        c = d8 >>> 13;\n        d8 &= 0x1fff;\n        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n        c += d8 >>> 13;\n        d8 &= 0x1fff;\n        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n        c = d9 >>> 13;\n        d9 &= 0x1fff;\n        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n        c += d9 >>> 13;\n        d9 &= 0x1fff;\n        c = ((c << 2) + c) | 0;\n        c = (c + d0) | 0;\n        d0 = c & 0x1fff;\n        c = c >>> 13;\n        d1 += c;\n        h[0] = d0;\n        h[1] = d1;\n        h[2] = d2;\n        h[3] = d3;\n        h[4] = d4;\n        h[5] = d5;\n        h[6] = d6;\n        h[7] = d7;\n        h[8] = d8;\n        h[9] = d9;\n    }\n    finalize() {\n        const { h, pad } = this;\n        const g = new Uint16Array(10);\n        let c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        for (let i = 2; i < 10; i++) {\n            h[i] += c;\n            c = h[i] >>> 13;\n            h[i] &= 0x1fff;\n        }\n        h[0] += c * 5;\n        c = h[0] >>> 13;\n        h[0] &= 0x1fff;\n        h[1] += c;\n        c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        h[2] += c;\n        g[0] = h[0] + 5;\n        c = g[0] >>> 13;\n        g[0] &= 0x1fff;\n        for (let i = 1; i < 10; i++) {\n            g[i] = h[i] + c;\n            c = g[i] >>> 13;\n            g[i] &= 0x1fff;\n        }\n        g[9] -= 1 << 13;\n        let mask = (c ^ 1) - 1;\n        for (let i = 0; i < 10; i++)\n            g[i] &= mask;\n        mask = ~mask;\n        for (let i = 0; i < 10; i++)\n            h[i] = (h[i] & mask) | g[i];\n        h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n        h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n        h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n        h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n        h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n        h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n        h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n        h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n        let f = h[0] + pad[0];\n        h[0] = f & 0xffff;\n        for (let i = 1; i < 8; i++) {\n            f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n            h[i] = f & 0xffff;\n        }\n    }\n    update(data) {\n        (0, _assert_js_1.exists)(this);\n        const { buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input\n            if (take === blockLen) {\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(data, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(buffer, 0, false);\n                this.pos = 0;\n            }\n        }\n        return this;\n    }\n    destroy() {\n        this.h.fill(0);\n        this.r.fill(0);\n        this.buffer.fill(0);\n        this.pad.fill(0);\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.output)(out, this);\n        this.finished = true;\n        const { buffer, h } = this;\n        let { pos } = this;\n        if (pos) {\n            buffer[pos++] = 1;\n            // buffer.subarray(pos).fill(0);\n            for (; pos < 16; pos++)\n                buffer[pos] = 0;\n            this.process(buffer, 0, true);\n        }\n        this.finalize();\n        let opos = 0;\n        for (let i = 0; i < 8; i++) {\n            out[opos++] = h[i] >>> 0;\n            out[opos++] = h[i] >>> 8;\n        }\n        return out;\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n}\nfunction wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key).update((0, utils_js_1.toBytes)(msg)).digest();\n    const tmp = hashCons(new Uint8Array(32));\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key) => hashCons(key);\n    return hashC;\n}\nexports.wrapConstructorWithKey = wrapConstructorWithKey;\nexports.poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));\n//# sourceMappingURL=_poly1305.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL19wb2x5MTMwNS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyw4QkFBOEI7QUFDakQscUJBQXFCLG1CQUFPLENBQUMsNEdBQWM7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsd0dBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9fcG9seTEzMDUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBvbHkxMzA1ID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoS2V5ID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIFBvbHkxMzA1IGlzIGEgZmFzdCBhbmQgcGFyYWxsZWwgc2VjcmV0LWtleSBtZXNzYWdlLWF1dGhlbnRpY2F0aW9uIGNvZGUuXG4vLyBodHRwczovL2NyLnlwLnRvL21hYy5odG1sLCBodHRwczovL2NyLnlwLnRvL21hYy9wb2x5MTMwNS0yMDA1MDMyOS5wZGZcbi8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjODQzOVxuLy8gQmFzZWQgb24gUHVibGljIERvbWFpbiBwb2x5MTMwNS1kb25uYSBodHRwczovL2dpdGh1Yi5jb20vZmxvb2R5YmVycnkvcG9seTEzMDUtZG9ubmFcbmNvbnN0IHU4dG8xNiA9IChhLCBpKSA9PiAoYVtpKytdICYgMHhmZikgfCAoKGFbaSsrXSAmIDB4ZmYpIDw8IDgpO1xuY2xhc3MgUG9seTEzMDUge1xuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gMTY7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMTY7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICB0aGlzLnIgPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICAgICAgICB0aGlzLmggPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICAgICAgICB0aGlzLnBhZCA9IG5ldyBVaW50MTZBcnJheSg4KTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIGtleSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGtleSk7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGtleSwgMzIpO1xuICAgICAgICBjb25zdCB0MCA9IHU4dG8xNihrZXksIDApO1xuICAgICAgICBjb25zdCB0MSA9IHU4dG8xNihrZXksIDIpO1xuICAgICAgICBjb25zdCB0MiA9IHU4dG8xNihrZXksIDQpO1xuICAgICAgICBjb25zdCB0MyA9IHU4dG8xNihrZXksIDYpO1xuICAgICAgICBjb25zdCB0NCA9IHU4dG8xNihrZXksIDgpO1xuICAgICAgICBjb25zdCB0NSA9IHU4dG8xNihrZXksIDEwKTtcbiAgICAgICAgY29uc3QgdDYgPSB1OHRvMTYoa2V5LCAxMik7XG4gICAgICAgIGNvbnN0IHQ3ID0gdTh0bzE2KGtleSwgMTQpO1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvb2R5YmVycnkvcG9seTEzMDUtZG9ubmEvYmxvYi9lNmFkNmUwOTFkMzBkN2Y0ZWMyZDRmOTc4YmUxZmNmY2JjZTcyNzgxL3BvbHkxMzA1LWRvbm5hLTE2LmgjTDQ3XG4gICAgICAgIHRoaXMuclswXSA9IHQwICYgMHgxZmZmO1xuICAgICAgICB0aGlzLnJbMV0gPSAoKHQwID4+PiAxMykgfCAodDEgPDwgMykpICYgMHgxZmZmO1xuICAgICAgICB0aGlzLnJbMl0gPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgNikpICYgMHgxZjAzO1xuICAgICAgICB0aGlzLnJbM10gPSAoKHQyID4+PiA3KSB8ICh0MyA8PCA5KSkgJiAweDFmZmY7XG4gICAgICAgIHRoaXMucls0XSA9ICgodDMgPj4+IDQpIHwgKHQ0IDw8IDEyKSkgJiAweDAwZmY7XG4gICAgICAgIHRoaXMucls1XSA9ICh0NCA+Pj4gMSkgJiAweDFmZmU7XG4gICAgICAgIHRoaXMucls2XSA9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAyKSkgJiAweDFmZmY7XG4gICAgICAgIHRoaXMucls3XSA9ICgodDUgPj4+IDExKSB8ICh0NiA8PCA1KSkgJiAweDFmODE7XG4gICAgICAgIHRoaXMucls4XSA9ICgodDYgPj4+IDgpIHwgKHQ3IDw8IDgpKSAmIDB4MWZmZjtcbiAgICAgICAgdGhpcy5yWzldID0gKHQ3ID4+PiA1KSAmIDB4MDA3ZjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspXG4gICAgICAgICAgICB0aGlzLnBhZFtpXSA9IHU4dG8xNihrZXksIDE2ICsgMiAqIGkpO1xuICAgIH1cbiAgICBwcm9jZXNzKGRhdGEsIG9mZnNldCwgaXNMYXN0ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaGliaXQgPSBpc0xhc3QgPyAwIDogMSA8PCAxMTtcbiAgICAgICAgY29uc3QgeyBoLCByIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCByMCA9IHJbMF07XG4gICAgICAgIGNvbnN0IHIxID0gclsxXTtcbiAgICAgICAgY29uc3QgcjIgPSByWzJdO1xuICAgICAgICBjb25zdCByMyA9IHJbM107XG4gICAgICAgIGNvbnN0IHI0ID0gcls0XTtcbiAgICAgICAgY29uc3QgcjUgPSByWzVdO1xuICAgICAgICBjb25zdCByNiA9IHJbNl07XG4gICAgICAgIGNvbnN0IHI3ID0gcls3XTtcbiAgICAgICAgY29uc3QgcjggPSByWzhdO1xuICAgICAgICBjb25zdCByOSA9IHJbOV07XG4gICAgICAgIGNvbnN0IHQwID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDApO1xuICAgICAgICBjb25zdCB0MSA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyAyKTtcbiAgICAgICAgY29uc3QgdDIgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIGNvbnN0IHQzID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDYpO1xuICAgICAgICBjb25zdCB0NCA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyA4KTtcbiAgICAgICAgY29uc3QgdDUgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMTApO1xuICAgICAgICBjb25zdCB0NiA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyAxMik7XG4gICAgICAgIGNvbnN0IHQ3ID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDE0KTtcbiAgICAgICAgbGV0IGgwID0gaFswXSArICh0MCAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoMSA9IGhbMV0gKyAoKCh0MCA+Pj4gMTMpIHwgKHQxIDw8IDMpKSAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoMiA9IGhbMl0gKyAoKCh0MSA+Pj4gMTApIHwgKHQyIDw8IDYpKSAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoMyA9IGhbM10gKyAoKCh0MiA+Pj4gNykgfCAodDMgPDwgOSkpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg0ID0gaFs0XSArICgoKHQzID4+PiA0KSB8ICh0NCA8PCAxMikpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg1ID0gaFs1XSArICgodDQgPj4+IDEpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg2ID0gaFs2XSArICgoKHQ0ID4+PiAxNCkgfCAodDUgPDwgMikpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg3ID0gaFs3XSArICgoKHQ1ID4+PiAxMSkgfCAodDYgPDwgNSkpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg4ID0gaFs4XSArICgoKHQ2ID4+PiA4KSB8ICh0NyA8PCA4KSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDkgPSBoWzldICsgKCh0NyA+Pj4gNSkgfCBoaWJpdCk7XG4gICAgICAgIGxldCBjID0gMDtcbiAgICAgICAgbGV0IGQwID0gYyArIGgwICogcjAgKyBoMSAqICg1ICogcjkpICsgaDIgKiAoNSAqIHI4KSArIGgzICogKDUgKiByNykgKyBoNCAqICg1ICogcjYpO1xuICAgICAgICBjID0gZDAgPj4+IDEzO1xuICAgICAgICBkMCAmPSAweDFmZmY7XG4gICAgICAgIGQwICs9IGg1ICogKDUgKiByNSkgKyBoNiAqICg1ICogcjQpICsgaDcgKiAoNSAqIHIzKSArIGg4ICogKDUgKiByMikgKyBoOSAqICg1ICogcjEpO1xuICAgICAgICBjICs9IGQwID4+PiAxMztcbiAgICAgICAgZDAgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDEgPSBjICsgaDAgKiByMSArIGgxICogcjAgKyBoMiAqICg1ICogcjkpICsgaDMgKiAoNSAqIHI4KSArIGg0ICogKDUgKiByNyk7XG4gICAgICAgIGMgPSBkMSA+Pj4gMTM7XG4gICAgICAgIGQxICY9IDB4MWZmZjtcbiAgICAgICAgZDEgKz0gaDUgKiAoNSAqIHI2KSArIGg2ICogKDUgKiByNSkgKyBoNyAqICg1ICogcjQpICsgaDggKiAoNSAqIHIzKSArIGg5ICogKDUgKiByMik7XG4gICAgICAgIGMgKz0gZDEgPj4+IDEzO1xuICAgICAgICBkMSAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkMiA9IGMgKyBoMCAqIHIyICsgaDEgKiByMSArIGgyICogcjAgKyBoMyAqICg1ICogcjkpICsgaDQgKiAoNSAqIHI4KTtcbiAgICAgICAgYyA9IGQyID4+PiAxMztcbiAgICAgICAgZDIgJj0gMHgxZmZmO1xuICAgICAgICBkMiArPSBoNSAqICg1ICogcjcpICsgaDYgKiAoNSAqIHI2KSArIGg3ICogKDUgKiByNSkgKyBoOCAqICg1ICogcjQpICsgaDkgKiAoNSAqIHIzKTtcbiAgICAgICAgYyArPSBkMiA+Pj4gMTM7XG4gICAgICAgIGQyICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQzID0gYyArIGgwICogcjMgKyBoMSAqIHIyICsgaDIgKiByMSArIGgzICogcjAgKyBoNCAqICg1ICogcjkpO1xuICAgICAgICBjID0gZDMgPj4+IDEzO1xuICAgICAgICBkMyAmPSAweDFmZmY7XG4gICAgICAgIGQzICs9IGg1ICogKDUgKiByOCkgKyBoNiAqICg1ICogcjcpICsgaDcgKiAoNSAqIHI2KSArIGg4ICogKDUgKiByNSkgKyBoOSAqICg1ICogcjQpO1xuICAgICAgICBjICs9IGQzID4+PiAxMztcbiAgICAgICAgZDMgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDQgPSBjICsgaDAgKiByNCArIGgxICogcjMgKyBoMiAqIHIyICsgaDMgKiByMSArIGg0ICogcjA7XG4gICAgICAgIGMgPSBkNCA+Pj4gMTM7XG4gICAgICAgIGQ0ICY9IDB4MWZmZjtcbiAgICAgICAgZDQgKz0gaDUgKiAoNSAqIHI5KSArIGg2ICogKDUgKiByOCkgKyBoNyAqICg1ICogcjcpICsgaDggKiAoNSAqIHI2KSArIGg5ICogKDUgKiByNSk7XG4gICAgICAgIGMgKz0gZDQgPj4+IDEzO1xuICAgICAgICBkNCAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkNSA9IGMgKyBoMCAqIHI1ICsgaDEgKiByNCArIGgyICogcjMgKyBoMyAqIHIyICsgaDQgKiByMTtcbiAgICAgICAgYyA9IGQ1ID4+PiAxMztcbiAgICAgICAgZDUgJj0gMHgxZmZmO1xuICAgICAgICBkNSArPSBoNSAqIHIwICsgaDYgKiAoNSAqIHI5KSArIGg3ICogKDUgKiByOCkgKyBoOCAqICg1ICogcjcpICsgaDkgKiAoNSAqIHI2KTtcbiAgICAgICAgYyArPSBkNSA+Pj4gMTM7XG4gICAgICAgIGQ1ICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQ2ID0gYyArIGgwICogcjYgKyBoMSAqIHI1ICsgaDIgKiByNCArIGgzICogcjMgKyBoNCAqIHIyO1xuICAgICAgICBjID0gZDYgPj4+IDEzO1xuICAgICAgICBkNiAmPSAweDFmZmY7XG4gICAgICAgIGQ2ICs9IGg1ICogcjEgKyBoNiAqIHIwICsgaDcgKiAoNSAqIHI5KSArIGg4ICogKDUgKiByOCkgKyBoOSAqICg1ICogcjcpO1xuICAgICAgICBjICs9IGQ2ID4+PiAxMztcbiAgICAgICAgZDYgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDcgPSBjICsgaDAgKiByNyArIGgxICogcjYgKyBoMiAqIHI1ICsgaDMgKiByNCArIGg0ICogcjM7XG4gICAgICAgIGMgPSBkNyA+Pj4gMTM7XG4gICAgICAgIGQ3ICY9IDB4MWZmZjtcbiAgICAgICAgZDcgKz0gaDUgKiByMiArIGg2ICogcjEgKyBoNyAqIHIwICsgaDggKiAoNSAqIHI5KSArIGg5ICogKDUgKiByOCk7XG4gICAgICAgIGMgKz0gZDcgPj4+IDEzO1xuICAgICAgICBkNyAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkOCA9IGMgKyBoMCAqIHI4ICsgaDEgKiByNyArIGgyICogcjYgKyBoMyAqIHI1ICsgaDQgKiByNDtcbiAgICAgICAgYyA9IGQ4ID4+PiAxMztcbiAgICAgICAgZDggJj0gMHgxZmZmO1xuICAgICAgICBkOCArPSBoNSAqIHIzICsgaDYgKiByMiArIGg3ICogcjEgKyBoOCAqIHIwICsgaDkgKiAoNSAqIHI5KTtcbiAgICAgICAgYyArPSBkOCA+Pj4gMTM7XG4gICAgICAgIGQ4ICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQ5ID0gYyArIGgwICogcjkgKyBoMSAqIHI4ICsgaDIgKiByNyArIGgzICogcjYgKyBoNCAqIHI1O1xuICAgICAgICBjID0gZDkgPj4+IDEzO1xuICAgICAgICBkOSAmPSAweDFmZmY7XG4gICAgICAgIGQ5ICs9IGg1ICogcjQgKyBoNiAqIHIzICsgaDcgKiByMiArIGg4ICogcjEgKyBoOSAqIHIwO1xuICAgICAgICBjICs9IGQ5ID4+PiAxMztcbiAgICAgICAgZDkgJj0gMHgxZmZmO1xuICAgICAgICBjID0gKChjIDw8IDIpICsgYykgfCAwO1xuICAgICAgICBjID0gKGMgKyBkMCkgfCAwO1xuICAgICAgICBkMCA9IGMgJiAweDFmZmY7XG4gICAgICAgIGMgPSBjID4+PiAxMztcbiAgICAgICAgZDEgKz0gYztcbiAgICAgICAgaFswXSA9IGQwO1xuICAgICAgICBoWzFdID0gZDE7XG4gICAgICAgIGhbMl0gPSBkMjtcbiAgICAgICAgaFszXSA9IGQzO1xuICAgICAgICBoWzRdID0gZDQ7XG4gICAgICAgIGhbNV0gPSBkNTtcbiAgICAgICAgaFs2XSA9IGQ2O1xuICAgICAgICBoWzddID0gZDc7XG4gICAgICAgIGhbOF0gPSBkODtcbiAgICAgICAgaFs5XSA9IGQ5O1xuICAgIH1cbiAgICBmaW5hbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgeyBoLCBwYWQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGcgPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICAgICAgICBsZXQgYyA9IGhbMV0gPj4+IDEzO1xuICAgICAgICBoWzFdICY9IDB4MWZmZjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICBoW2ldICs9IGM7XG4gICAgICAgICAgICBjID0gaFtpXSA+Pj4gMTM7XG4gICAgICAgICAgICBoW2ldICY9IDB4MWZmZjtcbiAgICAgICAgfVxuICAgICAgICBoWzBdICs9IGMgKiA1O1xuICAgICAgICBjID0gaFswXSA+Pj4gMTM7XG4gICAgICAgIGhbMF0gJj0gMHgxZmZmO1xuICAgICAgICBoWzFdICs9IGM7XG4gICAgICAgIGMgPSBoWzFdID4+PiAxMztcbiAgICAgICAgaFsxXSAmPSAweDFmZmY7XG4gICAgICAgIGhbMl0gKz0gYztcbiAgICAgICAgZ1swXSA9IGhbMF0gKyA1O1xuICAgICAgICBjID0gZ1swXSA+Pj4gMTM7XG4gICAgICAgIGdbMF0gJj0gMHgxZmZmO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgIGdbaV0gPSBoW2ldICsgYztcbiAgICAgICAgICAgIGMgPSBnW2ldID4+PiAxMztcbiAgICAgICAgICAgIGdbaV0gJj0gMHgxZmZmO1xuICAgICAgICB9XG4gICAgICAgIGdbOV0gLT0gMSA8PCAxMztcbiAgICAgICAgbGV0IG1hc2sgPSAoYyBeIDEpIC0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKVxuICAgICAgICAgICAgZ1tpXSAmPSBtYXNrO1xuICAgICAgICBtYXNrID0gfm1hc2s7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKylcbiAgICAgICAgICAgIGhbaV0gPSAoaFtpXSAmIG1hc2spIHwgZ1tpXTtcbiAgICAgICAgaFswXSA9IChoWzBdIHwgKGhbMV0gPDwgMTMpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFsxXSA9ICgoaFsxXSA+Pj4gMykgfCAoaFsyXSA8PCAxMCkpICYgMHhmZmZmO1xuICAgICAgICBoWzJdID0gKChoWzJdID4+PiA2KSB8IChoWzNdIDw8IDcpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFszXSA9ICgoaFszXSA+Pj4gOSkgfCAoaFs0XSA8PCA0KSkgJiAweGZmZmY7XG4gICAgICAgIGhbNF0gPSAoKGhbNF0gPj4+IDEyKSB8IChoWzVdIDw8IDEpIHwgKGhbNl0gPDwgMTQpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFs1XSA9ICgoaFs2XSA+Pj4gMikgfCAoaFs3XSA8PCAxMSkpICYgMHhmZmZmO1xuICAgICAgICBoWzZdID0gKChoWzddID4+PiA1KSB8IChoWzhdIDw8IDgpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFs3XSA9ICgoaFs4XSA+Pj4gOCkgfCAoaFs5XSA8PCA1KSkgJiAweGZmZmY7XG4gICAgICAgIGxldCBmID0gaFswXSArIHBhZFswXTtcbiAgICAgICAgaFswXSA9IGYgJiAweGZmZmY7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBmID0gKCgoaFtpXSArIHBhZFtpXSkgfCAwKSArIChmID4+PiAxNikpIHwgMDtcbiAgICAgICAgICAgIGhbaV0gPSBmICYgMHhmZmZmO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXRcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGEsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhidWZmZXIsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaC5maWxsKDApO1xuICAgICAgICB0aGlzLnIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5wYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLm91dHB1dCkob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBoIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwb3MpIHtcbiAgICAgICAgICAgIGJ1ZmZlcltwb3MrK10gPSAxO1xuICAgICAgICAgICAgLy8gYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgICAgIGZvciAoOyBwb3MgPCAxNjsgcG9zKyspXG4gICAgICAgICAgICAgICAgYnVmZmVyW3Bvc10gPSAwO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGJ1ZmZlciwgMCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgICAgICBsZXQgb3BvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbb3BvcysrXSA9IGhbaV0gPj4+IDA7XG4gICAgICAgICAgICBvdXRbb3BvcysrXSA9IGhbaV0gPj4+IDg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhLZXkoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIGtleSkgPT4gaGFzaENvbnMoa2V5KS51cGRhdGUoKDAsIHV0aWxzX2pzXzEudG9CeXRlcykobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMobmV3IFVpbnQ4QXJyYXkoMzIpKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChrZXkpID0+IGhhc2hDb25zKGtleSk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoS2V5ID0gd3JhcENvbnN0cnVjdG9yV2l0aEtleTtcbmV4cG9ydHMucG9seTEzMDUgPSB3cmFwQ29uc3RydWN0b3JXaXRoS2V5KChrZXkpID0+IG5ldyBQb2x5MTMwNShrZXkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9wb2x5MTMwNS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_poly1305.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_polyval.js":
/*!***************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/ciphers/_polyval.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.polyval = exports.ghash = exports._toGHASHKey = void 0;\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/utils.js\");\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_assert.js\");\n// GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n// Implemented in terms of GHash with conversion function for keys\n// GCM GHASH from NIST SP800-38d, SIV from RFC 8452.\n// https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\n// GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n// POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\nconst BLOCK_SIZE = 16;\n// TODO: rewrite\n// temporary padding buffer\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\nconst ZEROS32 = (0, utils_js_1.u32)(ZEROS16);\nconst POLY = 0xe1; // v = 2*v % POLY\n// v = 2*v % POLY\n// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\nconst mul2 = (s0, s1, s2, s3) => {\n    const hiBit = s3 & 1;\n    return {\n        s3: (s2 << 31) | (s3 >>> 1),\n        s2: (s1 << 31) | (s2 >>> 1),\n        s1: (s0 << 31) | (s1 >>> 1),\n        s0: (s0 >>> 1) ^ ((POLY << 24) & -(hiBit & 1)), // reduce % poly\n    };\n};\nconst swapLE = (n) => (((n >>> 0) & 0xff) << 24) |\n    (((n >>> 8) & 0xff) << 16) |\n    (((n >>> 16) & 0xff) << 8) |\n    ((n >>> 24) & 0xff) |\n    0;\n/**\n * `mulX_POLYVAL(ByteReverse(H))` from spec\n * @param k mutated in place\n */\nfunction _toGHASHKey(k) {\n    k.reverse();\n    const hiBit = k[15] & 1;\n    // k >>= 1\n    let carry = 0;\n    for (let i = 0; i < k.length; i++) {\n        const t = k[i];\n        k[i] = (t >>> 1) | carry;\n        carry = (t & 1) << 7;\n    }\n    k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n    return k;\n}\nexports._toGHASHKey = _toGHASHKey;\nconst estimateWindow = (bytes) => {\n    if (bytes > 64 * 1024)\n        return 8;\n    if (bytes > 1024)\n        return 4;\n    return 2;\n};\nclass GHASH {\n    // We select bits per window adaptively based on expectedLength\n    constructor(key, expectedLength) {\n        this.blockLen = BLOCK_SIZE;\n        this.outputLen = BLOCK_SIZE;\n        this.s0 = 0;\n        this.s1 = 0;\n        this.s2 = 0;\n        this.s3 = 0;\n        this.finished = false;\n        key = (0, utils_js_1.toBytes)(key);\n        (0, _assert_js_1.bytes)(key, 16);\n        const kView = (0, utils_js_1.createView)(key);\n        let k0 = kView.getUint32(0, false);\n        let k1 = kView.getUint32(4, false);\n        let k2 = kView.getUint32(8, false);\n        let k3 = kView.getUint32(12, false);\n        // generate table of doubled keys (half of montgomery ladder)\n        const doubles = [];\n        for (let i = 0; i < 128; i++) {\n            doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });\n            ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));\n        }\n        const W = estimateWindow(expectedLength || 1024);\n        if (![1, 2, 4, 8].includes(W))\n            throw new Error(`ghash: wrong window size=${W}, should be 2, 4 or 8`);\n        this.W = W;\n        const bits = 128; // always 128 bits;\n        const windows = bits / W;\n        const windowSize = (this.windowSize = 2 ** W);\n        const items = [];\n        // Create precompute table for window of W bits\n        for (let w = 0; w < windows; w++) {\n            // truth table: 00, 01, 10, 11\n            for (let byte = 0; byte < windowSize; byte++) {\n                // prettier-ignore\n                let s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n                for (let j = 0; j < W; j++) {\n                    const bit = (byte >>> (W - j - 1)) & 1;\n                    if (!bit)\n                        continue;\n                    const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];\n                    (s0 ^= d0), (s1 ^= d1), (s2 ^= d2), (s3 ^= d3);\n                }\n                items.push({ s0, s1, s2, s3 });\n            }\n        }\n        this.t = items;\n    }\n    _updateBlock(s0, s1, s2, s3) {\n        (s0 ^= this.s0), (s1 ^= this.s1), (s2 ^= this.s2), (s3 ^= this.s3);\n        const { W, t, windowSize } = this;\n        // prettier-ignore\n        let o0 = 0, o1 = 0, o2 = 0, o3 = 0;\n        const mask = (1 << W) - 1; // 2**W will kill performance.\n        let w = 0;\n        for (const num of [s0, s1, s2, s3]) {\n            for (let bytePos = 0; bytePos < 4; bytePos++) {\n                const byte = (num >>> (8 * bytePos)) & 0xff;\n                for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {\n                    const bit = (byte >>> (W * bitPos)) & mask;\n                    const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];\n                    (o0 ^= e0), (o1 ^= e1), (o2 ^= e2), (o3 ^= e3);\n                    w += 1;\n                }\n            }\n        }\n        this.s0 = o0;\n        this.s1 = o1;\n        this.s2 = o2;\n        this.s3 = o3;\n    }\n    update(data) {\n        data = (0, utils_js_1.toBytes)(data);\n        (0, _assert_js_1.exists)(this);\n        const b32 = (0, utils_js_1.u32)(data);\n        const blocks = Math.floor(data.length / BLOCK_SIZE);\n        const left = data.length % BLOCK_SIZE;\n        for (let i = 0; i < blocks; i++) {\n            this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n        }\n        if (left) {\n            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n            this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);\n            ZEROS32.fill(0); // clean tmp buffer\n        }\n        return this;\n    }\n    destroy() {\n        const { t } = this;\n        // clean precompute table\n        for (const elm of t) {\n            (elm.s0 = 0), (elm.s1 = 0), (elm.s2 = 0), (elm.s3 = 0);\n        }\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.output)(out, this);\n        this.finished = true;\n        const { s0, s1, s2, s3 } = this;\n        const o32 = (0, utils_js_1.u32)(out);\n        o32[0] = s0;\n        o32[1] = s1;\n        o32[2] = s2;\n        o32[3] = s3;\n        return out;\n    }\n    digest() {\n        const res = new Uint8Array(BLOCK_SIZE);\n        this.digestInto(res);\n        this.destroy();\n        return res;\n    }\n}\nclass Polyval extends GHASH {\n    constructor(key, expectedLength) {\n        key = (0, utils_js_1.toBytes)(key);\n        const ghKey = _toGHASHKey(key.slice());\n        super(ghKey, expectedLength);\n        ghKey.fill(0);\n    }\n    update(data) {\n        data = (0, utils_js_1.toBytes)(data);\n        (0, _assert_js_1.exists)(this);\n        const b32 = (0, utils_js_1.u32)(data);\n        const left = data.length % BLOCK_SIZE;\n        const blocks = Math.floor(data.length / BLOCK_SIZE);\n        for (let i = 0; i < blocks; i++) {\n            this._updateBlock(swapLE(b32[i * 4 + 3]), swapLE(b32[i * 4 + 2]), swapLE(b32[i * 4 + 1]), swapLE(b32[i * 4 + 0]));\n        }\n        if (left) {\n            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n            this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));\n            ZEROS32.fill(0); // clean tmp buffer\n        }\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.output)(out, this);\n        this.finished = true;\n        // tmp ugly hack\n        const { s0, s1, s2, s3 } = this;\n        const o32 = (0, utils_js_1.u32)(out);\n        o32[0] = s0;\n        o32[1] = s1;\n        o32[2] = s2;\n        o32[3] = s3;\n        return out.reverse();\n    }\n}\nfunction wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key, msg.length).update((0, utils_js_1.toBytes)(msg)).digest();\n    const tmp = hashCons(new Uint8Array(16), 0);\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key, expectedLength) => hashCons(key, expectedLength);\n    return hashC;\n}\nexports.ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));\nexports.polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));\n//# sourceMappingURL=_polyval.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL19wb2x5dmFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxhQUFhLEdBQUcsbUJBQW1CO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLHdHQUFZO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLDRHQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDLDJCQUEyQixnRUFBZ0U7QUFDM0YsZUFBZSxpQ0FBaUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEVBQUU7QUFDMUQ7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZUFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL19wb2x5dmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wb2x5dmFsID0gZXhwb3J0cy5naGFzaCA9IGV4cG9ydHMuX3RvR0hBU0hLZXkgPSB2b2lkIDA7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuLy8gR0hhc2ggZnJvbSBBRVMtR0NNIGFuZCBpdHMgbGl0dGxlLWVuZGlhbiBcIm1pcnJvciBpbWFnZVwiIFBvbHl2YWwgZnJvbSBBRVMtU0lWLlxuLy8gSW1wbGVtZW50ZWQgaW4gdGVybXMgb2YgR0hhc2ggd2l0aCBjb252ZXJzaW9uIGZ1bmN0aW9uIGZvciBrZXlzXG4vLyBHQ00gR0hBU0ggZnJvbSBOSVNUIFNQODAwLTM4ZCwgU0lWIGZyb20gUkZDIDg0NTIuXG4vLyBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvTGVnYWN5L1NQL25pc3RzcGVjaWFscHVibGljYXRpb244MDAtMzhkLnBkZlxuLy8gR0hBU0ggICBtb2R1bG86IHheMTI4ICsgeF43ICAgKyB4XjIgICArIHggICAgICsgMVxuLy8gUE9MWVZBTCBtb2R1bG86IHheMTI4ICsgeF4xMjcgKyB4XjEyNiArIHheMTIxICsgMVxuY29uc3QgQkxPQ0tfU0laRSA9IDE2O1xuLy8gVE9ETzogcmV3cml0ZVxuLy8gdGVtcG9yYXJ5IHBhZGRpbmcgYnVmZmVyXG5jb25zdCBaRVJPUzE2ID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50OEFycmF5KDE2KTtcbmNvbnN0IFpFUk9TMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKFpFUk9TMTYpO1xuY29uc3QgUE9MWSA9IDB4ZTE7IC8vIHYgPSAyKnYgJSBQT0xZXG4vLyB2ID0gMip2ICUgUE9MWVxuLy8gTk9URTogYmVjYXVzZSB4ICsgeCA9IDAgKGFkZC9zdWIgaXMgc2FtZSksIG11bDIoeCkgIT0geCt4XG4vLyBXZSBjYW4gbXVsdGlwbHkgYW55IG51bWJlciB1c2luZyBtb250Z29tZXJ5IGxhZGRlciBhbmQgdGhpcyBmdW5jdGlvbiAod29ya3MgYXMgZG91YmxlLCBhZGQgaXMgc2ltcGxlIHhvcilcbmNvbnN0IG11bDIgPSAoczAsIHMxLCBzMiwgczMpID0+IHtcbiAgICBjb25zdCBoaUJpdCA9IHMzICYgMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzMzogKHMyIDw8IDMxKSB8IChzMyA+Pj4gMSksXG4gICAgICAgIHMyOiAoczEgPDwgMzEpIHwgKHMyID4+PiAxKSxcbiAgICAgICAgczE6IChzMCA8PCAzMSkgfCAoczEgPj4+IDEpLFxuICAgICAgICBzMDogKHMwID4+PiAxKSBeICgoUE9MWSA8PCAyNCkgJiAtKGhpQml0ICYgMSkpLCAvLyByZWR1Y2UgJSBwb2x5XG4gICAgfTtcbn07XG5jb25zdCBzd2FwTEUgPSAobikgPT4gKCgobiA+Pj4gMCkgJiAweGZmKSA8PCAyNCkgfFxuICAgICgoKG4gPj4+IDgpICYgMHhmZikgPDwgMTYpIHxcbiAgICAoKChuID4+PiAxNikgJiAweGZmKSA8PCA4KSB8XG4gICAgKChuID4+PiAyNCkgJiAweGZmKSB8XG4gICAgMDtcbi8qKlxuICogYG11bFhfUE9MWVZBTChCeXRlUmV2ZXJzZShIKSlgIGZyb20gc3BlY1xuICogQHBhcmFtIGsgbXV0YXRlZCBpbiBwbGFjZVxuICovXG5mdW5jdGlvbiBfdG9HSEFTSEtleShrKSB7XG4gICAgay5yZXZlcnNlKCk7XG4gICAgY29uc3QgaGlCaXQgPSBrWzE1XSAmIDE7XG4gICAgLy8gayA+Pj0gMVxuICAgIGxldCBjYXJyeSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHQgPSBrW2ldO1xuICAgICAgICBrW2ldID0gKHQgPj4+IDEpIHwgY2Fycnk7XG4gICAgICAgIGNhcnJ5ID0gKHQgJiAxKSA8PCA3O1xuICAgIH1cbiAgICBrWzBdIF49IC1oaUJpdCAmIDB4ZTE7IC8vIGlmIChoaUJpdCkgbiBePSAweGUxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwO1xuICAgIHJldHVybiBrO1xufVxuZXhwb3J0cy5fdG9HSEFTSEtleSA9IF90b0dIQVNIS2V5O1xuY29uc3QgZXN0aW1hdGVXaW5kb3cgPSAoYnl0ZXMpID0+IHtcbiAgICBpZiAoYnl0ZXMgPiA2NCAqIDEwMjQpXG4gICAgICAgIHJldHVybiA4O1xuICAgIGlmIChieXRlcyA+IDEwMjQpXG4gICAgICAgIHJldHVybiA0O1xuICAgIHJldHVybiAyO1xufTtcbmNsYXNzIEdIQVNIIHtcbiAgICAvLyBXZSBzZWxlY3QgYml0cyBwZXIgd2luZG93IGFkYXB0aXZlbHkgYmFzZWQgb24gZXhwZWN0ZWRMZW5ndGhcbiAgICBjb25zdHJ1Y3RvcihrZXksIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBCTE9DS19TSVpFO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IEJMT0NLX1NJWkU7XG4gICAgICAgIHRoaXMuczAgPSAwO1xuICAgICAgICB0aGlzLnMxID0gMDtcbiAgICAgICAgdGhpcy5zMiA9IDA7XG4gICAgICAgIHRoaXMuczMgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIGtleSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGtleSk7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGtleSwgMTYpO1xuICAgICAgICBjb25zdCBrVmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKGtleSk7XG4gICAgICAgIGxldCBrMCA9IGtWaWV3LmdldFVpbnQzMigwLCBmYWxzZSk7XG4gICAgICAgIGxldCBrMSA9IGtWaWV3LmdldFVpbnQzMig0LCBmYWxzZSk7XG4gICAgICAgIGxldCBrMiA9IGtWaWV3LmdldFVpbnQzMig4LCBmYWxzZSk7XG4gICAgICAgIGxldCBrMyA9IGtWaWV3LmdldFVpbnQzMigxMiwgZmFsc2UpO1xuICAgICAgICAvLyBnZW5lcmF0ZSB0YWJsZSBvZiBkb3VibGVkIGtleXMgKGhhbGYgb2YgbW9udGdvbWVyeSBsYWRkZXIpXG4gICAgICAgIGNvbnN0IGRvdWJsZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgICAgICAgICAgZG91Ymxlcy5wdXNoKHsgczA6IHN3YXBMRShrMCksIHMxOiBzd2FwTEUoazEpLCBzMjogc3dhcExFKGsyKSwgczM6IHN3YXBMRShrMykgfSk7XG4gICAgICAgICAgICAoeyBzMDogazAsIHMxOiBrMSwgczI6IGsyLCBzMzogazMgfSA9IG11bDIoazAsIGsxLCBrMiwgazMpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBXID0gZXN0aW1hdGVXaW5kb3coZXhwZWN0ZWRMZW5ndGggfHwgMTAyNCk7XG4gICAgICAgIGlmICghWzEsIDIsIDQsIDhdLmluY2x1ZGVzKFcpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBnaGFzaDogd3Jvbmcgd2luZG93IHNpemU9JHtXfSwgc2hvdWxkIGJlIDIsIDQgb3IgOGApO1xuICAgICAgICB0aGlzLlcgPSBXO1xuICAgICAgICBjb25zdCBiaXRzID0gMTI4OyAvLyBhbHdheXMgMTI4IGJpdHM7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBiaXRzIC8gVztcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9ICh0aGlzLndpbmRvd1NpemUgPSAyICoqIFcpO1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICAvLyBDcmVhdGUgcHJlY29tcHV0ZSB0YWJsZSBmb3Igd2luZG93IG9mIFcgYml0c1xuICAgICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IHdpbmRvd3M7IHcrKykge1xuICAgICAgICAgICAgLy8gdHJ1dGggdGFibGU6IDAwLCAwMSwgMTAsIDExXG4gICAgICAgICAgICBmb3IgKGxldCBieXRlID0gMDsgYnl0ZSA8IHdpbmRvd1NpemU7IGJ5dGUrKykge1xuICAgICAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgICAgIGxldCBzMCA9IDAsIHMxID0gMCwgczIgPSAwLCBzMyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBXOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYml0ID0gKGJ5dGUgPj4+IChXIC0gaiAtIDEpKSAmIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYml0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgczA6IGQwLCBzMTogZDEsIHMyOiBkMiwgczM6IGQzIH0gPSBkb3VibGVzW1cgKiB3ICsgal07XG4gICAgICAgICAgICAgICAgICAgIChzMCBePSBkMCksIChzMSBePSBkMSksIChzMiBePSBkMiksIChzMyBePSBkMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goeyBzMCwgczEsIHMyLCBzMyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnQgPSBpdGVtcztcbiAgICB9XG4gICAgX3VwZGF0ZUJsb2NrKHMwLCBzMSwgczIsIHMzKSB7XG4gICAgICAgIChzMCBePSB0aGlzLnMwKSwgKHMxIF49IHRoaXMuczEpLCAoczIgXj0gdGhpcy5zMiksIChzMyBePSB0aGlzLnMzKTtcbiAgICAgICAgY29uc3QgeyBXLCB0LCB3aW5kb3dTaXplIH0gPSB0aGlzO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IG8wID0gMCwgbzEgPSAwLCBvMiA9IDAsIG8zID0gMDtcbiAgICAgICAgY29uc3QgbWFzayA9ICgxIDw8IFcpIC0gMTsgLy8gMioqVyB3aWxsIGtpbGwgcGVyZm9ybWFuY2UuXG4gICAgICAgIGxldCB3ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBudW0gb2YgW3MwLCBzMSwgczIsIHMzXSkge1xuICAgICAgICAgICAgZm9yIChsZXQgYnl0ZVBvcyA9IDA7IGJ5dGVQb3MgPCA0OyBieXRlUG9zKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlID0gKG51bSA+Pj4gKDggKiBieXRlUG9zKSkgJiAweGZmO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGJpdFBvcyA9IDggLyBXIC0gMTsgYml0UG9zID49IDA7IGJpdFBvcy0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IChieXRlID4+PiAoVyAqIGJpdFBvcykpICYgbWFzaztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzMDogZTAsIHMxOiBlMSwgczI6IGUyLCBzMzogZTMgfSA9IHRbdyAqIHdpbmRvd1NpemUgKyBiaXRdO1xuICAgICAgICAgICAgICAgICAgICAobzAgXj0gZTApLCAobzEgXj0gZTEpLCAobzIgXj0gZTIpLCAobzMgXj0gZTMpO1xuICAgICAgICAgICAgICAgICAgICB3ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuczAgPSBvMDtcbiAgICAgICAgdGhpcy5zMSA9IG8xO1xuICAgICAgICB0aGlzLnMyID0gbzI7XG4gICAgICAgIHRoaXMuczMgPSBvMztcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcyk7XG4gICAgICAgIGNvbnN0IGIzMiA9ICgwLCB1dGlsc19qc18xLnUzMikoZGF0YSk7XG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IE1hdGguZmxvb3IoZGF0YS5sZW5ndGggLyBCTE9DS19TSVpFKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IGRhdGEubGVuZ3RoICUgQkxPQ0tfU0laRTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3M7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQmxvY2soYjMyW2kgKiA0ICsgMF0sIGIzMltpICogNCArIDFdLCBiMzJbaSAqIDQgKyAyXSwgYjMyW2kgKiA0ICsgM10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgICAgICBaRVJPUzE2LnNldChkYXRhLnN1YmFycmF5KGJsb2NrcyAqIEJMT0NLX1NJWkUpKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJsb2NrKFpFUk9TMzJbMF0sIFpFUk9TMzJbMV0sIFpFUk9TMzJbMl0sIFpFUk9TMzJbM10pO1xuICAgICAgICAgICAgWkVST1MzMi5maWxsKDApOyAvLyBjbGVhbiB0bXAgYnVmZmVyXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IHsgdCB9ID0gdGhpcztcbiAgICAgICAgLy8gY2xlYW4gcHJlY29tcHV0ZSB0YWJsZVxuICAgICAgICBmb3IgKGNvbnN0IGVsbSBvZiB0KSB7XG4gICAgICAgICAgICAoZWxtLnMwID0gMCksIChlbG0uczEgPSAwKSwgKGVsbS5zMiA9IDApLCAoZWxtLnMzID0gMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLm91dHB1dCkob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgczAsIHMxLCBzMiwgczMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG8zMiA9ICgwLCB1dGlsc19qc18xLnUzMikob3V0KTtcbiAgICAgICAgbzMyWzBdID0gczA7XG4gICAgICAgIG8zMlsxXSA9IHMxO1xuICAgICAgICBvMzJbMl0gPSBzMjtcbiAgICAgICAgbzMyWzNdID0gczM7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoQkxPQ0tfU0laRSk7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhyZXMpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5jbGFzcyBQb2x5dmFsIGV4dGVuZHMgR0hBU0gge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAga2V5ID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoa2V5KTtcbiAgICAgICAgY29uc3QgZ2hLZXkgPSBfdG9HSEFTSEtleShrZXkuc2xpY2UoKSk7XG4gICAgICAgIHN1cGVyKGdoS2V5LCBleHBlY3RlZExlbmd0aCk7XG4gICAgICAgIGdoS2V5LmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGRhdGEgPSAoMCwgdXRpbHNfanNfMS50b0J5dGVzKShkYXRhKTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICBjb25zdCBiMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGRhdGEpO1xuICAgICAgICBjb25zdCBsZWZ0ID0gZGF0YS5sZW5ndGggJSBCTE9DS19TSVpFO1xuICAgICAgICBjb25zdCBibG9ja3MgPSBNYXRoLmZsb29yKGRhdGEubGVuZ3RoIC8gQkxPQ0tfU0laRSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJsb2NrKHN3YXBMRShiMzJbaSAqIDQgKyAzXSksIHN3YXBMRShiMzJbaSAqIDQgKyAyXSksIHN3YXBMRShiMzJbaSAqIDQgKyAxXSksIHN3YXBMRShiMzJbaSAqIDQgKyAwXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgICAgICBaRVJPUzE2LnNldChkYXRhLnN1YmFycmF5KGJsb2NrcyAqIEJMT0NLX1NJWkUpKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJsb2NrKHN3YXBMRShaRVJPUzMyWzNdKSwgc3dhcExFKFpFUk9TMzJbMl0pLCBzd2FwTEUoWkVST1MzMlsxXSksIHN3YXBMRShaRVJPUzMyWzBdKSk7XG4gICAgICAgICAgICBaRVJPUzMyLmZpbGwoMCk7IC8vIGNsZWFuIHRtcCBidWZmZXJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLm91dHB1dCkob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIHRtcCB1Z2x5IGhhY2tcbiAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbzMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShvdXQpO1xuICAgICAgICBvMzJbMF0gPSBzMDtcbiAgICAgICAgbzMyWzFdID0gczE7XG4gICAgICAgIG8zMlsyXSA9IHMyO1xuICAgICAgICBvMzJbM10gPSBzMztcbiAgICAgICAgcmV0dXJuIG91dC5yZXZlcnNlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aEtleShoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywga2V5KSA9PiBoYXNoQ29ucyhrZXksIG1zZy5sZW5ndGgpLnVwZGF0ZSgoMCwgdXRpbHNfanNfMS50b0J5dGVzKShtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyhuZXcgVWludDhBcnJheSgxNiksIDApO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKGtleSwgZXhwZWN0ZWRMZW5ndGgpID0+IGhhc2hDb25zKGtleSwgZXhwZWN0ZWRMZW5ndGgpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMuZ2hhc2ggPSB3cmFwQ29uc3RydWN0b3JXaXRoS2V5KChrZXksIGV4cGVjdGVkTGVuZ3RoKSA9PiBuZXcgR0hBU0goa2V5LCBleHBlY3RlZExlbmd0aCkpO1xuZXhwb3J0cy5wb2x5dmFsID0gd3JhcENvbnN0cnVjdG9yV2l0aEtleSgoa2V5LCBleHBlY3RlZExlbmd0aCkgPT4gbmV3IFBvbHl2YWwoa2V5LCBleHBlY3RlZExlbmd0aCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3BvbHl2YWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_polyval.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/aes.js":
/*!**********************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/ciphers/aes.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unsafe = exports.siv = exports.gcm = exports.cfb = exports.cbc = exports.ecb = exports.ctr = exports.expandKeyDecLE = exports.expandKeyLE = void 0;\n// prettier-ignore\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/utils.js\");\nconst _polyval_js_1 = __webpack_require__(/*! ./_polyval.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_polyval.js\");\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_assert.js\");\n/*\nAES (Advanced Encryption Standard) aka Rijndael block cipher.\n\nData is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256 bits). In every round:\n1. **S-box**, table substitution\n2. **Shift rows**, cyclic shift left of all rows of data array\n3. **Mix columns**, multiplying every column by fixed polynomial\n4. **Add round key**, round_key xor i-th column of array\n\nResources:\n- FIPS-197 https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf\n- Original proposal: https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf\n*/\nconst BLOCK_SIZE = 16;\nconst BLOCK_SIZE32 = 4;\nconst EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE);\nconst POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n// TODO: remove multiplication, binary ops only\nfunction mul2(n) {\n    return (n << 1) ^ (POLY & -(n >> 7));\n}\nfunction mul(a, b) {\n    let res = 0;\n    for (; b > 0; b >>= 1) {\n        // Montgomery ladder\n        res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n        a = mul2(a); // a = 2*a\n    }\n    return res;\n}\n// AES S-box is generated using finite field inversion,\n// an affine transform, and xor of a constant 0x63.\nconst sbox = /* @__PURE__ */ (() => {\n    let t = new Uint8Array(256);\n    for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x))\n        t[i] = x;\n    const box = new Uint8Array(256);\n    box[0] = 0x63; // first elm\n    for (let i = 0; i < 255; i++) {\n        let x = t[255 - i];\n        x |= x << 8;\n        box[t[i]] = (x ^ (x >> 4) ^ (x >> 5) ^ (x >> 6) ^ (x >> 7) ^ 0x63) & 0xff;\n    }\n    return box;\n})();\n// Inverted S-box\nconst invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));\n// Rotate u32 by 8\nconst rotr32_8 = (n) => (n << 24) | (n >>> 8);\nconst rotl32_8 = (n) => (n << 8) | (n >>> 24);\n// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n// - LE instead of BE\n// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n//   so index is u16, instead of u8. This speeds up things, unexpectedly\nfunction genTtable(sbox, fn) {\n    if (sbox.length !== 256)\n        throw new Error('Wrong sbox length');\n    const T0 = new Uint32Array(256).map((_, j) => fn(sbox[j]));\n    const T1 = T0.map(rotl32_8);\n    const T2 = T1.map(rotl32_8);\n    const T3 = T2.map(rotl32_8);\n    const T01 = new Uint32Array(256 * 256);\n    const T23 = new Uint32Array(256 * 256);\n    const sbox2 = new Uint16Array(256 * 256);\n    for (let i = 0; i < 256; i++) {\n        for (let j = 0; j < 256; j++) {\n            const idx = i * 256 + j;\n            T01[idx] = T0[i] ^ T1[j];\n            T23[idx] = T2[i] ^ T3[j];\n            sbox2[idx] = (sbox[i] << 8) | sbox[j];\n        }\n    }\n    return { sbox, sbox2, T0, T1, T2, T3, T01, T23 };\n}\nconst tableEncoding = /* @__PURE__ */ genTtable(sbox, (s) => (mul(s, 3) << 24) | (s << 16) | (s << 8) | mul(s, 2));\nconst tableDecoding = /* @__PURE__ */ genTtable(invSbox, (s) => (mul(s, 11) << 24) | (mul(s, 13) << 16) | (mul(s, 9) << 8) | mul(s, 14));\nconst xPowers = /* @__PURE__ */ (() => {\n    const p = new Uint8Array(16);\n    for (let i = 0, x = 1; i < 16; i++, x = mul2(x))\n        p[i] = x;\n    return p;\n})();\nfunction expandKeyLE(key) {\n    (0, _assert_js_1.bytes)(key);\n    const len = key.length;\n    if (![16, 24, 32].includes(len))\n        throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${len}`);\n    const { sbox2 } = tableEncoding;\n    const k32 = (0, utils_js_1.u32)(key);\n    const Nk = k32.length;\n    const subByte = (n) => applySbox(sbox2, n, n, n, n);\n    const xk = new Uint32Array(len + 28); // expanded key\n    xk.set(k32);\n    // 4.3.1 Key expansion\n    for (let i = Nk; i < xk.length; i++) {\n        let t = xk[i - 1];\n        if (i % Nk === 0)\n            t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];\n        else if (Nk > 6 && i % Nk === 4)\n            t = subByte(t);\n        xk[i] = xk[i - Nk] ^ t;\n    }\n    return xk;\n}\nexports.expandKeyLE = expandKeyLE;\nfunction expandKeyDecLE(key) {\n    const encKey = expandKeyLE(key);\n    const xk = encKey.slice();\n    const Nk = encKey.length;\n    const { sbox2 } = tableEncoding;\n    const { T0, T1, T2, T3 } = tableDecoding;\n    // Inverse key by chunks of 4 (rounds)\n    for (let i = 0; i < Nk; i += 4) {\n        for (let j = 0; j < 4; j++)\n            xk[i + j] = encKey[Nk - i - 4 + j];\n    }\n    encKey.fill(0);\n    // apply InvMixColumn except first & last round\n    for (let i = 4; i < Nk - 4; i++) {\n        const x = xk[i];\n        const w = applySbox(sbox2, x, x, x, x);\n        xk[i] = T0[w & 0xff] ^ T1[(w >>> 8) & 0xff] ^ T2[(w >>> 16) & 0xff] ^ T3[w >>> 24];\n    }\n    return xk;\n}\nexports.expandKeyDecLE = expandKeyDecLE;\n// Apply tables\nfunction apply0123(T01, T23, s0, s1, s2, s3) {\n    return (T01[((s0 << 8) & 0xff00) | ((s1 >>> 8) & 0xff)] ^\n        T23[((s2 >>> 8) & 0xff00) | ((s3 >>> 24) & 0xff)]);\n}\nfunction applySbox(sbox2, s0, s1, s2, s3) {\n    return (sbox2[(s0 & 0xff) | (s1 & 0xff00)] |\n        (sbox2[((s2 >>> 16) & 0xff) | ((s3 >>> 16) & 0xff00)] << 16));\n}\nfunction encrypt(xk, s0, s1, s2, s3) {\n    const { sbox2, T01, T23 } = tableEncoding;\n    let k = 0;\n    (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n    const rounds = xk.length / 4 - 2;\n    for (let i = 0; i < rounds; i++) {\n        const t0 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);\n        const t1 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);\n        const t2 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);\n        const t3 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);\n        (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n    }\n    // last round (without mixcolumns, so using SBOX2 table)\n    const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);\n    const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);\n    const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);\n    const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);\n    return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\nfunction decrypt(xk, s0, s1, s2, s3) {\n    const { sbox2, T01, T23 } = tableDecoding;\n    let k = 0;\n    (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n    const rounds = xk.length / 4 - 2;\n    for (let i = 0; i < rounds; i++) {\n        const t0 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);\n        const t1 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);\n        const t2 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);\n        const t3 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);\n        (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n    }\n    // Last round\n    const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);\n    const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);\n    const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);\n    const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);\n    return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\nfunction getDst(len, dst) {\n    if (!dst)\n        return new Uint8Array(len);\n    (0, _assert_js_1.bytes)(dst);\n    if (dst.length < len)\n        throw new Error(`aes: wrong destination length, expected at least ${len}, got: ${dst.length}`);\n    return dst;\n}\n// TODO: investigate merging with ctr32\nfunction ctrCounter(xk, nonce, src, dst) {\n    (0, _assert_js_1.bytes)(nonce, BLOCK_SIZE);\n    (0, _assert_js_1.bytes)(src);\n    const srcLen = src.length;\n    dst = getDst(srcLen, dst);\n    const ctr = nonce;\n    const c32 = (0, utils_js_1.u32)(ctr);\n    // Fill block (empty, ctr=0)\n    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n    const src32 = (0, utils_js_1.u32)(src);\n    const dst32 = (0, utils_js_1.u32)(dst);\n    // process blocks\n    for (let i = 0; i + 4 <= src32.length; i += 4) {\n        dst32[i + 0] = src32[i + 0] ^ s0;\n        dst32[i + 1] = src32[i + 1] ^ s1;\n        dst32[i + 2] = src32[i + 2] ^ s2;\n        dst32[i + 3] = src32[i + 3] ^ s3;\n        // Full 128 bit counter with wrap around\n        let carry = 1;\n        for (let i = ctr.length - 1; i >= 0; i--) {\n            carry = (carry + (ctr[i] & 0xff)) | 0;\n            ctr[i] = carry & 0xff;\n            carry >>>= 8;\n        }\n        ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n    }\n    // leftovers (less than block)\n    // It's possible to handle > u32 fast, but is it worth it?\n    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n    if (start < srcLen) {\n        const b32 = new Uint32Array([s0, s1, s2, s3]);\n        const buf = (0, utils_js_1.u8)(b32);\n        for (let i = start, pos = 0; i < srcLen; i++, pos++)\n            dst[i] = src[i] ^ buf[pos];\n    }\n    return dst;\n}\n// AES CTR with overflowing 32 bit counter\n// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n// But, we need both, and perf bottleneck is in ghash anyway.\nfunction ctr32(xk, isLE, nonce, src, dst) {\n    (0, _assert_js_1.bytes)(nonce, BLOCK_SIZE);\n    (0, _assert_js_1.bytes)(src);\n    dst = getDst(src.length, dst);\n    const ctr = nonce; // write new value to nonce, so it can be re-used\n    const c32 = (0, utils_js_1.u32)(ctr);\n    const view = (0, utils_js_1.createView)(ctr);\n    const src32 = (0, utils_js_1.u32)(src);\n    const dst32 = (0, utils_js_1.u32)(dst);\n    const ctrPos = isLE ? 0 : 12;\n    const srcLen = src.length;\n    // Fill block (empty, ctr=0)\n    let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n    // process blocks\n    for (let i = 0; i + 4 <= src32.length; i += 4) {\n        dst32[i + 0] = src32[i + 0] ^ s0;\n        dst32[i + 1] = src32[i + 1] ^ s1;\n        dst32[i + 2] = src32[i + 2] ^ s2;\n        dst32[i + 3] = src32[i + 3] ^ s3;\n        ctrNum = (ctrNum + 1) >>> 0; // u32 wrap\n        view.setUint32(ctrPos, ctrNum, isLE);\n        ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n    }\n    // leftovers (less than a block)\n    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n    if (start < srcLen) {\n        const b32 = new Uint32Array([s0, s1, s2, s3]);\n        const buf = (0, utils_js_1.u8)(b32);\n        for (let i = start, pos = 0; i < srcLen; i++, pos++)\n            dst[i] = src[i] ^ buf[pos];\n    }\n    return dst;\n}\n/**\n * CTR: counter mode. Creates stream cipher.\n * Requires good IV. Parallelizable. OK, but no MAC.\n */\nexports.ctr = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function ctr(key, nonce) {\n    (0, _assert_js_1.bytes)(key);\n    (0, _assert_js_1.bytes)(nonce, BLOCK_SIZE);\n    function processCtr(buf, dst) {\n        const xk = expandKeyLE(key);\n        const n = nonce.slice();\n        const out = ctrCounter(xk, n, buf, dst);\n        xk.fill(0);\n        n.fill(0);\n        return out;\n    }\n    return {\n        encrypt: (plaintext, dst) => processCtr(plaintext, dst),\n        decrypt: (ciphertext, dst) => processCtr(ciphertext, dst),\n    };\n});\nfunction validateBlockDecrypt(data) {\n    (0, _assert_js_1.bytes)(data);\n    if (data.length % BLOCK_SIZE !== 0) {\n        throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE}`);\n    }\n}\nfunction validateBlockEncrypt(plaintext, pcks5, dst) {\n    let outLen = plaintext.length;\n    const remaining = outLen % BLOCK_SIZE;\n    if (!pcks5 && remaining !== 0)\n        throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n    const b = (0, utils_js_1.u32)(plaintext);\n    if (pcks5) {\n        let left = BLOCK_SIZE - remaining;\n        if (!left)\n            left = BLOCK_SIZE; // if no bytes left, create empty padding block\n        outLen = outLen + left;\n    }\n    const out = getDst(outLen, dst);\n    const o = (0, utils_js_1.u32)(out);\n    return { b, o, out };\n}\nfunction validatePCKS(data, pcks5) {\n    if (!pcks5)\n        return data;\n    const len = data.length;\n    if (!len)\n        throw new Error(`aes/pcks5: empty ciphertext not allowed`);\n    const lastByte = data[len - 1];\n    if (lastByte <= 0 || lastByte > 16)\n        throw new Error(`aes/pcks5: wrong padding byte: ${lastByte}`);\n    const out = data.subarray(0, -lastByte);\n    for (let i = 0; i < lastByte; i++)\n        if (data[len - i - 1] !== lastByte)\n            throw new Error(`aes/pcks5: wrong padding`);\n    return out;\n}\nfunction padPCKS(left) {\n    const tmp = new Uint8Array(16);\n    const tmp32 = (0, utils_js_1.u32)(tmp);\n    tmp.set(left);\n    const paddingByte = BLOCK_SIZE - left.length;\n    for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++)\n        tmp[i] = paddingByte;\n    return tmp32;\n}\n/**\n * ECB: Electronic CodeBook. Simple deterministic replacement.\n * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n */\nexports.ecb = (0, utils_js_1.wrapCipher)({ blockSize: 16 }, function ecb(key, opts = {}) {\n    (0, _assert_js_1.bytes)(key);\n    const pcks5 = !opts.disablePadding;\n    return {\n        encrypt: (plaintext, dst) => {\n            (0, _assert_js_1.bytes)(plaintext);\n            const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n            const xk = expandKeyLE(key);\n            let i = 0;\n            for (; i + 4 <= b.length;) {\n                const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            if (pcks5) {\n                const tmp32 = padPCKS(plaintext.subarray(i * 4));\n                const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return _out;\n        },\n        decrypt: (ciphertext, dst) => {\n            validateBlockDecrypt(ciphertext);\n            const xk = expandKeyDecLE(key);\n            const out = getDst(ciphertext.length, dst);\n            const b = (0, utils_js_1.u32)(ciphertext);\n            const o = (0, utils_js_1.u32)(out);\n            for (let i = 0; i + 4 <= b.length;) {\n                const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return validatePCKS(out, pcks5);\n        },\n    };\n});\n/**\n * CBC: Cipher-Block-Chaining. Key is previous round’s block.\n * Fragile: needs proper padding. Unauthenticated: needs MAC.\n */\nexports.cbc = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function cbc(key, iv, opts = {}) {\n    (0, _assert_js_1.bytes)(key);\n    (0, _assert_js_1.bytes)(iv, 16);\n    const pcks5 = !opts.disablePadding;\n    return {\n        encrypt: (plaintext, dst) => {\n            const xk = expandKeyLE(key);\n            const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n            const n32 = (0, utils_js_1.u32)(iv);\n            // prettier-ignore\n            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n            let i = 0;\n            for (; i + 4 <= b.length;) {\n                (s0 ^= b[i + 0]), (s1 ^= b[i + 1]), (s2 ^= b[i + 2]), (s3 ^= b[i + 3]);\n                ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            if (pcks5) {\n                const tmp32 = padPCKS(plaintext.subarray(i * 4));\n                (s0 ^= tmp32[0]), (s1 ^= tmp32[1]), (s2 ^= tmp32[2]), (s3 ^= tmp32[3]);\n                ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return _out;\n        },\n        decrypt: (ciphertext, dst) => {\n            validateBlockDecrypt(ciphertext);\n            const xk = expandKeyDecLE(key);\n            const n32 = (0, utils_js_1.u32)(iv);\n            const out = getDst(ciphertext.length, dst);\n            const b = (0, utils_js_1.u32)(ciphertext);\n            const o = (0, utils_js_1.u32)(out);\n            // prettier-ignore\n            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n            for (let i = 0; i + 4 <= b.length;) {\n                // prettier-ignore\n                const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;\n                (s0 = b[i + 0]), (s1 = b[i + 1]), (s2 = b[i + 2]), (s3 = b[i + 3]);\n                const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);\n                (o[i++] = o0 ^ ps0), (o[i++] = o1 ^ ps1), (o[i++] = o2 ^ ps2), (o[i++] = o3 ^ ps3);\n            }\n            xk.fill(0);\n            return validatePCKS(out, pcks5);\n        },\n    };\n});\n/**\n * CFB: Cipher Feedback Mode. The input for the block cipher is the previous cipher output.\n * Unauthenticated: needs MAC.\n */\nexports.cfb = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function cfb(key, iv) {\n    (0, _assert_js_1.bytes)(key);\n    (0, _assert_js_1.bytes)(iv, 16);\n    function processCfb(src, isEncrypt, dst) {\n        const xk = expandKeyLE(key);\n        const srcLen = src.length;\n        dst = getDst(srcLen, dst);\n        const src32 = (0, utils_js_1.u32)(src);\n        const dst32 = (0, utils_js_1.u32)(dst);\n        const next32 = isEncrypt ? dst32 : src32;\n        const n32 = (0, utils_js_1.u32)(iv);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        for (let i = 0; i + 4 <= src32.length;) {\n            const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt(xk, s0, s1, s2, s3);\n            dst32[i + 0] = src32[i + 0] ^ e0;\n            dst32[i + 1] = src32[i + 1] ^ e1;\n            dst32[i + 2] = src32[i + 2] ^ e2;\n            dst32[i + 3] = src32[i + 3] ^ e3;\n            (s0 = next32[i++]), (s1 = next32[i++]), (s2 = next32[i++]), (s3 = next32[i++]);\n        }\n        // leftovers (less than block)\n        const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n        if (start < srcLen) {\n            ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n            const buf = (0, utils_js_1.u8)(new Uint32Array([s0, s1, s2, s3]));\n            for (let i = start, pos = 0; i < srcLen; i++, pos++)\n                dst[i] = src[i] ^ buf[pos];\n            buf.fill(0);\n        }\n        xk.fill(0);\n        return dst;\n    }\n    return {\n        encrypt: (plaintext, dst) => processCfb(plaintext, true, dst),\n        decrypt: (ciphertext, dst) => processCfb(ciphertext, false, dst),\n    };\n});\n// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\nfunction computeTag(fn, isLE, key, data, AAD) {\n    const h = fn.create(key, data.length + (AAD?.length || 0));\n    if (AAD)\n        h.update(AAD);\n    h.update(data);\n    const num = new Uint8Array(16);\n    const view = (0, utils_js_1.createView)(num);\n    if (AAD)\n        (0, utils_js_1.setBigUint64)(view, 0, BigInt(AAD.length * 8), isLE);\n    (0, utils_js_1.setBigUint64)(view, 8, BigInt(data.length * 8), isLE);\n    h.update(num);\n    return h.digest();\n}\n/**\n * GCM: Galois/Counter Mode.\n * Good, modern version of CTR, parallel, with MAC.\n * Be careful: MACs can be forged.\n */\nexports.gcm = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function gcm(key, nonce, AAD) {\n    (0, _assert_js_1.bytes)(nonce);\n    // Nonce can be pretty much anything (even 1 byte). But smaller nonces less secure.\n    if (nonce.length === 0)\n        throw new Error('aes/gcm: empty nonce');\n    const tagLength = 16;\n    function _computeTag(authKey, tagMask, data) {\n        const tag = computeTag(_polyval_js_1.ghash, false, authKey, data, AAD);\n        for (let i = 0; i < tagMask.length; i++)\n            tag[i] ^= tagMask[i];\n        return tag;\n    }\n    function deriveKeys() {\n        const xk = expandKeyLE(key);\n        const authKey = EMPTY_BLOCK.slice();\n        const counter = EMPTY_BLOCK.slice();\n        ctr32(xk, false, counter, counter, authKey);\n        if (nonce.length === 12) {\n            counter.set(nonce);\n        }\n        else {\n            // Spec (NIST 800-38d) supports variable size nonce.\n            // Not supported for now, but can be useful.\n            const nonceLen = EMPTY_BLOCK.slice();\n            const view = (0, utils_js_1.createView)(nonceLen);\n            (0, utils_js_1.setBigUint64)(view, 8, BigInt(nonce.length * 8), false);\n            // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n            _polyval_js_1.ghash.create(authKey).update(nonce).update(nonceLen).digestInto(counter);\n        }\n        const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);\n        return { xk, authKey, counter, tagMask };\n    }\n    return {\n        encrypt: (plaintext) => {\n            (0, _assert_js_1.bytes)(plaintext);\n            const { xk, authKey, counter, tagMask } = deriveKeys();\n            const out = new Uint8Array(plaintext.length + tagLength);\n            ctr32(xk, false, counter, plaintext, out);\n            const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n            out.set(tag, plaintext.length);\n            xk.fill(0);\n            return out;\n        },\n        decrypt: (ciphertext) => {\n            (0, _assert_js_1.bytes)(ciphertext);\n            if (ciphertext.length < tagLength)\n                throw new Error(`aes/gcm: ciphertext less than tagLen (${tagLength})`);\n            const { xk, authKey, counter, tagMask } = deriveKeys();\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = _computeTag(authKey, tagMask, data);\n            if (!(0, utils_js_1.equalBytes)(tag, passedTag))\n                throw new Error('aes/gcm: invalid ghash tag');\n            const out = ctr32(xk, false, counter, data);\n            authKey.fill(0);\n            tagMask.fill(0);\n            xk.fill(0);\n            return out;\n        },\n    };\n});\nconst limit = (name, min, max) => (value) => {\n    if (!Number.isSafeInteger(value) || min > value || value > max)\n        throw new Error(`${name}: invalid value=${value}, must be [${min}..${max}]`);\n};\n/**\n * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n * Guarantees that, when a nonce is repeated, the only security loss is that identical\n * plaintexts will produce identical ciphertexts.\n * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n */\nexports.siv = (0, utils_js_1.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function siv(key, nonce, AAD) {\n    const tagLength = 16;\n    // From RFC 8452: Section 6\n    const AAD_LIMIT = limit('AAD', 0, 2 ** 36);\n    const PLAIN_LIMIT = limit('plaintext', 0, 2 ** 36);\n    const NONCE_LIMIT = limit('nonce', 12, 12);\n    const CIPHER_LIMIT = limit('ciphertext', 16, 2 ** 36 + 16);\n    (0, _assert_js_1.bytes)(nonce);\n    NONCE_LIMIT(nonce.length);\n    if (AAD) {\n        (0, _assert_js_1.bytes)(AAD);\n        AAD_LIMIT(AAD.length);\n    }\n    function deriveKeys() {\n        const len = key.length;\n        if (len !== 16 && len !== 24 && len !== 32)\n            throw new Error(`key length must be 16, 24 or 32 bytes, got: ${len} bytes`);\n        const xk = expandKeyLE(key);\n        const encKey = new Uint8Array(len);\n        const authKey = new Uint8Array(16);\n        const n32 = (0, utils_js_1.u32)(nonce);\n        // prettier-ignore\n        let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];\n        let counter = 0;\n        for (const derivedKey of [authKey, encKey].map(utils_js_1.u32)) {\n            const d32 = (0, utils_js_1.u32)(derivedKey);\n            for (let i = 0; i < d32.length; i += 2) {\n                // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n                const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);\n                d32[i + 0] = o0;\n                d32[i + 1] = o1;\n                s0 = ++counter; // increment counter inside state\n            }\n        }\n        xk.fill(0);\n        return { authKey, encKey: expandKeyLE(encKey) };\n    }\n    function _computeTag(encKey, authKey, data) {\n        const tag = computeTag(_polyval_js_1.polyval, true, authKey, data, AAD);\n        // Compute the expected tag by XORing S_s and the nonce, clearing the\n        // most significant bit of the last byte and encrypting with the\n        // message-encryption key.\n        for (let i = 0; i < 12; i++)\n            tag[i] ^= nonce[i];\n        tag[15] &= 0x7f; // Clear the highest bit\n        // encrypt tag as block\n        const t32 = (0, utils_js_1.u32)(tag);\n        // prettier-ignore\n        let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];\n        ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));\n        (t32[0] = s0), (t32[1] = s1), (t32[2] = s2), (t32[3] = s3);\n        return tag;\n    }\n    // actual decrypt/encrypt of message.\n    function processSiv(encKey, tag, input) {\n        let block = tag.slice();\n        block[15] |= 0x80; // Force highest bit\n        return ctr32(encKey, true, block, input);\n    }\n    return {\n        encrypt: (plaintext) => {\n            (0, _assert_js_1.bytes)(plaintext);\n            PLAIN_LIMIT(plaintext.length);\n            const { encKey, authKey } = deriveKeys();\n            const tag = _computeTag(encKey, authKey, plaintext);\n            const out = new Uint8Array(plaintext.length + tagLength);\n            out.set(tag, plaintext.length);\n            out.set(processSiv(encKey, tag, plaintext));\n            encKey.fill(0);\n            authKey.fill(0);\n            return out;\n        },\n        decrypt: (ciphertext) => {\n            (0, _assert_js_1.bytes)(ciphertext);\n            CIPHER_LIMIT(ciphertext.length);\n            const tag = ciphertext.subarray(-tagLength);\n            const { encKey, authKey } = deriveKeys();\n            const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n            const expectedTag = _computeTag(encKey, authKey, plaintext);\n            encKey.fill(0);\n            authKey.fill(0);\n            if (!(0, utils_js_1.equalBytes)(tag, expectedTag))\n                throw new Error('invalid polyval tag');\n            return plaintext;\n        },\n    };\n});\nfunction isBytes32(a) {\n    return (a != null &&\n        typeof a === 'object' &&\n        (a instanceof Uint32Array || a.constructor.name === 'Uint32Array'));\n}\nfunction encryptBlock(xk, block) {\n    (0, _assert_js_1.bytes)(block, 16);\n    if (!isBytes32(xk))\n        throw new Error('_encryptBlock accepts result of expandKeyLE');\n    const b32 = (0, utils_js_1.u32)(block);\n    let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n    (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n    return block;\n}\nfunction decryptBlock(xk, block) {\n    (0, _assert_js_1.bytes)(block, 16);\n    if (!isBytes32(xk))\n        throw new Error('_decryptBlock accepts result of expandKeyLE');\n    const b32 = (0, utils_js_1.u32)(block);\n    let { s0, s1, s2, s3 } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n    (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n    return block;\n}\n// Highly unsafe private functions for implementing new modes or ciphers based on AES\n// Can change at any time, no API guarantees\nexports.unsafe = {\n    expandKeyLE,\n    expandKeyDecLE,\n    encrypt,\n    decrypt,\n    encryptBlock,\n    decryptBlock,\n    ctrCounter,\n    ctr32,\n};\n//# sourceMappingURL=aes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2Flcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsV0FBVyxHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsV0FBVyxHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsc0JBQXNCLEdBQUcsbUJBQW1CO0FBQ2pKO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsd0dBQVk7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsOEdBQWU7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsNEdBQWM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLDZCQUE2QjtBQUM3QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3Qix3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsSUFB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Q0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2Flcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5zYWZlID0gZXhwb3J0cy5zaXYgPSBleHBvcnRzLmdjbSA9IGV4cG9ydHMuY2ZiID0gZXhwb3J0cy5jYmMgPSBleHBvcnRzLmVjYiA9IGV4cG9ydHMuY3RyID0gZXhwb3J0cy5leHBhbmRLZXlEZWNMRSA9IGV4cG9ydHMuZXhwYW5kS2V5TEUgPSB2b2lkIDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IF9wb2x5dmFsX2pzXzEgPSByZXF1aXJlKFwiLi9fcG9seXZhbC5qc1wiKTtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG4vKlxuQUVTIChBZHZhbmNlZCBFbmNyeXB0aW9uIFN0YW5kYXJkKSBha2EgUmlqbmRhZWwgYmxvY2sgY2lwaGVyLlxuXG5EYXRhIGlzIHNwbGl0IGludG8gMTI4LWJpdCBibG9ja3MuIEVuY3J5cHRlZCBpbiAxMC8xMi8xNCByb3VuZHMgKDEyOC8xOTIvMjU2IGJpdHMpLiBJbiBldmVyeSByb3VuZDpcbjEuICoqUy1ib3gqKiwgdGFibGUgc3Vic3RpdHV0aW9uXG4yLiAqKlNoaWZ0IHJvd3MqKiwgY3ljbGljIHNoaWZ0IGxlZnQgb2YgYWxsIHJvd3Mgb2YgZGF0YSBhcnJheVxuMy4gKipNaXggY29sdW1ucyoqLCBtdWx0aXBseWluZyBldmVyeSBjb2x1bW4gYnkgZml4ZWQgcG9seW5vbWlhbFxuNC4gKipBZGQgcm91bmQga2V5KiosIHJvdW5kX2tleSB4b3IgaS10aCBjb2x1bW4gb2YgYXJyYXlcblxuUmVzb3VyY2VzOlxuLSBGSVBTLTE5NyBodHRwczovL2NzcmMubmlzdC5nb3YvZmlsZXMvcHVicy9maXBzLzE5Ny9maW5hbC9kb2NzL2ZpcHMtMTk3LnBkZlxuLSBPcmlnaW5hbCBwcm9wb3NhbDogaHR0cHM6Ly9jc3JjLm5pc3QuZ292L2NzcmMvbWVkaWEvcHJvamVjdHMvY3J5cHRvZ3JhcGhpYy1zdGFuZGFyZHMtYW5kLWd1aWRlbGluZXMvZG9jdW1lbnRzL2Flcy1kZXZlbG9wbWVudC9yaWpuZGFlbC1hbW1lbmRlZC5wZGZcbiovXG5jb25zdCBCTE9DS19TSVpFID0gMTY7XG5jb25zdCBCTE9DS19TSVpFMzIgPSA0O1xuY29uc3QgRU1QVFlfQkxPQ0sgPSBuZXcgVWludDhBcnJheShCTE9DS19TSVpFKTtcbmNvbnN0IFBPTFkgPSAweDExYjsgLy8gMSArIHggKyB4KiozICsgeCoqNCArIHgqKjhcbi8vIFRPRE86IHJlbW92ZSBtdWx0aXBsaWNhdGlvbiwgYmluYXJ5IG9wcyBvbmx5XG5mdW5jdGlvbiBtdWwyKG4pIHtcbiAgICByZXR1cm4gKG4gPDwgMSkgXiAoUE9MWSAmIC0obiA+PiA3KSk7XG59XG5mdW5jdGlvbiBtdWwoYSwgYikge1xuICAgIGxldCByZXMgPSAwO1xuICAgIGZvciAoOyBiID4gMDsgYiA+Pj0gMSkge1xuICAgICAgICAvLyBNb250Z29tZXJ5IGxhZGRlclxuICAgICAgICByZXMgXj0gYSAmIC0oYiAmIDEpOyAvLyBpZiAoYiYxKSByZXMgXj1hIChidXQgY29uc3QtdGltZSkuXG4gICAgICAgIGEgPSBtdWwyKGEpOyAvLyBhID0gMiphXG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBBRVMgUy1ib3ggaXMgZ2VuZXJhdGVkIHVzaW5nIGZpbml0ZSBmaWVsZCBpbnZlcnNpb24sXG4vLyBhbiBhZmZpbmUgdHJhbnNmb3JtLCBhbmQgeG9yIG9mIGEgY29uc3RhbnQgMHg2My5cbmNvbnN0IHNib3ggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICBsZXQgdCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDAsIHggPSAxOyBpIDwgMjU2OyBpKyssIHggXj0gbXVsMih4KSlcbiAgICAgICAgdFtpXSA9IHg7XG4gICAgY29uc3QgYm94ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICBib3hbMF0gPSAweDYzOyAvLyBmaXJzdCBlbG1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NTsgaSsrKSB7XG4gICAgICAgIGxldCB4ID0gdFsyNTUgLSBpXTtcbiAgICAgICAgeCB8PSB4IDw8IDg7XG4gICAgICAgIGJveFt0W2ldXSA9ICh4IF4gKHggPj4gNCkgXiAoeCA+PiA1KSBeICh4ID4+IDYpIF4gKHggPj4gNykgXiAweDYzKSAmIDB4ZmY7XG4gICAgfVxuICAgIHJldHVybiBib3g7XG59KSgpO1xuLy8gSW52ZXJ0ZWQgUy1ib3hcbmNvbnN0IGludlNib3ggPSAvKiBAX19QVVJFX18gKi8gc2JveC5tYXAoKF8sIGopID0+IHNib3guaW5kZXhPZihqKSk7XG4vLyBSb3RhdGUgdTMyIGJ5IDhcbmNvbnN0IHJvdHIzMl84ID0gKG4pID0+IChuIDw8IDI0KSB8IChuID4+PiA4KTtcbmNvbnN0IHJvdGwzMl84ID0gKG4pID0+IChuIDw8IDgpIHwgKG4gPj4+IDI0KTtcbi8vIFQtdGFibGUgaXMgb3B0aW1pemF0aW9uIHN1Z2dlc3RlZCBpbiA1LjIgb2Ygb3JpZ2luYWwgcHJvcG9zYWwgKG1pc3NlZCBmcm9tIEZJUFMtMTk3KS4gQ2hhbmdlczpcbi8vIC0gTEUgaW5zdGVhZCBvZiBCRVxuLy8gLSBiaWdnZXIgdGFibGVzOiBUMCBhbmQgVDEgYXJlIG1lcmdlZCBpbnRvIFQwMSB0YWJsZSBhbmQgVDIgJiBUMyBpbnRvIFQyMztcbi8vICAgc28gaW5kZXggaXMgdTE2LCBpbnN0ZWFkIG9mIHU4LiBUaGlzIHNwZWVkcyB1cCB0aGluZ3MsIHVuZXhwZWN0ZWRseVxuZnVuY3Rpb24gZ2VuVHRhYmxlKHNib3gsIGZuKSB7XG4gICAgaWYgKHNib3gubGVuZ3RoICE9PSAyNTYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV3Jvbmcgc2JveCBsZW5ndGgnKTtcbiAgICBjb25zdCBUMCA9IG5ldyBVaW50MzJBcnJheSgyNTYpLm1hcCgoXywgaikgPT4gZm4oc2JveFtqXSkpO1xuICAgIGNvbnN0IFQxID0gVDAubWFwKHJvdGwzMl84KTtcbiAgICBjb25zdCBUMiA9IFQxLm1hcChyb3RsMzJfOCk7XG4gICAgY29uc3QgVDMgPSBUMi5tYXAocm90bDMyXzgpO1xuICAgIGNvbnN0IFQwMSA9IG5ldyBVaW50MzJBcnJheSgyNTYgKiAyNTYpO1xuICAgIGNvbnN0IFQyMyA9IG5ldyBVaW50MzJBcnJheSgyNTYgKiAyNTYpO1xuICAgIGNvbnN0IHNib3gyID0gbmV3IFVpbnQxNkFycmF5KDI1NiAqIDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI1NjsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBpICogMjU2ICsgajtcbiAgICAgICAgICAgIFQwMVtpZHhdID0gVDBbaV0gXiBUMVtqXTtcbiAgICAgICAgICAgIFQyM1tpZHhdID0gVDJbaV0gXiBUM1tqXTtcbiAgICAgICAgICAgIHNib3gyW2lkeF0gPSAoc2JveFtpXSA8PCA4KSB8IHNib3hbal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc2JveCwgc2JveDIsIFQwLCBUMSwgVDIsIFQzLCBUMDEsIFQyMyB9O1xufVxuY29uc3QgdGFibGVFbmNvZGluZyA9IC8qIEBfX1BVUkVfXyAqLyBnZW5UdGFibGUoc2JveCwgKHMpID0+IChtdWwocywgMykgPDwgMjQpIHwgKHMgPDwgMTYpIHwgKHMgPDwgOCkgfCBtdWwocywgMikpO1xuY29uc3QgdGFibGVEZWNvZGluZyA9IC8qIEBfX1BVUkVfXyAqLyBnZW5UdGFibGUoaW52U2JveCwgKHMpID0+IChtdWwocywgMTEpIDw8IDI0KSB8IChtdWwocywgMTMpIDw8IDE2KSB8IChtdWwocywgOSkgPDwgOCkgfCBtdWwocywgMTQpKTtcbmNvbnN0IHhQb3dlcnMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICBjb25zdCBwID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGZvciAobGV0IGkgPSAwLCB4ID0gMTsgaSA8IDE2OyBpKyssIHggPSBtdWwyKHgpKVxuICAgICAgICBwW2ldID0geDtcbiAgICByZXR1cm4gcDtcbn0pKCk7XG5mdW5jdGlvbiBleHBhbmRLZXlMRShrZXkpIHtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShrZXkpO1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgaWYgKCFbMTYsIDI0LCAzMl0uaW5jbHVkZXMobGVuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhZXM6IHdyb25nIGtleSBzaXplOiBzaG91bGQgYmUgMTYsIDI0IG9yIDMyLCBnb3Q6ICR7bGVufWApO1xuICAgIGNvbnN0IHsgc2JveDIgfSA9IHRhYmxlRW5jb2Rpbmc7XG4gICAgY29uc3QgazMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShrZXkpO1xuICAgIGNvbnN0IE5rID0gazMyLmxlbmd0aDtcbiAgICBjb25zdCBzdWJCeXRlID0gKG4pID0+IGFwcGx5U2JveChzYm94Miwgbiwgbiwgbiwgbik7XG4gICAgY29uc3QgeGsgPSBuZXcgVWludDMyQXJyYXkobGVuICsgMjgpOyAvLyBleHBhbmRlZCBrZXlcbiAgICB4ay5zZXQoazMyKTtcbiAgICAvLyA0LjMuMSBLZXkgZXhwYW5zaW9uXG4gICAgZm9yIChsZXQgaSA9IE5rOyBpIDwgeGsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHQgPSB4a1tpIC0gMV07XG4gICAgICAgIGlmIChpICUgTmsgPT09IDApXG4gICAgICAgICAgICB0ID0gc3ViQnl0ZShyb3RyMzJfOCh0KSkgXiB4UG93ZXJzW2kgLyBOayAtIDFdO1xuICAgICAgICBlbHNlIGlmIChOayA+IDYgJiYgaSAlIE5rID09PSA0KVxuICAgICAgICAgICAgdCA9IHN1YkJ5dGUodCk7XG4gICAgICAgIHhrW2ldID0geGtbaSAtIE5rXSBeIHQ7XG4gICAgfVxuICAgIHJldHVybiB4aztcbn1cbmV4cG9ydHMuZXhwYW5kS2V5TEUgPSBleHBhbmRLZXlMRTtcbmZ1bmN0aW9uIGV4cGFuZEtleURlY0xFKGtleSkge1xuICAgIGNvbnN0IGVuY0tleSA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgY29uc3QgeGsgPSBlbmNLZXkuc2xpY2UoKTtcbiAgICBjb25zdCBOayA9IGVuY0tleS5sZW5ndGg7XG4gICAgY29uc3QgeyBzYm94MiB9ID0gdGFibGVFbmNvZGluZztcbiAgICBjb25zdCB7IFQwLCBUMSwgVDIsIFQzIH0gPSB0YWJsZURlY29kaW5nO1xuICAgIC8vIEludmVyc2Uga2V5IGJ5IGNodW5rcyBvZiA0IChyb3VuZHMpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOazsgaSArPSA0KSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKVxuICAgICAgICAgICAgeGtbaSArIGpdID0gZW5jS2V5W05rIC0gaSAtIDQgKyBqXTtcbiAgICB9XG4gICAgZW5jS2V5LmZpbGwoMCk7XG4gICAgLy8gYXBwbHkgSW52TWl4Q29sdW1uIGV4Y2VwdCBmaXJzdCAmIGxhc3Qgcm91bmRcbiAgICBmb3IgKGxldCBpID0gNDsgaSA8IE5rIC0gNDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSB4a1tpXTtcbiAgICAgICAgY29uc3QgdyA9IGFwcGx5U2JveChzYm94MiwgeCwgeCwgeCwgeCk7XG4gICAgICAgIHhrW2ldID0gVDBbdyAmIDB4ZmZdIF4gVDFbKHcgPj4+IDgpICYgMHhmZl0gXiBUMlsodyA+Pj4gMTYpICYgMHhmZl0gXiBUM1t3ID4+PiAyNF07XG4gICAgfVxuICAgIHJldHVybiB4aztcbn1cbmV4cG9ydHMuZXhwYW5kS2V5RGVjTEUgPSBleHBhbmRLZXlEZWNMRTtcbi8vIEFwcGx5IHRhYmxlc1xuZnVuY3Rpb24gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMCwgczEsIHMyLCBzMykge1xuICAgIHJldHVybiAoVDAxWygoczAgPDwgOCkgJiAweGZmMDApIHwgKChzMSA+Pj4gOCkgJiAweGZmKV0gXlxuICAgICAgICBUMjNbKChzMiA+Pj4gOCkgJiAweGZmMDApIHwgKChzMyA+Pj4gMjQpICYgMHhmZildKTtcbn1cbmZ1bmN0aW9uIGFwcGx5U2JveChzYm94MiwgczAsIHMxLCBzMiwgczMpIHtcbiAgICByZXR1cm4gKHNib3gyWyhzMCAmIDB4ZmYpIHwgKHMxICYgMHhmZjAwKV0gfFxuICAgICAgICAoc2JveDJbKChzMiA+Pj4gMTYpICYgMHhmZikgfCAoKHMzID4+PiAxNikgJiAweGZmMDApXSA8PCAxNikpO1xufVxuZnVuY3Rpb24gZW5jcnlwdCh4aywgczAsIHMxLCBzMiwgczMpIHtcbiAgICBjb25zdCB7IHNib3gyLCBUMDEsIFQyMyB9ID0gdGFibGVFbmNvZGluZztcbiAgICBsZXQgayA9IDA7XG4gICAgKHMwIF49IHhrW2srK10pLCAoczEgXj0geGtbaysrXSksIChzMiBePSB4a1trKytdKSwgKHMzIF49IHhrW2srK10pO1xuICAgIGNvbnN0IHJvdW5kcyA9IHhrLmxlbmd0aCAvIDQgLSAyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91bmRzOyBpKyspIHtcbiAgICAgICAgY29uc3QgdDAgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMCwgczEsIHMyLCBzMyk7XG4gICAgICAgIGNvbnN0IHQxID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczEsIHMyLCBzMywgczApO1xuICAgICAgICBjb25zdCB0MiA9IHhrW2srK10gXiBhcHBseTAxMjMoVDAxLCBUMjMsIHMyLCBzMywgczAsIHMxKTtcbiAgICAgICAgY29uc3QgdDMgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMywgczAsIHMxLCBzMik7XG4gICAgICAgIChzMCA9IHQwKSwgKHMxID0gdDEpLCAoczIgPSB0MiksIChzMyA9IHQzKTtcbiAgICB9XG4gICAgLy8gbGFzdCByb3VuZCAod2l0aG91dCBtaXhjb2x1bW5zLCBzbyB1c2luZyBTQk9YMiB0YWJsZSlcbiAgICBjb25zdCB0MCA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMwLCBzMSwgczIsIHMzKTtcbiAgICBjb25zdCB0MSA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMxLCBzMiwgczMsIHMwKTtcbiAgICBjb25zdCB0MiA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMyLCBzMywgczAsIHMxKTtcbiAgICBjb25zdCB0MyA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMzLCBzMCwgczEsIHMyKTtcbiAgICByZXR1cm4geyBzMDogdDAsIHMxOiB0MSwgczI6IHQyLCBzMzogdDMgfTtcbn1cbmZ1bmN0aW9uIGRlY3J5cHQoeGssIHMwLCBzMSwgczIsIHMzKSB7XG4gICAgY29uc3QgeyBzYm94MiwgVDAxLCBUMjMgfSA9IHRhYmxlRGVjb2Rpbmc7XG4gICAgbGV0IGsgPSAwO1xuICAgIChzMCBePSB4a1trKytdKSwgKHMxIF49IHhrW2srK10pLCAoczIgXj0geGtbaysrXSksIChzMyBePSB4a1trKytdKTtcbiAgICBjb25zdCByb3VuZHMgPSB4ay5sZW5ndGggLyA0IC0gMjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHQwID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczAsIHMzLCBzMiwgczEpO1xuICAgICAgICBjb25zdCB0MSA9IHhrW2srK10gXiBhcHBseTAxMjMoVDAxLCBUMjMsIHMxLCBzMCwgczMsIHMyKTtcbiAgICAgICAgY29uc3QgdDIgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMiwgczEsIHMwLCBzMyk7XG4gICAgICAgIGNvbnN0IHQzID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczMsIHMyLCBzMSwgczApO1xuICAgICAgICAoczAgPSB0MCksIChzMSA9IHQxKSwgKHMyID0gdDIpLCAoczMgPSB0Myk7XG4gICAgfVxuICAgIC8vIExhc3Qgcm91bmRcbiAgICBjb25zdCB0MCA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMwLCBzMywgczIsIHMxKTtcbiAgICBjb25zdCB0MSA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMxLCBzMCwgczMsIHMyKTtcbiAgICBjb25zdCB0MiA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMyLCBzMSwgczAsIHMzKTtcbiAgICBjb25zdCB0MyA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMzLCBzMiwgczEsIHMwKTtcbiAgICByZXR1cm4geyBzMDogdDAsIHMxOiB0MSwgczI6IHQyLCBzMzogdDMgfTtcbn1cbmZ1bmN0aW9uIGdldERzdChsZW4sIGRzdCkge1xuICAgIGlmICghZHN0KVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShkc3QpO1xuICAgIGlmIChkc3QubGVuZ3RoIDwgbGVuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFlczogd3JvbmcgZGVzdGluYXRpb24gbGVuZ3RoLCBleHBlY3RlZCBhdCBsZWFzdCAke2xlbn0sIGdvdDogJHtkc3QubGVuZ3RofWApO1xuICAgIHJldHVybiBkc3Q7XG59XG4vLyBUT0RPOiBpbnZlc3RpZ2F0ZSBtZXJnaW5nIHdpdGggY3RyMzJcbmZ1bmN0aW9uIGN0ckNvdW50ZXIoeGssIG5vbmNlLCBzcmMsIGRzdCkge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKG5vbmNlLCBCTE9DS19TSVpFKTtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShzcmMpO1xuICAgIGNvbnN0IHNyY0xlbiA9IHNyYy5sZW5ndGg7XG4gICAgZHN0ID0gZ2V0RHN0KHNyY0xlbiwgZHN0KTtcbiAgICBjb25zdCBjdHIgPSBub25jZTtcbiAgICBjb25zdCBjMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGN0cik7XG4gICAgLy8gRmlsbCBibG9jayAoZW1wdHksIGN0cj0wKVxuICAgIGxldCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBjMzJbMF0sIGMzMlsxXSwgYzMyWzJdLCBjMzJbM10pO1xuICAgIGNvbnN0IHNyYzMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShzcmMpO1xuICAgIGNvbnN0IGRzdDMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShkc3QpO1xuICAgIC8vIHByb2Nlc3MgYmxvY2tzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgKyA0IDw9IHNyYzMyLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIGRzdDMyW2kgKyAwXSA9IHNyYzMyW2kgKyAwXSBeIHMwO1xuICAgICAgICBkc3QzMltpICsgMV0gPSBzcmMzMltpICsgMV0gXiBzMTtcbiAgICAgICAgZHN0MzJbaSArIDJdID0gc3JjMzJbaSArIDJdIF4gczI7XG4gICAgICAgIGRzdDMyW2kgKyAzXSA9IHNyYzMyW2kgKyAzXSBeIHMzO1xuICAgICAgICAvLyBGdWxsIDEyOCBiaXQgY291bnRlciB3aXRoIHdyYXAgYXJvdW5kXG4gICAgICAgIGxldCBjYXJyeSA9IDE7XG4gICAgICAgIGZvciAobGV0IGkgPSBjdHIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNhcnJ5ID0gKGNhcnJ5ICsgKGN0cltpXSAmIDB4ZmYpKSB8IDA7XG4gICAgICAgICAgICBjdHJbaV0gPSBjYXJyeSAmIDB4ZmY7XG4gICAgICAgICAgICBjYXJyeSA+Pj49IDg7XG4gICAgICAgIH1cbiAgICAgICAgKHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIGMzMlswXSwgYzMyWzFdLCBjMzJbMl0sIGMzMlszXSkpO1xuICAgIH1cbiAgICAvLyBsZWZ0b3ZlcnMgKGxlc3MgdGhhbiBibG9jaylcbiAgICAvLyBJdCdzIHBvc3NpYmxlIHRvIGhhbmRsZSA+IHUzMiBmYXN0LCBidXQgaXMgaXQgd29ydGggaXQ/XG4gICAgY29uc3Qgc3RhcnQgPSBCTE9DS19TSVpFICogTWF0aC5mbG9vcihzcmMzMi5sZW5ndGggLyBCTE9DS19TSVpFMzIpO1xuICAgIGlmIChzdGFydCA8IHNyY0xlbikge1xuICAgICAgICBjb25zdCBiMzIgPSBuZXcgVWludDMyQXJyYXkoW3MwLCBzMSwgczIsIHMzXSk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9ICgwLCB1dGlsc19qc18xLnU4KShiMzIpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQsIHBvcyA9IDA7IGkgPCBzcmNMZW47IGkrKywgcG9zKyspXG4gICAgICAgICAgICBkc3RbaV0gPSBzcmNbaV0gXiBidWZbcG9zXTtcbiAgICB9XG4gICAgcmV0dXJuIGRzdDtcbn1cbi8vIEFFUyBDVFIgd2l0aCBvdmVyZmxvd2luZyAzMiBiaXQgY291bnRlclxuLy8gSXQncyBwb3NzaWJsZSB0byBkbyAzMmxlIHNpZ25pZmljYW50bHkgc2ltcGxlciAoYW5kIHByb2JhYmx5IGZhc3RlcikgYnkgdXNpbmcgdTMyLlxuLy8gQnV0LCB3ZSBuZWVkIGJvdGgsIGFuZCBwZXJmIGJvdHRsZW5lY2sgaXMgaW4gZ2hhc2ggYW55d2F5LlxuZnVuY3Rpb24gY3RyMzIoeGssIGlzTEUsIG5vbmNlLCBzcmMsIGRzdCkge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKG5vbmNlLCBCTE9DS19TSVpFKTtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShzcmMpO1xuICAgIGRzdCA9IGdldERzdChzcmMubGVuZ3RoLCBkc3QpO1xuICAgIGNvbnN0IGN0ciA9IG5vbmNlOyAvLyB3cml0ZSBuZXcgdmFsdWUgdG8gbm9uY2UsIHNvIGl0IGNhbiBiZSByZS11c2VkXG4gICAgY29uc3QgYzMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShjdHIpO1xuICAgIGNvbnN0IHZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShjdHIpO1xuICAgIGNvbnN0IHNyYzMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShzcmMpO1xuICAgIGNvbnN0IGRzdDMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShkc3QpO1xuICAgIGNvbnN0IGN0clBvcyA9IGlzTEUgPyAwIDogMTI7XG4gICAgY29uc3Qgc3JjTGVuID0gc3JjLmxlbmd0aDtcbiAgICAvLyBGaWxsIGJsb2NrIChlbXB0eSwgY3RyPTApXG4gICAgbGV0IGN0ck51bSA9IHZpZXcuZ2V0VWludDMyKGN0clBvcywgaXNMRSk7IC8vIHJlYWQgY3VycmVudCBjb3VudGVyIHZhbHVlXG4gICAgbGV0IHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIGMzMlswXSwgYzMyWzFdLCBjMzJbMl0sIGMzMlszXSk7XG4gICAgLy8gcHJvY2VzcyBibG9ja3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSArIDQgPD0gc3JjMzIubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgZHN0MzJbaSArIDBdID0gc3JjMzJbaSArIDBdIF4gczA7XG4gICAgICAgIGRzdDMyW2kgKyAxXSA9IHNyYzMyW2kgKyAxXSBeIHMxO1xuICAgICAgICBkc3QzMltpICsgMl0gPSBzcmMzMltpICsgMl0gXiBzMjtcbiAgICAgICAgZHN0MzJbaSArIDNdID0gc3JjMzJbaSArIDNdIF4gczM7XG4gICAgICAgIGN0ck51bSA9IChjdHJOdW0gKyAxKSA+Pj4gMDsgLy8gdTMyIHdyYXBcbiAgICAgICAgdmlldy5zZXRVaW50MzIoY3RyUG9zLCBjdHJOdW0sIGlzTEUpO1xuICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgYzMyWzBdLCBjMzJbMV0sIGMzMlsyXSwgYzMyWzNdKSk7XG4gICAgfVxuICAgIC8vIGxlZnRvdmVycyAobGVzcyB0aGFuIGEgYmxvY2spXG4gICAgY29uc3Qgc3RhcnQgPSBCTE9DS19TSVpFICogTWF0aC5mbG9vcihzcmMzMi5sZW5ndGggLyBCTE9DS19TSVpFMzIpO1xuICAgIGlmIChzdGFydCA8IHNyY0xlbikge1xuICAgICAgICBjb25zdCBiMzIgPSBuZXcgVWludDMyQXJyYXkoW3MwLCBzMSwgczIsIHMzXSk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9ICgwLCB1dGlsc19qc18xLnU4KShiMzIpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQsIHBvcyA9IDA7IGkgPCBzcmNMZW47IGkrKywgcG9zKyspXG4gICAgICAgICAgICBkc3RbaV0gPSBzcmNbaV0gXiBidWZbcG9zXTtcbiAgICB9XG4gICAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ1RSOiBjb3VudGVyIG1vZGUuIENyZWF0ZXMgc3RyZWFtIGNpcGhlci5cbiAqIFJlcXVpcmVzIGdvb2QgSVYuIFBhcmFsbGVsaXphYmxlLiBPSywgYnV0IG5vIE1BQy5cbiAqL1xuZXhwb3J0cy5jdHIgPSAoMCwgdXRpbHNfanNfMS53cmFwQ2lwaGVyKSh7IGJsb2NrU2l6ZTogMTYsIG5vbmNlTGVuZ3RoOiAxNiB9LCBmdW5jdGlvbiBjdHIoa2V5LCBub25jZSkge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGtleSk7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykobm9uY2UsIEJMT0NLX1NJWkUpO1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NDdHIoYnVmLCBkc3QpIHtcbiAgICAgICAgY29uc3QgeGsgPSBleHBhbmRLZXlMRShrZXkpO1xuICAgICAgICBjb25zdCBuID0gbm9uY2Uuc2xpY2UoKTtcbiAgICAgICAgY29uc3Qgb3V0ID0gY3RyQ291bnRlcih4aywgbiwgYnVmLCBkc3QpO1xuICAgICAgICB4ay5maWxsKDApO1xuICAgICAgICBuLmZpbGwoMCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuY3J5cHQ6IChwbGFpbnRleHQsIGRzdCkgPT4gcHJvY2Vzc0N0cihwbGFpbnRleHQsIGRzdCksXG4gICAgICAgIGRlY3J5cHQ6IChjaXBoZXJ0ZXh0LCBkc3QpID0+IHByb2Nlc3NDdHIoY2lwaGVydGV4dCwgZHN0KSxcbiAgICB9O1xufSk7XG5mdW5jdGlvbiB2YWxpZGF0ZUJsb2NrRGVjcnlwdChkYXRhKSB7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykoZGF0YSk7XG4gICAgaWYgKGRhdGEubGVuZ3RoICUgQkxPQ0tfU0laRSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFlcy8oY2JjLWVjYikuZGVjcnlwdCBjaXBoZXJ0ZXh0IHNob3VsZCBjb25zaXN0IG9mIGJsb2NrcyB3aXRoIHNpemUgJHtCTE9DS19TSVpFfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQmxvY2tFbmNyeXB0KHBsYWludGV4dCwgcGNrczUsIGRzdCkge1xuICAgIGxldCBvdXRMZW4gPSBwbGFpbnRleHQubGVuZ3RoO1xuICAgIGNvbnN0IHJlbWFpbmluZyA9IG91dExlbiAlIEJMT0NLX1NJWkU7XG4gICAgaWYgKCFwY2tzNSAmJiByZW1haW5pbmcgIT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWVjLyhjYmMtZWNiKTogdW5wYWRkZWQgcGxhaW50ZXh0IHdpdGggZGlzYWJsZWQgcGFkZGluZycpO1xuICAgIGNvbnN0IGIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHBsYWludGV4dCk7XG4gICAgaWYgKHBja3M1KSB7XG4gICAgICAgIGxldCBsZWZ0ID0gQkxPQ0tfU0laRSAtIHJlbWFpbmluZztcbiAgICAgICAgaWYgKCFsZWZ0KVxuICAgICAgICAgICAgbGVmdCA9IEJMT0NLX1NJWkU7IC8vIGlmIG5vIGJ5dGVzIGxlZnQsIGNyZWF0ZSBlbXB0eSBwYWRkaW5nIGJsb2NrXG4gICAgICAgIG91dExlbiA9IG91dExlbiArIGxlZnQ7XG4gICAgfVxuICAgIGNvbnN0IG91dCA9IGdldERzdChvdXRMZW4sIGRzdCk7XG4gICAgY29uc3QgbyA9ICgwLCB1dGlsc19qc18xLnUzMikob3V0KTtcbiAgICByZXR1cm4geyBiLCBvLCBvdXQgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUENLUyhkYXRhLCBwY2tzNSkge1xuICAgIGlmICghcGNrczUpXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgIGlmICghbGVuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFlcy9wY2tzNTogZW1wdHkgY2lwaGVydGV4dCBub3QgYWxsb3dlZGApO1xuICAgIGNvbnN0IGxhc3RCeXRlID0gZGF0YVtsZW4gLSAxXTtcbiAgICBpZiAobGFzdEJ5dGUgPD0gMCB8fCBsYXN0Qnl0ZSA+IDE2KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFlcy9wY2tzNTogd3JvbmcgcGFkZGluZyBieXRlOiAke2xhc3RCeXRlfWApO1xuICAgIGNvbnN0IG91dCA9IGRhdGEuc3ViYXJyYXkoMCwgLWxhc3RCeXRlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RCeXRlOyBpKyspXG4gICAgICAgIGlmIChkYXRhW2xlbiAtIGkgLSAxXSAhPT0gbGFzdEJ5dGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFlcy9wY2tzNTogd3JvbmcgcGFkZGluZ2ApO1xuICAgIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBwYWRQQ0tTKGxlZnQpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgY29uc3QgdG1wMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHRtcCk7XG4gICAgdG1wLnNldChsZWZ0KTtcbiAgICBjb25zdCBwYWRkaW5nQnl0ZSA9IEJMT0NLX1NJWkUgLSBsZWZ0Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gQkxPQ0tfU0laRSAtIHBhZGRpbmdCeXRlOyBpIDwgQkxPQ0tfU0laRTsgaSsrKVxuICAgICAgICB0bXBbaV0gPSBwYWRkaW5nQnl0ZTtcbiAgICByZXR1cm4gdG1wMzI7XG59XG4vKipcbiAqIEVDQjogRWxlY3Ryb25pYyBDb2RlQm9vay4gU2ltcGxlIGRldGVybWluaXN0aWMgcmVwbGFjZW1lbnQuXG4gKiBEYW5nZXJvdXM6IGFsd2F5cyBtYXAgeCB0byB5LiBTZWUgW0FFUyBQZW5ndWluXShodHRwczovL3dvcmRzLmZpbGlwcG8uaW8vdGhlLWVjYi1wZW5ndWluLykuXG4gKi9cbmV4cG9ydHMuZWNiID0gKDAsIHV0aWxzX2pzXzEud3JhcENpcGhlcikoeyBibG9ja1NpemU6IDE2IH0sIGZ1bmN0aW9uIGVjYihrZXksIG9wdHMgPSB7fSkge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGtleSk7XG4gICAgY29uc3QgcGNrczUgPSAhb3B0cy5kaXNhYmxlUGFkZGluZztcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0OiAocGxhaW50ZXh0LCBkc3QpID0+IHtcbiAgICAgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKHBsYWludGV4dCk7XG4gICAgICAgICAgICBjb25zdCB7IGIsIG8sIG91dDogX291dCB9ID0gdmFsaWRhdGVCbG9ja0VuY3J5cHQocGxhaW50ZXh0LCBwY2tzNSwgZHN0KTtcbiAgICAgICAgICAgIGNvbnN0IHhrID0gZXhwYW5kS2V5TEUoa2V5KTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpICsgNCA8PSBiLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBiW2kgKyAwXSwgYltpICsgMV0sIGJbaSArIDJdLCBiW2kgKyAzXSk7XG4gICAgICAgICAgICAgICAgKG9baSsrXSA9IHMwKSwgKG9baSsrXSA9IHMxKSwgKG9baSsrXSA9IHMyKSwgKG9baSsrXSA9IHMzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwY2tzNSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRtcDMyID0gcGFkUENLUyhwbGFpbnRleHQuc3ViYXJyYXkoaSAqIDQpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCB0bXAzMlswXSwgdG1wMzJbMV0sIHRtcDMyWzJdLCB0bXAzMlszXSk7XG4gICAgICAgICAgICAgICAgKG9baSsrXSA9IHMwKSwgKG9baSsrXSA9IHMxKSwgKG9baSsrXSA9IHMyKSwgKG9baSsrXSA9IHMzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhrLmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm4gX291dDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjcnlwdDogKGNpcGhlcnRleHQsIGRzdCkgPT4ge1xuICAgICAgICAgICAgdmFsaWRhdGVCbG9ja0RlY3J5cHQoY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleURlY0xFKGtleSk7XG4gICAgICAgICAgICBjb25zdCBvdXQgPSBnZXREc3QoY2lwaGVydGV4dC5sZW5ndGgsIGRzdCk7XG4gICAgICAgICAgICBjb25zdCBiID0gKDAsIHV0aWxzX2pzXzEudTMyKShjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG8gPSAoMCwgdXRpbHNfanNfMS51MzIpKG91dCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSArIDQgPD0gYi5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gZGVjcnlwdCh4aywgYltpICsgMF0sIGJbaSArIDFdLCBiW2kgKyAyXSwgYltpICsgM10pO1xuICAgICAgICAgICAgICAgIChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ay5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlUENLUyhvdXQsIHBja3M1KTtcbiAgICAgICAgfSxcbiAgICB9O1xufSk7XG4vKipcbiAqIENCQzogQ2lwaGVyLUJsb2NrLUNoYWluaW5nLiBLZXkgaXMgcHJldmlvdXMgcm91bmTigJlzIGJsb2NrLlxuICogRnJhZ2lsZTogbmVlZHMgcHJvcGVyIHBhZGRpbmcuIFVuYXV0aGVudGljYXRlZDogbmVlZHMgTUFDLlxuICovXG5leHBvcnRzLmNiYyA9ICgwLCB1dGlsc19qc18xLndyYXBDaXBoZXIpKHsgYmxvY2tTaXplOiAxNiwgbm9uY2VMZW5ndGg6IDE2IH0sIGZ1bmN0aW9uIGNiYyhrZXksIGl2LCBvcHRzID0ge30pIHtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShrZXkpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGl2LCAxNik7XG4gICAgY29uc3QgcGNrczUgPSAhb3B0cy5kaXNhYmxlUGFkZGluZztcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0OiAocGxhaW50ZXh0LCBkc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHhrID0gZXhwYW5kS2V5TEUoa2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHsgYiwgbywgb3V0OiBfb3V0IH0gPSB2YWxpZGF0ZUJsb2NrRW5jcnlwdChwbGFpbnRleHQsIHBja3M1LCBkc3QpO1xuICAgICAgICAgICAgY29uc3QgbjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShpdik7XG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCBzMCA9IG4zMlswXSwgczEgPSBuMzJbMV0sIHMyID0gbjMyWzJdLCBzMyA9IG4zMlszXTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpICsgNCA8PSBiLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAoczAgXj0gYltpICsgMF0pLCAoczEgXj0gYltpICsgMV0pLCAoczIgXj0gYltpICsgMl0pLCAoczMgXj0gYltpICsgM10pO1xuICAgICAgICAgICAgICAgICh7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBzMCwgczEsIHMyLCBzMykpO1xuICAgICAgICAgICAgICAgIChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGNrczUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bXAzMiA9IHBhZFBDS1MocGxhaW50ZXh0LnN1YmFycmF5KGkgKiA0KSk7XG4gICAgICAgICAgICAgICAgKHMwIF49IHRtcDMyWzBdKSwgKHMxIF49IHRtcDMyWzFdKSwgKHMyIF49IHRtcDMyWzJdKSwgKHMzIF49IHRtcDMyWzNdKTtcbiAgICAgICAgICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgczAsIHMxLCBzMiwgczMpKTtcbiAgICAgICAgICAgICAgICAob1tpKytdID0gczApLCAob1tpKytdID0gczEpLCAob1tpKytdID0gczIpLCAob1tpKytdID0gczMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeGsuZmlsbCgwKTtcbiAgICAgICAgICAgIHJldHVybiBfb3V0O1xuICAgICAgICB9LFxuICAgICAgICBkZWNyeXB0OiAoY2lwaGVydGV4dCwgZHN0KSA9PiB7XG4gICAgICAgICAgICB2YWxpZGF0ZUJsb2NrRGVjcnlwdChjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IHhrID0gZXhwYW5kS2V5RGVjTEUoa2V5KTtcbiAgICAgICAgICAgIGNvbnN0IG4zMiA9ICgwLCB1dGlsc19qc18xLnUzMikoaXYpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gZ2V0RHN0KGNpcGhlcnRleHQubGVuZ3RoLCBkc3QpO1xuICAgICAgICAgICAgY29uc3QgYiA9ICgwLCB1dGlsc19qc18xLnUzMikoY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBjb25zdCBvID0gKDAsIHV0aWxzX2pzXzEudTMyKShvdXQpO1xuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgczAgPSBuMzJbMF0sIHMxID0gbjMyWzFdLCBzMiA9IG4zMlsyXSwgczMgPSBuMzJbM107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSArIDQgPD0gYi5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICAgICAgY29uc3QgcHMwID0gczAsIHBzMSA9IHMxLCBwczIgPSBzMiwgcHMzID0gczM7XG4gICAgICAgICAgICAgICAgKHMwID0gYltpICsgMF0pLCAoczEgPSBiW2kgKyAxXSksIChzMiA9IGJbaSArIDJdKSwgKHMzID0gYltpICsgM10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgczA6IG8wLCBzMTogbzEsIHMyOiBvMiwgczM6IG8zIH0gPSBkZWNyeXB0KHhrLCBzMCwgczEsIHMyLCBzMyk7XG4gICAgICAgICAgICAgICAgKG9baSsrXSA9IG8wIF4gcHMwKSwgKG9baSsrXSA9IG8xIF4gcHMxKSwgKG9baSsrXSA9IG8yIF4gcHMyKSwgKG9baSsrXSA9IG8zIF4gcHMzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhrLmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVQQ0tTKG91dCwgcGNrczUpO1xuICAgICAgICB9LFxuICAgIH07XG59KTtcbi8qKlxuICogQ0ZCOiBDaXBoZXIgRmVlZGJhY2sgTW9kZS4gVGhlIGlucHV0IGZvciB0aGUgYmxvY2sgY2lwaGVyIGlzIHRoZSBwcmV2aW91cyBjaXBoZXIgb3V0cHV0LlxuICogVW5hdXRoZW50aWNhdGVkOiBuZWVkcyBNQUMuXG4gKi9cbmV4cG9ydHMuY2ZiID0gKDAsIHV0aWxzX2pzXzEud3JhcENpcGhlcikoeyBibG9ja1NpemU6IDE2LCBub25jZUxlbmd0aDogMTYgfSwgZnVuY3Rpb24gY2ZiKGtleSwgaXYpIHtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShrZXkpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGl2LCAxNik7XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0NmYihzcmMsIGlzRW5jcnlwdCwgZHN0KSB7XG4gICAgICAgIGNvbnN0IHhrID0gZXhwYW5kS2V5TEUoa2V5KTtcbiAgICAgICAgY29uc3Qgc3JjTGVuID0gc3JjLmxlbmd0aDtcbiAgICAgICAgZHN0ID0gZ2V0RHN0KHNyY0xlbiwgZHN0KTtcbiAgICAgICAgY29uc3Qgc3JjMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHNyYyk7XG4gICAgICAgIGNvbnN0IGRzdDMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShkc3QpO1xuICAgICAgICBjb25zdCBuZXh0MzIgPSBpc0VuY3J5cHQgPyBkc3QzMiA6IHNyYzMyO1xuICAgICAgICBjb25zdCBuMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGl2KTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCBzMCA9IG4zMlswXSwgczEgPSBuMzJbMV0sIHMyID0gbjMyWzJdLCBzMyA9IG4zMlszXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgKyA0IDw9IHNyYzMyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGNvbnN0IHsgczA6IGUwLCBzMTogZTEsIHMyOiBlMiwgczM6IGUzIH0gPSBlbmNyeXB0KHhrLCBzMCwgczEsIHMyLCBzMyk7XG4gICAgICAgICAgICBkc3QzMltpICsgMF0gPSBzcmMzMltpICsgMF0gXiBlMDtcbiAgICAgICAgICAgIGRzdDMyW2kgKyAxXSA9IHNyYzMyW2kgKyAxXSBeIGUxO1xuICAgICAgICAgICAgZHN0MzJbaSArIDJdID0gc3JjMzJbaSArIDJdIF4gZTI7XG4gICAgICAgICAgICBkc3QzMltpICsgM10gPSBzcmMzMltpICsgM10gXiBlMztcbiAgICAgICAgICAgIChzMCA9IG5leHQzMltpKytdKSwgKHMxID0gbmV4dDMyW2krK10pLCAoczIgPSBuZXh0MzJbaSsrXSksIChzMyA9IG5leHQzMltpKytdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsZWZ0b3ZlcnMgKGxlc3MgdGhhbiBibG9jaylcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBCTE9DS19TSVpFICogTWF0aC5mbG9vcihzcmMzMi5sZW5ndGggLyBCTE9DS19TSVpFMzIpO1xuICAgICAgICBpZiAoc3RhcnQgPCBzcmNMZW4pIHtcbiAgICAgICAgICAgICh7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBzMCwgczEsIHMyLCBzMykpO1xuICAgICAgICAgICAgY29uc3QgYnVmID0gKDAsIHV0aWxzX2pzXzEudTgpKG5ldyBVaW50MzJBcnJheShbczAsIHMxLCBzMiwgczNdKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQsIHBvcyA9IDA7IGkgPCBzcmNMZW47IGkrKywgcG9zKyspXG4gICAgICAgICAgICAgICAgZHN0W2ldID0gc3JjW2ldIF4gYnVmW3Bvc107XG4gICAgICAgICAgICBidWYuZmlsbCgwKTtcbiAgICAgICAgfVxuICAgICAgICB4ay5maWxsKDApO1xuICAgICAgICByZXR1cm4gZHN0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0OiAocGxhaW50ZXh0LCBkc3QpID0+IHByb2Nlc3NDZmIocGxhaW50ZXh0LCB0cnVlLCBkc3QpLFxuICAgICAgICBkZWNyeXB0OiAoY2lwaGVydGV4dCwgZHN0KSA9PiBwcm9jZXNzQ2ZiKGNpcGhlcnRleHQsIGZhbHNlLCBkc3QpLFxuICAgIH07XG59KTtcbi8vIFRPRE86IG1lcmdlIHdpdGggY2hhY2hhLCBob3dldmVyIGdjbSBoYXMgYml0TGVuIHdoaWxlIGNoYWNoYSBoYXMgYnl0ZUxlblxuZnVuY3Rpb24gY29tcHV0ZVRhZyhmbiwgaXNMRSwga2V5LCBkYXRhLCBBQUQpIHtcbiAgICBjb25zdCBoID0gZm4uY3JlYXRlKGtleSwgZGF0YS5sZW5ndGggKyAoQUFEPy5sZW5ndGggfHwgMCkpO1xuICAgIGlmIChBQUQpXG4gICAgICAgIGgudXBkYXRlKEFBRCk7XG4gICAgaC51cGRhdGUoZGF0YSk7XG4gICAgY29uc3QgbnVtID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGNvbnN0IHZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShudW0pO1xuICAgIGlmIChBQUQpXG4gICAgICAgICgwLCB1dGlsc19qc18xLnNldEJpZ1VpbnQ2NCkodmlldywgMCwgQmlnSW50KEFBRC5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgKDAsIHV0aWxzX2pzXzEuc2V0QmlnVWludDY0KSh2aWV3LCA4LCBCaWdJbnQoZGF0YS5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgaC51cGRhdGUobnVtKTtcbiAgICByZXR1cm4gaC5kaWdlc3QoKTtcbn1cbi8qKlxuICogR0NNOiBHYWxvaXMvQ291bnRlciBNb2RlLlxuICogR29vZCwgbW9kZXJuIHZlcnNpb24gb2YgQ1RSLCBwYXJhbGxlbCwgd2l0aCBNQUMuXG4gKiBCZSBjYXJlZnVsOiBNQUNzIGNhbiBiZSBmb3JnZWQuXG4gKi9cbmV4cG9ydHMuZ2NtID0gKDAsIHV0aWxzX2pzXzEud3JhcENpcGhlcikoeyBibG9ja1NpemU6IDE2LCBub25jZUxlbmd0aDogMTIsIHRhZ0xlbmd0aDogMTYgfSwgZnVuY3Rpb24gZ2NtKGtleSwgbm9uY2UsIEFBRCkge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKG5vbmNlKTtcbiAgICAvLyBOb25jZSBjYW4gYmUgcHJldHR5IG11Y2ggYW55dGhpbmcgKGV2ZW4gMSBieXRlKS4gQnV0IHNtYWxsZXIgbm9uY2VzIGxlc3Mgc2VjdXJlLlxuICAgIGlmIChub25jZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWVzL2djbTogZW1wdHkgbm9uY2UnKTtcbiAgICBjb25zdCB0YWdMZW5ndGggPSAxNjtcbiAgICBmdW5jdGlvbiBfY29tcHV0ZVRhZyhhdXRoS2V5LCB0YWdNYXNrLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IGNvbXB1dGVUYWcoX3BvbHl2YWxfanNfMS5naGFzaCwgZmFsc2UsIGF1dGhLZXksIGRhdGEsIEFBRCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFnTWFzay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRhZ1tpXSBePSB0YWdNYXNrW2ldO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXJpdmVLZXlzKCkge1xuICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICAgIGNvbnN0IGF1dGhLZXkgPSBFTVBUWV9CTE9DSy5zbGljZSgpO1xuICAgICAgICBjb25zdCBjb3VudGVyID0gRU1QVFlfQkxPQ0suc2xpY2UoKTtcbiAgICAgICAgY3RyMzIoeGssIGZhbHNlLCBjb3VudGVyLCBjb3VudGVyLCBhdXRoS2V5KTtcbiAgICAgICAgaWYgKG5vbmNlLmxlbmd0aCA9PT0gMTIpIHtcbiAgICAgICAgICAgIGNvdW50ZXIuc2V0KG5vbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNwZWMgKE5JU1QgODAwLTM4ZCkgc3VwcG9ydHMgdmFyaWFibGUgc2l6ZSBub25jZS5cbiAgICAgICAgICAgIC8vIE5vdCBzdXBwb3J0ZWQgZm9yIG5vdywgYnV0IGNhbiBiZSB1c2VmdWwuXG4gICAgICAgICAgICBjb25zdCBub25jZUxlbiA9IEVNUFRZX0JMT0NLLnNsaWNlKCk7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykobm9uY2VMZW4pO1xuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuc2V0QmlnVWludDY0KSh2aWV3LCA4LCBCaWdJbnQobm9uY2UubGVuZ3RoICogOCksIGZhbHNlKTtcbiAgICAgICAgICAgIC8vIGdoYXNoKG5vbmNlIHx8IHU2NGJlKDApIHx8IHU2NGJlKG5vbmNlTGVuKjgpKVxuICAgICAgICAgICAgX3BvbHl2YWxfanNfMS5naGFzaC5jcmVhdGUoYXV0aEtleSkudXBkYXRlKG5vbmNlKS51cGRhdGUobm9uY2VMZW4pLmRpZ2VzdEludG8oY291bnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFnTWFzayA9IGN0cjMyKHhrLCBmYWxzZSwgY291bnRlciwgRU1QVFlfQkxPQ0spO1xuICAgICAgICByZXR1cm4geyB4aywgYXV0aEtleSwgY291bnRlciwgdGFnTWFzayB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0OiAocGxhaW50ZXh0KSA9PiB7XG4gICAgICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShwbGFpbnRleHQpO1xuICAgICAgICAgICAgY29uc3QgeyB4aywgYXV0aEtleSwgY291bnRlciwgdGFnTWFzayB9ID0gZGVyaXZlS2V5cygpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCArIHRhZ0xlbmd0aCk7XG4gICAgICAgICAgICBjdHIzMih4aywgZmFsc2UsIGNvdW50ZXIsIHBsYWludGV4dCwgb3V0KTtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IF9jb21wdXRlVGFnKGF1dGhLZXksIHRhZ01hc2ssIG91dC5zdWJhcnJheSgwLCBvdXQubGVuZ3RoIC0gdGFnTGVuZ3RoKSk7XG4gICAgICAgICAgICBvdXQuc2V0KHRhZywgcGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB4ay5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjcnlwdDogKGNpcGhlcnRleHQpID0+IHtcbiAgICAgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGNpcGhlcnRleHQpO1xuICAgICAgICAgICAgaWYgKGNpcGhlcnRleHQubGVuZ3RoIDwgdGFnTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWVzL2djbTogY2lwaGVydGV4dCBsZXNzIHRoYW4gdGFnTGVuICgke3RhZ0xlbmd0aH0pYCk7XG4gICAgICAgICAgICBjb25zdCB7IHhrLCBhdXRoS2V5LCBjb3VudGVyLCB0YWdNYXNrIH0gPSBkZXJpdmVLZXlzKCk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2lwaGVydGV4dC5zdWJhcnJheSgwLCAtdGFnTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhc3NlZFRhZyA9IGNpcGhlcnRleHQuc3ViYXJyYXkoLXRhZ0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBfY29tcHV0ZVRhZyhhdXRoS2V5LCB0YWdNYXNrLCBkYXRhKTtcbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxzX2pzXzEuZXF1YWxCeXRlcykodGFnLCBwYXNzZWRUYWcpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWVzL2djbTogaW52YWxpZCBnaGFzaCB0YWcnKTtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IGN0cjMyKHhrLCBmYWxzZSwgY291bnRlciwgZGF0YSk7XG4gICAgICAgICAgICBhdXRoS2V5LmZpbGwoMCk7XG4gICAgICAgICAgICB0YWdNYXNrLmZpbGwoMCk7XG4gICAgICAgICAgICB4ay5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICB9O1xufSk7XG5jb25zdCBsaW1pdCA9IChuYW1lLCBtaW4sIG1heCkgPT4gKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkgfHwgbWluID4gdmFsdWUgfHwgdmFsdWUgPiBtYXgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfTogaW52YWxpZCB2YWx1ZT0ke3ZhbHVlfSwgbXVzdCBiZSBbJHttaW59Li4ke21heH1dYCk7XG59O1xuLyoqXG4gKiBBRVMtR0NNLVNJVjogY2xhc3NpYyBBRVMtR0NNIHdpdGggbm9uY2UtbWlzdXNlIHJlc2lzdGFuY2UuXG4gKiBHdWFyYW50ZWVzIHRoYXQsIHdoZW4gYSBub25jZSBpcyByZXBlYXRlZCwgdGhlIG9ubHkgc2VjdXJpdHkgbG9zcyBpcyB0aGF0IGlkZW50aWNhbFxuICogcGxhaW50ZXh0cyB3aWxsIHByb2R1Y2UgaWRlbnRpY2FsIGNpcGhlcnRleHRzLlxuICogUkZDIDg0NTIsIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjODQ1MlxuICovXG5leHBvcnRzLnNpdiA9ICgwLCB1dGlsc19qc18xLndyYXBDaXBoZXIpKHsgYmxvY2tTaXplOiAxNiwgbm9uY2VMZW5ndGg6IDEyLCB0YWdMZW5ndGg6IDE2IH0sIGZ1bmN0aW9uIHNpdihrZXksIG5vbmNlLCBBQUQpIHtcbiAgICBjb25zdCB0YWdMZW5ndGggPSAxNjtcbiAgICAvLyBGcm9tIFJGQyA4NDUyOiBTZWN0aW9uIDZcbiAgICBjb25zdCBBQURfTElNSVQgPSBsaW1pdCgnQUFEJywgMCwgMiAqKiAzNik7XG4gICAgY29uc3QgUExBSU5fTElNSVQgPSBsaW1pdCgncGxhaW50ZXh0JywgMCwgMiAqKiAzNik7XG4gICAgY29uc3QgTk9OQ0VfTElNSVQgPSBsaW1pdCgnbm9uY2UnLCAxMiwgMTIpO1xuICAgIGNvbnN0IENJUEhFUl9MSU1JVCA9IGxpbWl0KCdjaXBoZXJ0ZXh0JywgMTYsIDIgKiogMzYgKyAxNik7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykobm9uY2UpO1xuICAgIE5PTkNFX0xJTUlUKG5vbmNlLmxlbmd0aCk7XG4gICAgaWYgKEFBRCkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShBQUQpO1xuICAgICAgICBBQURfTElNSVQoQUFELmxlbmd0aCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlcml2ZUtleXMoKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gIT09IDE2ICYmIGxlbiAhPT0gMjQgJiYgbGVuICE9PSAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihga2V5IGxlbmd0aCBtdXN0IGJlIDE2LCAyNCBvciAzMiBieXRlcywgZ290OiAke2xlbn0gYnl0ZXNgKTtcbiAgICAgICAgY29uc3QgeGsgPSBleHBhbmRLZXlMRShrZXkpO1xuICAgICAgICBjb25zdCBlbmNLZXkgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICBjb25zdCBhdXRoS2V5ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBjb25zdCBuMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKG5vbmNlKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCBzMCA9IDAsIHMxID0gbjMyWzBdLCBzMiA9IG4zMlsxXSwgczMgPSBuMzJbMl07XG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBkZXJpdmVkS2V5IG9mIFthdXRoS2V5LCBlbmNLZXldLm1hcCh1dGlsc19qc18xLnUzMikpIHtcbiAgICAgICAgICAgIGNvbnN0IGQzMiA9ICgwLCB1dGlsc19qc18xLnUzMikoZGVyaXZlZEtleSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGQzMi5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIC8vIGFlcyh1MzJsZSgwKSB8fCBub25jZSlbOjhdIHx8IGFlcyh1MzJsZSgxKSB8fCBub25jZSlbOjhdIC4uLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgczA6IG8wLCBzMTogbzEgfSA9IGVuY3J5cHQoeGssIHMwLCBzMSwgczIsIHMzKTtcbiAgICAgICAgICAgICAgICBkMzJbaSArIDBdID0gbzA7XG4gICAgICAgICAgICAgICAgZDMyW2kgKyAxXSA9IG8xO1xuICAgICAgICAgICAgICAgIHMwID0gKytjb3VudGVyOyAvLyBpbmNyZW1lbnQgY291bnRlciBpbnNpZGUgc3RhdGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4ay5maWxsKDApO1xuICAgICAgICByZXR1cm4geyBhdXRoS2V5LCBlbmNLZXk6IGV4cGFuZEtleUxFKGVuY0tleSkgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2NvbXB1dGVUYWcoZW5jS2V5LCBhdXRoS2V5LCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IGNvbXB1dGVUYWcoX3BvbHl2YWxfanNfMS5wb2x5dmFsLCB0cnVlLCBhdXRoS2V5LCBkYXRhLCBBQUQpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBleHBlY3RlZCB0YWcgYnkgWE9SaW5nIFNfcyBhbmQgdGhlIG5vbmNlLCBjbGVhcmluZyB0aGVcbiAgICAgICAgLy8gbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGxhc3QgYnl0ZSBhbmQgZW5jcnlwdGluZyB3aXRoIHRoZVxuICAgICAgICAvLyBtZXNzYWdlLWVuY3J5cHRpb24ga2V5LlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspXG4gICAgICAgICAgICB0YWdbaV0gXj0gbm9uY2VbaV07XG4gICAgICAgIHRhZ1sxNV0gJj0gMHg3ZjsgLy8gQ2xlYXIgdGhlIGhpZ2hlc3QgYml0XG4gICAgICAgIC8vIGVuY3J5cHQgdGFnIGFzIGJsb2NrXG4gICAgICAgIGNvbnN0IHQzMiA9ICgwLCB1dGlsc19qc18xLnUzMikodGFnKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCBzMCA9IHQzMlswXSwgczEgPSB0MzJbMV0sIHMyID0gdDMyWzJdLCBzMyA9IHQzMlszXTtcbiAgICAgICAgKHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoZW5jS2V5LCBzMCwgczEsIHMyLCBzMykpO1xuICAgICAgICAodDMyWzBdID0gczApLCAodDMyWzFdID0gczEpLCAodDMyWzJdID0gczIpLCAodDMyWzNdID0gczMpO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICAvLyBhY3R1YWwgZGVjcnlwdC9lbmNyeXB0IG9mIG1lc3NhZ2UuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc1NpdihlbmNLZXksIHRhZywgaW5wdXQpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gdGFnLnNsaWNlKCk7XG4gICAgICAgIGJsb2NrWzE1XSB8PSAweDgwOyAvLyBGb3JjZSBoaWdoZXN0IGJpdFxuICAgICAgICByZXR1cm4gY3RyMzIoZW5jS2V5LCB0cnVlLCBibG9jaywgaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0OiAocGxhaW50ZXh0KSA9PiB7XG4gICAgICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShwbGFpbnRleHQpO1xuICAgICAgICAgICAgUExBSU5fTElNSVQocGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCB7IGVuY0tleSwgYXV0aEtleSB9ID0gZGVyaXZlS2V5cygpO1xuICAgICAgICAgICAgY29uc3QgdGFnID0gX2NvbXB1dGVUYWcoZW5jS2V5LCBhdXRoS2V5LCBwbGFpbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCArIHRhZ0xlbmd0aCk7XG4gICAgICAgICAgICBvdXQuc2V0KHRhZywgcGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICBvdXQuc2V0KHByb2Nlc3NTaXYoZW5jS2V5LCB0YWcsIHBsYWludGV4dCkpO1xuICAgICAgICAgICAgZW5jS2V5LmZpbGwoMCk7XG4gICAgICAgICAgICBhdXRoS2V5LmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICBkZWNyeXB0OiAoY2lwaGVydGV4dCkgPT4ge1xuICAgICAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykoY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBDSVBIRVJfTElNSVQoY2lwaGVydGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgdGFnID0gY2lwaGVydGV4dC5zdWJhcnJheSgtdGFnTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5jS2V5LCBhdXRoS2V5IH0gPSBkZXJpdmVLZXlzKCk7XG4gICAgICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBwcm9jZXNzU2l2KGVuY0tleSwgdGFnLCBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIC10YWdMZW5ndGgpKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVGFnID0gX2NvbXB1dGVUYWcoZW5jS2V5LCBhdXRoS2V5LCBwbGFpbnRleHQpO1xuICAgICAgICAgICAgZW5jS2V5LmZpbGwoMCk7XG4gICAgICAgICAgICBhdXRoS2V5LmZpbGwoMCk7XG4gICAgICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmVxdWFsQnl0ZXMpKHRhZywgZXhwZWN0ZWRUYWcpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2x5dmFsIHRhZycpO1xuICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICAgICAgfSxcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBpc0J5dGVzMzIoYSkge1xuICAgIHJldHVybiAoYSAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAoYSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8IGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQzMkFycmF5JykpO1xufVxuZnVuY3Rpb24gZW5jcnlwdEJsb2NrKHhrLCBibG9jaykge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGJsb2NrLCAxNik7XG4gICAgaWYgKCFpc0J5dGVzMzIoeGspKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19lbmNyeXB0QmxvY2sgYWNjZXB0cyByZXN1bHQgb2YgZXhwYW5kS2V5TEUnKTtcbiAgICBjb25zdCBiMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGJsb2NrKTtcbiAgICBsZXQgeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgYjMyWzBdLCBiMzJbMV0sIGIzMlsyXSwgYjMyWzNdKTtcbiAgICAoYjMyWzBdID0gczApLCAoYjMyWzFdID0gczEpLCAoYjMyWzJdID0gczIpLCAoYjMyWzNdID0gczMpO1xuICAgIHJldHVybiBibG9jaztcbn1cbmZ1bmN0aW9uIGRlY3J5cHRCbG9jayh4aywgYmxvY2spIHtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShibG9jaywgMTYpO1xuICAgIGlmICghaXNCeXRlczMyKHhrKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfZGVjcnlwdEJsb2NrIGFjY2VwdHMgcmVzdWx0IG9mIGV4cGFuZEtleUxFJyk7XG4gICAgY29uc3QgYjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShibG9jayk7XG4gICAgbGV0IHsgczAsIHMxLCBzMiwgczMgfSA9IGRlY3J5cHQoeGssIGIzMlswXSwgYjMyWzFdLCBiMzJbMl0sIGIzMlszXSk7XG4gICAgKGIzMlswXSA9IHMwKSwgKGIzMlsxXSA9IHMxKSwgKGIzMlsyXSA9IHMyKSwgKGIzMlszXSA9IHMzKTtcbiAgICByZXR1cm4gYmxvY2s7XG59XG4vLyBIaWdobHkgdW5zYWZlIHByaXZhdGUgZnVuY3Rpb25zIGZvciBpbXBsZW1lbnRpbmcgbmV3IG1vZGVzIG9yIGNpcGhlcnMgYmFzZWQgb24gQUVTXG4vLyBDYW4gY2hhbmdlIGF0IGFueSB0aW1lLCBubyBBUEkgZ3VhcmFudGVlc1xuZXhwb3J0cy51bnNhZmUgPSB7XG4gICAgZXhwYW5kS2V5TEUsXG4gICAgZXhwYW5kS2V5RGVjTEUsXG4gICAgZW5jcnlwdCxcbiAgICBkZWNyeXB0LFxuICAgIGVuY3J5cHRCbG9jayxcbiAgICBkZWNyeXB0QmxvY2ssXG4gICAgY3RyQ291bnRlcixcbiAgICBjdHIzMixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/aes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/chacha.js":
/*!*************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/ciphers/chacha.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.xchacha20poly1305 = exports.chacha20poly1305 = exports._poly1305_aead = exports.chacha12 = exports.chacha8 = exports.xchacha20 = exports.chacha20 = exports.chacha20orig = exports.hchacha = void 0;\n// prettier-ignore\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/utils.js\");\nconst _poly1305_js_1 = __webpack_require__(/*! ./_poly1305.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_poly1305.js\");\nconst _arx_js_1 = __webpack_require__(/*! ./_arx.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_arx.js\");\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_assert.js\");\n// ChaCha20 stream cipher was released in 2008. ChaCha aims to increase\n// the diffusion per round, but had slightly less cryptanalysis.\n// https://cr.yp.to/chacha.html, http://cr.yp.to/chacha/chacha-20080128.pdf\n/**\n * ChaCha core function.\n */\n// prettier-ignore\nfunction chachaCore(s, k, n, out, cnt, rounds = 20) {\n    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n    y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], // Key      Key     Key     Key\n    y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], // Key      Key     Key     Key\n    y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n    // Save state to temporary variables\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    for (let r = 0; r < rounds; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x09, 7);\n    }\n    // Write output\n    let oi = 0;\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha helper method, used primarily in xchacha, to hash\n * key and nonce into key' and nonce'.\n * Same as chachaCore, but there doesn't seem to be a way to move the block\n * out without 25% performance hit.\n */\n// prettier-ignore\nfunction hchacha(s, k, i, o32) {\n    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n    for (let r = 0; r < 20; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = (0, _arx_js_1.rotl)(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = (0, _arx_js_1.rotl)(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = (0, _arx_js_1.rotl)(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = (0, _arx_js_1.rotl)(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = (0, _arx_js_1.rotl)(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = (0, _arx_js_1.rotl)(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = (0, _arx_js_1.rotl)(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = (0, _arx_js_1.rotl)(x04 ^ x09, 7);\n    }\n    let oi = 0;\n    o32[oi++] = x00;\n    o32[oi++] = x01;\n    o32[oi++] = x02;\n    o32[oi++] = x03;\n    o32[oi++] = x12;\n    o32[oi++] = x13;\n    o32[oi++] = x14;\n    o32[oi++] = x15;\n}\nexports.hchacha = hchacha;\n/**\n * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.\n */\nexports.chacha20orig = (0, _arx_js_1.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    allowShortKeys: true,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexports.chacha20 = (0, _arx_js_1.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    allowShortKeys: false,\n});\n/**\n * XChaCha eXtended-nonce ChaCha. 24-byte nonce.\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n */\nexports.xchacha20 = (0, _arx_js_1.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    extendNonceFn: hchacha,\n    allowShortKeys: false,\n});\n/**\n * Reduced 8-round chacha, described in original paper.\n */\nexports.chacha8 = (0, _arx_js_1.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 8,\n});\n/**\n * Reduced 12-round chacha, described in original paper.\n */\nexports.chacha12 = (0, _arx_js_1.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 12,\n});\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h, msg) => {\n    h.update(msg);\n    const left = msg.length % 16;\n    if (left)\n        h.update(ZEROS16.subarray(left));\n};\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(fn, key, nonce, data, AAD) {\n    const authKey = fn(key, nonce, ZEROS32);\n    const h = _poly1305_js_1.poly1305.create(authKey);\n    if (AAD)\n        updatePadded(h, AAD);\n    updatePadded(h, data);\n    const num = new Uint8Array(16);\n    const view = (0, utils_js_1.createView)(num);\n    (0, utils_js_1.setBigUint64)(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    (0, utils_js_1.setBigUint64)(view, 8, BigInt(data.length), true);\n    h.update(num);\n    const res = h.digest();\n    authKey.fill(0);\n    return res;\n}\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them similar to:\n * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250\n * But it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nconst _poly1305_aead = (xorStream) => (key, nonce, AAD) => {\n    const tagLength = 16;\n    (0, _assert_js_1.bytes)(key, 32);\n    (0, _assert_js_1.bytes)(nonce);\n    return {\n        encrypt: (plaintext, output) => {\n            const plength = plaintext.length;\n            const clength = plength + tagLength;\n            if (output) {\n                (0, _assert_js_1.bytes)(output, clength);\n            }\n            else {\n                output = new Uint8Array(clength);\n            }\n            xorStream(key, nonce, plaintext, output, 1);\n            const tag = computeTag(xorStream, key, nonce, output.subarray(0, -tagLength), AAD);\n            output.set(tag, plength); // append tag\n            return output;\n        },\n        decrypt: (ciphertext, output) => {\n            const clength = ciphertext.length;\n            const plength = clength - tagLength;\n            if (clength < tagLength)\n                throw new Error(`encrypted data must be at least ${tagLength} bytes`);\n            if (output) {\n                (0, _assert_js_1.bytes)(output, plength);\n            }\n            else {\n                output = new Uint8Array(plength);\n            }\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = computeTag(xorStream, key, nonce, data, AAD);\n            if (!(0, utils_js_1.equalBytes)(passedTag, tag))\n                throw new Error('invalid tag');\n            xorStream(key, nonce, data, output, 1);\n            return output;\n        },\n    };\n};\nexports._poly1305_aead = _poly1305_aead;\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nexports.chacha20poly1305 = (0, utils_js_1.wrapCipher)({ blockSize: 64, nonceLength: 12, tagLength: 16 }, (0, exports._poly1305_aead)(exports.chacha20));\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n */\nexports.xchacha20poly1305 = (0, utils_js_1.wrapCipher)({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (0, exports._poly1305_aead)(exports.xchacha20));\n//# sourceMappingURL=chacha.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2NoYWNoYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyxzQkFBc0IsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcsb0JBQW9CLEdBQUcsZUFBZTtBQUNsTTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHdHQUFZO0FBQ3ZDLHVCQUF1QixtQkFBTyxDQUFDLGdIQUFnQjtBQUMvQyxrQkFBa0IsbUJBQU8sQ0FBQyxzR0FBVztBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyw0R0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsV0FBVztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQywrQ0FBK0M7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQ0FBZ0MsK0NBQStDO0FBQ3hHIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2NoYWNoYS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMueGNoYWNoYTIwcG9seTEzMDUgPSBleHBvcnRzLmNoYWNoYTIwcG9seTEzMDUgPSBleHBvcnRzLl9wb2x5MTMwNV9hZWFkID0gZXhwb3J0cy5jaGFjaGExMiA9IGV4cG9ydHMuY2hhY2hhOCA9IGV4cG9ydHMueGNoYWNoYTIwID0gZXhwb3J0cy5jaGFjaGEyMCA9IGV4cG9ydHMuY2hhY2hhMjBvcmlnID0gZXhwb3J0cy5oY2hhY2hhID0gdm9pZCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBfcG9seTEzMDVfanNfMSA9IHJlcXVpcmUoXCIuL19wb2x5MTMwNS5qc1wiKTtcbmNvbnN0IF9hcnhfanNfMSA9IHJlcXVpcmUoXCIuL19hcnguanNcIik7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuLy8gQ2hhQ2hhMjAgc3RyZWFtIGNpcGhlciB3YXMgcmVsZWFzZWQgaW4gMjAwOC4gQ2hhQ2hhIGFpbXMgdG8gaW5jcmVhc2Vcbi8vIHRoZSBkaWZmdXNpb24gcGVyIHJvdW5kLCBidXQgaGFkIHNsaWdodGx5IGxlc3MgY3J5cHRhbmFseXNpcy5cbi8vIGh0dHBzOi8vY3IueXAudG8vY2hhY2hhLmh0bWwsIGh0dHA6Ly9jci55cC50by9jaGFjaGEvY2hhY2hhLTIwMDgwMTI4LnBkZlxuLyoqXG4gKiBDaGFDaGEgY29yZSBmdW5jdGlvbi5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBjaGFjaGFDb3JlKHMsIGssIG4sIG91dCwgY250LCByb3VuZHMgPSAyMCkge1xuICAgIGxldCB5MDAgPSBzWzBdLCB5MDEgPSBzWzFdLCB5MDIgPSBzWzJdLCB5MDMgPSBzWzNdLCAvLyBcImV4cGFcIiAgIFwibmQgM1wiICBcIjItYnlcIiAgXCJ0ZSBrXCJcbiAgICB5MDQgPSBrWzBdLCB5MDUgPSBrWzFdLCB5MDYgPSBrWzJdLCB5MDcgPSBrWzNdLCAvLyBLZXkgICAgICBLZXkgICAgIEtleSAgICAgS2V5XG4gICAgeTA4ID0ga1s0XSwgeTA5ID0ga1s1XSwgeTEwID0ga1s2XSwgeTExID0ga1s3XSwgLy8gS2V5ICAgICAgS2V5ICAgICBLZXkgICAgIEtleVxuICAgIHkxMiA9IGNudCwgeTEzID0gblswXSwgeTE0ID0gblsxXSwgeTE1ID0gblsyXTsgLy8gQ291bnRlciAgQ291bnRlclx0Tm9uY2UgICBOb25jZVxuICAgIC8vIFNhdmUgc3RhdGUgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlc1xuICAgIGxldCB4MDAgPSB5MDAsIHgwMSA9IHkwMSwgeDAyID0geTAyLCB4MDMgPSB5MDMsIHgwNCA9IHkwNCwgeDA1ID0geTA1LCB4MDYgPSB5MDYsIHgwNyA9IHkwNywgeDA4ID0geTA4LCB4MDkgPSB5MDksIHgxMCA9IHkxMCwgeDExID0geTExLCB4MTIgPSB5MTIsIHgxMyA9IHkxMywgeDE0ID0geTE0LCB4MTUgPSB5MTU7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3VuZHM7IHIgKz0gMikge1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7XG4gICAgICAgIHgxMiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEyIF4geDAwLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDQgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNCkgfCAwO1xuICAgICAgICB4MTIgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxMiBeIHgwMCwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDQgXiB4MDgsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG4gICAgICAgIHgxMyA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEzIF4geDAxLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDUgXiB4MDksIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNSkgfCAwO1xuICAgICAgICB4MTMgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxMyBeIHgwMSwgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDUgXiB4MDksIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG4gICAgICAgIHgxNCA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE0IF4geDAyLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDYgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNikgfCAwO1xuICAgICAgICB4MTQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxNCBeIHgwMiwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDYgXiB4MTAsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7XG4gICAgICAgIHgxNSA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE1IF4geDAzLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDcgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNykgfCAwO1xuICAgICAgICB4MTUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxNSBeIHgwMywgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDcgXiB4MTEsIDcpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG4gICAgICAgIHgxNSA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE1IF4geDAwLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDUgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNSkgfCAwO1xuICAgICAgICB4MTUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxNSBeIHgwMCwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDUgXiB4MTAsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG4gICAgICAgIHgxMiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEyIF4geDAxLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDYgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNikgfCAwO1xuICAgICAgICB4MTIgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxMiBeIHgwMSwgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDYgXiB4MTEsIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7XG4gICAgICAgIHgxMyA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEzIF4geDAyLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDcgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNykgfCAwO1xuICAgICAgICB4MTMgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxMyBeIHgwMiwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDcgXiB4MDgsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG4gICAgICAgIHgxNCA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE0IF4geDAzLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDQgXiB4MDksIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNCkgfCAwO1xuICAgICAgICB4MTQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxNCBeIHgwMywgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDQgXiB4MDksIDcpO1xuICAgIH1cbiAgICAvLyBXcml0ZSBvdXRwdXRcbiAgICBsZXQgb2kgPSAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDAgKyB4MDApIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAxICsgeDAxKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMiArIHgwMikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDMgKyB4MDMpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA0ICsgeDA0KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNSArIHgwNSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDYgKyB4MDYpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA3ICsgeDA3KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwOCArIHgwOCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDkgKyB4MDkpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEwICsgeDEwKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMSArIHgxMSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTIgKyB4MTIpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEzICsgeDEzKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxNCArIHgxNCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTUgKyB4MTUpIHwgMDtcbn1cbi8qKlxuICogaGNoYWNoYSBoZWxwZXIgbWV0aG9kLCB1c2VkIHByaW1hcmlseSBpbiB4Y2hhY2hhLCB0byBoYXNoXG4gKiBrZXkgYW5kIG5vbmNlIGludG8ga2V5JyBhbmQgbm9uY2UnLlxuICogU2FtZSBhcyBjaGFjaGFDb3JlLCBidXQgdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgd2F5IHRvIG1vdmUgdGhlIGJsb2NrXG4gKiBvdXQgd2l0aG91dCAyNSUgcGVyZm9ybWFuY2UgaGl0LlxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIGhjaGFjaGEocywgaywgaSwgbzMyKSB7XG4gICAgbGV0IHgwMCA9IHNbMF0sIHgwMSA9IHNbMV0sIHgwMiA9IHNbMl0sIHgwMyA9IHNbM10sIHgwNCA9IGtbMF0sIHgwNSA9IGtbMV0sIHgwNiA9IGtbMl0sIHgwNyA9IGtbM10sIHgwOCA9IGtbNF0sIHgwOSA9IGtbNV0sIHgxMCA9IGtbNl0sIHgxMSA9IGtbN10sIHgxMiA9IGlbMF0sIHgxMyA9IGlbMV0sIHgxNCA9IGlbMl0sIHgxNSA9IGlbM107XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCAyMDsgciArPSAyKSB7XG4gICAgICAgIHgwMCA9ICh4MDAgKyB4MDQpIHwgMDtcbiAgICAgICAgeDEyID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTIgXiB4MDAsIDE2KTtcbiAgICAgICAgeDA4ID0gKHgwOCArIHgxMikgfCAwO1xuICAgICAgICB4MDQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNCBeIHgwOCwgMTIpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7XG4gICAgICAgIHgxMiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEyIF4geDAwLCA4KTtcbiAgICAgICAgeDA4ID0gKHgwOCArIHgxMikgfCAwO1xuICAgICAgICB4MDQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNCBeIHgwOCwgNyk7XG4gICAgICAgIHgwMSA9ICh4MDEgKyB4MDUpIHwgMDtcbiAgICAgICAgeDEzID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTMgXiB4MDEsIDE2KTtcbiAgICAgICAgeDA5ID0gKHgwOSArIHgxMykgfCAwO1xuICAgICAgICB4MDUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNSBeIHgwOSwgMTIpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG4gICAgICAgIHgxMyA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEzIF4geDAxLCA4KTtcbiAgICAgICAgeDA5ID0gKHgwOSArIHgxMykgfCAwO1xuICAgICAgICB4MDUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNSBeIHgwOSwgNyk7XG4gICAgICAgIHgwMiA9ICh4MDIgKyB4MDYpIHwgMDtcbiAgICAgICAgeDE0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTQgXiB4MDIsIDE2KTtcbiAgICAgICAgeDEwID0gKHgxMCArIHgxNCkgfCAwO1xuICAgICAgICB4MDYgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNiBeIHgxMCwgMTIpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG4gICAgICAgIHgxNCA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE0IF4geDAyLCA4KTtcbiAgICAgICAgeDEwID0gKHgxMCArIHgxNCkgfCAwO1xuICAgICAgICB4MDYgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNiBeIHgxMCwgNyk7XG4gICAgICAgIHgwMyA9ICh4MDMgKyB4MDcpIHwgMDtcbiAgICAgICAgeDE1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTUgXiB4MDMsIDE2KTtcbiAgICAgICAgeDExID0gKHgxMSArIHgxNSkgfCAwO1xuICAgICAgICB4MDcgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNyBeIHgxMSwgMTIpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7XG4gICAgICAgIHgxNSA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE1IF4geDAzLCA4KTtcbiAgICAgICAgeDExID0gKHgxMSArIHgxNSkgfCAwO1xuICAgICAgICB4MDcgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNyBeIHgxMSwgNyk7XG4gICAgICAgIHgwMCA9ICh4MDAgKyB4MDUpIHwgMDtcbiAgICAgICAgeDE1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTUgXiB4MDAsIDE2KTtcbiAgICAgICAgeDEwID0gKHgxMCArIHgxNSkgfCAwO1xuICAgICAgICB4MDUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNSBeIHgxMCwgMTIpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG4gICAgICAgIHgxNSA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE1IF4geDAwLCA4KTtcbiAgICAgICAgeDEwID0gKHgxMCArIHgxNSkgfCAwO1xuICAgICAgICB4MDUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNSBeIHgxMCwgNyk7XG4gICAgICAgIHgwMSA9ICh4MDEgKyB4MDYpIHwgMDtcbiAgICAgICAgeDEyID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTIgXiB4MDEsIDE2KTtcbiAgICAgICAgeDExID0gKHgxMSArIHgxMikgfCAwO1xuICAgICAgICB4MDYgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNiBeIHgxMSwgMTIpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG4gICAgICAgIHgxMiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEyIF4geDAxLCA4KTtcbiAgICAgICAgeDExID0gKHgxMSArIHgxMikgfCAwO1xuICAgICAgICB4MDYgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNiBeIHgxMSwgNyk7XG4gICAgICAgIHgwMiA9ICh4MDIgKyB4MDcpIHwgMDtcbiAgICAgICAgeDEzID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTMgXiB4MDIsIDE2KTtcbiAgICAgICAgeDA4ID0gKHgwOCArIHgxMykgfCAwO1xuICAgICAgICB4MDcgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNyBeIHgwOCwgMTIpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7XG4gICAgICAgIHgxMyA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEzIF4geDAyLCA4KTtcbiAgICAgICAgeDA4ID0gKHgwOCArIHgxMykgfCAwO1xuICAgICAgICB4MDcgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNyBeIHgwOCwgNyk7XG4gICAgICAgIHgwMyA9ICh4MDMgKyB4MDQpIHwgMDtcbiAgICAgICAgeDE0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTQgXiB4MDMsIDE2KTtcbiAgICAgICAgeDA5ID0gKHgwOSArIHgxNCkgfCAwO1xuICAgICAgICB4MDQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNCBeIHgwOSwgMTIpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG4gICAgICAgIHgxNCA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE0IF4geDAzLCA4KTtcbiAgICAgICAgeDA5ID0gKHgwOSArIHgxNCkgfCAwO1xuICAgICAgICB4MDQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNCBeIHgwOSwgNyk7XG4gICAgfVxuICAgIGxldCBvaSA9IDA7XG4gICAgbzMyW29pKytdID0geDAwO1xuICAgIG8zMltvaSsrXSA9IHgwMTtcbiAgICBvMzJbb2krK10gPSB4MDI7XG4gICAgbzMyW29pKytdID0geDAzO1xuICAgIG8zMltvaSsrXSA9IHgxMjtcbiAgICBvMzJbb2krK10gPSB4MTM7XG4gICAgbzMyW29pKytdID0geDE0O1xuICAgIG8zMltvaSsrXSA9IHgxNTtcbn1cbmV4cG9ydHMuaGNoYWNoYSA9IGhjaGFjaGE7XG4vKipcbiAqIE9yaWdpbmFsLCBub24tUkZDIGNoYWNoYTIwIGZyb20gREpCLiA4LWJ5dGUgbm9uY2UsIDgtYnl0ZSBjb3VudGVyLlxuICovXG5leHBvcnRzLmNoYWNoYTIwb3JpZyA9ICgwLCBfYXJ4X2pzXzEuY3JlYXRlQ2lwaGVyKShjaGFjaGFDb3JlLCB7XG4gICAgY291bnRlclJpZ2h0OiBmYWxzZSxcbiAgICBjb3VudGVyTGVuZ3RoOiA4LFxuICAgIGFsbG93U2hvcnRLZXlzOiB0cnVlLFxufSk7XG4vKipcbiAqIENoYUNoYSBzdHJlYW0gY2lwaGVyLiBDb25mb3JtcyB0byBSRkMgODQzOSAoSUVURiwgVExTKS4gMTItYnl0ZSBub25jZSwgNC1ieXRlIGNvdW50ZXIuXG4gKiBXaXRoIDEyLWJ5dGUgbm9uY2UsIGl0J3Mgbm90IHNhZmUgdG8gdXNlIGZpbGwgaXQgd2l0aCByYW5kb20gKENTUFJORyksIGR1ZSB0byBjb2xsaXNpb24gY2hhbmNlLlxuICovXG5leHBvcnRzLmNoYWNoYTIwID0gKDAsIF9hcnhfanNfMS5jcmVhdGVDaXBoZXIpKGNoYWNoYUNvcmUsIHtcbiAgICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICAgIGNvdW50ZXJMZW5ndGg6IDQsXG4gICAgYWxsb3dTaG9ydEtleXM6IGZhbHNlLFxufSk7XG4vKipcbiAqIFhDaGFDaGEgZVh0ZW5kZWQtbm9uY2UgQ2hhQ2hhLiAyNC1ieXRlIG5vbmNlLlxuICogV2l0aCAyNC1ieXRlIG5vbmNlLCBpdCdzIHNhZmUgdG8gdXNlIGZpbGwgaXQgd2l0aCByYW5kb20gKENTUFJORykuXG4gKiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy14Y2hhY2hhXG4gKi9cbmV4cG9ydHMueGNoYWNoYTIwID0gKDAsIF9hcnhfanNfMS5jcmVhdGVDaXBoZXIpKGNoYWNoYUNvcmUsIHtcbiAgICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICAgIGNvdW50ZXJMZW5ndGg6IDgsXG4gICAgZXh0ZW5kTm9uY2VGbjogaGNoYWNoYSxcbiAgICBhbGxvd1Nob3J0S2V5czogZmFsc2UsXG59KTtcbi8qKlxuICogUmVkdWNlZCA4LXJvdW5kIGNoYWNoYSwgZGVzY3JpYmVkIGluIG9yaWdpbmFsIHBhcGVyLlxuICovXG5leHBvcnRzLmNoYWNoYTggPSAoMCwgX2FyeF9qc18xLmNyZWF0ZUNpcGhlcikoY2hhY2hhQ29yZSwge1xuICAgIGNvdW50ZXJSaWdodDogZmFsc2UsXG4gICAgY291bnRlckxlbmd0aDogNCxcbiAgICByb3VuZHM6IDgsXG59KTtcbi8qKlxuICogUmVkdWNlZCAxMi1yb3VuZCBjaGFjaGEsIGRlc2NyaWJlZCBpbiBvcmlnaW5hbCBwYXBlci5cbiAqL1xuZXhwb3J0cy5jaGFjaGExMiA9ICgwLCBfYXJ4X2pzXzEuY3JlYXRlQ2lwaGVyKShjaGFjaGFDb3JlLCB7XG4gICAgY291bnRlclJpZ2h0OiBmYWxzZSxcbiAgICBjb3VudGVyTGVuZ3RoOiA0LFxuICAgIHJvdW5kczogMTIsXG59KTtcbmNvbnN0IFpFUk9TMTYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuLy8gUGFkIHRvIGRpZ2VzdCBzaXplIHdpdGggemVyb3NcbmNvbnN0IHVwZGF0ZVBhZGRlZCA9IChoLCBtc2cpID0+IHtcbiAgICBoLnVwZGF0ZShtc2cpO1xuICAgIGNvbnN0IGxlZnQgPSBtc2cubGVuZ3RoICUgMTY7XG4gICAgaWYgKGxlZnQpXG4gICAgICAgIGgudXBkYXRlKFpFUk9TMTYuc3ViYXJyYXkobGVmdCkpO1xufTtcbmNvbnN0IFpFUk9TMzIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuZnVuY3Rpb24gY29tcHV0ZVRhZyhmbiwga2V5LCBub25jZSwgZGF0YSwgQUFEKSB7XG4gICAgY29uc3QgYXV0aEtleSA9IGZuKGtleSwgbm9uY2UsIFpFUk9TMzIpO1xuICAgIGNvbnN0IGggPSBfcG9seTEzMDVfanNfMS5wb2x5MTMwNS5jcmVhdGUoYXV0aEtleSk7XG4gICAgaWYgKEFBRClcbiAgICAgICAgdXBkYXRlUGFkZGVkKGgsIEFBRCk7XG4gICAgdXBkYXRlUGFkZGVkKGgsIGRhdGEpO1xuICAgIGNvbnN0IG51bSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBjb25zdCB2aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykobnVtKTtcbiAgICAoMCwgdXRpbHNfanNfMS5zZXRCaWdVaW50NjQpKHZpZXcsIDAsIEJpZ0ludChBQUQgPyBBQUQubGVuZ3RoIDogMCksIHRydWUpO1xuICAgICgwLCB1dGlsc19qc18xLnNldEJpZ1VpbnQ2NCkodmlldywgOCwgQmlnSW50KGRhdGEubGVuZ3RoKSwgdHJ1ZSk7XG4gICAgaC51cGRhdGUobnVtKTtcbiAgICBjb25zdCByZXMgPSBoLmRpZ2VzdCgpO1xuICAgIGF1dGhLZXkuZmlsbCgwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBBRUFEIGFsZ29yaXRobSBmcm9tIFJGQyA4NDM5LlxuICogU2Fsc2EyMCBhbmQgY2hhY2hhIChSRkMgODQzOSkgdXNlIHBvbHkxMzA1IGRpZmZlcmVudGx5LlxuICogV2UgY291bGQgaGF2ZSBjb21wb3NlZCB0aGVtIHNpbWlsYXIgdG86XG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL3NjdXJlLWJhc2UvYmxvYi9iMjY2YzczZGRlOTc3YjFkZDdlZjQwZWY3YTIzY2MxNWFhYjUyNmIzL2luZGV4LnRzI0wyNTBcbiAqIEJ1dCBpdCdzIGhhcmQgYmVjYXVzZSBvZiBhdXRoS2V5OlxuICogSW4gc2Fsc2EyMCwgYXV0aEtleSBjaGFuZ2VzIHBvc2l0aW9uIGluIHNhbHNhIHN0cmVhbS5cbiAqIEluIGNoYWNoYSwgYXV0aEtleSBjYW4ndCBiZSBjb21wdXRlZCBpbnNpZGUgY29tcHV0ZVRhZywgaXQgbW9kaWZpZXMgdGhlIGNvdW50ZXIuXG4gKi9cbmNvbnN0IF9wb2x5MTMwNV9hZWFkID0gKHhvclN0cmVhbSkgPT4gKGtleSwgbm9uY2UsIEFBRCkgPT4ge1xuICAgIGNvbnN0IHRhZ0xlbmd0aCA9IDE2O1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGtleSwgMzIpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKG5vbmNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0OiAocGxhaW50ZXh0LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBsZW5ndGggPSBwbGFpbnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgY2xlbmd0aCA9IHBsZW5ndGggKyB0YWdMZW5ndGg7XG4gICAgICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykob3V0cHV0LCBjbGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGNsZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeG9yU3RyZWFtKGtleSwgbm9uY2UsIHBsYWludGV4dCwgb3V0cHV0LCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IGNvbXB1dGVUYWcoeG9yU3RyZWFtLCBrZXksIG5vbmNlLCBvdXRwdXQuc3ViYXJyYXkoMCwgLXRhZ0xlbmd0aCksIEFBRCk7XG4gICAgICAgICAgICBvdXRwdXQuc2V0KHRhZywgcGxlbmd0aCk7IC8vIGFwcGVuZCB0YWdcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY3J5cHQ6IChjaXBoZXJ0ZXh0LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNsZW5ndGggPSBjaXBoZXJ0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHBsZW5ndGggPSBjbGVuZ3RoIC0gdGFnTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGNsZW5ndGggPCB0YWdMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBlbmNyeXB0ZWQgZGF0YSBtdXN0IGJlIGF0IGxlYXN0ICR7dGFnTGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKG91dHB1dCwgcGxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBuZXcgVWludDhBcnJheShwbGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIC10YWdMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgcGFzc2VkVGFnID0gY2lwaGVydGV4dC5zdWJhcnJheSgtdGFnTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IGNvbXB1dGVUYWcoeG9yU3RyZWFtLCBrZXksIG5vbmNlLCBkYXRhLCBBQUQpO1xuICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfanNfMS5lcXVhbEJ5dGVzKShwYXNzZWRUYWcsIHRhZykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHRhZycpO1xuICAgICAgICAgICAgeG9yU3RyZWFtKGtleSwgbm9uY2UsIGRhdGEsIG91dHB1dCwgMSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5fcG9seTEzMDVfYWVhZCA9IF9wb2x5MTMwNV9hZWFkO1xuLyoqXG4gKiBDaGFDaGEyMC1Qb2x5MTMwNSBmcm9tIFJGQyA4NDM5LlxuICogV2l0aCAxMi1ieXRlIG5vbmNlLCBpdCdzIG5vdCBzYWZlIHRvIHVzZSBmaWxsIGl0IHdpdGggcmFuZG9tIChDU1BSTkcpLCBkdWUgdG8gY29sbGlzaW9uIGNoYW5jZS5cbiAqL1xuZXhwb3J0cy5jaGFjaGEyMHBvbHkxMzA1ID0gKDAsIHV0aWxzX2pzXzEud3JhcENpcGhlcikoeyBibG9ja1NpemU6IDY0LCBub25jZUxlbmd0aDogMTIsIHRhZ0xlbmd0aDogMTYgfSwgKDAsIGV4cG9ydHMuX3BvbHkxMzA1X2FlYWQpKGV4cG9ydHMuY2hhY2hhMjApKTtcbi8qKlxuICogWENoYUNoYTIwLVBvbHkxMzA1IGV4dGVuZGVkLW5vbmNlIGNoYWNoYS5cbiAqIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXhjaGFjaGFcbiAqIFdpdGggMjQtYnl0ZSBub25jZSwgaXQncyBzYWZlIHRvIHVzZSBmaWxsIGl0IHdpdGggcmFuZG9tIChDU1BSTkcpLlxuICovXG5leHBvcnRzLnhjaGFjaGEyMHBvbHkxMzA1ID0gKDAsIHV0aWxzX2pzXzEud3JhcENpcGhlcikoeyBibG9ja1NpemU6IDY0LCBub25jZUxlbmd0aDogMjQsIHRhZ0xlbmd0aDogMTYgfSwgKDAsIGV4cG9ydHMuX3BvbHkxMzA1X2FlYWQpKGV4cG9ydHMueGNoYWNoYTIwKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFjaGEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/chacha.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_arx.js":
/*!***************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_arx.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCipher: () => (/* binding */ createCipher),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   sigma: () => (/* binding */ sigma)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/utils.js\");\n// Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\n\n\n/*\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | ctr(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | ctr(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | ctr(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n*/\n// We can't make top-level var depend on utils.utf8ToBytes\n// because it's not present in all envs. Creating a similar fn here\nconst _utf8ToBytes = (str) => Uint8Array.from(str.split('').map((c) => c.charCodeAt(0)));\nconst sigma16 = _utf8ToBytes('expand 16-byte k');\nconst sigma32 = _utf8ToBytes('expand 32-byte k');\nconst sigma16_32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(sigma16);\nconst sigma32_32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(sigma32);\nconst sigma = sigma32_32.slice();\nfunction rotl(a, b) {\n    return (a << b) | (a >>> (32 - b));\n}\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b) {\n    return b.byteOffset % 4 === 0;\n}\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\nconst U32_EMPTY = new Uint32Array();\nfunction runCipher(core, sigma, key, nonce, data, output, counter, rounds) {\n    const len = data.length;\n    const block = new Uint8Array(BLOCK_LEN);\n    const b32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(block);\n    // Make sure that buffers aligned to 4 bytes\n    const isAligned = isAligned32(data) && isAligned32(output);\n    const d32 = isAligned ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(data) : U32_EMPTY;\n    const o32 = isAligned ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(output) : U32_EMPTY;\n    for (let pos = 0; pos < len; counter++) {\n        core(sigma, key, nonce, b32, counter, rounds);\n        if (counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        const take = Math.min(BLOCK_LEN, len - pos);\n        // aligned to 4 bytes\n        if (isAligned && take === BLOCK_LEN) {\n            const pos32 = pos / 4;\n            if (pos % 4 !== 0)\n                throw new Error('arx: invalid block position');\n            for (let j = 0, posj; j < BLOCK_LEN32; j++) {\n                posj = pos32 + j;\n                o32[posj] = d32[posj] ^ b32[j];\n            }\n            pos += BLOCK_LEN;\n            continue;\n        }\n        for (let j = 0, posj; j < take; j++) {\n            posj = pos + j;\n            output[posj] = data[posj] ^ block[j];\n        }\n        pos += take;\n    }\n}\nfunction createCipher(core, opts) {\n    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.checkOpts)({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);\n    if (typeof core !== 'function')\n        throw new Error('core must be a function');\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(counterLength);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(rounds);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bool)(counterRight);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bool)(allowShortKeys);\n    return (key, nonce, data, output, counter = 0) => {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(key);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(nonce);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(data);\n        const len = data.length;\n        if (!output)\n            output = new Uint8Array(len);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(output);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.number)(counter);\n        if (counter < 0 || counter >= MAX_COUNTER)\n            throw new Error('arx: counter overflow');\n        if (output.length < len)\n            throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n        const toClean = [];\n        // Key & sigma\n        // key=16 -> sigma16, k=key|key\n        // key=32 -> sigma32, k=key\n        let l = key.length, k, sigma;\n        if (l === 32) {\n            k = key.slice();\n            toClean.push(k);\n            sigma = sigma32_32;\n        }\n        else if (l === 16 && allowShortKeys) {\n            k = new Uint8Array(32);\n            k.set(key);\n            k.set(key, 16);\n            sigma = sigma16_32;\n            toClean.push(k);\n        }\n        else {\n            throw new Error(`arx: invalid 32-byte key, got length=${l}`);\n        }\n        // Nonce\n        // salsa20:      8   (8-byte counter)\n        // chacha20orig: 8   (8-byte counter)\n        // chacha20:     12  (4-byte counter)\n        // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n        // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n        // Align nonce to 4 bytes\n        if (!isAligned32(nonce)) {\n            nonce = nonce.slice();\n            toClean.push(nonce);\n        }\n        const k32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(k);\n        // hsalsa & hchacha: handle extended nonce\n        if (extendNonceFn) {\n            if (nonce.length !== 24)\n                throw new Error(`arx: extended nonce must be 24 bytes`);\n            extendNonceFn(sigma, k32, (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(nonce.subarray(0, 16)), k32);\n            nonce = nonce.subarray(16);\n        }\n        // Handle nonce counter\n        const nonceNcLen = 16 - counterLength;\n        if (nonceNcLen !== nonce.length)\n            throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n        // Pad counter when nonce is 64 bit\n        if (nonceNcLen !== 12) {\n            const nc = new Uint8Array(12);\n            nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n            nonce = nc;\n            toClean.push(nonce);\n        }\n        const n32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(nonce);\n        runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n        while (toClean.length > 0)\n            toClean.pop().fill(0);\n        return output;\n    };\n}\n//# sourceMappingURL=_arx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2VzbS9fYXJ4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDaUY7QUFDckM7QUFDNUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CLCtCQUErQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBRztBQUN0QixtQkFBbUIsOENBQUc7QUFDZjtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQUc7QUFDbkI7QUFDQTtBQUNBLDRCQUE0Qiw4Q0FBRztBQUMvQiw0QkFBNEIsOENBQUc7QUFDL0Isc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVkscUVBQXFFLEVBQUUsb0RBQVMsR0FBRywwRUFBMEU7QUFDeks7QUFDQTtBQUNBLElBQUksa0RBQU87QUFDWCxJQUFJLGtEQUFPO0FBQ1gsSUFBSSxnREFBSztBQUNULElBQUksZ0RBQUs7QUFDVDtBQUNBLFFBQVEsaURBQU07QUFDZCxRQUFRLGlEQUFNO0FBQ2QsUUFBUSxpREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaURBQU07QUFDZCxRQUFRLGtEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGNBQWMsMEJBQTBCLElBQUk7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLEVBQUU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhDQUFHO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4Q0FBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9lc20vX2FyeC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBCYXNpYyB1dGlscyBmb3IgQVJYIChhZGQtcm90YXRlLXhvcikgc2Fsc2EgYW5kIGNoYWNoYSBjaXBoZXJzLlxuaW1wb3J0IHsgbnVtYmVyIGFzIGFudW1iZXIsIGJ5dGVzIGFzIGFieXRlcywgYm9vbCBhcyBhYm9vbCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBjaGVja09wdHMsIHUzMiB9IGZyb20gJy4vdXRpbHMuanMnO1xuLypcblJGQzg0MzkgcmVxdWlyZXMgbXVsdGktc3RlcCBjaXBoZXIgc3RyZWFtLCB3aGVyZVxuYXV0aEtleSBzdGFydHMgd2l0aCBjb3VudGVyOiAwLCBhY3R1YWwgbXNnIHdpdGggY291bnRlcjogMS5cblxuRm9yIHRoaXMsIHdlIG5lZWQgYSB3YXkgdG8gcmUtdXNlIG5vbmNlIC8gY291bnRlcjpcblxuICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBjaGFjaGEoLi4uLCBjb3VudGVyLCAuLi4pOyAvLyBjb3VudGVyIGlzIG5vdyAxXG4gICAgY2hhY2hhKC4uLiwgY291bnRlciwgLi4uKTsgLy8gY291bnRlciBpcyBub3cgMlxuXG5UaGlzIGlzIGNvbXBsaWNhdGVkOlxuXG4tIDMyLWJpdCBjb3VudGVycyBhcmUgZW5vdWdoLCBubyBuZWVkIGZvciA2NC1iaXQ6IG1heCBBcnJheUJ1ZmZlciBzaXplIGluIEpTIGlzIDRHQlxuLSBPcmlnaW5hbCBwYXBlcnMgZG9uJ3QgYWxsb3cgbXV0YXRpbmcgY291bnRlcnNcbi0gQ291bnRlciBvdmVyZmxvdyBpcyB1bmRlZmluZWQgW14xXVxuLSBJZGVhIEE6IGFsbG93IHByb3ZpZGluZyAobm9uY2UgfCBjb3VudGVyKSBpbnN0ZWFkIG9mIGp1c3Qgbm9uY2UsIHJlLXVzZSBpdFxuLSBDYXZlYXQ6IENhbm5vdCBiZSByZS11c2VkIHRocm91Z2ggYWxsIGNhc2VzOlxuLSAqIGNoYWNoYSBoYXMgKGNvdW50ZXIgfCBub25jZSlcbi0gKiB4Y2hhY2hhIGhhcyAobm9uY2UxNiB8IGNvdW50ZXIgfCBub25jZTE2KVxuLSBJZGVhIEI6IHNlcGFyYXRlIG5vbmNlIC8gY291bnRlciBhbmQgcHJvdmlkZSBzZXBhcmF0ZSBBUEkgZm9yIGNvdW50ZXIgcmUtdXNlXG4tIENhdmVhdDogdGhlcmUgYXJlIGRpZmZlcmVudCBjb3VudGVyIHNpemVzIGRlcGVuZGluZyBvbiBhbiBhbGdvcml0aG0uXG4tIHNhbHNhICYgY2hhY2hhIGFsc28gZGlmZmVyIGluIHN0cnVjdHVyZXMgb2Yga2V5ICYgc2lnbWE6XG4gIHNhbHNhMjA6ICAgICAgc1swXSB8IGsoNCkgfCBzWzFdIHwgbm9uY2UoMikgfCBjdHIoMikgfCBzWzJdIHwgayg0KSB8IHNbM11cbiAgY2hhY2hhOiAgICAgICBzKDQpIHwgayg4KSB8IGN0cigxKSB8IG5vbmNlKDMpXG4gIGNoYWNoYTIwb3JpZzogcyg0KSB8IGsoOCkgfCBjdHIoMikgfCBub25jZSgyKVxuLSBJZGVhIEM6IGhlbHBlciBtZXRob2Qgc3VjaCBhcyBgc2V0U2Fsc2FTdGF0ZShrZXksIG5vbmNlLCBzaWdtYSwgZGF0YSlgXG4tIENhdmVhdDogd2UgY2FuJ3QgcmUtdXNlIGNvdW50ZXIgYXJyYXlcblxueGNoYWNoYSBbXjJdIHVzZXMgdGhlIHN1YmtleSBhbmQgcmVtYWluaW5nIDggYnl0ZSBub25jZSB3aXRoIENoYUNoYTIwIGFzIG5vcm1hbFxuKHByZWZpeGVkIGJ5IDQgTlVMIGJ5dGVzLCBzaW5jZSBbUkZDODQzOV0gc3BlY2lmaWVzIGEgMTItYnl0ZSBub25jZSkuXG5cblteMV06IGh0dHBzOi8vbWFpbGFyY2hpdmUuaWV0Zi5vcmcvYXJjaC9tc2cvY2ZyZy9nc09uVEp6Y2JnRzZPcUQ4U2MwR081YVJfdFUvXG5bXjJdOiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy14Y2hhY2hhI2FwcGVuZGl4LUEuMlxuKi9cbi8vIFdlIGNhbid0IG1ha2UgdG9wLWxldmVsIHZhciBkZXBlbmQgb24gdXRpbHMudXRmOFRvQnl0ZXNcbi8vIGJlY2F1c2UgaXQncyBub3QgcHJlc2VudCBpbiBhbGwgZW52cy4gQ3JlYXRpbmcgYSBzaW1pbGFyIGZuIGhlcmVcbmNvbnN0IF91dGY4VG9CeXRlcyA9IChzdHIpID0+IFVpbnQ4QXJyYXkuZnJvbShzdHIuc3BsaXQoJycpLm1hcCgoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG5jb25zdCBzaWdtYTE2ID0gX3V0ZjhUb0J5dGVzKCdleHBhbmQgMTYtYnl0ZSBrJyk7XG5jb25zdCBzaWdtYTMyID0gX3V0ZjhUb0J5dGVzKCdleHBhbmQgMzItYnl0ZSBrJyk7XG5jb25zdCBzaWdtYTE2XzMyID0gdTMyKHNpZ21hMTYpO1xuY29uc3Qgc2lnbWEzMl8zMiA9IHUzMihzaWdtYTMyKTtcbmV4cG9ydCBjb25zdCBzaWdtYSA9IHNpZ21hMzJfMzIuc2xpY2UoKTtcbmV4cG9ydCBmdW5jdGlvbiByb3RsKGEsIGIpIHtcbiAgICByZXR1cm4gKGEgPDwgYikgfCAoYSA+Pj4gKDMyIC0gYikpO1xufVxuLy8gSXMgYnl0ZSBhcnJheSBhbGlnbmVkIHRvIDQgYnl0ZSBvZmZzZXQgKHUzMik/XG5mdW5jdGlvbiBpc0FsaWduZWQzMihiKSB7XG4gICAgcmV0dXJuIGIuYnl0ZU9mZnNldCAlIDQgPT09IDA7XG59XG4vLyBTYWxzYSBhbmQgQ2hhY2hhIGJsb2NrIGxlbmd0aCBpcyBhbHdheXMgNTEyLWJpdFxuY29uc3QgQkxPQ0tfTEVOID0gNjQ7XG5jb25zdCBCTE9DS19MRU4zMiA9IDE2O1xuLy8gbmV3IFVpbnQzMkFycmF5KFsyKiozMl0pICAgLy8gPT4gVWludDMyQXJyYXkoMSkgWyAwIF1cbi8vIG5ldyBVaW50MzJBcnJheShbMioqMzItMV0pIC8vID0+IFVpbnQzMkFycmF5KDEpIFsgNDI5NDk2NzI5NSBdXG5jb25zdCBNQVhfQ09VTlRFUiA9IDIgKiogMzIgLSAxO1xuY29uc3QgVTMyX0VNUFRZID0gbmV3IFVpbnQzMkFycmF5KCk7XG5mdW5jdGlvbiBydW5DaXBoZXIoY29yZSwgc2lnbWEsIGtleSwgbm9uY2UsIGRhdGEsIG91dHB1dCwgY291bnRlciwgcm91bmRzKSB7XG4gICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgY29uc3QgYmxvY2sgPSBuZXcgVWludDhBcnJheShCTE9DS19MRU4pO1xuICAgIGNvbnN0IGIzMiA9IHUzMihibG9jayk7XG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgYnVmZmVycyBhbGlnbmVkIHRvIDQgYnl0ZXNcbiAgICBjb25zdCBpc0FsaWduZWQgPSBpc0FsaWduZWQzMihkYXRhKSAmJiBpc0FsaWduZWQzMihvdXRwdXQpO1xuICAgIGNvbnN0IGQzMiA9IGlzQWxpZ25lZCA/IHUzMihkYXRhKSA6IFUzMl9FTVBUWTtcbiAgICBjb25zdCBvMzIgPSBpc0FsaWduZWQgPyB1MzIob3V0cHV0KSA6IFUzMl9FTVBUWTtcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47IGNvdW50ZXIrKykge1xuICAgICAgICBjb3JlKHNpZ21hLCBrZXksIG5vbmNlLCBiMzIsIGNvdW50ZXIsIHJvdW5kcyk7XG4gICAgICAgIGlmIChjb3VudGVyID49IE1BWF9DT1VOVEVSKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcng6IGNvdW50ZXIgb3ZlcmZsb3cnKTtcbiAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKEJMT0NLX0xFTiwgbGVuIC0gcG9zKTtcbiAgICAgICAgLy8gYWxpZ25lZCB0byA0IGJ5dGVzXG4gICAgICAgIGlmIChpc0FsaWduZWQgJiYgdGFrZSA9PT0gQkxPQ0tfTEVOKSB7XG4gICAgICAgICAgICBjb25zdCBwb3MzMiA9IHBvcyAvIDQ7XG4gICAgICAgICAgICBpZiAocG9zICUgNCAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FyeDogaW52YWxpZCBibG9jayBwb3NpdGlvbicpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIHBvc2o7IGogPCBCTE9DS19MRU4zMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcG9zaiA9IHBvczMyICsgajtcbiAgICAgICAgICAgICAgICBvMzJbcG9zal0gPSBkMzJbcG9zal0gXiBiMzJbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgKz0gQkxPQ0tfTEVOO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIHBvc2o7IGogPCB0YWtlOyBqKyspIHtcbiAgICAgICAgICAgIHBvc2ogPSBwb3MgKyBqO1xuICAgICAgICAgICAgb3V0cHV0W3Bvc2pdID0gZGF0YVtwb3NqXSBeIGJsb2NrW2pdO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSB0YWtlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDaXBoZXIoY29yZSwgb3B0cykge1xuICAgIGNvbnN0IHsgYWxsb3dTaG9ydEtleXMsIGV4dGVuZE5vbmNlRm4sIGNvdW50ZXJMZW5ndGgsIGNvdW50ZXJSaWdodCwgcm91bmRzIH0gPSBjaGVja09wdHMoeyBhbGxvd1Nob3J0S2V5czogZmFsc2UsIGNvdW50ZXJMZW5ndGg6IDgsIGNvdW50ZXJSaWdodDogZmFsc2UsIHJvdW5kczogMjAgfSwgb3B0cyk7XG4gICAgaWYgKHR5cGVvZiBjb3JlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgYW51bWJlcihjb3VudGVyTGVuZ3RoKTtcbiAgICBhbnVtYmVyKHJvdW5kcyk7XG4gICAgYWJvb2woY291bnRlclJpZ2h0KTtcbiAgICBhYm9vbChhbGxvd1Nob3J0S2V5cyk7XG4gICAgcmV0dXJuIChrZXksIG5vbmNlLCBkYXRhLCBvdXRwdXQsIGNvdW50ZXIgPSAwKSA9PiB7XG4gICAgICAgIGFieXRlcyhrZXkpO1xuICAgICAgICBhYnl0ZXMobm9uY2UpO1xuICAgICAgICBhYnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAoIW91dHB1dClcbiAgICAgICAgICAgIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgICAgIGFieXRlcyhvdXRwdXQpO1xuICAgICAgICBhbnVtYmVyKGNvdW50ZXIpO1xuICAgICAgICBpZiAoY291bnRlciA8IDAgfHwgY291bnRlciA+PSBNQVhfQ09VTlRFUilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJ4OiBjb3VudGVyIG92ZXJmbG93Jyk7XG4gICAgICAgIGlmIChvdXRwdXQubGVuZ3RoIDwgbGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IG91dHB1dCAoJHtvdXRwdXQubGVuZ3RofSkgaXMgc2hvcnRlciB0aGFuIGRhdGEgKCR7bGVufSlgKTtcbiAgICAgICAgY29uc3QgdG9DbGVhbiA9IFtdO1xuICAgICAgICAvLyBLZXkgJiBzaWdtYVxuICAgICAgICAvLyBrZXk9MTYgLT4gc2lnbWExNiwgaz1rZXl8a2V5XG4gICAgICAgIC8vIGtleT0zMiAtPiBzaWdtYTMyLCBrPWtleVxuICAgICAgICBsZXQgbCA9IGtleS5sZW5ndGgsIGssIHNpZ21hO1xuICAgICAgICBpZiAobCA9PT0gMzIpIHtcbiAgICAgICAgICAgIGsgPSBrZXkuc2xpY2UoKTtcbiAgICAgICAgICAgIHRvQ2xlYW4ucHVzaChrKTtcbiAgICAgICAgICAgIHNpZ21hID0gc2lnbWEzMl8zMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsID09PSAxNiAmJiBhbGxvd1Nob3J0S2V5cykge1xuICAgICAgICAgICAgayA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgICAgIGsuc2V0KGtleSk7XG4gICAgICAgICAgICBrLnNldChrZXksIDE2KTtcbiAgICAgICAgICAgIHNpZ21hID0gc2lnbWExNl8zMjtcbiAgICAgICAgICAgIHRvQ2xlYW4ucHVzaChrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYXJ4OiBpbnZhbGlkIDMyLWJ5dGUga2V5LCBnb3QgbGVuZ3RoPSR7bH1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb25jZVxuICAgICAgICAvLyBzYWxzYTIwOiAgICAgIDggICAoOC1ieXRlIGNvdW50ZXIpXG4gICAgICAgIC8vIGNoYWNoYTIwb3JpZzogOCAgICg4LWJ5dGUgY291bnRlcilcbiAgICAgICAgLy8gY2hhY2hhMjA6ICAgICAxMiAgKDQtYnl0ZSBjb3VudGVyKVxuICAgICAgICAvLyB4c2Fsc2EyMDogICAgIDI0ICAoMTYgLT4gaHNhbHNhLCAgOCAtPiBvbGQgbm9uY2UpXG4gICAgICAgIC8vIHhjaGFjaGEyMDogICAgMjQgICgxNiAtPiBoY2hhY2hhLCA4IC0+IG9sZCBub25jZSlcbiAgICAgICAgLy8gQWxpZ24gbm9uY2UgdG8gNCBieXRlc1xuICAgICAgICBpZiAoIWlzQWxpZ25lZDMyKG5vbmNlKSkge1xuICAgICAgICAgICAgbm9uY2UgPSBub25jZS5zbGljZSgpO1xuICAgICAgICAgICAgdG9DbGVhbi5wdXNoKG5vbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrMzIgPSB1MzIoayk7XG4gICAgICAgIC8vIGhzYWxzYSAmIGhjaGFjaGE6IGhhbmRsZSBleHRlbmRlZCBub25jZVxuICAgICAgICBpZiAoZXh0ZW5kTm9uY2VGbikge1xuICAgICAgICAgICAgaWYgKG5vbmNlLmxlbmd0aCAhPT0gMjQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IGV4dGVuZGVkIG5vbmNlIG11c3QgYmUgMjQgYnl0ZXNgKTtcbiAgICAgICAgICAgIGV4dGVuZE5vbmNlRm4oc2lnbWEsIGszMiwgdTMyKG5vbmNlLnN1YmFycmF5KDAsIDE2KSksIGszMik7XG4gICAgICAgICAgICBub25jZSA9IG5vbmNlLnN1YmFycmF5KDE2KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgbm9uY2UgY291bnRlclxuICAgICAgICBjb25zdCBub25jZU5jTGVuID0gMTYgLSBjb3VudGVyTGVuZ3RoO1xuICAgICAgICBpZiAobm9uY2VOY0xlbiAhPT0gbm9uY2UubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IG5vbmNlIG11c3QgYmUgJHtub25jZU5jTGVufSBvciAxNiBieXRlc2ApO1xuICAgICAgICAvLyBQYWQgY291bnRlciB3aGVuIG5vbmNlIGlzIDY0IGJpdFxuICAgICAgICBpZiAobm9uY2VOY0xlbiAhPT0gMTIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5jID0gbmV3IFVpbnQ4QXJyYXkoMTIpO1xuICAgICAgICAgICAgbmMuc2V0KG5vbmNlLCBjb3VudGVyUmlnaHQgPyAwIDogMTIgLSBub25jZS5sZW5ndGgpO1xuICAgICAgICAgICAgbm9uY2UgPSBuYztcbiAgICAgICAgICAgIHRvQ2xlYW4ucHVzaChub25jZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbjMyID0gdTMyKG5vbmNlKTtcbiAgICAgICAgcnVuQ2lwaGVyKGNvcmUsIHNpZ21hLCBrMzIsIG4zMiwgZGF0YSwgb3V0cHV0LCBjb3VudGVyLCByb3VuZHMpO1xuICAgICAgICB3aGlsZSAodG9DbGVhbi5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdG9DbGVhbi5wb3AoKS5maWxsKDApO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXJ4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_arx.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_assert.js":
/*!******************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_assert.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('hash must be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLDBEQUEwRCxFQUFFO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ3FEO0FBQ3JELGlCQUFpQjtBQUNqQixpRUFBZSxNQUFNLEVBQUM7QUFDdEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvZXNtL19hc3NlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIG5vdCAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBib29sZWFuIGV4cGVjdGVkLCBub3QgJHtifWApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaCBtdXN0IGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnQgeyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_poly1305.js":
/*!********************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_poly1305.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   poly1305: () => (/* binding */ poly1305),\n/* harmony export */   wrapConstructorWithKey: () => (/* binding */ wrapConstructorWithKey)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/utils.js\");\n\n\n// Poly1305 is a fast and parallel secret-key message-authentication code.\n// https://cr.yp.to/mac.html, https://cr.yp.to/mac/poly1305-20050329.pdf\n// https://datatracker.ietf.org/doc/html/rfc8439\n// Based on Public Domain poly1305-donna https://github.com/floodyberry/poly1305-donna\nconst u8to16 = (a, i) => (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\nclass Poly1305 {\n    constructor(key) {\n        this.blockLen = 16;\n        this.outputLen = 16;\n        this.buffer = new Uint8Array(16);\n        this.r = new Uint16Array(10);\n        this.h = new Uint16Array(10);\n        this.pad = new Uint16Array(8);\n        this.pos = 0;\n        this.finished = false;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(key);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(key, 32);\n        const t0 = u8to16(key, 0);\n        const t1 = u8to16(key, 2);\n        const t2 = u8to16(key, 4);\n        const t3 = u8to16(key, 6);\n        const t4 = u8to16(key, 8);\n        const t5 = u8to16(key, 10);\n        const t6 = u8to16(key, 12);\n        const t7 = u8to16(key, 14);\n        // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n        this.r[0] = t0 & 0x1fff;\n        this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n        this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n        this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n        this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n        this.r[5] = (t4 >>> 1) & 0x1ffe;\n        this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n        this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n        this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n        this.r[9] = (t7 >>> 5) & 0x007f;\n        for (let i = 0; i < 8; i++)\n            this.pad[i] = u8to16(key, 16 + 2 * i);\n    }\n    process(data, offset, isLast = false) {\n        const hibit = isLast ? 0 : 1 << 11;\n        const { h, r } = this;\n        const r0 = r[0];\n        const r1 = r[1];\n        const r2 = r[2];\n        const r3 = r[3];\n        const r4 = r[4];\n        const r5 = r[5];\n        const r6 = r[6];\n        const r7 = r[7];\n        const r8 = r[8];\n        const r9 = r[9];\n        const t0 = u8to16(data, offset + 0);\n        const t1 = u8to16(data, offset + 2);\n        const t2 = u8to16(data, offset + 4);\n        const t3 = u8to16(data, offset + 6);\n        const t4 = u8to16(data, offset + 8);\n        const t5 = u8to16(data, offset + 10);\n        const t6 = u8to16(data, offset + 12);\n        const t7 = u8to16(data, offset + 14);\n        let h0 = h[0] + (t0 & 0x1fff);\n        let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n        let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n        let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n        let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n        let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n        let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n        let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n        let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n        let h9 = h[9] + ((t7 >>> 5) | hibit);\n        let c = 0;\n        let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n        c = d0 >>> 13;\n        d0 &= 0x1fff;\n        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n        c += d0 >>> 13;\n        d0 &= 0x1fff;\n        let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n        c = d1 >>> 13;\n        d1 &= 0x1fff;\n        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n        c += d1 >>> 13;\n        d1 &= 0x1fff;\n        let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n        c = d2 >>> 13;\n        d2 &= 0x1fff;\n        d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n        c += d2 >>> 13;\n        d2 &= 0x1fff;\n        let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n        c = d3 >>> 13;\n        d3 &= 0x1fff;\n        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n        c += d3 >>> 13;\n        d3 &= 0x1fff;\n        let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n        c = d4 >>> 13;\n        d4 &= 0x1fff;\n        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n        c += d4 >>> 13;\n        d4 &= 0x1fff;\n        let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n        c = d5 >>> 13;\n        d5 &= 0x1fff;\n        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n        c += d5 >>> 13;\n        d5 &= 0x1fff;\n        let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n        c = d6 >>> 13;\n        d6 &= 0x1fff;\n        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n        c += d6 >>> 13;\n        d6 &= 0x1fff;\n        let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n        c = d7 >>> 13;\n        d7 &= 0x1fff;\n        d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n        c += d7 >>> 13;\n        d7 &= 0x1fff;\n        let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n        c = d8 >>> 13;\n        d8 &= 0x1fff;\n        d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n        c += d8 >>> 13;\n        d8 &= 0x1fff;\n        let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n        c = d9 >>> 13;\n        d9 &= 0x1fff;\n        d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n        c += d9 >>> 13;\n        d9 &= 0x1fff;\n        c = ((c << 2) + c) | 0;\n        c = (c + d0) | 0;\n        d0 = c & 0x1fff;\n        c = c >>> 13;\n        d1 += c;\n        h[0] = d0;\n        h[1] = d1;\n        h[2] = d2;\n        h[3] = d3;\n        h[4] = d4;\n        h[5] = d5;\n        h[6] = d6;\n        h[7] = d7;\n        h[8] = d8;\n        h[9] = d9;\n    }\n    finalize() {\n        const { h, pad } = this;\n        const g = new Uint16Array(10);\n        let c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        for (let i = 2; i < 10; i++) {\n            h[i] += c;\n            c = h[i] >>> 13;\n            h[i] &= 0x1fff;\n        }\n        h[0] += c * 5;\n        c = h[0] >>> 13;\n        h[0] &= 0x1fff;\n        h[1] += c;\n        c = h[1] >>> 13;\n        h[1] &= 0x1fff;\n        h[2] += c;\n        g[0] = h[0] + 5;\n        c = g[0] >>> 13;\n        g[0] &= 0x1fff;\n        for (let i = 1; i < 10; i++) {\n            g[i] = h[i] + c;\n            c = g[i] >>> 13;\n            g[i] &= 0x1fff;\n        }\n        g[9] -= 1 << 13;\n        let mask = (c ^ 1) - 1;\n        for (let i = 0; i < 10; i++)\n            g[i] &= mask;\n        mask = ~mask;\n        for (let i = 0; i < 10; i++)\n            h[i] = (h[i] & mask) | g[i];\n        h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n        h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n        h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n        h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n        h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n        h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n        h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n        h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n        let f = h[0] + pad[0];\n        h[0] = f & 0xffff;\n        for (let i = 1; i < 8; i++) {\n            f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n            h[i] = f & 0xffff;\n        }\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input\n            if (take === blockLen) {\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(data, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(buffer, 0, false);\n                this.pos = 0;\n            }\n        }\n        return this;\n    }\n    destroy() {\n        this.h.fill(0);\n        this.r.fill(0);\n        this.buffer.fill(0);\n        this.pad.fill(0);\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        const { buffer, h } = this;\n        let { pos } = this;\n        if (pos) {\n            buffer[pos++] = 1;\n            // buffer.subarray(pos).fill(0);\n            for (; pos < 16; pos++)\n                buffer[pos] = 0;\n            this.process(buffer, 0, true);\n        }\n        this.finalize();\n        let opos = 0;\n        for (let i = 0; i < 8; i++) {\n            out[opos++] = h[i] >>> 0;\n            out[opos++] = h[i] >>> 8;\n        }\n        return out;\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n}\nfunction wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(msg)).digest();\n    const tmp = hashCons(new Uint8Array(32));\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key) => hashCons(key);\n    return hashC;\n}\nconst poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));\n//# sourceMappingURL=_poly1305.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2VzbS9fcG9seTEzMDUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFxRjtBQUNoRDtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFPO0FBQ3JCLFFBQVEsaURBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmLGdCQUFnQixtQkFBbUI7QUFDbkMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZixRQUFRLGtEQUFPO0FBQ2Y7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxxREFBcUQsa0RBQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9lc20vX3BvbHkxMzA1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0cyBhcyBhZXhpc3RzLCBieXRlcyBhcyBhYnl0ZXMsIG91dHB1dCBhcyBhb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHkxMzA1IGlzIGEgZmFzdCBhbmQgcGFyYWxsZWwgc2VjcmV0LWtleSBtZXNzYWdlLWF1dGhlbnRpY2F0aW9uIGNvZGUuXG4vLyBodHRwczovL2NyLnlwLnRvL21hYy5odG1sLCBodHRwczovL2NyLnlwLnRvL21hYy9wb2x5MTMwNS0yMDA1MDMyOS5wZGZcbi8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjODQzOVxuLy8gQmFzZWQgb24gUHVibGljIERvbWFpbiBwb2x5MTMwNS1kb25uYSBodHRwczovL2dpdGh1Yi5jb20vZmxvb2R5YmVycnkvcG9seTEzMDUtZG9ubmFcbmNvbnN0IHU4dG8xNiA9IChhLCBpKSA9PiAoYVtpKytdICYgMHhmZikgfCAoKGFbaSsrXSAmIDB4ZmYpIDw8IDgpO1xuY2xhc3MgUG9seTEzMDUge1xuICAgIGNvbnN0cnVjdG9yKGtleSkge1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gMTY7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMTY7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICB0aGlzLnIgPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICAgICAgICB0aGlzLmggPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICAgICAgICB0aGlzLnBhZCA9IG5ldyBVaW50MTZBcnJheSg4KTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIGtleSA9IHRvQnl0ZXMoa2V5KTtcbiAgICAgICAgYWJ5dGVzKGtleSwgMzIpO1xuICAgICAgICBjb25zdCB0MCA9IHU4dG8xNihrZXksIDApO1xuICAgICAgICBjb25zdCB0MSA9IHU4dG8xNihrZXksIDIpO1xuICAgICAgICBjb25zdCB0MiA9IHU4dG8xNihrZXksIDQpO1xuICAgICAgICBjb25zdCB0MyA9IHU4dG8xNihrZXksIDYpO1xuICAgICAgICBjb25zdCB0NCA9IHU4dG8xNihrZXksIDgpO1xuICAgICAgICBjb25zdCB0NSA9IHU4dG8xNihrZXksIDEwKTtcbiAgICAgICAgY29uc3QgdDYgPSB1OHRvMTYoa2V5LCAxMik7XG4gICAgICAgIGNvbnN0IHQ3ID0gdTh0bzE2KGtleSwgMTQpO1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvb2R5YmVycnkvcG9seTEzMDUtZG9ubmEvYmxvYi9lNmFkNmUwOTFkMzBkN2Y0ZWMyZDRmOTc4YmUxZmNmY2JjZTcyNzgxL3BvbHkxMzA1LWRvbm5hLTE2LmgjTDQ3XG4gICAgICAgIHRoaXMuclswXSA9IHQwICYgMHgxZmZmO1xuICAgICAgICB0aGlzLnJbMV0gPSAoKHQwID4+PiAxMykgfCAodDEgPDwgMykpICYgMHgxZmZmO1xuICAgICAgICB0aGlzLnJbMl0gPSAoKHQxID4+PiAxMCkgfCAodDIgPDwgNikpICYgMHgxZjAzO1xuICAgICAgICB0aGlzLnJbM10gPSAoKHQyID4+PiA3KSB8ICh0MyA8PCA5KSkgJiAweDFmZmY7XG4gICAgICAgIHRoaXMucls0XSA9ICgodDMgPj4+IDQpIHwgKHQ0IDw8IDEyKSkgJiAweDAwZmY7XG4gICAgICAgIHRoaXMucls1XSA9ICh0NCA+Pj4gMSkgJiAweDFmZmU7XG4gICAgICAgIHRoaXMucls2XSA9ICgodDQgPj4+IDE0KSB8ICh0NSA8PCAyKSkgJiAweDFmZmY7XG4gICAgICAgIHRoaXMucls3XSA9ICgodDUgPj4+IDExKSB8ICh0NiA8PCA1KSkgJiAweDFmODE7XG4gICAgICAgIHRoaXMucls4XSA9ICgodDYgPj4+IDgpIHwgKHQ3IDw8IDgpKSAmIDB4MWZmZjtcbiAgICAgICAgdGhpcy5yWzldID0gKHQ3ID4+PiA1KSAmIDB4MDA3ZjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspXG4gICAgICAgICAgICB0aGlzLnBhZFtpXSA9IHU4dG8xNihrZXksIDE2ICsgMiAqIGkpO1xuICAgIH1cbiAgICBwcm9jZXNzKGRhdGEsIG9mZnNldCwgaXNMYXN0ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaGliaXQgPSBpc0xhc3QgPyAwIDogMSA8PCAxMTtcbiAgICAgICAgY29uc3QgeyBoLCByIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCByMCA9IHJbMF07XG4gICAgICAgIGNvbnN0IHIxID0gclsxXTtcbiAgICAgICAgY29uc3QgcjIgPSByWzJdO1xuICAgICAgICBjb25zdCByMyA9IHJbM107XG4gICAgICAgIGNvbnN0IHI0ID0gcls0XTtcbiAgICAgICAgY29uc3QgcjUgPSByWzVdO1xuICAgICAgICBjb25zdCByNiA9IHJbNl07XG4gICAgICAgIGNvbnN0IHI3ID0gcls3XTtcbiAgICAgICAgY29uc3QgcjggPSByWzhdO1xuICAgICAgICBjb25zdCByOSA9IHJbOV07XG4gICAgICAgIGNvbnN0IHQwID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDApO1xuICAgICAgICBjb25zdCB0MSA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyAyKTtcbiAgICAgICAgY29uc3QgdDIgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIGNvbnN0IHQzID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDYpO1xuICAgICAgICBjb25zdCB0NCA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyA4KTtcbiAgICAgICAgY29uc3QgdDUgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMTApO1xuICAgICAgICBjb25zdCB0NiA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyAxMik7XG4gICAgICAgIGNvbnN0IHQ3ID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDE0KTtcbiAgICAgICAgbGV0IGgwID0gaFswXSArICh0MCAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoMSA9IGhbMV0gKyAoKCh0MCA+Pj4gMTMpIHwgKHQxIDw8IDMpKSAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoMiA9IGhbMl0gKyAoKCh0MSA+Pj4gMTApIHwgKHQyIDw8IDYpKSAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoMyA9IGhbM10gKyAoKCh0MiA+Pj4gNykgfCAodDMgPDwgOSkpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg0ID0gaFs0XSArICgoKHQzID4+PiA0KSB8ICh0NCA8PCAxMikpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg1ID0gaFs1XSArICgodDQgPj4+IDEpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg2ID0gaFs2XSArICgoKHQ0ID4+PiAxNCkgfCAodDUgPDwgMikpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg3ID0gaFs3XSArICgoKHQ1ID4+PiAxMSkgfCAodDYgPDwgNSkpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGg4ID0gaFs4XSArICgoKHQ2ID4+PiA4KSB8ICh0NyA8PCA4KSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDkgPSBoWzldICsgKCh0NyA+Pj4gNSkgfCBoaWJpdCk7XG4gICAgICAgIGxldCBjID0gMDtcbiAgICAgICAgbGV0IGQwID0gYyArIGgwICogcjAgKyBoMSAqICg1ICogcjkpICsgaDIgKiAoNSAqIHI4KSArIGgzICogKDUgKiByNykgKyBoNCAqICg1ICogcjYpO1xuICAgICAgICBjID0gZDAgPj4+IDEzO1xuICAgICAgICBkMCAmPSAweDFmZmY7XG4gICAgICAgIGQwICs9IGg1ICogKDUgKiByNSkgKyBoNiAqICg1ICogcjQpICsgaDcgKiAoNSAqIHIzKSArIGg4ICogKDUgKiByMikgKyBoOSAqICg1ICogcjEpO1xuICAgICAgICBjICs9IGQwID4+PiAxMztcbiAgICAgICAgZDAgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDEgPSBjICsgaDAgKiByMSArIGgxICogcjAgKyBoMiAqICg1ICogcjkpICsgaDMgKiAoNSAqIHI4KSArIGg0ICogKDUgKiByNyk7XG4gICAgICAgIGMgPSBkMSA+Pj4gMTM7XG4gICAgICAgIGQxICY9IDB4MWZmZjtcbiAgICAgICAgZDEgKz0gaDUgKiAoNSAqIHI2KSArIGg2ICogKDUgKiByNSkgKyBoNyAqICg1ICogcjQpICsgaDggKiAoNSAqIHIzKSArIGg5ICogKDUgKiByMik7XG4gICAgICAgIGMgKz0gZDEgPj4+IDEzO1xuICAgICAgICBkMSAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkMiA9IGMgKyBoMCAqIHIyICsgaDEgKiByMSArIGgyICogcjAgKyBoMyAqICg1ICogcjkpICsgaDQgKiAoNSAqIHI4KTtcbiAgICAgICAgYyA9IGQyID4+PiAxMztcbiAgICAgICAgZDIgJj0gMHgxZmZmO1xuICAgICAgICBkMiArPSBoNSAqICg1ICogcjcpICsgaDYgKiAoNSAqIHI2KSArIGg3ICogKDUgKiByNSkgKyBoOCAqICg1ICogcjQpICsgaDkgKiAoNSAqIHIzKTtcbiAgICAgICAgYyArPSBkMiA+Pj4gMTM7XG4gICAgICAgIGQyICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQzID0gYyArIGgwICogcjMgKyBoMSAqIHIyICsgaDIgKiByMSArIGgzICogcjAgKyBoNCAqICg1ICogcjkpO1xuICAgICAgICBjID0gZDMgPj4+IDEzO1xuICAgICAgICBkMyAmPSAweDFmZmY7XG4gICAgICAgIGQzICs9IGg1ICogKDUgKiByOCkgKyBoNiAqICg1ICogcjcpICsgaDcgKiAoNSAqIHI2KSArIGg4ICogKDUgKiByNSkgKyBoOSAqICg1ICogcjQpO1xuICAgICAgICBjICs9IGQzID4+PiAxMztcbiAgICAgICAgZDMgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDQgPSBjICsgaDAgKiByNCArIGgxICogcjMgKyBoMiAqIHIyICsgaDMgKiByMSArIGg0ICogcjA7XG4gICAgICAgIGMgPSBkNCA+Pj4gMTM7XG4gICAgICAgIGQ0ICY9IDB4MWZmZjtcbiAgICAgICAgZDQgKz0gaDUgKiAoNSAqIHI5KSArIGg2ICogKDUgKiByOCkgKyBoNyAqICg1ICogcjcpICsgaDggKiAoNSAqIHI2KSArIGg5ICogKDUgKiByNSk7XG4gICAgICAgIGMgKz0gZDQgPj4+IDEzO1xuICAgICAgICBkNCAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkNSA9IGMgKyBoMCAqIHI1ICsgaDEgKiByNCArIGgyICogcjMgKyBoMyAqIHIyICsgaDQgKiByMTtcbiAgICAgICAgYyA9IGQ1ID4+PiAxMztcbiAgICAgICAgZDUgJj0gMHgxZmZmO1xuICAgICAgICBkNSArPSBoNSAqIHIwICsgaDYgKiAoNSAqIHI5KSArIGg3ICogKDUgKiByOCkgKyBoOCAqICg1ICogcjcpICsgaDkgKiAoNSAqIHI2KTtcbiAgICAgICAgYyArPSBkNSA+Pj4gMTM7XG4gICAgICAgIGQ1ICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQ2ID0gYyArIGgwICogcjYgKyBoMSAqIHI1ICsgaDIgKiByNCArIGgzICogcjMgKyBoNCAqIHIyO1xuICAgICAgICBjID0gZDYgPj4+IDEzO1xuICAgICAgICBkNiAmPSAweDFmZmY7XG4gICAgICAgIGQ2ICs9IGg1ICogcjEgKyBoNiAqIHIwICsgaDcgKiAoNSAqIHI5KSArIGg4ICogKDUgKiByOCkgKyBoOSAqICg1ICogcjcpO1xuICAgICAgICBjICs9IGQ2ID4+PiAxMztcbiAgICAgICAgZDYgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDcgPSBjICsgaDAgKiByNyArIGgxICogcjYgKyBoMiAqIHI1ICsgaDMgKiByNCArIGg0ICogcjM7XG4gICAgICAgIGMgPSBkNyA+Pj4gMTM7XG4gICAgICAgIGQ3ICY9IDB4MWZmZjtcbiAgICAgICAgZDcgKz0gaDUgKiByMiArIGg2ICogcjEgKyBoNyAqIHIwICsgaDggKiAoNSAqIHI5KSArIGg5ICogKDUgKiByOCk7XG4gICAgICAgIGMgKz0gZDcgPj4+IDEzO1xuICAgICAgICBkNyAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkOCA9IGMgKyBoMCAqIHI4ICsgaDEgKiByNyArIGgyICogcjYgKyBoMyAqIHI1ICsgaDQgKiByNDtcbiAgICAgICAgYyA9IGQ4ID4+PiAxMztcbiAgICAgICAgZDggJj0gMHgxZmZmO1xuICAgICAgICBkOCArPSBoNSAqIHIzICsgaDYgKiByMiArIGg3ICogcjEgKyBoOCAqIHIwICsgaDkgKiAoNSAqIHI5KTtcbiAgICAgICAgYyArPSBkOCA+Pj4gMTM7XG4gICAgICAgIGQ4ICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQ5ID0gYyArIGgwICogcjkgKyBoMSAqIHI4ICsgaDIgKiByNyArIGgzICogcjYgKyBoNCAqIHI1O1xuICAgICAgICBjID0gZDkgPj4+IDEzO1xuICAgICAgICBkOSAmPSAweDFmZmY7XG4gICAgICAgIGQ5ICs9IGg1ICogcjQgKyBoNiAqIHIzICsgaDcgKiByMiArIGg4ICogcjEgKyBoOSAqIHIwO1xuICAgICAgICBjICs9IGQ5ID4+PiAxMztcbiAgICAgICAgZDkgJj0gMHgxZmZmO1xuICAgICAgICBjID0gKChjIDw8IDIpICsgYykgfCAwO1xuICAgICAgICBjID0gKGMgKyBkMCkgfCAwO1xuICAgICAgICBkMCA9IGMgJiAweDFmZmY7XG4gICAgICAgIGMgPSBjID4+PiAxMztcbiAgICAgICAgZDEgKz0gYztcbiAgICAgICAgaFswXSA9IGQwO1xuICAgICAgICBoWzFdID0gZDE7XG4gICAgICAgIGhbMl0gPSBkMjtcbiAgICAgICAgaFszXSA9IGQzO1xuICAgICAgICBoWzRdID0gZDQ7XG4gICAgICAgIGhbNV0gPSBkNTtcbiAgICAgICAgaFs2XSA9IGQ2O1xuICAgICAgICBoWzddID0gZDc7XG4gICAgICAgIGhbOF0gPSBkODtcbiAgICAgICAgaFs5XSA9IGQ5O1xuICAgIH1cbiAgICBmaW5hbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgeyBoLCBwYWQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGcgPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICAgICAgICBsZXQgYyA9IGhbMV0gPj4+IDEzO1xuICAgICAgICBoWzFdICY9IDB4MWZmZjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICBoW2ldICs9IGM7XG4gICAgICAgICAgICBjID0gaFtpXSA+Pj4gMTM7XG4gICAgICAgICAgICBoW2ldICY9IDB4MWZmZjtcbiAgICAgICAgfVxuICAgICAgICBoWzBdICs9IGMgKiA1O1xuICAgICAgICBjID0gaFswXSA+Pj4gMTM7XG4gICAgICAgIGhbMF0gJj0gMHgxZmZmO1xuICAgICAgICBoWzFdICs9IGM7XG4gICAgICAgIGMgPSBoWzFdID4+PiAxMztcbiAgICAgICAgaFsxXSAmPSAweDFmZmY7XG4gICAgICAgIGhbMl0gKz0gYztcbiAgICAgICAgZ1swXSA9IGhbMF0gKyA1O1xuICAgICAgICBjID0gZ1swXSA+Pj4gMTM7XG4gICAgICAgIGdbMF0gJj0gMHgxZmZmO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgIGdbaV0gPSBoW2ldICsgYztcbiAgICAgICAgICAgIGMgPSBnW2ldID4+PiAxMztcbiAgICAgICAgICAgIGdbaV0gJj0gMHgxZmZmO1xuICAgICAgICB9XG4gICAgICAgIGdbOV0gLT0gMSA8PCAxMztcbiAgICAgICAgbGV0IG1hc2sgPSAoYyBeIDEpIC0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKVxuICAgICAgICAgICAgZ1tpXSAmPSBtYXNrO1xuICAgICAgICBtYXNrID0gfm1hc2s7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKylcbiAgICAgICAgICAgIGhbaV0gPSAoaFtpXSAmIG1hc2spIHwgZ1tpXTtcbiAgICAgICAgaFswXSA9IChoWzBdIHwgKGhbMV0gPDwgMTMpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFsxXSA9ICgoaFsxXSA+Pj4gMykgfCAoaFsyXSA8PCAxMCkpICYgMHhmZmZmO1xuICAgICAgICBoWzJdID0gKChoWzJdID4+PiA2KSB8IChoWzNdIDw8IDcpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFszXSA9ICgoaFszXSA+Pj4gOSkgfCAoaFs0XSA8PCA0KSkgJiAweGZmZmY7XG4gICAgICAgIGhbNF0gPSAoKGhbNF0gPj4+IDEyKSB8IChoWzVdIDw8IDEpIHwgKGhbNl0gPDwgMTQpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFs1XSA9ICgoaFs2XSA+Pj4gMikgfCAoaFs3XSA8PCAxMSkpICYgMHhmZmZmO1xuICAgICAgICBoWzZdID0gKChoWzddID4+PiA1KSB8IChoWzhdIDw8IDgpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFs3XSA9ICgoaFs4XSA+Pj4gOCkgfCAoaFs5XSA8PCA1KSkgJiAweGZmZmY7XG4gICAgICAgIGxldCBmID0gaFswXSArIHBhZFswXTtcbiAgICAgICAgaFswXSA9IGYgJiAweGZmZmY7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBmID0gKCgoaFtpXSArIHBhZFtpXSkgfCAwKSArIChmID4+PiAxNikpIHwgMDtcbiAgICAgICAgICAgIGhbaV0gPSBmICYgMHhmZmZmO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXRcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGEsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhidWZmZXIsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaC5maWxsKDApO1xuICAgICAgICB0aGlzLnIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5wYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgYW91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIGggfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgYnVmZmVyW3BvcysrXSA9IDE7XG4gICAgICAgICAgICAvLyBidWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAgICAgZm9yICg7IHBvcyA8IDE2OyBwb3MrKylcbiAgICAgICAgICAgICAgICBidWZmZXJbcG9zXSA9IDA7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3MoYnVmZmVyLCAwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgICAgIGxldCBvcG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIG91dFtvcG9zKytdID0gaFtpXSA+Pj4gMDtcbiAgICAgICAgICAgIG91dFtvcG9zKytdID0gaFtpXSA+Pj4gODtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhLZXkoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIGtleSkgPT4gaGFzaENvbnMoa2V5KS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyhuZXcgVWludDhBcnJheSgzMikpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKGtleSkgPT4gaGFzaENvbnMoa2V5KTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgY29uc3QgcG9seTEzMDUgPSB3cmFwQ29uc3RydWN0b3JXaXRoS2V5KChrZXkpID0+IG5ldyBQb2x5MTMwNShrZXkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9wb2x5MTMwNS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_poly1305.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_polyval.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_polyval.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _toGHASHKey: () => (/* binding */ _toGHASHKey),\n/* harmony export */   ghash: () => (/* binding */ ghash),\n/* harmony export */   polyval: () => (/* binding */ polyval)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/utils.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_assert.js\");\n\n\n// GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n// Implemented in terms of GHash with conversion function for keys\n// GCM GHASH from NIST SP800-38d, SIV from RFC 8452.\n// https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf\n// GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n// POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\nconst BLOCK_SIZE = 16;\n// TODO: rewrite\n// temporary padding buffer\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\nconst ZEROS32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(ZEROS16);\nconst POLY = 0xe1; // v = 2*v % POLY\n// v = 2*v % POLY\n// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\nconst mul2 = (s0, s1, s2, s3) => {\n    const hiBit = s3 & 1;\n    return {\n        s3: (s2 << 31) | (s3 >>> 1),\n        s2: (s1 << 31) | (s2 >>> 1),\n        s1: (s0 << 31) | (s1 >>> 1),\n        s0: (s0 >>> 1) ^ ((POLY << 24) & -(hiBit & 1)), // reduce % poly\n    };\n};\nconst swapLE = (n) => (((n >>> 0) & 0xff) << 24) |\n    (((n >>> 8) & 0xff) << 16) |\n    (((n >>> 16) & 0xff) << 8) |\n    ((n >>> 24) & 0xff) |\n    0;\n/**\n * `mulX_POLYVAL(ByteReverse(H))` from spec\n * @param k mutated in place\n */\nfunction _toGHASHKey(k) {\n    k.reverse();\n    const hiBit = k[15] & 1;\n    // k >>= 1\n    let carry = 0;\n    for (let i = 0; i < k.length; i++) {\n        const t = k[i];\n        k[i] = (t >>> 1) | carry;\n        carry = (t & 1) << 7;\n    }\n    k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n    return k;\n}\nconst estimateWindow = (bytes) => {\n    if (bytes > 64 * 1024)\n        return 8;\n    if (bytes > 1024)\n        return 4;\n    return 2;\n};\nclass GHASH {\n    // We select bits per window adaptively based on expectedLength\n    constructor(key, expectedLength) {\n        this.blockLen = BLOCK_SIZE;\n        this.outputLen = BLOCK_SIZE;\n        this.s0 = 0;\n        this.s1 = 0;\n        this.s2 = 0;\n        this.s3 = 0;\n        this.finished = false;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(key);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(key, 16);\n        const kView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(key);\n        let k0 = kView.getUint32(0, false);\n        let k1 = kView.getUint32(4, false);\n        let k2 = kView.getUint32(8, false);\n        let k3 = kView.getUint32(12, false);\n        // generate table of doubled keys (half of montgomery ladder)\n        const doubles = [];\n        for (let i = 0; i < 128; i++) {\n            doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });\n            ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));\n        }\n        const W = estimateWindow(expectedLength || 1024);\n        if (![1, 2, 4, 8].includes(W))\n            throw new Error(`ghash: wrong window size=${W}, should be 2, 4 or 8`);\n        this.W = W;\n        const bits = 128; // always 128 bits;\n        const windows = bits / W;\n        const windowSize = (this.windowSize = 2 ** W);\n        const items = [];\n        // Create precompute table for window of W bits\n        for (let w = 0; w < windows; w++) {\n            // truth table: 00, 01, 10, 11\n            for (let byte = 0; byte < windowSize; byte++) {\n                // prettier-ignore\n                let s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n                for (let j = 0; j < W; j++) {\n                    const bit = (byte >>> (W - j - 1)) & 1;\n                    if (!bit)\n                        continue;\n                    const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];\n                    (s0 ^= d0), (s1 ^= d1), (s2 ^= d2), (s3 ^= d3);\n                }\n                items.push({ s0, s1, s2, s3 });\n            }\n        }\n        this.t = items;\n    }\n    _updateBlock(s0, s1, s2, s3) {\n        (s0 ^= this.s0), (s1 ^= this.s1), (s2 ^= this.s2), (s3 ^= this.s3);\n        const { W, t, windowSize } = this;\n        // prettier-ignore\n        let o0 = 0, o1 = 0, o2 = 0, o3 = 0;\n        const mask = (1 << W) - 1; // 2**W will kill performance.\n        let w = 0;\n        for (const num of [s0, s1, s2, s3]) {\n            for (let bytePos = 0; bytePos < 4; bytePos++) {\n                const byte = (num >>> (8 * bytePos)) & 0xff;\n                for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {\n                    const bit = (byte >>> (W * bitPos)) & mask;\n                    const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];\n                    (o0 ^= e0), (o1 ^= e1), (o2 ^= e2), (o3 ^= e3);\n                    w += 1;\n                }\n            }\n        }\n        this.s0 = o0;\n        this.s1 = o1;\n        this.s2 = o2;\n        this.s3 = o3;\n    }\n    update(data) {\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const b32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(data);\n        const blocks = Math.floor(data.length / BLOCK_SIZE);\n        const left = data.length % BLOCK_SIZE;\n        for (let i = 0; i < blocks; i++) {\n            this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n        }\n        if (left) {\n            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n            this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);\n            ZEROS32.fill(0); // clean tmp buffer\n        }\n        return this;\n    }\n    destroy() {\n        const { t } = this;\n        // clean precompute table\n        for (const elm of t) {\n            (elm.s0 = 0), (elm.s1 = 0), (elm.s2 = 0), (elm.s3 = 0);\n        }\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        const { s0, s1, s2, s3 } = this;\n        const o32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(out);\n        o32[0] = s0;\n        o32[1] = s1;\n        o32[2] = s2;\n        o32[3] = s3;\n        return out;\n    }\n    digest() {\n        const res = new Uint8Array(BLOCK_SIZE);\n        this.digestInto(res);\n        this.destroy();\n        return res;\n    }\n}\nclass Polyval extends GHASH {\n    constructor(key, expectedLength) {\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(key);\n        const ghKey = _toGHASHKey(key.slice());\n        super(ghKey, expectedLength);\n        ghKey.fill(0);\n    }\n    update(data) {\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const b32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(data);\n        const left = data.length % BLOCK_SIZE;\n        const blocks = Math.floor(data.length / BLOCK_SIZE);\n        for (let i = 0; i < blocks; i++) {\n            this._updateBlock(swapLE(b32[i * 4 + 3]), swapLE(b32[i * 4 + 2]), swapLE(b32[i * 4 + 1]), swapLE(b32[i * 4 + 0]));\n        }\n        if (left) {\n            ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n            this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));\n            ZEROS32.fill(0); // clean tmp buffer\n        }\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // tmp ugly hack\n        const { s0, s1, s2, s3 } = this;\n        const o32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.u32)(out);\n        o32[0] = s0;\n        o32[1] = s1;\n        o32[2] = s2;\n        o32[3] = s3;\n        return out.reverse();\n    }\n}\nfunction wrapConstructorWithKey(hashCons) {\n    const hashC = (msg, key) => hashCons(key, msg.length).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(msg)).digest();\n    const tmp = hashCons(new Uint8Array(16), 0);\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (key, expectedLength) => hashCons(key, expectedLength);\n    return hashC;\n}\nconst ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));\nconst polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));\n//# sourceMappingURL=_polyval.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2VzbS9fcG9seXZhbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFzRDtBQUMrQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBRztBQUNuQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBTztBQUNyQixRQUFRLGlEQUFNO0FBQ2Qsc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDLDJCQUEyQixnRUFBZ0U7QUFDM0YsZUFBZSxpQ0FBaUM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEVBQUU7QUFDMUQ7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBTztBQUN0QixRQUFRLGtEQUFPO0FBQ2Ysb0JBQW9CLDhDQUFHO0FBQ3ZCO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQUk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmLFFBQVEsa0RBQU87QUFDZjtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsb0JBQW9CLDhDQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0RBQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQU87QUFDdEIsUUFBUSxrREFBTztBQUNmLG9CQUFvQiw4Q0FBRztBQUN2QjtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZixRQUFRLGtEQUFPO0FBQ2Y7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsb0JBQW9CLDhDQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsa0RBQU87QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2VzbS9fcG9seXZhbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVWaWV3LCB0b0J5dGVzLCB1MzIgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGJ5dGVzIGFzIGFieXRlcywgZXhpc3RzIGFzIGFleGlzdHMsIG91dHB1dCBhcyBhb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbi8vIEdIYXNoIGZyb20gQUVTLUdDTSBhbmQgaXRzIGxpdHRsZS1lbmRpYW4gXCJtaXJyb3IgaW1hZ2VcIiBQb2x5dmFsIGZyb20gQUVTLVNJVi5cbi8vIEltcGxlbWVudGVkIGluIHRlcm1zIG9mIEdIYXNoIHdpdGggY29udmVyc2lvbiBmdW5jdGlvbiBmb3Iga2V5c1xuLy8gR0NNIEdIQVNIIGZyb20gTklTVCBTUDgwMC0zOGQsIFNJViBmcm9tIFJGQyA4NDUyLlxuLy8gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0xlZ2FjeS9TUC9uaXN0c3BlY2lhbHB1YmxpY2F0aW9uODAwLTM4ZC5wZGZcbi8vIEdIQVNIICAgbW9kdWxvOiB4XjEyOCArIHheNyAgICsgeF4yICAgKyB4ICAgICArIDFcbi8vIFBPTFlWQUwgbW9kdWxvOiB4XjEyOCArIHheMTI3ICsgeF4xMjYgKyB4XjEyMSArIDFcbmNvbnN0IEJMT0NLX1NJWkUgPSAxNjtcbi8vIFRPRE86IHJld3JpdGVcbi8vIHRlbXBvcmFyeSBwYWRkaW5nIGJ1ZmZlclxuY29uc3QgWkVST1MxNiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDhBcnJheSgxNik7XG5jb25zdCBaRVJPUzMyID0gdTMyKFpFUk9TMTYpO1xuY29uc3QgUE9MWSA9IDB4ZTE7IC8vIHYgPSAyKnYgJSBQT0xZXG4vLyB2ID0gMip2ICUgUE9MWVxuLy8gTk9URTogYmVjYXVzZSB4ICsgeCA9IDAgKGFkZC9zdWIgaXMgc2FtZSksIG11bDIoeCkgIT0geCt4XG4vLyBXZSBjYW4gbXVsdGlwbHkgYW55IG51bWJlciB1c2luZyBtb250Z29tZXJ5IGxhZGRlciBhbmQgdGhpcyBmdW5jdGlvbiAod29ya3MgYXMgZG91YmxlLCBhZGQgaXMgc2ltcGxlIHhvcilcbmNvbnN0IG11bDIgPSAoczAsIHMxLCBzMiwgczMpID0+IHtcbiAgICBjb25zdCBoaUJpdCA9IHMzICYgMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzMzogKHMyIDw8IDMxKSB8IChzMyA+Pj4gMSksXG4gICAgICAgIHMyOiAoczEgPDwgMzEpIHwgKHMyID4+PiAxKSxcbiAgICAgICAgczE6IChzMCA8PCAzMSkgfCAoczEgPj4+IDEpLFxuICAgICAgICBzMDogKHMwID4+PiAxKSBeICgoUE9MWSA8PCAyNCkgJiAtKGhpQml0ICYgMSkpLCAvLyByZWR1Y2UgJSBwb2x5XG4gICAgfTtcbn07XG5jb25zdCBzd2FwTEUgPSAobikgPT4gKCgobiA+Pj4gMCkgJiAweGZmKSA8PCAyNCkgfFxuICAgICgoKG4gPj4+IDgpICYgMHhmZikgPDwgMTYpIHxcbiAgICAoKChuID4+PiAxNikgJiAweGZmKSA8PCA4KSB8XG4gICAgKChuID4+PiAyNCkgJiAweGZmKSB8XG4gICAgMDtcbi8qKlxuICogYG11bFhfUE9MWVZBTChCeXRlUmV2ZXJzZShIKSlgIGZyb20gc3BlY1xuICogQHBhcmFtIGsgbXV0YXRlZCBpbiBwbGFjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3RvR0hBU0hLZXkoaykge1xuICAgIGsucmV2ZXJzZSgpO1xuICAgIGNvbnN0IGhpQml0ID0ga1sxNV0gJiAxO1xuICAgIC8vIGsgPj49IDFcbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0ID0ga1tpXTtcbiAgICAgICAga1tpXSA9ICh0ID4+PiAxKSB8IGNhcnJ5O1xuICAgICAgICBjYXJyeSA9ICh0ICYgMSkgPDwgNztcbiAgICB9XG4gICAga1swXSBePSAtaGlCaXQgJiAweGUxOyAvLyBpZiAoaGlCaXQpIG4gXj0gMHhlMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDtcbiAgICByZXR1cm4gaztcbn1cbmNvbnN0IGVzdGltYXRlV2luZG93ID0gKGJ5dGVzKSA9PiB7XG4gICAgaWYgKGJ5dGVzID4gNjQgKiAxMDI0KVxuICAgICAgICByZXR1cm4gODtcbiAgICBpZiAoYnl0ZXMgPiAxMDI0KVxuICAgICAgICByZXR1cm4gNDtcbiAgICByZXR1cm4gMjtcbn07XG5jbGFzcyBHSEFTSCB7XG4gICAgLy8gV2Ugc2VsZWN0IGJpdHMgcGVyIHdpbmRvdyBhZGFwdGl2ZWx5IGJhc2VkIG9uIGV4cGVjdGVkTGVuZ3RoXG4gICAgY29uc3RydWN0b3Ioa2V5LCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gQkxPQ0tfU0laRTtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBCTE9DS19TSVpFO1xuICAgICAgICB0aGlzLnMwID0gMDtcbiAgICAgICAgdGhpcy5zMSA9IDA7XG4gICAgICAgIHRoaXMuczIgPSAwO1xuICAgICAgICB0aGlzLnMzID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICBrZXkgPSB0b0J5dGVzKGtleSk7XG4gICAgICAgIGFieXRlcyhrZXksIDE2KTtcbiAgICAgICAgY29uc3Qga1ZpZXcgPSBjcmVhdGVWaWV3KGtleSk7XG4gICAgICAgIGxldCBrMCA9IGtWaWV3LmdldFVpbnQzMigwLCBmYWxzZSk7XG4gICAgICAgIGxldCBrMSA9IGtWaWV3LmdldFVpbnQzMig0LCBmYWxzZSk7XG4gICAgICAgIGxldCBrMiA9IGtWaWV3LmdldFVpbnQzMig4LCBmYWxzZSk7XG4gICAgICAgIGxldCBrMyA9IGtWaWV3LmdldFVpbnQzMigxMiwgZmFsc2UpO1xuICAgICAgICAvLyBnZW5lcmF0ZSB0YWJsZSBvZiBkb3VibGVkIGtleXMgKGhhbGYgb2YgbW9udGdvbWVyeSBsYWRkZXIpXG4gICAgICAgIGNvbnN0IGRvdWJsZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgICAgICAgICAgZG91Ymxlcy5wdXNoKHsgczA6IHN3YXBMRShrMCksIHMxOiBzd2FwTEUoazEpLCBzMjogc3dhcExFKGsyKSwgczM6IHN3YXBMRShrMykgfSk7XG4gICAgICAgICAgICAoeyBzMDogazAsIHMxOiBrMSwgczI6IGsyLCBzMzogazMgfSA9IG11bDIoazAsIGsxLCBrMiwgazMpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBXID0gZXN0aW1hdGVXaW5kb3coZXhwZWN0ZWRMZW5ndGggfHwgMTAyNCk7XG4gICAgICAgIGlmICghWzEsIDIsIDQsIDhdLmluY2x1ZGVzKFcpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBnaGFzaDogd3Jvbmcgd2luZG93IHNpemU9JHtXfSwgc2hvdWxkIGJlIDIsIDQgb3IgOGApO1xuICAgICAgICB0aGlzLlcgPSBXO1xuICAgICAgICBjb25zdCBiaXRzID0gMTI4OyAvLyBhbHdheXMgMTI4IGJpdHM7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBiaXRzIC8gVztcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9ICh0aGlzLndpbmRvd1NpemUgPSAyICoqIFcpO1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICAvLyBDcmVhdGUgcHJlY29tcHV0ZSB0YWJsZSBmb3Igd2luZG93IG9mIFcgYml0c1xuICAgICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IHdpbmRvd3M7IHcrKykge1xuICAgICAgICAgICAgLy8gdHJ1dGggdGFibGU6IDAwLCAwMSwgMTAsIDExXG4gICAgICAgICAgICBmb3IgKGxldCBieXRlID0gMDsgYnl0ZSA8IHdpbmRvd1NpemU7IGJ5dGUrKykge1xuICAgICAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgICAgIGxldCBzMCA9IDAsIHMxID0gMCwgczIgPSAwLCBzMyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBXOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYml0ID0gKGJ5dGUgPj4+IChXIC0gaiAtIDEpKSAmIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYml0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgczA6IGQwLCBzMTogZDEsIHMyOiBkMiwgczM6IGQzIH0gPSBkb3VibGVzW1cgKiB3ICsgal07XG4gICAgICAgICAgICAgICAgICAgIChzMCBePSBkMCksIChzMSBePSBkMSksIChzMiBePSBkMiksIChzMyBePSBkMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goeyBzMCwgczEsIHMyLCBzMyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnQgPSBpdGVtcztcbiAgICB9XG4gICAgX3VwZGF0ZUJsb2NrKHMwLCBzMSwgczIsIHMzKSB7XG4gICAgICAgIChzMCBePSB0aGlzLnMwKSwgKHMxIF49IHRoaXMuczEpLCAoczIgXj0gdGhpcy5zMiksIChzMyBePSB0aGlzLnMzKTtcbiAgICAgICAgY29uc3QgeyBXLCB0LCB3aW5kb3dTaXplIH0gPSB0aGlzO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IG8wID0gMCwgbzEgPSAwLCBvMiA9IDAsIG8zID0gMDtcbiAgICAgICAgY29uc3QgbWFzayA9ICgxIDw8IFcpIC0gMTsgLy8gMioqVyB3aWxsIGtpbGwgcGVyZm9ybWFuY2UuXG4gICAgICAgIGxldCB3ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBudW0gb2YgW3MwLCBzMSwgczIsIHMzXSkge1xuICAgICAgICAgICAgZm9yIChsZXQgYnl0ZVBvcyA9IDA7IGJ5dGVQb3MgPCA0OyBieXRlUG9zKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlID0gKG51bSA+Pj4gKDggKiBieXRlUG9zKSkgJiAweGZmO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGJpdFBvcyA9IDggLyBXIC0gMTsgYml0UG9zID49IDA7IGJpdFBvcy0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IChieXRlID4+PiAoVyAqIGJpdFBvcykpICYgbWFzaztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzMDogZTAsIHMxOiBlMSwgczI6IGUyLCBzMzogZTMgfSA9IHRbdyAqIHdpbmRvd1NpemUgKyBiaXRdO1xuICAgICAgICAgICAgICAgICAgICAobzAgXj0gZTApLCAobzEgXj0gZTEpLCAobzIgXj0gZTIpLCAobzMgXj0gZTMpO1xuICAgICAgICAgICAgICAgICAgICB3ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuczAgPSBvMDtcbiAgICAgICAgdGhpcy5zMSA9IG8xO1xuICAgICAgICB0aGlzLnMyID0gbzI7XG4gICAgICAgIHRoaXMuczMgPSBvMztcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IGIzMiA9IHUzMihkYXRhKTtcbiAgICAgICAgY29uc3QgYmxvY2tzID0gTWF0aC5mbG9vcihkYXRhLmxlbmd0aCAvIEJMT0NLX1NJWkUpO1xuICAgICAgICBjb25zdCBsZWZ0ID0gZGF0YS5sZW5ndGggJSBCTE9DS19TSVpFO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCbG9jayhiMzJbaSAqIDQgKyAwXSwgYjMyW2kgKiA0ICsgMV0sIGIzMltpICogNCArIDJdLCBiMzJbaSAqIDQgKyAzXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQpIHtcbiAgICAgICAgICAgIFpFUk9TMTYuc2V0KGRhdGEuc3ViYXJyYXkoYmxvY2tzICogQkxPQ0tfU0laRSkpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQmxvY2soWkVST1MzMlswXSwgWkVST1MzMlsxXSwgWkVST1MzMlsyXSwgWkVST1MzMlszXSk7XG4gICAgICAgICAgICBaRVJPUzMyLmZpbGwoMCk7IC8vIGNsZWFuIHRtcCBidWZmZXJcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY29uc3QgeyB0IH0gPSB0aGlzO1xuICAgICAgICAvLyBjbGVhbiBwcmVjb21wdXRlIHRhYmxlXG4gICAgICAgIGZvciAoY29uc3QgZWxtIG9mIHQpIHtcbiAgICAgICAgICAgIChlbG0uczAgPSAwKSwgKGVsbS5zMSA9IDApLCAoZWxtLnMyID0gMCksIChlbG0uczMgPSAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHMwLCBzMSwgczIsIHMzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBvMzIgPSB1MzIob3V0KTtcbiAgICAgICAgbzMyWzBdID0gczA7XG4gICAgICAgIG8zMlsxXSA9IHMxO1xuICAgICAgICBvMzJbMl0gPSBzMjtcbiAgICAgICAgbzMyWzNdID0gczM7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoQkxPQ0tfU0laRSk7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhyZXMpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5jbGFzcyBQb2x5dmFsIGV4dGVuZHMgR0hBU0gge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAga2V5ID0gdG9CeXRlcyhrZXkpO1xuICAgICAgICBjb25zdCBnaEtleSA9IF90b0dIQVNIS2V5KGtleS5zbGljZSgpKTtcbiAgICAgICAgc3VwZXIoZ2hLZXksIGV4cGVjdGVkTGVuZ3RoKTtcbiAgICAgICAgZ2hLZXkuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IGIzMiA9IHUzMihkYXRhKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IGRhdGEubGVuZ3RoICUgQkxPQ0tfU0laRTtcbiAgICAgICAgY29uc3QgYmxvY2tzID0gTWF0aC5mbG9vcihkYXRhLmxlbmd0aCAvIEJMT0NLX1NJWkUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCbG9jayhzd2FwTEUoYjMyW2kgKiA0ICsgM10pLCBzd2FwTEUoYjMyW2kgKiA0ICsgMl0pLCBzd2FwTEUoYjMyW2kgKiA0ICsgMV0pLCBzd2FwTEUoYjMyW2kgKiA0ICsgMF0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgWkVST1MxNi5zZXQoZGF0YS5zdWJhcnJheShibG9ja3MgKiBCTE9DS19TSVpFKSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCbG9jayhzd2FwTEUoWkVST1MzMlszXSksIHN3YXBMRShaRVJPUzMyWzJdKSwgc3dhcExFKFpFUk9TMzJbMV0pLCBzd2FwTEUoWkVST1MzMlswXSkpO1xuICAgICAgICAgICAgWkVST1MzMi5maWxsKDApOyAvLyBjbGVhbiB0bXAgYnVmZmVyXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIHRtcCB1Z2x5IGhhY2tcbiAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbzMyID0gdTMyKG91dCk7XG4gICAgICAgIG8zMlswXSA9IHMwO1xuICAgICAgICBvMzJbMV0gPSBzMTtcbiAgICAgICAgbzMyWzJdID0gczI7XG4gICAgICAgIG8zMlszXSA9IHMzO1xuICAgICAgICByZXR1cm4gb3V0LnJldmVyc2UoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoS2V5KGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBrZXkpID0+IGhhc2hDb25zKGtleSwgbXNnLmxlbmd0aCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMobmV3IFVpbnQ4QXJyYXkoMTYpLCAwKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChrZXksIGV4cGVjdGVkTGVuZ3RoKSA9PiBoYXNoQ29ucyhrZXksIGV4cGVjdGVkTGVuZ3RoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgY29uc3QgZ2hhc2ggPSB3cmFwQ29uc3RydWN0b3JXaXRoS2V5KChrZXksIGV4cGVjdGVkTGVuZ3RoKSA9PiBuZXcgR0hBU0goa2V5LCBleHBlY3RlZExlbmd0aCkpO1xuZXhwb3J0IGNvbnN0IHBvbHl2YWwgPSB3cmFwQ29uc3RydWN0b3JXaXRoS2V5KChrZXksIGV4cGVjdGVkTGVuZ3RoKSA9PiBuZXcgUG9seXZhbChrZXksIGV4cGVjdGVkTGVuZ3RoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fcG9seXZhbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_polyval.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/aes.js":
/*!**************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/aes.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cbc: () => (/* binding */ cbc),\n/* harmony export */   cfb: () => (/* binding */ cfb),\n/* harmony export */   ctr: () => (/* binding */ ctr),\n/* harmony export */   ecb: () => (/* binding */ ecb),\n/* harmony export */   expandKeyDecLE: () => (/* binding */ expandKeyDecLE),\n/* harmony export */   expandKeyLE: () => (/* binding */ expandKeyLE),\n/* harmony export */   gcm: () => (/* binding */ gcm),\n/* harmony export */   siv: () => (/* binding */ siv),\n/* harmony export */   unsafe: () => (/* binding */ unsafe)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/utils.js\");\n/* harmony import */ var _polyval_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_polyval.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_polyval.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_assert.js\");\n// prettier-ignore\n\n\n\n/*\nAES (Advanced Encryption Standard) aka Rijndael block cipher.\n\nData is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256 bits). In every round:\n1. **S-box**, table substitution\n2. **Shift rows**, cyclic shift left of all rows of data array\n3. **Mix columns**, multiplying every column by fixed polynomial\n4. **Add round key**, round_key xor i-th column of array\n\nResources:\n- FIPS-197 https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf\n- Original proposal: https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf\n*/\nconst BLOCK_SIZE = 16;\nconst BLOCK_SIZE32 = 4;\nconst EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE);\nconst POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n// TODO: remove multiplication, binary ops only\nfunction mul2(n) {\n    return (n << 1) ^ (POLY & -(n >> 7));\n}\nfunction mul(a, b) {\n    let res = 0;\n    for (; b > 0; b >>= 1) {\n        // Montgomery ladder\n        res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n        a = mul2(a); // a = 2*a\n    }\n    return res;\n}\n// AES S-box is generated using finite field inversion,\n// an affine transform, and xor of a constant 0x63.\nconst sbox = /* @__PURE__ */ (() => {\n    let t = new Uint8Array(256);\n    for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x))\n        t[i] = x;\n    const box = new Uint8Array(256);\n    box[0] = 0x63; // first elm\n    for (let i = 0; i < 255; i++) {\n        let x = t[255 - i];\n        x |= x << 8;\n        box[t[i]] = (x ^ (x >> 4) ^ (x >> 5) ^ (x >> 6) ^ (x >> 7) ^ 0x63) & 0xff;\n    }\n    return box;\n})();\n// Inverted S-box\nconst invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));\n// Rotate u32 by 8\nconst rotr32_8 = (n) => (n << 24) | (n >>> 8);\nconst rotl32_8 = (n) => (n << 8) | (n >>> 24);\n// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n// - LE instead of BE\n// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n//   so index is u16, instead of u8. This speeds up things, unexpectedly\nfunction genTtable(sbox, fn) {\n    if (sbox.length !== 256)\n        throw new Error('Wrong sbox length');\n    const T0 = new Uint32Array(256).map((_, j) => fn(sbox[j]));\n    const T1 = T0.map(rotl32_8);\n    const T2 = T1.map(rotl32_8);\n    const T3 = T2.map(rotl32_8);\n    const T01 = new Uint32Array(256 * 256);\n    const T23 = new Uint32Array(256 * 256);\n    const sbox2 = new Uint16Array(256 * 256);\n    for (let i = 0; i < 256; i++) {\n        for (let j = 0; j < 256; j++) {\n            const idx = i * 256 + j;\n            T01[idx] = T0[i] ^ T1[j];\n            T23[idx] = T2[i] ^ T3[j];\n            sbox2[idx] = (sbox[i] << 8) | sbox[j];\n        }\n    }\n    return { sbox, sbox2, T0, T1, T2, T3, T01, T23 };\n}\nconst tableEncoding = /* @__PURE__ */ genTtable(sbox, (s) => (mul(s, 3) << 24) | (s << 16) | (s << 8) | mul(s, 2));\nconst tableDecoding = /* @__PURE__ */ genTtable(invSbox, (s) => (mul(s, 11) << 24) | (mul(s, 13) << 16) | (mul(s, 9) << 8) | mul(s, 14));\nconst xPowers = /* @__PURE__ */ (() => {\n    const p = new Uint8Array(16);\n    for (let i = 0, x = 1; i < 16; i++, x = mul2(x))\n        p[i] = x;\n    return p;\n})();\nfunction expandKeyLE(key) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(key);\n    const len = key.length;\n    if (![16, 24, 32].includes(len))\n        throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${len}`);\n    const { sbox2 } = tableEncoding;\n    const k32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(key);\n    const Nk = k32.length;\n    const subByte = (n) => applySbox(sbox2, n, n, n, n);\n    const xk = new Uint32Array(len + 28); // expanded key\n    xk.set(k32);\n    // 4.3.1 Key expansion\n    for (let i = Nk; i < xk.length; i++) {\n        let t = xk[i - 1];\n        if (i % Nk === 0)\n            t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];\n        else if (Nk > 6 && i % Nk === 4)\n            t = subByte(t);\n        xk[i] = xk[i - Nk] ^ t;\n    }\n    return xk;\n}\nfunction expandKeyDecLE(key) {\n    const encKey = expandKeyLE(key);\n    const xk = encKey.slice();\n    const Nk = encKey.length;\n    const { sbox2 } = tableEncoding;\n    const { T0, T1, T2, T3 } = tableDecoding;\n    // Inverse key by chunks of 4 (rounds)\n    for (let i = 0; i < Nk; i += 4) {\n        for (let j = 0; j < 4; j++)\n            xk[i + j] = encKey[Nk - i - 4 + j];\n    }\n    encKey.fill(0);\n    // apply InvMixColumn except first & last round\n    for (let i = 4; i < Nk - 4; i++) {\n        const x = xk[i];\n        const w = applySbox(sbox2, x, x, x, x);\n        xk[i] = T0[w & 0xff] ^ T1[(w >>> 8) & 0xff] ^ T2[(w >>> 16) & 0xff] ^ T3[w >>> 24];\n    }\n    return xk;\n}\n// Apply tables\nfunction apply0123(T01, T23, s0, s1, s2, s3) {\n    return (T01[((s0 << 8) & 0xff00) | ((s1 >>> 8) & 0xff)] ^\n        T23[((s2 >>> 8) & 0xff00) | ((s3 >>> 24) & 0xff)]);\n}\nfunction applySbox(sbox2, s0, s1, s2, s3) {\n    return (sbox2[(s0 & 0xff) | (s1 & 0xff00)] |\n        (sbox2[((s2 >>> 16) & 0xff) | ((s3 >>> 16) & 0xff00)] << 16));\n}\nfunction encrypt(xk, s0, s1, s2, s3) {\n    const { sbox2, T01, T23 } = tableEncoding;\n    let k = 0;\n    (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n    const rounds = xk.length / 4 - 2;\n    for (let i = 0; i < rounds; i++) {\n        const t0 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);\n        const t1 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);\n        const t2 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);\n        const t3 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);\n        (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n    }\n    // last round (without mixcolumns, so using SBOX2 table)\n    const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);\n    const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);\n    const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);\n    const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);\n    return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\nfunction decrypt(xk, s0, s1, s2, s3) {\n    const { sbox2, T01, T23 } = tableDecoding;\n    let k = 0;\n    (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n    const rounds = xk.length / 4 - 2;\n    for (let i = 0; i < rounds; i++) {\n        const t0 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);\n        const t1 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);\n        const t2 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);\n        const t3 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);\n        (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n    }\n    // Last round\n    const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);\n    const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);\n    const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);\n    const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);\n    return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\nfunction getDst(len, dst) {\n    if (!dst)\n        return new Uint8Array(len);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(dst);\n    if (dst.length < len)\n        throw new Error(`aes: wrong destination length, expected at least ${len}, got: ${dst.length}`);\n    return dst;\n}\n// TODO: investigate merging with ctr32\nfunction ctrCounter(xk, nonce, src, dst) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(nonce, BLOCK_SIZE);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(src);\n    const srcLen = src.length;\n    dst = getDst(srcLen, dst);\n    const ctr = nonce;\n    const c32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(ctr);\n    // Fill block (empty, ctr=0)\n    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n    const src32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(src);\n    const dst32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(dst);\n    // process blocks\n    for (let i = 0; i + 4 <= src32.length; i += 4) {\n        dst32[i + 0] = src32[i + 0] ^ s0;\n        dst32[i + 1] = src32[i + 1] ^ s1;\n        dst32[i + 2] = src32[i + 2] ^ s2;\n        dst32[i + 3] = src32[i + 3] ^ s3;\n        // Full 128 bit counter with wrap around\n        let carry = 1;\n        for (let i = ctr.length - 1; i >= 0; i--) {\n            carry = (carry + (ctr[i] & 0xff)) | 0;\n            ctr[i] = carry & 0xff;\n            carry >>>= 8;\n        }\n        ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n    }\n    // leftovers (less than block)\n    // It's possible to handle > u32 fast, but is it worth it?\n    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n    if (start < srcLen) {\n        const b32 = new Uint32Array([s0, s1, s2, s3]);\n        const buf = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u8)(b32);\n        for (let i = start, pos = 0; i < srcLen; i++, pos++)\n            dst[i] = src[i] ^ buf[pos];\n    }\n    return dst;\n}\n// AES CTR with overflowing 32 bit counter\n// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n// But, we need both, and perf bottleneck is in ghash anyway.\nfunction ctr32(xk, isLE, nonce, src, dst) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(nonce, BLOCK_SIZE);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(src);\n    dst = getDst(src.length, dst);\n    const ctr = nonce; // write new value to nonce, so it can be re-used\n    const c32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(ctr);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(ctr);\n    const src32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(src);\n    const dst32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(dst);\n    const ctrPos = isLE ? 0 : 12;\n    const srcLen = src.length;\n    // Fill block (empty, ctr=0)\n    let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n    // process blocks\n    for (let i = 0; i + 4 <= src32.length; i += 4) {\n        dst32[i + 0] = src32[i + 0] ^ s0;\n        dst32[i + 1] = src32[i + 1] ^ s1;\n        dst32[i + 2] = src32[i + 2] ^ s2;\n        dst32[i + 3] = src32[i + 3] ^ s3;\n        ctrNum = (ctrNum + 1) >>> 0; // u32 wrap\n        view.setUint32(ctrPos, ctrNum, isLE);\n        ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n    }\n    // leftovers (less than a block)\n    const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n    if (start < srcLen) {\n        const b32 = new Uint32Array([s0, s1, s2, s3]);\n        const buf = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u8)(b32);\n        for (let i = start, pos = 0; i < srcLen; i++, pos++)\n            dst[i] = src[i] ^ buf[pos];\n    }\n    return dst;\n}\n/**\n * CTR: counter mode. Creates stream cipher.\n * Requires good IV. Parallelizable. OK, but no MAC.\n */\nconst ctr = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function ctr(key, nonce) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(key);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(nonce, BLOCK_SIZE);\n    function processCtr(buf, dst) {\n        const xk = expandKeyLE(key);\n        const n = nonce.slice();\n        const out = ctrCounter(xk, n, buf, dst);\n        xk.fill(0);\n        n.fill(0);\n        return out;\n    }\n    return {\n        encrypt: (plaintext, dst) => processCtr(plaintext, dst),\n        decrypt: (ciphertext, dst) => processCtr(ciphertext, dst),\n    };\n});\nfunction validateBlockDecrypt(data) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    if (data.length % BLOCK_SIZE !== 0) {\n        throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE}`);\n    }\n}\nfunction validateBlockEncrypt(plaintext, pcks5, dst) {\n    let outLen = plaintext.length;\n    const remaining = outLen % BLOCK_SIZE;\n    if (!pcks5 && remaining !== 0)\n        throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n    const b = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(plaintext);\n    if (pcks5) {\n        let left = BLOCK_SIZE - remaining;\n        if (!left)\n            left = BLOCK_SIZE; // if no bytes left, create empty padding block\n        outLen = outLen + left;\n    }\n    const out = getDst(outLen, dst);\n    const o = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(out);\n    return { b, o, out };\n}\nfunction validatePCKS(data, pcks5) {\n    if (!pcks5)\n        return data;\n    const len = data.length;\n    if (!len)\n        throw new Error(`aes/pcks5: empty ciphertext not allowed`);\n    const lastByte = data[len - 1];\n    if (lastByte <= 0 || lastByte > 16)\n        throw new Error(`aes/pcks5: wrong padding byte: ${lastByte}`);\n    const out = data.subarray(0, -lastByte);\n    for (let i = 0; i < lastByte; i++)\n        if (data[len - i - 1] !== lastByte)\n            throw new Error(`aes/pcks5: wrong padding`);\n    return out;\n}\nfunction padPCKS(left) {\n    const tmp = new Uint8Array(16);\n    const tmp32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(tmp);\n    tmp.set(left);\n    const paddingByte = BLOCK_SIZE - left.length;\n    for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++)\n        tmp[i] = paddingByte;\n    return tmp32;\n}\n/**\n * ECB: Electronic CodeBook. Simple deterministic replacement.\n * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n */\nconst ecb = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapCipher)({ blockSize: 16 }, function ecb(key, opts = {}) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(key);\n    const pcks5 = !opts.disablePadding;\n    return {\n        encrypt: (plaintext, dst) => {\n            (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(plaintext);\n            const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n            const xk = expandKeyLE(key);\n            let i = 0;\n            for (; i + 4 <= b.length;) {\n                const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            if (pcks5) {\n                const tmp32 = padPCKS(plaintext.subarray(i * 4));\n                const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return _out;\n        },\n        decrypt: (ciphertext, dst) => {\n            validateBlockDecrypt(ciphertext);\n            const xk = expandKeyDecLE(key);\n            const out = getDst(ciphertext.length, dst);\n            const b = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(ciphertext);\n            const o = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(out);\n            for (let i = 0; i + 4 <= b.length;) {\n                const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return validatePCKS(out, pcks5);\n        },\n    };\n});\n/**\n * CBC: Cipher-Block-Chaining. Key is previous round’s block.\n * Fragile: needs proper padding. Unauthenticated: needs MAC.\n */\nconst cbc = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function cbc(key, iv, opts = {}) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(key);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(iv, 16);\n    const pcks5 = !opts.disablePadding;\n    return {\n        encrypt: (plaintext, dst) => {\n            const xk = expandKeyLE(key);\n            const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n            const n32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(iv);\n            // prettier-ignore\n            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n            let i = 0;\n            for (; i + 4 <= b.length;) {\n                (s0 ^= b[i + 0]), (s1 ^= b[i + 1]), (s2 ^= b[i + 2]), (s3 ^= b[i + 3]);\n                ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            if (pcks5) {\n                const tmp32 = padPCKS(plaintext.subarray(i * 4));\n                (s0 ^= tmp32[0]), (s1 ^= tmp32[1]), (s2 ^= tmp32[2]), (s3 ^= tmp32[3]);\n                ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n                (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n            }\n            xk.fill(0);\n            return _out;\n        },\n        decrypt: (ciphertext, dst) => {\n            validateBlockDecrypt(ciphertext);\n            const xk = expandKeyDecLE(key);\n            const n32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(iv);\n            const out = getDst(ciphertext.length, dst);\n            const b = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(ciphertext);\n            const o = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(out);\n            // prettier-ignore\n            let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n            for (let i = 0; i + 4 <= b.length;) {\n                // prettier-ignore\n                const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;\n                (s0 = b[i + 0]), (s1 = b[i + 1]), (s2 = b[i + 2]), (s3 = b[i + 3]);\n                const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);\n                (o[i++] = o0 ^ ps0), (o[i++] = o1 ^ ps1), (o[i++] = o2 ^ ps2), (o[i++] = o3 ^ ps3);\n            }\n            xk.fill(0);\n            return validatePCKS(out, pcks5);\n        },\n    };\n});\n/**\n * CFB: Cipher Feedback Mode. The input for the block cipher is the previous cipher output.\n * Unauthenticated: needs MAC.\n */\nconst cfb = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapCipher)({ blockSize: 16, nonceLength: 16 }, function cfb(key, iv) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(key);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(iv, 16);\n    function processCfb(src, isEncrypt, dst) {\n        const xk = expandKeyLE(key);\n        const srcLen = src.length;\n        dst = getDst(srcLen, dst);\n        const src32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(src);\n        const dst32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(dst);\n        const next32 = isEncrypt ? dst32 : src32;\n        const n32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(iv);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        for (let i = 0; i + 4 <= src32.length;) {\n            const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt(xk, s0, s1, s2, s3);\n            dst32[i + 0] = src32[i + 0] ^ e0;\n            dst32[i + 1] = src32[i + 1] ^ e1;\n            dst32[i + 2] = src32[i + 2] ^ e2;\n            dst32[i + 3] = src32[i + 3] ^ e3;\n            (s0 = next32[i++]), (s1 = next32[i++]), (s2 = next32[i++]), (s3 = next32[i++]);\n        }\n        // leftovers (less than block)\n        const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n        if (start < srcLen) {\n            ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n            const buf = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u8)(new Uint32Array([s0, s1, s2, s3]));\n            for (let i = start, pos = 0; i < srcLen; i++, pos++)\n                dst[i] = src[i] ^ buf[pos];\n            buf.fill(0);\n        }\n        xk.fill(0);\n        return dst;\n    }\n    return {\n        encrypt: (plaintext, dst) => processCfb(plaintext, true, dst),\n        decrypt: (ciphertext, dst) => processCfb(ciphertext, false, dst),\n    };\n});\n// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\nfunction computeTag(fn, isLE, key, data, AAD) {\n    const h = fn.create(key, data.length + (AAD?.length || 0));\n    if (AAD)\n        h.update(AAD);\n    h.update(data);\n    const num = new Uint8Array(16);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(num);\n    if (AAD)\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.setBigUint64)(view, 0, BigInt(AAD.length * 8), isLE);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.setBigUint64)(view, 8, BigInt(data.length * 8), isLE);\n    h.update(num);\n    return h.digest();\n}\n/**\n * GCM: Galois/Counter Mode.\n * Good, modern version of CTR, parallel, with MAC.\n * Be careful: MACs can be forged.\n */\nconst gcm = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function gcm(key, nonce, AAD) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(nonce);\n    // Nonce can be pretty much anything (even 1 byte). But smaller nonces less secure.\n    if (nonce.length === 0)\n        throw new Error('aes/gcm: empty nonce');\n    const tagLength = 16;\n    function _computeTag(authKey, tagMask, data) {\n        const tag = computeTag(_polyval_js__WEBPACK_IMPORTED_MODULE_2__.ghash, false, authKey, data, AAD);\n        for (let i = 0; i < tagMask.length; i++)\n            tag[i] ^= tagMask[i];\n        return tag;\n    }\n    function deriveKeys() {\n        const xk = expandKeyLE(key);\n        const authKey = EMPTY_BLOCK.slice();\n        const counter = EMPTY_BLOCK.slice();\n        ctr32(xk, false, counter, counter, authKey);\n        if (nonce.length === 12) {\n            counter.set(nonce);\n        }\n        else {\n            // Spec (NIST 800-38d) supports variable size nonce.\n            // Not supported for now, but can be useful.\n            const nonceLen = EMPTY_BLOCK.slice();\n            const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(nonceLen);\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.setBigUint64)(view, 8, BigInt(nonce.length * 8), false);\n            // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n            _polyval_js__WEBPACK_IMPORTED_MODULE_2__.ghash.create(authKey).update(nonce).update(nonceLen).digestInto(counter);\n        }\n        const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);\n        return { xk, authKey, counter, tagMask };\n    }\n    return {\n        encrypt: (plaintext) => {\n            (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(plaintext);\n            const { xk, authKey, counter, tagMask } = deriveKeys();\n            const out = new Uint8Array(plaintext.length + tagLength);\n            ctr32(xk, false, counter, plaintext, out);\n            const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n            out.set(tag, plaintext.length);\n            xk.fill(0);\n            return out;\n        },\n        decrypt: (ciphertext) => {\n            (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(ciphertext);\n            if (ciphertext.length < tagLength)\n                throw new Error(`aes/gcm: ciphertext less than tagLen (${tagLength})`);\n            const { xk, authKey, counter, tagMask } = deriveKeys();\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = _computeTag(authKey, tagMask, data);\n            if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.equalBytes)(tag, passedTag))\n                throw new Error('aes/gcm: invalid ghash tag');\n            const out = ctr32(xk, false, counter, data);\n            authKey.fill(0);\n            tagMask.fill(0);\n            xk.fill(0);\n            return out;\n        },\n    };\n});\nconst limit = (name, min, max) => (value) => {\n    if (!Number.isSafeInteger(value) || min > value || value > max)\n        throw new Error(`${name}: invalid value=${value}, must be [${min}..${max}]`);\n};\n/**\n * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n * Guarantees that, when a nonce is repeated, the only security loss is that identical\n * plaintexts will produce identical ciphertexts.\n * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n */\nconst siv = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapCipher)({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function siv(key, nonce, AAD) {\n    const tagLength = 16;\n    // From RFC 8452: Section 6\n    const AAD_LIMIT = limit('AAD', 0, 2 ** 36);\n    const PLAIN_LIMIT = limit('plaintext', 0, 2 ** 36);\n    const NONCE_LIMIT = limit('nonce', 12, 12);\n    const CIPHER_LIMIT = limit('ciphertext', 16, 2 ** 36 + 16);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(nonce);\n    NONCE_LIMIT(nonce.length);\n    if (AAD) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(AAD);\n        AAD_LIMIT(AAD.length);\n    }\n    function deriveKeys() {\n        const len = key.length;\n        if (len !== 16 && len !== 24 && len !== 32)\n            throw new Error(`key length must be 16, 24 or 32 bytes, got: ${len} bytes`);\n        const xk = expandKeyLE(key);\n        const encKey = new Uint8Array(len);\n        const authKey = new Uint8Array(16);\n        const n32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(nonce);\n        // prettier-ignore\n        let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];\n        let counter = 0;\n        for (const derivedKey of [authKey, encKey].map(_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)) {\n            const d32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(derivedKey);\n            for (let i = 0; i < d32.length; i += 2) {\n                // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n                const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);\n                d32[i + 0] = o0;\n                d32[i + 1] = o1;\n                s0 = ++counter; // increment counter inside state\n            }\n        }\n        xk.fill(0);\n        return { authKey, encKey: expandKeyLE(encKey) };\n    }\n    function _computeTag(encKey, authKey, data) {\n        const tag = computeTag(_polyval_js__WEBPACK_IMPORTED_MODULE_2__.polyval, true, authKey, data, AAD);\n        // Compute the expected tag by XORing S_s and the nonce, clearing the\n        // most significant bit of the last byte and encrypting with the\n        // message-encryption key.\n        for (let i = 0; i < 12; i++)\n            tag[i] ^= nonce[i];\n        tag[15] &= 0x7f; // Clear the highest bit\n        // encrypt tag as block\n        const t32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(tag);\n        // prettier-ignore\n        let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];\n        ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));\n        (t32[0] = s0), (t32[1] = s1), (t32[2] = s2), (t32[3] = s3);\n        return tag;\n    }\n    // actual decrypt/encrypt of message.\n    function processSiv(encKey, tag, input) {\n        let block = tag.slice();\n        block[15] |= 0x80; // Force highest bit\n        return ctr32(encKey, true, block, input);\n    }\n    return {\n        encrypt: (plaintext) => {\n            (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(plaintext);\n            PLAIN_LIMIT(plaintext.length);\n            const { encKey, authKey } = deriveKeys();\n            const tag = _computeTag(encKey, authKey, plaintext);\n            const out = new Uint8Array(plaintext.length + tagLength);\n            out.set(tag, plaintext.length);\n            out.set(processSiv(encKey, tag, plaintext));\n            encKey.fill(0);\n            authKey.fill(0);\n            return out;\n        },\n        decrypt: (ciphertext) => {\n            (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(ciphertext);\n            CIPHER_LIMIT(ciphertext.length);\n            const tag = ciphertext.subarray(-tagLength);\n            const { encKey, authKey } = deriveKeys();\n            const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n            const expectedTag = _computeTag(encKey, authKey, plaintext);\n            encKey.fill(0);\n            authKey.fill(0);\n            if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.equalBytes)(tag, expectedTag))\n                throw new Error('invalid polyval tag');\n            return plaintext;\n        },\n    };\n});\nfunction isBytes32(a) {\n    return (a != null &&\n        typeof a === 'object' &&\n        (a instanceof Uint32Array || a.constructor.name === 'Uint32Array'));\n}\nfunction encryptBlock(xk, block) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(block, 16);\n    if (!isBytes32(xk))\n        throw new Error('_encryptBlock accepts result of expandKeyLE');\n    const b32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(block);\n    let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n    (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n    return block;\n}\nfunction decryptBlock(xk, block) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(block, 16);\n    if (!isBytes32(xk))\n        throw new Error('_decryptBlock accepts result of expandKeyLE');\n    const b32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(block);\n    let { s0, s1, s2, s3 } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n    (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n    return block;\n}\n// Highly unsafe private functions for implementing new modes or ciphers based on AES\n// Can change at any time, no API guarantees\nconst unsafe = {\n    expandKeyLE,\n    expandKeyDecLE,\n    encrypt,\n    decrypt,\n    encryptBlock,\n    decryptBlock,\n    ctrCounter,\n    ctr32,\n};\n//# sourceMappingURL=aes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2VzbS9hZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0Y7QUFDekM7QUFDQTtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsNkJBQTZCO0FBQzdCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBLENBQUM7QUFDTTtBQUNQLElBQUksaURBQU07QUFDVjtBQUNBO0FBQ0EsNkVBQTZFLElBQUk7QUFDakYsWUFBWSxRQUFRO0FBQ3BCLGdCQUFnQiw4Q0FBRztBQUNuQjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtB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QUNBLElBQUksaURBQU07QUFDVjtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUFHO0FBQ25CLFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2VzbS9hZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcHJldHRpZXItaWdub3JlXG5pbXBvcnQgeyB3cmFwQ2lwaGVyLCBjcmVhdGVWaWV3LCBzZXRCaWdVaW50NjQsIGVxdWFsQnl0ZXMsIHUzMiwgdTgsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBnaGFzaCwgcG9seXZhbCB9IGZyb20gJy4vX3BvbHl2YWwuanMnO1xuaW1wb3J0IHsgYnl0ZXMgYXMgYWJ5dGVzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbi8qXG5BRVMgKEFkdmFuY2VkIEVuY3J5cHRpb24gU3RhbmRhcmQpIGFrYSBSaWpuZGFlbCBibG9jayBjaXBoZXIuXG5cbkRhdGEgaXMgc3BsaXQgaW50byAxMjgtYml0IGJsb2Nrcy4gRW5jcnlwdGVkIGluIDEwLzEyLzE0IHJvdW5kcyAoMTI4LzE5Mi8yNTYgYml0cykuIEluIGV2ZXJ5IHJvdW5kOlxuMS4gKipTLWJveCoqLCB0YWJsZSBzdWJzdGl0dXRpb25cbjIuICoqU2hpZnQgcm93cyoqLCBjeWNsaWMgc2hpZnQgbGVmdCBvZiBhbGwgcm93cyBvZiBkYXRhIGFycmF5XG4zLiAqKk1peCBjb2x1bW5zKiosIG11bHRpcGx5aW5nIGV2ZXJ5IGNvbHVtbiBieSBmaXhlZCBwb2x5bm9taWFsXG40LiAqKkFkZCByb3VuZCBrZXkqKiwgcm91bmRfa2V5IHhvciBpLXRoIGNvbHVtbiBvZiBhcnJheVxuXG5SZXNvdXJjZXM6XG4tIEZJUFMtMTk3IGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9maWxlcy9wdWJzL2ZpcHMvMTk3L2ZpbmFsL2RvY3MvZmlwcy0xOTcucGRmXG4tIE9yaWdpbmFsIHByb3Bvc2FsOiBodHRwczovL2NzcmMubmlzdC5nb3YvY3NyYy9tZWRpYS9wcm9qZWN0cy9jcnlwdG9ncmFwaGljLXN0YW5kYXJkcy1hbmQtZ3VpZGVsaW5lcy9kb2N1bWVudHMvYWVzLWRldmVsb3BtZW50L3Jpam5kYWVsLWFtbWVuZGVkLnBkZlxuKi9cbmNvbnN0IEJMT0NLX1NJWkUgPSAxNjtcbmNvbnN0IEJMT0NLX1NJWkUzMiA9IDQ7XG5jb25zdCBFTVBUWV9CTE9DSyA9IG5ldyBVaW50OEFycmF5KEJMT0NLX1NJWkUpO1xuY29uc3QgUE9MWSA9IDB4MTFiOyAvLyAxICsgeCArIHgqKjMgKyB4Kio0ICsgeCoqOFxuLy8gVE9ETzogcmVtb3ZlIG11bHRpcGxpY2F0aW9uLCBiaW5hcnkgb3BzIG9ubHlcbmZ1bmN0aW9uIG11bDIobikge1xuICAgIHJldHVybiAobiA8PCAxKSBeIChQT0xZICYgLShuID4+IDcpKTtcbn1cbmZ1bmN0aW9uIG11bChhLCBiKSB7XG4gICAgbGV0IHJlcyA9IDA7XG4gICAgZm9yICg7IGIgPiAwOyBiID4+PSAxKSB7XG4gICAgICAgIC8vIE1vbnRnb21lcnkgbGFkZGVyXG4gICAgICAgIHJlcyBePSBhICYgLShiICYgMSk7IC8vIGlmIChiJjEpIHJlcyBePWEgKGJ1dCBjb25zdC10aW1lKS5cbiAgICAgICAgYSA9IG11bDIoYSk7IC8vIGEgPSAyKmFcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEFFUyBTLWJveCBpcyBnZW5lcmF0ZWQgdXNpbmcgZmluaXRlIGZpZWxkIGludmVyc2lvbixcbi8vIGFuIGFmZmluZSB0cmFuc2Zvcm0sIGFuZCB4b3Igb2YgYSBjb25zdGFudCAweDYzLlxuY29uc3Qgc2JveCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIGxldCB0ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMCwgeCA9IDE7IGkgPCAyNTY7IGkrKywgeCBePSBtdWwyKHgpKVxuICAgICAgICB0W2ldID0geDtcbiAgICBjb25zdCBib3ggPSBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgIGJveFswXSA9IDB4NjM7IC8vIGZpcnN0IGVsbVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU1OyBpKyspIHtcbiAgICAgICAgbGV0IHggPSB0WzI1NSAtIGldO1xuICAgICAgICB4IHw9IHggPDwgODtcbiAgICAgICAgYm94W3RbaV1dID0gKHggXiAoeCA+PiA0KSBeICh4ID4+IDUpIF4gKHggPj4gNikgXiAoeCA+PiA3KSBeIDB4NjMpICYgMHhmZjtcbiAgICB9XG4gICAgcmV0dXJuIGJveDtcbn0pKCk7XG4vLyBJbnZlcnRlZCBTLWJveFxuY29uc3QgaW52U2JveCA9IC8qIEBfX1BVUkVfXyAqLyBzYm94Lm1hcCgoXywgaikgPT4gc2JveC5pbmRleE9mKGopKTtcbi8vIFJvdGF0ZSB1MzIgYnkgOFxuY29uc3Qgcm90cjMyXzggPSAobikgPT4gKG4gPDwgMjQpIHwgKG4gPj4+IDgpO1xuY29uc3Qgcm90bDMyXzggPSAobikgPT4gKG4gPDwgOCkgfCAobiA+Pj4gMjQpO1xuLy8gVC10YWJsZSBpcyBvcHRpbWl6YXRpb24gc3VnZ2VzdGVkIGluIDUuMiBvZiBvcmlnaW5hbCBwcm9wb3NhbCAobWlzc2VkIGZyb20gRklQUy0xOTcpLiBDaGFuZ2VzOlxuLy8gLSBMRSBpbnN0ZWFkIG9mIEJFXG4vLyAtIGJpZ2dlciB0YWJsZXM6IFQwIGFuZCBUMSBhcmUgbWVyZ2VkIGludG8gVDAxIHRhYmxlIGFuZCBUMiAmIFQzIGludG8gVDIzO1xuLy8gICBzbyBpbmRleCBpcyB1MTYsIGluc3RlYWQgb2YgdTguIFRoaXMgc3BlZWRzIHVwIHRoaW5ncywgdW5leHBlY3RlZGx5XG5mdW5jdGlvbiBnZW5UdGFibGUoc2JveCwgZm4pIHtcbiAgICBpZiAoc2JveC5sZW5ndGggIT09IDI1NilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBzYm94IGxlbmd0aCcpO1xuICAgIGNvbnN0IFQwID0gbmV3IFVpbnQzMkFycmF5KDI1NikubWFwKChfLCBqKSA9PiBmbihzYm94W2pdKSk7XG4gICAgY29uc3QgVDEgPSBUMC5tYXAocm90bDMyXzgpO1xuICAgIGNvbnN0IFQyID0gVDEubWFwKHJvdGwzMl84KTtcbiAgICBjb25zdCBUMyA9IFQyLm1hcChyb3RsMzJfOCk7XG4gICAgY29uc3QgVDAxID0gbmV3IFVpbnQzMkFycmF5KDI1NiAqIDI1Nik7XG4gICAgY29uc3QgVDIzID0gbmV3IFVpbnQzMkFycmF5KDI1NiAqIDI1Nik7XG4gICAgY29uc3Qgc2JveDIgPSBuZXcgVWludDE2QXJyYXkoMjU2ICogMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjU2OyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGkgKiAyNTYgKyBqO1xuICAgICAgICAgICAgVDAxW2lkeF0gPSBUMFtpXSBeIFQxW2pdO1xuICAgICAgICAgICAgVDIzW2lkeF0gPSBUMltpXSBeIFQzW2pdO1xuICAgICAgICAgICAgc2JveDJbaWR4XSA9IChzYm94W2ldIDw8IDgpIHwgc2JveFtqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzYm94LCBzYm94MiwgVDAsIFQxLCBUMiwgVDMsIFQwMSwgVDIzIH07XG59XG5jb25zdCB0YWJsZUVuY29kaW5nID0gLyogQF9fUFVSRV9fICovIGdlblR0YWJsZShzYm94LCAocykgPT4gKG11bChzLCAzKSA8PCAyNCkgfCAocyA8PCAxNikgfCAocyA8PCA4KSB8IG11bChzLCAyKSk7XG5jb25zdCB0YWJsZURlY29kaW5nID0gLyogQF9fUFVSRV9fICovIGdlblR0YWJsZShpbnZTYm94LCAocykgPT4gKG11bChzLCAxMSkgPDwgMjQpIHwgKG11bChzLCAxMykgPDwgMTYpIHwgKG11bChzLCA5KSA8PCA4KSB8IG11bChzLCAxNCkpO1xuY29uc3QgeFBvd2VycyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIGNvbnN0IHAgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgZm9yIChsZXQgaSA9IDAsIHggPSAxOyBpIDwgMTY7IGkrKywgeCA9IG11bDIoeCkpXG4gICAgICAgIHBbaV0gPSB4O1xuICAgIHJldHVybiBwO1xufSkoKTtcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRLZXlMRShrZXkpIHtcbiAgICBhYnl0ZXMoa2V5KTtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGlmICghWzE2LCAyNCwgMzJdLmluY2x1ZGVzKGxlbikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYWVzOiB3cm9uZyBrZXkgc2l6ZTogc2hvdWxkIGJlIDE2LCAyNCBvciAzMiwgZ290OiAke2xlbn1gKTtcbiAgICBjb25zdCB7IHNib3gyIH0gPSB0YWJsZUVuY29kaW5nO1xuICAgIGNvbnN0IGszMiA9IHUzMihrZXkpO1xuICAgIGNvbnN0IE5rID0gazMyLmxlbmd0aDtcbiAgICBjb25zdCBzdWJCeXRlID0gKG4pID0+IGFwcGx5U2JveChzYm94Miwgbiwgbiwgbiwgbik7XG4gICAgY29uc3QgeGsgPSBuZXcgVWludDMyQXJyYXkobGVuICsgMjgpOyAvLyBleHBhbmRlZCBrZXlcbiAgICB4ay5zZXQoazMyKTtcbiAgICAvLyA0LjMuMSBLZXkgZXhwYW5zaW9uXG4gICAgZm9yIChsZXQgaSA9IE5rOyBpIDwgeGsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHQgPSB4a1tpIC0gMV07XG4gICAgICAgIGlmIChpICUgTmsgPT09IDApXG4gICAgICAgICAgICB0ID0gc3ViQnl0ZShyb3RyMzJfOCh0KSkgXiB4UG93ZXJzW2kgLyBOayAtIDFdO1xuICAgICAgICBlbHNlIGlmIChOayA+IDYgJiYgaSAlIE5rID09PSA0KVxuICAgICAgICAgICAgdCA9IHN1YkJ5dGUodCk7XG4gICAgICAgIHhrW2ldID0geGtbaSAtIE5rXSBeIHQ7XG4gICAgfVxuICAgIHJldHVybiB4aztcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRLZXlEZWNMRShrZXkpIHtcbiAgICBjb25zdCBlbmNLZXkgPSBleHBhbmRLZXlMRShrZXkpO1xuICAgIGNvbnN0IHhrID0gZW5jS2V5LnNsaWNlKCk7XG4gICAgY29uc3QgTmsgPSBlbmNLZXkubGVuZ3RoO1xuICAgIGNvbnN0IHsgc2JveDIgfSA9IHRhYmxlRW5jb2Rpbmc7XG4gICAgY29uc3QgeyBUMCwgVDEsIFQyLCBUMyB9ID0gdGFibGVEZWNvZGluZztcbiAgICAvLyBJbnZlcnNlIGtleSBieSBjaHVua3Mgb2YgNCAocm91bmRzKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTms7IGkgKz0gNCkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgICAgICAgIHhrW2kgKyBqXSA9IGVuY0tleVtOayAtIGkgLSA0ICsgal07XG4gICAgfVxuICAgIGVuY0tleS5maWxsKDApO1xuICAgIC8vIGFwcGx5IEludk1peENvbHVtbiBleGNlcHQgZmlyc3QgJiBsYXN0IHJvdW5kXG4gICAgZm9yIChsZXQgaSA9IDQ7IGkgPCBOayAtIDQ7IGkrKykge1xuICAgICAgICBjb25zdCB4ID0geGtbaV07XG4gICAgICAgIGNvbnN0IHcgPSBhcHBseVNib3goc2JveDIsIHgsIHgsIHgsIHgpO1xuICAgICAgICB4a1tpXSA9IFQwW3cgJiAweGZmXSBeIFQxWyh3ID4+PiA4KSAmIDB4ZmZdIF4gVDJbKHcgPj4+IDE2KSAmIDB4ZmZdIF4gVDNbdyA+Pj4gMjRdO1xuICAgIH1cbiAgICByZXR1cm4geGs7XG59XG4vLyBBcHBseSB0YWJsZXNcbmZ1bmN0aW9uIGFwcGx5MDEyMyhUMDEsIFQyMywgczAsIHMxLCBzMiwgczMpIHtcbiAgICByZXR1cm4gKFQwMVsoKHMwIDw8IDgpICYgMHhmZjAwKSB8ICgoczEgPj4+IDgpICYgMHhmZildIF5cbiAgICAgICAgVDIzWygoczIgPj4+IDgpICYgMHhmZjAwKSB8ICgoczMgPj4+IDI0KSAmIDB4ZmYpXSk7XG59XG5mdW5jdGlvbiBhcHBseVNib3goc2JveDIsIHMwLCBzMSwgczIsIHMzKSB7XG4gICAgcmV0dXJuIChzYm94MlsoczAgJiAweGZmKSB8IChzMSAmIDB4ZmYwMCldIHxcbiAgICAgICAgKHNib3gyWygoczIgPj4+IDE2KSAmIDB4ZmYpIHwgKChzMyA+Pj4gMTYpICYgMHhmZjAwKV0gPDwgMTYpKTtcbn1cbmZ1bmN0aW9uIGVuY3J5cHQoeGssIHMwLCBzMSwgczIsIHMzKSB7XG4gICAgY29uc3QgeyBzYm94MiwgVDAxLCBUMjMgfSA9IHRhYmxlRW5jb2Rpbmc7XG4gICAgbGV0IGsgPSAwO1xuICAgIChzMCBePSB4a1trKytdKSwgKHMxIF49IHhrW2srK10pLCAoczIgXj0geGtbaysrXSksIChzMyBePSB4a1trKytdKTtcbiAgICBjb25zdCByb3VuZHMgPSB4ay5sZW5ndGggLyA0IC0gMjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdW5kczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHQwID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczAsIHMxLCBzMiwgczMpO1xuICAgICAgICBjb25zdCB0MSA9IHhrW2srK10gXiBhcHBseTAxMjMoVDAxLCBUMjMsIHMxLCBzMiwgczMsIHMwKTtcbiAgICAgICAgY29uc3QgdDIgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMiwgczMsIHMwLCBzMSk7XG4gICAgICAgIGNvbnN0IHQzID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczMsIHMwLCBzMSwgczIpO1xuICAgICAgICAoczAgPSB0MCksIChzMSA9IHQxKSwgKHMyID0gdDIpLCAoczMgPSB0Myk7XG4gICAgfVxuICAgIC8vIGxhc3Qgcm91bmQgKHdpdGhvdXQgbWl4Y29sdW1ucywgc28gdXNpbmcgU0JPWDIgdGFibGUpXG4gICAgY29uc3QgdDAgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMCwgczEsIHMyLCBzMyk7XG4gICAgY29uc3QgdDEgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMSwgczIsIHMzLCBzMCk7XG4gICAgY29uc3QgdDIgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMiwgczMsIHMwLCBzMSk7XG4gICAgY29uc3QgdDMgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMywgczAsIHMxLCBzMik7XG4gICAgcmV0dXJuIHsgczA6IHQwLCBzMTogdDEsIHMyOiB0MiwgczM6IHQzIH07XG59XG5mdW5jdGlvbiBkZWNyeXB0KHhrLCBzMCwgczEsIHMyLCBzMykge1xuICAgIGNvbnN0IHsgc2JveDIsIFQwMSwgVDIzIH0gPSB0YWJsZURlY29kaW5nO1xuICAgIGxldCBrID0gMDtcbiAgICAoczAgXj0geGtbaysrXSksIChzMSBePSB4a1trKytdKSwgKHMyIF49IHhrW2srK10pLCAoczMgXj0geGtbaysrXSk7XG4gICAgY29uc3Qgcm91bmRzID0geGsubGVuZ3RoIC8gNCAtIDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3VuZHM7IGkrKykge1xuICAgICAgICBjb25zdCB0MCA9IHhrW2srK10gXiBhcHBseTAxMjMoVDAxLCBUMjMsIHMwLCBzMywgczIsIHMxKTtcbiAgICAgICAgY29uc3QgdDEgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMSwgczAsIHMzLCBzMik7XG4gICAgICAgIGNvbnN0IHQyID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczIsIHMxLCBzMCwgczMpO1xuICAgICAgICBjb25zdCB0MyA9IHhrW2srK10gXiBhcHBseTAxMjMoVDAxLCBUMjMsIHMzLCBzMiwgczEsIHMwKTtcbiAgICAgICAgKHMwID0gdDApLCAoczEgPSB0MSksIChzMiA9IHQyKSwgKHMzID0gdDMpO1xuICAgIH1cbiAgICAvLyBMYXN0IHJvdW5kXG4gICAgY29uc3QgdDAgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMCwgczMsIHMyLCBzMSk7XG4gICAgY29uc3QgdDEgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMSwgczAsIHMzLCBzMik7XG4gICAgY29uc3QgdDIgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMiwgczEsIHMwLCBzMyk7XG4gICAgY29uc3QgdDMgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMywgczIsIHMxLCBzMCk7XG4gICAgcmV0dXJuIHsgczA6IHQwLCBzMTogdDEsIHMyOiB0MiwgczM6IHQzIH07XG59XG5mdW5jdGlvbiBnZXREc3QobGVuLCBkc3QpIHtcbiAgICBpZiAoIWRzdClcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgYWJ5dGVzKGRzdCk7XG4gICAgaWYgKGRzdC5sZW5ndGggPCBsZW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYWVzOiB3cm9uZyBkZXN0aW5hdGlvbiBsZW5ndGgsIGV4cGVjdGVkIGF0IGxlYXN0ICR7bGVufSwgZ290OiAke2RzdC5sZW5ndGh9YCk7XG4gICAgcmV0dXJuIGRzdDtcbn1cbi8vIFRPRE86IGludmVzdGlnYXRlIG1lcmdpbmcgd2l0aCBjdHIzMlxuZnVuY3Rpb24gY3RyQ291bnRlcih4aywgbm9uY2UsIHNyYywgZHN0KSB7XG4gICAgYWJ5dGVzKG5vbmNlLCBCTE9DS19TSVpFKTtcbiAgICBhYnl0ZXMoc3JjKTtcbiAgICBjb25zdCBzcmNMZW4gPSBzcmMubGVuZ3RoO1xuICAgIGRzdCA9IGdldERzdChzcmNMZW4sIGRzdCk7XG4gICAgY29uc3QgY3RyID0gbm9uY2U7XG4gICAgY29uc3QgYzMyID0gdTMyKGN0cik7XG4gICAgLy8gRmlsbCBibG9jayAoZW1wdHksIGN0cj0wKVxuICAgIGxldCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBjMzJbMF0sIGMzMlsxXSwgYzMyWzJdLCBjMzJbM10pO1xuICAgIGNvbnN0IHNyYzMyID0gdTMyKHNyYyk7XG4gICAgY29uc3QgZHN0MzIgPSB1MzIoZHN0KTtcbiAgICAvLyBwcm9jZXNzIGJsb2Nrc1xuICAgIGZvciAobGV0IGkgPSAwOyBpICsgNCA8PSBzcmMzMi5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBkc3QzMltpICsgMF0gPSBzcmMzMltpICsgMF0gXiBzMDtcbiAgICAgICAgZHN0MzJbaSArIDFdID0gc3JjMzJbaSArIDFdIF4gczE7XG4gICAgICAgIGRzdDMyW2kgKyAyXSA9IHNyYzMyW2kgKyAyXSBeIHMyO1xuICAgICAgICBkc3QzMltpICsgM10gPSBzcmMzMltpICsgM10gXiBzMztcbiAgICAgICAgLy8gRnVsbCAxMjggYml0IGNvdW50ZXIgd2l0aCB3cmFwIGFyb3VuZFxuICAgICAgICBsZXQgY2FycnkgPSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gY3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjYXJyeSA9IChjYXJyeSArIChjdHJbaV0gJiAweGZmKSkgfCAwO1xuICAgICAgICAgICAgY3RyW2ldID0gY2FycnkgJiAweGZmO1xuICAgICAgICAgICAgY2FycnkgPj4+PSA4O1xuICAgICAgICB9XG4gICAgICAgICh7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBjMzJbMF0sIGMzMlsxXSwgYzMyWzJdLCBjMzJbM10pKTtcbiAgICB9XG4gICAgLy8gbGVmdG92ZXJzIChsZXNzIHRoYW4gYmxvY2spXG4gICAgLy8gSXQncyBwb3NzaWJsZSB0byBoYW5kbGUgPiB1MzIgZmFzdCwgYnV0IGlzIGl0IHdvcnRoIGl0P1xuICAgIGNvbnN0IHN0YXJ0ID0gQkxPQ0tfU0laRSAqIE1hdGguZmxvb3Ioc3JjMzIubGVuZ3RoIC8gQkxPQ0tfU0laRTMyKTtcbiAgICBpZiAoc3RhcnQgPCBzcmNMZW4pIHtcbiAgICAgICAgY29uc3QgYjMyID0gbmV3IFVpbnQzMkFycmF5KFtzMCwgczEsIHMyLCBzM10pO1xuICAgICAgICBjb25zdCBidWYgPSB1OChiMzIpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQsIHBvcyA9IDA7IGkgPCBzcmNMZW47IGkrKywgcG9zKyspXG4gICAgICAgICAgICBkc3RbaV0gPSBzcmNbaV0gXiBidWZbcG9zXTtcbiAgICB9XG4gICAgcmV0dXJuIGRzdDtcbn1cbi8vIEFFUyBDVFIgd2l0aCBvdmVyZmxvd2luZyAzMiBiaXQgY291bnRlclxuLy8gSXQncyBwb3NzaWJsZSB0byBkbyAzMmxlIHNpZ25pZmljYW50bHkgc2ltcGxlciAoYW5kIHByb2JhYmx5IGZhc3RlcikgYnkgdXNpbmcgdTMyLlxuLy8gQnV0LCB3ZSBuZWVkIGJvdGgsIGFuZCBwZXJmIGJvdHRsZW5lY2sgaXMgaW4gZ2hhc2ggYW55d2F5LlxuZnVuY3Rpb24gY3RyMzIoeGssIGlzTEUsIG5vbmNlLCBzcmMsIGRzdCkge1xuICAgIGFieXRlcyhub25jZSwgQkxPQ0tfU0laRSk7XG4gICAgYWJ5dGVzKHNyYyk7XG4gICAgZHN0ID0gZ2V0RHN0KHNyYy5sZW5ndGgsIGRzdCk7XG4gICAgY29uc3QgY3RyID0gbm9uY2U7IC8vIHdyaXRlIG5ldyB2YWx1ZSB0byBub25jZSwgc28gaXQgY2FuIGJlIHJlLXVzZWRcbiAgICBjb25zdCBjMzIgPSB1MzIoY3RyKTtcbiAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhjdHIpO1xuICAgIGNvbnN0IHNyYzMyID0gdTMyKHNyYyk7XG4gICAgY29uc3QgZHN0MzIgPSB1MzIoZHN0KTtcbiAgICBjb25zdCBjdHJQb3MgPSBpc0xFID8gMCA6IDEyO1xuICAgIGNvbnN0IHNyY0xlbiA9IHNyYy5sZW5ndGg7XG4gICAgLy8gRmlsbCBibG9jayAoZW1wdHksIGN0cj0wKVxuICAgIGxldCBjdHJOdW0gPSB2aWV3LmdldFVpbnQzMihjdHJQb3MsIGlzTEUpOyAvLyByZWFkIGN1cnJlbnQgY291bnRlciB2YWx1ZVxuICAgIGxldCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBjMzJbMF0sIGMzMlsxXSwgYzMyWzJdLCBjMzJbM10pO1xuICAgIC8vIHByb2Nlc3MgYmxvY2tzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgKyA0IDw9IHNyYzMyLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIGRzdDMyW2kgKyAwXSA9IHNyYzMyW2kgKyAwXSBeIHMwO1xuICAgICAgICBkc3QzMltpICsgMV0gPSBzcmMzMltpICsgMV0gXiBzMTtcbiAgICAgICAgZHN0MzJbaSArIDJdID0gc3JjMzJbaSArIDJdIF4gczI7XG4gICAgICAgIGRzdDMyW2kgKyAzXSA9IHNyYzMyW2kgKyAzXSBeIHMzO1xuICAgICAgICBjdHJOdW0gPSAoY3RyTnVtICsgMSkgPj4+IDA7IC8vIHUzMiB3cmFwXG4gICAgICAgIHZpZXcuc2V0VWludDMyKGN0clBvcywgY3RyTnVtLCBpc0xFKTtcbiAgICAgICAgKHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIGMzMlswXSwgYzMyWzFdLCBjMzJbMl0sIGMzMlszXSkpO1xuICAgIH1cbiAgICAvLyBsZWZ0b3ZlcnMgKGxlc3MgdGhhbiBhIGJsb2NrKVxuICAgIGNvbnN0IHN0YXJ0ID0gQkxPQ0tfU0laRSAqIE1hdGguZmxvb3Ioc3JjMzIubGVuZ3RoIC8gQkxPQ0tfU0laRTMyKTtcbiAgICBpZiAoc3RhcnQgPCBzcmNMZW4pIHtcbiAgICAgICAgY29uc3QgYjMyID0gbmV3IFVpbnQzMkFycmF5KFtzMCwgczEsIHMyLCBzM10pO1xuICAgICAgICBjb25zdCBidWYgPSB1OChiMzIpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQsIHBvcyA9IDA7IGkgPCBzcmNMZW47IGkrKywgcG9zKyspXG4gICAgICAgICAgICBkc3RbaV0gPSBzcmNbaV0gXiBidWZbcG9zXTtcbiAgICB9XG4gICAgcmV0dXJuIGRzdDtcbn1cbi8qKlxuICogQ1RSOiBjb3VudGVyIG1vZGUuIENyZWF0ZXMgc3RyZWFtIGNpcGhlci5cbiAqIFJlcXVpcmVzIGdvb2QgSVYuIFBhcmFsbGVsaXphYmxlLiBPSywgYnV0IG5vIE1BQy5cbiAqL1xuZXhwb3J0IGNvbnN0IGN0ciA9IHdyYXBDaXBoZXIoeyBibG9ja1NpemU6IDE2LCBub25jZUxlbmd0aDogMTYgfSwgZnVuY3Rpb24gY3RyKGtleSwgbm9uY2UpIHtcbiAgICBhYnl0ZXMoa2V5KTtcbiAgICBhYnl0ZXMobm9uY2UsIEJMT0NLX1NJWkUpO1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NDdHIoYnVmLCBkc3QpIHtcbiAgICAgICAgY29uc3QgeGsgPSBleHBhbmRLZXlMRShrZXkpO1xuICAgICAgICBjb25zdCBuID0gbm9uY2Uuc2xpY2UoKTtcbiAgICAgICAgY29uc3Qgb3V0ID0gY3RyQ291bnRlcih4aywgbiwgYnVmLCBkc3QpO1xuICAgICAgICB4ay5maWxsKDApO1xuICAgICAgICBuLmZpbGwoMCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuY3J5cHQ6IChwbGFpbnRleHQsIGRzdCkgPT4gcHJvY2Vzc0N0cihwbGFpbnRleHQsIGRzdCksXG4gICAgICAgIGRlY3J5cHQ6IChjaXBoZXJ0ZXh0LCBkc3QpID0+IHByb2Nlc3NDdHIoY2lwaGVydGV4dCwgZHN0KSxcbiAgICB9O1xufSk7XG5mdW5jdGlvbiB2YWxpZGF0ZUJsb2NrRGVjcnlwdChkYXRhKSB7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIGlmIChkYXRhLmxlbmd0aCAlIEJMT0NLX1NJWkUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhZXMvKGNiYy1lY2IpLmRlY3J5cHQgY2lwaGVydGV4dCBzaG91bGQgY29uc2lzdCBvZiBibG9ja3Mgd2l0aCBzaXplICR7QkxPQ0tfU0laRX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUJsb2NrRW5jcnlwdChwbGFpbnRleHQsIHBja3M1LCBkc3QpIHtcbiAgICBsZXQgb3V0TGVuID0gcGxhaW50ZXh0Lmxlbmd0aDtcbiAgICBjb25zdCByZW1haW5pbmcgPSBvdXRMZW4gJSBCTE9DS19TSVpFO1xuICAgIGlmICghcGNrczUgJiYgcmVtYWluaW5nICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FlYy8oY2JjLWVjYik6IHVucGFkZGVkIHBsYWludGV4dCB3aXRoIGRpc2FibGVkIHBhZGRpbmcnKTtcbiAgICBjb25zdCBiID0gdTMyKHBsYWludGV4dCk7XG4gICAgaWYgKHBja3M1KSB7XG4gICAgICAgIGxldCBsZWZ0ID0gQkxPQ0tfU0laRSAtIHJlbWFpbmluZztcbiAgICAgICAgaWYgKCFsZWZ0KVxuICAgICAgICAgICAgbGVmdCA9IEJMT0NLX1NJWkU7IC8vIGlmIG5vIGJ5dGVzIGxlZnQsIGNyZWF0ZSBlbXB0eSBwYWRkaW5nIGJsb2NrXG4gICAgICAgIG91dExlbiA9IG91dExlbiArIGxlZnQ7XG4gICAgfVxuICAgIGNvbnN0IG91dCA9IGdldERzdChvdXRMZW4sIGRzdCk7XG4gICAgY29uc3QgbyA9IHUzMihvdXQpO1xuICAgIHJldHVybiB7IGIsIG8sIG91dCB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQQ0tTKGRhdGEsIHBja3M1KSB7XG4gICAgaWYgKCFwY2tzNSlcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKCFsZW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYWVzL3Bja3M1OiBlbXB0eSBjaXBoZXJ0ZXh0IG5vdCBhbGxvd2VkYCk7XG4gICAgY29uc3QgbGFzdEJ5dGUgPSBkYXRhW2xlbiAtIDFdO1xuICAgIGlmIChsYXN0Qnl0ZSA8PSAwIHx8IGxhc3RCeXRlID4gMTYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYWVzL3Bja3M1OiB3cm9uZyBwYWRkaW5nIGJ5dGU6ICR7bGFzdEJ5dGV9YCk7XG4gICAgY29uc3Qgb3V0ID0gZGF0YS5zdWJhcnJheSgwLCAtbGFzdEJ5dGUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdEJ5dGU7IGkrKylcbiAgICAgICAgaWYgKGRhdGFbbGVuIC0gaSAtIDFdICE9PSBsYXN0Qnl0ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWVzL3Bja3M1OiB3cm9uZyBwYWRkaW5nYCk7XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIHBhZFBDS1MobGVmdCkge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBjb25zdCB0bXAzMiA9IHUzMih0bXApO1xuICAgIHRtcC5zZXQobGVmdCk7XG4gICAgY29uc3QgcGFkZGluZ0J5dGUgPSBCTE9DS19TSVpFIC0gbGVmdC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IEJMT0NLX1NJWkUgLSBwYWRkaW5nQnl0ZTsgaSA8IEJMT0NLX1NJWkU7IGkrKylcbiAgICAgICAgdG1wW2ldID0gcGFkZGluZ0J5dGU7XG4gICAgcmV0dXJuIHRtcDMyO1xufVxuLyoqXG4gKiBFQ0I6IEVsZWN0cm9uaWMgQ29kZUJvb2suIFNpbXBsZSBkZXRlcm1pbmlzdGljIHJlcGxhY2VtZW50LlxuICogRGFuZ2Vyb3VzOiBhbHdheXMgbWFwIHggdG8geS4gU2VlIFtBRVMgUGVuZ3Vpbl0oaHR0cHM6Ly93b3Jkcy5maWxpcHBvLmlvL3RoZS1lY2ItcGVuZ3Vpbi8pLlxuICovXG5leHBvcnQgY29uc3QgZWNiID0gd3JhcENpcGhlcih7IGJsb2NrU2l6ZTogMTYgfSwgZnVuY3Rpb24gZWNiKGtleSwgb3B0cyA9IHt9KSB7XG4gICAgYWJ5dGVzKGtleSk7XG4gICAgY29uc3QgcGNrczUgPSAhb3B0cy5kaXNhYmxlUGFkZGluZztcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0OiAocGxhaW50ZXh0LCBkc3QpID0+IHtcbiAgICAgICAgICAgIGFieXRlcyhwbGFpbnRleHQpO1xuICAgICAgICAgICAgY29uc3QgeyBiLCBvLCBvdXQ6IF9vdXQgfSA9IHZhbGlkYXRlQmxvY2tFbmNyeXB0KHBsYWludGV4dCwgcGNrczUsIGRzdCk7XG4gICAgICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSArIDQgPD0gYi5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgYltpICsgMF0sIGJbaSArIDFdLCBiW2kgKyAyXSwgYltpICsgM10pO1xuICAgICAgICAgICAgICAgIChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGNrczUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bXAzMiA9IHBhZFBDS1MocGxhaW50ZXh0LnN1YmFycmF5KGkgKiA0KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgdG1wMzJbMF0sIHRtcDMyWzFdLCB0bXAzMlsyXSwgdG1wMzJbM10pO1xuICAgICAgICAgICAgICAgIChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ay5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuIF9vdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY3J5cHQ6IChjaXBoZXJ0ZXh0LCBkc3QpID0+IHtcbiAgICAgICAgICAgIHZhbGlkYXRlQmxvY2tEZWNyeXB0KGNpcGhlcnRleHQpO1xuICAgICAgICAgICAgY29uc3QgeGsgPSBleHBhbmRLZXlEZWNMRShrZXkpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gZ2V0RHN0KGNpcGhlcnRleHQubGVuZ3RoLCBkc3QpO1xuICAgICAgICAgICAgY29uc3QgYiA9IHUzMihjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG8gPSB1MzIob3V0KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpICsgNCA8PSBiLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHMwLCBzMSwgczIsIHMzIH0gPSBkZWNyeXB0KHhrLCBiW2kgKyAwXSwgYltpICsgMV0sIGJbaSArIDJdLCBiW2kgKyAzXSk7XG4gICAgICAgICAgICAgICAgKG9baSsrXSA9IHMwKSwgKG9baSsrXSA9IHMxKSwgKG9baSsrXSA9IHMyKSwgKG9baSsrXSA9IHMzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhrLmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVQQ0tTKG91dCwgcGNrczUpO1xuICAgICAgICB9LFxuICAgIH07XG59KTtcbi8qKlxuICogQ0JDOiBDaXBoZXItQmxvY2stQ2hhaW5pbmcuIEtleSBpcyBwcmV2aW91cyByb3VuZOKAmXMgYmxvY2suXG4gKiBGcmFnaWxlOiBuZWVkcyBwcm9wZXIgcGFkZGluZy4gVW5hdXRoZW50aWNhdGVkOiBuZWVkcyBNQUMuXG4gKi9cbmV4cG9ydCBjb25zdCBjYmMgPSB3cmFwQ2lwaGVyKHsgYmxvY2tTaXplOiAxNiwgbm9uY2VMZW5ndGg6IDE2IH0sIGZ1bmN0aW9uIGNiYyhrZXksIGl2LCBvcHRzID0ge30pIHtcbiAgICBhYnl0ZXMoa2V5KTtcbiAgICBhYnl0ZXMoaXYsIDE2KTtcbiAgICBjb25zdCBwY2tzNSA9ICFvcHRzLmRpc2FibGVQYWRkaW5nO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY3J5cHQ6IChwbGFpbnRleHQsIGRzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeGsgPSBleHBhbmRLZXlMRShrZXkpO1xuICAgICAgICAgICAgY29uc3QgeyBiLCBvLCBvdXQ6IF9vdXQgfSA9IHZhbGlkYXRlQmxvY2tFbmNyeXB0KHBsYWludGV4dCwgcGNrczUsIGRzdCk7XG4gICAgICAgICAgICBjb25zdCBuMzIgPSB1MzIoaXYpO1xuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgczAgPSBuMzJbMF0sIHMxID0gbjMyWzFdLCBzMiA9IG4zMlsyXSwgczMgPSBuMzJbM107XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSArIDQgPD0gYi5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgKHMwIF49IGJbaSArIDBdKSwgKHMxIF49IGJbaSArIDFdKSwgKHMyIF49IGJbaSArIDJdKSwgKHMzIF49IGJbaSArIDNdKTtcbiAgICAgICAgICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgczAsIHMxLCBzMiwgczMpKTtcbiAgICAgICAgICAgICAgICAob1tpKytdID0gczApLCAob1tpKytdID0gczEpLCAob1tpKytdID0gczIpLCAob1tpKytdID0gczMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBja3M1KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG1wMzIgPSBwYWRQQ0tTKHBsYWludGV4dC5zdWJhcnJheShpICogNCkpO1xuICAgICAgICAgICAgICAgIChzMCBePSB0bXAzMlswXSksIChzMSBePSB0bXAzMlsxXSksIChzMiBePSB0bXAzMlsyXSksIChzMyBePSB0bXAzMlszXSk7XG4gICAgICAgICAgICAgICAgKHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIHMwLCBzMSwgczIsIHMzKSk7XG4gICAgICAgICAgICAgICAgKG9baSsrXSA9IHMwKSwgKG9baSsrXSA9IHMxKSwgKG9baSsrXSA9IHMyKSwgKG9baSsrXSA9IHMzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhrLmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm4gX291dDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjcnlwdDogKGNpcGhlcnRleHQsIGRzdCkgPT4ge1xuICAgICAgICAgICAgdmFsaWRhdGVCbG9ja0RlY3J5cHQoY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleURlY0xFKGtleSk7XG4gICAgICAgICAgICBjb25zdCBuMzIgPSB1MzIoaXYpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gZ2V0RHN0KGNpcGhlcnRleHQubGVuZ3RoLCBkc3QpO1xuICAgICAgICAgICAgY29uc3QgYiA9IHUzMihjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG8gPSB1MzIob3V0KTtcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgbGV0IHMwID0gbjMyWzBdLCBzMSA9IG4zMlsxXSwgczIgPSBuMzJbMl0sIHMzID0gbjMyWzNdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgKyA0IDw9IGIubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgICAgIGNvbnN0IHBzMCA9IHMwLCBwczEgPSBzMSwgcHMyID0gczIsIHBzMyA9IHMzO1xuICAgICAgICAgICAgICAgIChzMCA9IGJbaSArIDBdKSwgKHMxID0gYltpICsgMV0pLCAoczIgPSBiW2kgKyAyXSksIChzMyA9IGJbaSArIDNdKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHMwOiBvMCwgczE6IG8xLCBzMjogbzIsIHMzOiBvMyB9ID0gZGVjcnlwdCh4aywgczAsIHMxLCBzMiwgczMpO1xuICAgICAgICAgICAgICAgIChvW2krK10gPSBvMCBeIHBzMCksIChvW2krK10gPSBvMSBeIHBzMSksIChvW2krK10gPSBvMiBeIHBzMiksIChvW2krK10gPSBvMyBeIHBzMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4ay5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlUENLUyhvdXQsIHBja3M1KTtcbiAgICAgICAgfSxcbiAgICB9O1xufSk7XG4vKipcbiAqIENGQjogQ2lwaGVyIEZlZWRiYWNrIE1vZGUuIFRoZSBpbnB1dCBmb3IgdGhlIGJsb2NrIGNpcGhlciBpcyB0aGUgcHJldmlvdXMgY2lwaGVyIG91dHB1dC5cbiAqIFVuYXV0aGVudGljYXRlZDogbmVlZHMgTUFDLlxuICovXG5leHBvcnQgY29uc3QgY2ZiID0gd3JhcENpcGhlcih7IGJsb2NrU2l6ZTogMTYsIG5vbmNlTGVuZ3RoOiAxNiB9LCBmdW5jdGlvbiBjZmIoa2V5LCBpdikge1xuICAgIGFieXRlcyhrZXkpO1xuICAgIGFieXRlcyhpdiwgMTYpO1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NDZmIoc3JjLCBpc0VuY3J5cHQsIGRzdCkge1xuICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICAgIGNvbnN0IHNyY0xlbiA9IHNyYy5sZW5ndGg7XG4gICAgICAgIGRzdCA9IGdldERzdChzcmNMZW4sIGRzdCk7XG4gICAgICAgIGNvbnN0IHNyYzMyID0gdTMyKHNyYyk7XG4gICAgICAgIGNvbnN0IGRzdDMyID0gdTMyKGRzdCk7XG4gICAgICAgIGNvbnN0IG5leHQzMiA9IGlzRW5jcnlwdCA/IGRzdDMyIDogc3JjMzI7XG4gICAgICAgIGNvbnN0IG4zMiA9IHUzMihpdik7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgczAgPSBuMzJbMF0sIHMxID0gbjMyWzFdLCBzMiA9IG4zMlsyXSwgczMgPSBuMzJbM107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpICsgNCA8PSBzcmMzMi5sZW5ndGg7KSB7XG4gICAgICAgICAgICBjb25zdCB7IHMwOiBlMCwgczE6IGUxLCBzMjogZTIsIHMzOiBlMyB9ID0gZW5jcnlwdCh4aywgczAsIHMxLCBzMiwgczMpO1xuICAgICAgICAgICAgZHN0MzJbaSArIDBdID0gc3JjMzJbaSArIDBdIF4gZTA7XG4gICAgICAgICAgICBkc3QzMltpICsgMV0gPSBzcmMzMltpICsgMV0gXiBlMTtcbiAgICAgICAgICAgIGRzdDMyW2kgKyAyXSA9IHNyYzMyW2kgKyAyXSBeIGUyO1xuICAgICAgICAgICAgZHN0MzJbaSArIDNdID0gc3JjMzJbaSArIDNdIF4gZTM7XG4gICAgICAgICAgICAoczAgPSBuZXh0MzJbaSsrXSksIChzMSA9IG5leHQzMltpKytdKSwgKHMyID0gbmV4dDMyW2krK10pLCAoczMgPSBuZXh0MzJbaSsrXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGVmdG92ZXJzIChsZXNzIHRoYW4gYmxvY2spXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gQkxPQ0tfU0laRSAqIE1hdGguZmxvb3Ioc3JjMzIubGVuZ3RoIC8gQkxPQ0tfU0laRTMyKTtcbiAgICAgICAgaWYgKHN0YXJ0IDwgc3JjTGVuKSB7XG4gICAgICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgczAsIHMxLCBzMiwgczMpKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IHU4KG5ldyBVaW50MzJBcnJheShbczAsIHMxLCBzMiwgczNdKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQsIHBvcyA9IDA7IGkgPCBzcmNMZW47IGkrKywgcG9zKyspXG4gICAgICAgICAgICAgICAgZHN0W2ldID0gc3JjW2ldIF4gYnVmW3Bvc107XG4gICAgICAgICAgICBidWYuZmlsbCgwKTtcbiAgICAgICAgfVxuICAgICAgICB4ay5maWxsKDApO1xuICAgICAgICByZXR1cm4gZHN0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0OiAocGxhaW50ZXh0LCBkc3QpID0+IHByb2Nlc3NDZmIocGxhaW50ZXh0LCB0cnVlLCBkc3QpLFxuICAgICAgICBkZWNyeXB0OiAoY2lwaGVydGV4dCwgZHN0KSA9PiBwcm9jZXNzQ2ZiKGNpcGhlcnRleHQsIGZhbHNlLCBkc3QpLFxuICAgIH07XG59KTtcbi8vIFRPRE86IG1lcmdlIHdpdGggY2hhY2hhLCBob3dldmVyIGdjbSBoYXMgYml0TGVuIHdoaWxlIGNoYWNoYSBoYXMgYnl0ZUxlblxuZnVuY3Rpb24gY29tcHV0ZVRhZyhmbiwgaXNMRSwga2V5LCBkYXRhLCBBQUQpIHtcbiAgICBjb25zdCBoID0gZm4uY3JlYXRlKGtleSwgZGF0YS5sZW5ndGggKyAoQUFEPy5sZW5ndGggfHwgMCkpO1xuICAgIGlmIChBQUQpXG4gICAgICAgIGgudXBkYXRlKEFBRCk7XG4gICAgaC51cGRhdGUoZGF0YSk7XG4gICAgY29uc3QgbnVtID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KG51bSk7XG4gICAgaWYgKEFBRClcbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIDAsIEJpZ0ludChBQUQubGVuZ3RoICogOCksIGlzTEUpO1xuICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCA4LCBCaWdJbnQoZGF0YS5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgaC51cGRhdGUobnVtKTtcbiAgICByZXR1cm4gaC5kaWdlc3QoKTtcbn1cbi8qKlxuICogR0NNOiBHYWxvaXMvQ291bnRlciBNb2RlLlxuICogR29vZCwgbW9kZXJuIHZlcnNpb24gb2YgQ1RSLCBwYXJhbGxlbCwgd2l0aCBNQUMuXG4gKiBCZSBjYXJlZnVsOiBNQUNzIGNhbiBiZSBmb3JnZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBnY20gPSB3cmFwQ2lwaGVyKHsgYmxvY2tTaXplOiAxNiwgbm9uY2VMZW5ndGg6IDEyLCB0YWdMZW5ndGg6IDE2IH0sIGZ1bmN0aW9uIGdjbShrZXksIG5vbmNlLCBBQUQpIHtcbiAgICBhYnl0ZXMobm9uY2UpO1xuICAgIC8vIE5vbmNlIGNhbiBiZSBwcmV0dHkgbXVjaCBhbnl0aGluZyAoZXZlbiAxIGJ5dGUpLiBCdXQgc21hbGxlciBub25jZXMgbGVzcyBzZWN1cmUuXG4gICAgaWYgKG5vbmNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZXMvZ2NtOiBlbXB0eSBub25jZScpO1xuICAgIGNvbnN0IHRhZ0xlbmd0aCA9IDE2O1xuICAgIGZ1bmN0aW9uIF9jb21wdXRlVGFnKGF1dGhLZXksIHRhZ01hc2ssIGRhdGEpIHtcbiAgICAgICAgY29uc3QgdGFnID0gY29tcHV0ZVRhZyhnaGFzaCwgZmFsc2UsIGF1dGhLZXksIGRhdGEsIEFBRCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFnTWFzay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRhZ1tpXSBePSB0YWdNYXNrW2ldO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXJpdmVLZXlzKCkge1xuICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICAgIGNvbnN0IGF1dGhLZXkgPSBFTVBUWV9CTE9DSy5zbGljZSgpO1xuICAgICAgICBjb25zdCBjb3VudGVyID0gRU1QVFlfQkxPQ0suc2xpY2UoKTtcbiAgICAgICAgY3RyMzIoeGssIGZhbHNlLCBjb3VudGVyLCBjb3VudGVyLCBhdXRoS2V5KTtcbiAgICAgICAgaWYgKG5vbmNlLmxlbmd0aCA9PT0gMTIpIHtcbiAgICAgICAgICAgIGNvdW50ZXIuc2V0KG5vbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNwZWMgKE5JU1QgODAwLTM4ZCkgc3VwcG9ydHMgdmFyaWFibGUgc2l6ZSBub25jZS5cbiAgICAgICAgICAgIC8vIE5vdCBzdXBwb3J0ZWQgZm9yIG5vdywgYnV0IGNhbiBiZSB1c2VmdWwuXG4gICAgICAgICAgICBjb25zdCBub25jZUxlbiA9IEVNUFRZX0JMT0NLLnNsaWNlKCk7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhub25jZUxlbik7XG4gICAgICAgICAgICBzZXRCaWdVaW50NjQodmlldywgOCwgQmlnSW50KG5vbmNlLmxlbmd0aCAqIDgpLCBmYWxzZSk7XG4gICAgICAgICAgICAvLyBnaGFzaChub25jZSB8fCB1NjRiZSgwKSB8fCB1NjRiZShub25jZUxlbio4KSlcbiAgICAgICAgICAgIGdoYXNoLmNyZWF0ZShhdXRoS2V5KS51cGRhdGUobm9uY2UpLnVwZGF0ZShub25jZUxlbikuZGlnZXN0SW50byhjb3VudGVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWdNYXNrID0gY3RyMzIoeGssIGZhbHNlLCBjb3VudGVyLCBFTVBUWV9CTE9DSyk7XG4gICAgICAgIHJldHVybiB7IHhrLCBhdXRoS2V5LCBjb3VudGVyLCB0YWdNYXNrIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuY3J5cHQ6IChwbGFpbnRleHQpID0+IHtcbiAgICAgICAgICAgIGFieXRlcyhwbGFpbnRleHQpO1xuICAgICAgICAgICAgY29uc3QgeyB4aywgYXV0aEtleSwgY291bnRlciwgdGFnTWFzayB9ID0gZGVyaXZlS2V5cygpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCArIHRhZ0xlbmd0aCk7XG4gICAgICAgICAgICBjdHIzMih4aywgZmFsc2UsIGNvdW50ZXIsIHBsYWludGV4dCwgb3V0KTtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IF9jb21wdXRlVGFnKGF1dGhLZXksIHRhZ01hc2ssIG91dC5zdWJhcnJheSgwLCBvdXQubGVuZ3RoIC0gdGFnTGVuZ3RoKSk7XG4gICAgICAgICAgICBvdXQuc2V0KHRhZywgcGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB4ay5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjcnlwdDogKGNpcGhlcnRleHQpID0+IHtcbiAgICAgICAgICAgIGFieXRlcyhjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCA8IHRhZ0xlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFlcy9nY206IGNpcGhlcnRleHQgbGVzcyB0aGFuIHRhZ0xlbiAoJHt0YWdMZW5ndGh9KWApO1xuICAgICAgICAgICAgY29uc3QgeyB4aywgYXV0aEtleSwgY291bnRlciwgdGFnTWFzayB9ID0gZGVyaXZlS2V5cygpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgLXRhZ0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBwYXNzZWRUYWcgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KC10YWdMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgdGFnID0gX2NvbXB1dGVUYWcoYXV0aEtleSwgdGFnTWFzaywgZGF0YSk7XG4gICAgICAgICAgICBpZiAoIWVxdWFsQnl0ZXModGFnLCBwYXNzZWRUYWcpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWVzL2djbTogaW52YWxpZCBnaGFzaCB0YWcnKTtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IGN0cjMyKHhrLCBmYWxzZSwgY291bnRlciwgZGF0YSk7XG4gICAgICAgICAgICBhdXRoS2V5LmZpbGwoMCk7XG4gICAgICAgICAgICB0YWdNYXNrLmZpbGwoMCk7XG4gICAgICAgICAgICB4ay5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICB9O1xufSk7XG5jb25zdCBsaW1pdCA9IChuYW1lLCBtaW4sIG1heCkgPT4gKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWx1ZSkgfHwgbWluID4gdmFsdWUgfHwgdmFsdWUgPiBtYXgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfTogaW52YWxpZCB2YWx1ZT0ke3ZhbHVlfSwgbXVzdCBiZSBbJHttaW59Li4ke21heH1dYCk7XG59O1xuLyoqXG4gKiBBRVMtR0NNLVNJVjogY2xhc3NpYyBBRVMtR0NNIHdpdGggbm9uY2UtbWlzdXNlIHJlc2lzdGFuY2UuXG4gKiBHdWFyYW50ZWVzIHRoYXQsIHdoZW4gYSBub25jZSBpcyByZXBlYXRlZCwgdGhlIG9ubHkgc2VjdXJpdHkgbG9zcyBpcyB0aGF0IGlkZW50aWNhbFxuICogcGxhaW50ZXh0cyB3aWxsIHByb2R1Y2UgaWRlbnRpY2FsIGNpcGhlcnRleHRzLlxuICogUkZDIDg0NTIsIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjODQ1MlxuICovXG5leHBvcnQgY29uc3Qgc2l2ID0gd3JhcENpcGhlcih7IGJsb2NrU2l6ZTogMTYsIG5vbmNlTGVuZ3RoOiAxMiwgdGFnTGVuZ3RoOiAxNiB9LCBmdW5jdGlvbiBzaXYoa2V5LCBub25jZSwgQUFEKSB7XG4gICAgY29uc3QgdGFnTGVuZ3RoID0gMTY7XG4gICAgLy8gRnJvbSBSRkMgODQ1MjogU2VjdGlvbiA2XG4gICAgY29uc3QgQUFEX0xJTUlUID0gbGltaXQoJ0FBRCcsIDAsIDIgKiogMzYpO1xuICAgIGNvbnN0IFBMQUlOX0xJTUlUID0gbGltaXQoJ3BsYWludGV4dCcsIDAsIDIgKiogMzYpO1xuICAgIGNvbnN0IE5PTkNFX0xJTUlUID0gbGltaXQoJ25vbmNlJywgMTIsIDEyKTtcbiAgICBjb25zdCBDSVBIRVJfTElNSVQgPSBsaW1pdCgnY2lwaGVydGV4dCcsIDE2LCAyICoqIDM2ICsgMTYpO1xuICAgIGFieXRlcyhub25jZSk7XG4gICAgTk9OQ0VfTElNSVQobm9uY2UubGVuZ3RoKTtcbiAgICBpZiAoQUFEKSB7XG4gICAgICAgIGFieXRlcyhBQUQpO1xuICAgICAgICBBQURfTElNSVQoQUFELmxlbmd0aCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlcml2ZUtleXMoKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gIT09IDE2ICYmIGxlbiAhPT0gMjQgJiYgbGVuICE9PSAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihga2V5IGxlbmd0aCBtdXN0IGJlIDE2LCAyNCBvciAzMiBieXRlcywgZ290OiAke2xlbn0gYnl0ZXNgKTtcbiAgICAgICAgY29uc3QgeGsgPSBleHBhbmRLZXlMRShrZXkpO1xuICAgICAgICBjb25zdCBlbmNLZXkgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICBjb25zdCBhdXRoS2V5ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgICAgICBjb25zdCBuMzIgPSB1MzIobm9uY2UpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHMwID0gMCwgczEgPSBuMzJbMF0sIHMyID0gbjMyWzFdLCBzMyA9IG4zMlsyXTtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGRlcml2ZWRLZXkgb2YgW2F1dGhLZXksIGVuY0tleV0ubWFwKHUzMikpIHtcbiAgICAgICAgICAgIGNvbnN0IGQzMiA9IHUzMihkZXJpdmVkS2V5KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZDMyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gYWVzKHUzMmxlKDApIHx8IG5vbmNlKVs6OF0gfHwgYWVzKHUzMmxlKDEpIHx8IG5vbmNlKVs6OF0gLi4uXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzMDogbzAsIHMxOiBvMSB9ID0gZW5jcnlwdCh4aywgczAsIHMxLCBzMiwgczMpO1xuICAgICAgICAgICAgICAgIGQzMltpICsgMF0gPSBvMDtcbiAgICAgICAgICAgICAgICBkMzJbaSArIDFdID0gbzE7XG4gICAgICAgICAgICAgICAgczAgPSArK2NvdW50ZXI7IC8vIGluY3JlbWVudCBjb3VudGVyIGluc2lkZSBzdGF0ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHhrLmZpbGwoMCk7XG4gICAgICAgIHJldHVybiB7IGF1dGhLZXksIGVuY0tleTogZXhwYW5kS2V5TEUoZW5jS2V5KSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBfY29tcHV0ZVRhZyhlbmNLZXksIGF1dGhLZXksIGRhdGEpIHtcbiAgICAgICAgY29uc3QgdGFnID0gY29tcHV0ZVRhZyhwb2x5dmFsLCB0cnVlLCBhdXRoS2V5LCBkYXRhLCBBQUQpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBleHBlY3RlZCB0YWcgYnkgWE9SaW5nIFNfcyBhbmQgdGhlIG5vbmNlLCBjbGVhcmluZyB0aGVcbiAgICAgICAgLy8gbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGxhc3QgYnl0ZSBhbmQgZW5jcnlwdGluZyB3aXRoIHRoZVxuICAgICAgICAvLyBtZXNzYWdlLWVuY3J5cHRpb24ga2V5LlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspXG4gICAgICAgICAgICB0YWdbaV0gXj0gbm9uY2VbaV07XG4gICAgICAgIHRhZ1sxNV0gJj0gMHg3ZjsgLy8gQ2xlYXIgdGhlIGhpZ2hlc3QgYml0XG4gICAgICAgIC8vIGVuY3J5cHQgdGFnIGFzIGJsb2NrXG4gICAgICAgIGNvbnN0IHQzMiA9IHUzMih0YWcpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHMwID0gdDMyWzBdLCBzMSA9IHQzMlsxXSwgczIgPSB0MzJbMl0sIHMzID0gdDMyWzNdO1xuICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdChlbmNLZXksIHMwLCBzMSwgczIsIHMzKSk7XG4gICAgICAgICh0MzJbMF0gPSBzMCksICh0MzJbMV0gPSBzMSksICh0MzJbMl0gPSBzMiksICh0MzJbM10gPSBzMyk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8vIGFjdHVhbCBkZWNyeXB0L2VuY3J5cHQgb2YgbWVzc2FnZS5cbiAgICBmdW5jdGlvbiBwcm9jZXNzU2l2KGVuY0tleSwgdGFnLCBpbnB1dCkge1xuICAgICAgICBsZXQgYmxvY2sgPSB0YWcuc2xpY2UoKTtcbiAgICAgICAgYmxvY2tbMTVdIHw9IDB4ODA7IC8vIEZvcmNlIGhpZ2hlc3QgYml0XG4gICAgICAgIHJldHVybiBjdHIzMihlbmNLZXksIHRydWUsIGJsb2NrLCBpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuY3J5cHQ6IChwbGFpbnRleHQpID0+IHtcbiAgICAgICAgICAgIGFieXRlcyhwbGFpbnRleHQpO1xuICAgICAgICAgICAgUExBSU5fTElNSVQocGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCB7IGVuY0tleSwgYXV0aEtleSB9ID0gZGVyaXZlS2V5cygpO1xuICAgICAgICAgICAgY29uc3QgdGFnID0gX2NvbXB1dGVUYWcoZW5jS2V5LCBhdXRoS2V5LCBwbGFpbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCArIHRhZ0xlbmd0aCk7XG4gICAgICAgICAgICBvdXQuc2V0KHRhZywgcGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICBvdXQuc2V0KHByb2Nlc3NTaXYoZW5jS2V5LCB0YWcsIHBsYWludGV4dCkpO1xuICAgICAgICAgICAgZW5jS2V5LmZpbGwoMCk7XG4gICAgICAgICAgICBhdXRoS2V5LmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICBkZWNyeXB0OiAoY2lwaGVydGV4dCkgPT4ge1xuICAgICAgICAgICAgYWJ5dGVzKGNpcGhlcnRleHQpO1xuICAgICAgICAgICAgQ0lQSEVSX0xJTUlUKGNpcGhlcnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IGNpcGhlcnRleHQuc3ViYXJyYXkoLXRhZ0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCB7IGVuY0tleSwgYXV0aEtleSB9ID0gZGVyaXZlS2V5cygpO1xuICAgICAgICAgICAgY29uc3QgcGxhaW50ZXh0ID0gcHJvY2Vzc1NpdihlbmNLZXksIHRhZywgY2lwaGVydGV4dC5zdWJhcnJheSgwLCAtdGFnTGVuZ3RoKSk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFRhZyA9IF9jb21wdXRlVGFnKGVuY0tleSwgYXV0aEtleSwgcGxhaW50ZXh0KTtcbiAgICAgICAgICAgIGVuY0tleS5maWxsKDApO1xuICAgICAgICAgICAgYXV0aEtleS5maWxsKDApO1xuICAgICAgICAgICAgaWYgKCFlcXVhbEJ5dGVzKHRhZywgZXhwZWN0ZWRUYWcpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2x5dmFsIHRhZycpO1xuICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICAgICAgfSxcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBpc0J5dGVzMzIoYSkge1xuICAgIHJldHVybiAoYSAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAoYSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8IGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQzMkFycmF5JykpO1xufVxuZnVuY3Rpb24gZW5jcnlwdEJsb2NrKHhrLCBibG9jaykge1xuICAgIGFieXRlcyhibG9jaywgMTYpO1xuICAgIGlmICghaXNCeXRlczMyKHhrKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfZW5jcnlwdEJsb2NrIGFjY2VwdHMgcmVzdWx0IG9mIGV4cGFuZEtleUxFJyk7XG4gICAgY29uc3QgYjMyID0gdTMyKGJsb2NrKTtcbiAgICBsZXQgeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgYjMyWzBdLCBiMzJbMV0sIGIzMlsyXSwgYjMyWzNdKTtcbiAgICAoYjMyWzBdID0gczApLCAoYjMyWzFdID0gczEpLCAoYjMyWzJdID0gczIpLCAoYjMyWzNdID0gczMpO1xuICAgIHJldHVybiBibG9jaztcbn1cbmZ1bmN0aW9uIGRlY3J5cHRCbG9jayh4aywgYmxvY2spIHtcbiAgICBhYnl0ZXMoYmxvY2ssIDE2KTtcbiAgICBpZiAoIWlzQnl0ZXMzMih4aykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignX2RlY3J5cHRCbG9jayBhY2NlcHRzIHJlc3VsdCBvZiBleHBhbmRLZXlMRScpO1xuICAgIGNvbnN0IGIzMiA9IHUzMihibG9jayk7XG4gICAgbGV0IHsgczAsIHMxLCBzMiwgczMgfSA9IGRlY3J5cHQoeGssIGIzMlswXSwgYjMyWzFdLCBiMzJbMl0sIGIzMlszXSk7XG4gICAgKGIzMlswXSA9IHMwKSwgKGIzMlsxXSA9IHMxKSwgKGIzMlsyXSA9IHMyKSwgKGIzMlszXSA9IHMzKTtcbiAgICByZXR1cm4gYmxvY2s7XG59XG4vLyBIaWdobHkgdW5zYWZlIHByaXZhdGUgZnVuY3Rpb25zIGZvciBpbXBsZW1lbnRpbmcgbmV3IG1vZGVzIG9yIGNpcGhlcnMgYmFzZWQgb24gQUVTXG4vLyBDYW4gY2hhbmdlIGF0IGFueSB0aW1lLCBubyBBUEkgZ3VhcmFudGVlc1xuZXhwb3J0IGNvbnN0IHVuc2FmZSA9IHtcbiAgICBleHBhbmRLZXlMRSxcbiAgICBleHBhbmRLZXlEZWNMRSxcbiAgICBlbmNyeXB0LFxuICAgIGRlY3J5cHQsXG4gICAgZW5jcnlwdEJsb2NrLFxuICAgIGRlY3J5cHRCbG9jayxcbiAgICBjdHJDb3VudGVyLFxuICAgIGN0cjMyLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/aes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/chacha.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/chacha.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _poly1305_aead: () => (/* binding */ _poly1305_aead),\n/* harmony export */   chacha12: () => (/* binding */ chacha12),\n/* harmony export */   chacha20: () => (/* binding */ chacha20),\n/* harmony export */   chacha20orig: () => (/* binding */ chacha20orig),\n/* harmony export */   chacha20poly1305: () => (/* binding */ chacha20poly1305),\n/* harmony export */   chacha8: () => (/* binding */ chacha8),\n/* harmony export */   hchacha: () => (/* binding */ hchacha),\n/* harmony export */   xchacha20: () => (/* binding */ xchacha20),\n/* harmony export */   xchacha20poly1305: () => (/* binding */ xchacha20poly1305)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/utils.js\");\n/* harmony import */ var _poly1305_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_poly1305.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_poly1305.js\");\n/* harmony import */ var _arx_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arx.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_arx.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_assert.js\");\n// prettier-ignore\n\n\n\n\n// ChaCha20 stream cipher was released in 2008. ChaCha aims to increase\n// the diffusion per round, but had slightly less cryptanalysis.\n// https://cr.yp.to/chacha.html, http://cr.yp.to/chacha/chacha-20080128.pdf\n/**\n * ChaCha core function.\n */\n// prettier-ignore\nfunction chachaCore(s, k, n, out, cnt, rounds = 20) {\n    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n    y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], // Key      Key     Key     Key\n    y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], // Key      Key     Key     Key\n    y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2]; // Counter  Counter\tNonce   Nonce\n    // Save state to temporary variables\n    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n    for (let r = 0; r < rounds; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x09, 7);\n    }\n    // Write output\n    let oi = 0;\n    out[oi++] = (y00 + x00) | 0;\n    out[oi++] = (y01 + x01) | 0;\n    out[oi++] = (y02 + x02) | 0;\n    out[oi++] = (y03 + x03) | 0;\n    out[oi++] = (y04 + x04) | 0;\n    out[oi++] = (y05 + x05) | 0;\n    out[oi++] = (y06 + x06) | 0;\n    out[oi++] = (y07 + x07) | 0;\n    out[oi++] = (y08 + x08) | 0;\n    out[oi++] = (y09 + x09) | 0;\n    out[oi++] = (y10 + x10) | 0;\n    out[oi++] = (y11 + x11) | 0;\n    out[oi++] = (y12 + x12) | 0;\n    out[oi++] = (y13 + x13) | 0;\n    out[oi++] = (y14 + x14) | 0;\n    out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha helper method, used primarily in xchacha, to hash\n * key and nonce into key' and nonce'.\n * Same as chachaCore, but there doesn't seem to be a way to move the block\n * out without 25% performance hit.\n */\n// prettier-ignore\nfunction hchacha(s, k, i, o32) {\n    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n    for (let r = 0; r < 20; r += 2) {\n        x00 = (x00 + x04) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x00, 16);\n        x08 = (x08 + x12) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x08, 12);\n        x00 = (x00 + x04) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x00, 8);\n        x08 = (x08 + x12) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x08, 7);\n        x01 = (x01 + x05) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x01, 16);\n        x09 = (x09 + x13) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x09, 12);\n        x01 = (x01 + x05) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x01, 8);\n        x09 = (x09 + x13) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x09, 7);\n        x02 = (x02 + x06) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x02, 16);\n        x10 = (x10 + x14) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x10, 12);\n        x02 = (x02 + x06) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x02, 8);\n        x10 = (x10 + x14) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x10, 7);\n        x03 = (x03 + x07) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x03, 16);\n        x11 = (x11 + x15) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x11, 12);\n        x03 = (x03 + x07) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x03, 8);\n        x11 = (x11 + x15) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x11, 7);\n        x00 = (x00 + x05) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x00, 16);\n        x10 = (x10 + x15) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x10, 12);\n        x00 = (x00 + x05) | 0;\n        x15 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x15 ^ x00, 8);\n        x10 = (x10 + x15) | 0;\n        x05 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x05 ^ x10, 7);\n        x01 = (x01 + x06) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x01, 16);\n        x11 = (x11 + x12) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x11, 12);\n        x01 = (x01 + x06) | 0;\n        x12 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x12 ^ x01, 8);\n        x11 = (x11 + x12) | 0;\n        x06 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x06 ^ x11, 7);\n        x02 = (x02 + x07) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x02, 16);\n        x08 = (x08 + x13) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x08, 12);\n        x02 = (x02 + x07) | 0;\n        x13 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x13 ^ x02, 8);\n        x08 = (x08 + x13) | 0;\n        x07 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x07 ^ x08, 7);\n        x03 = (x03 + x04) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x03, 16);\n        x09 = (x09 + x14) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x09, 12);\n        x03 = (x03 + x04) | 0;\n        x14 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x14 ^ x03, 8);\n        x09 = (x09 + x14) | 0;\n        x04 = (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.rotl)(x04 ^ x09, 7);\n    }\n    let oi = 0;\n    o32[oi++] = x00;\n    o32[oi++] = x01;\n    o32[oi++] = x02;\n    o32[oi++] = x03;\n    o32[oi++] = x12;\n    o32[oi++] = x13;\n    o32[oi++] = x14;\n    o32[oi++] = x15;\n}\n/**\n * Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter.\n */\nconst chacha20orig = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    allowShortKeys: true,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nconst chacha20 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    allowShortKeys: false,\n});\n/**\n * XChaCha eXtended-nonce ChaCha. 24-byte nonce.\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n */\nconst xchacha20 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 8,\n    extendNonceFn: hchacha,\n    allowShortKeys: false,\n});\n/**\n * Reduced 8-round chacha, described in original paper.\n */\nconst chacha8 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 8,\n});\n/**\n * Reduced 12-round chacha, described in original paper.\n */\nconst chacha12 = /* @__PURE__ */ (0,_arx_js__WEBPACK_IMPORTED_MODULE_0__.createCipher)(chachaCore, {\n    counterRight: false,\n    counterLength: 4,\n    rounds: 12,\n});\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h, msg) => {\n    h.update(msg);\n    const left = msg.length % 16;\n    if (left)\n        h.update(ZEROS16.subarray(left));\n};\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(fn, key, nonce, data, AAD) {\n    const authKey = fn(key, nonce, ZEROS32);\n    const h = _poly1305_js__WEBPACK_IMPORTED_MODULE_1__.poly1305.create(authKey);\n    if (AAD)\n        updatePadded(h, AAD);\n    updatePadded(h, data);\n    const num = new Uint8Array(16);\n    const view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.createView)(num);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.setBigUint64)(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.setBigUint64)(view, 8, BigInt(data.length), true);\n    h.update(num);\n    const res = h.digest();\n    authKey.fill(0);\n    return res;\n}\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them similar to:\n * https://github.com/paulmillr/scure-base/blob/b266c73dde977b1dd7ef40ef7a23cc15aab526b3/index.ts#L250\n * But it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nconst _poly1305_aead = (xorStream) => (key, nonce, AAD) => {\n    const tagLength = 16;\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_3__.bytes)(key, 32);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_3__.bytes)(nonce);\n    return {\n        encrypt: (plaintext, output) => {\n            const plength = plaintext.length;\n            const clength = plength + tagLength;\n            if (output) {\n                (0,_assert_js__WEBPACK_IMPORTED_MODULE_3__.bytes)(output, clength);\n            }\n            else {\n                output = new Uint8Array(clength);\n            }\n            xorStream(key, nonce, plaintext, output, 1);\n            const tag = computeTag(xorStream, key, nonce, output.subarray(0, -tagLength), AAD);\n            output.set(tag, plength); // append tag\n            return output;\n        },\n        decrypt: (ciphertext, output) => {\n            const clength = ciphertext.length;\n            const plength = clength - tagLength;\n            if (clength < tagLength)\n                throw new Error(`encrypted data must be at least ${tagLength} bytes`);\n            if (output) {\n                (0,_assert_js__WEBPACK_IMPORTED_MODULE_3__.bytes)(output, plength);\n            }\n            else {\n                output = new Uint8Array(plength);\n            }\n            const data = ciphertext.subarray(0, -tagLength);\n            const passedTag = ciphertext.subarray(-tagLength);\n            const tag = computeTag(xorStream, key, nonce, data, AAD);\n            if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.equalBytes)(passedTag, tag))\n                throw new Error('invalid tag');\n            xorStream(key, nonce, data, output, 1);\n            return output;\n        },\n    };\n};\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n * With 12-byte nonce, it's not safe to use fill it with random (CSPRNG), due to collision chance.\n */\nconst chacha20poly1305 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapCipher)({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha\n * With 24-byte nonce, it's safe to use fill it with random (CSPRNG).\n */\nconst xchacha20poly1305 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapCipher)({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));\n//# sourceMappingURL=chacha.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2VzbS9jaGFjaGEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQytFO0FBQ3JDO0FBQ0s7QUFDQTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0EsY0FBYyw2Q0FBSTtBQUNsQjtBQUNBLGNBQWMsNkNBQUk7QUFDbEI7QUFDQSxjQUFjLDZDQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQ0FBcUMscURBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ08saUNBQWlDLHFEQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLHFEQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyxxREFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ08saUNBQWlDLHFEQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxREFBVTtBQUMzQixJQUFJLHVEQUFZO0FBQ2hCLElBQUksdURBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxJQUFJLGlEQUFNO0FBQ1YsSUFBSSxpREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFdBQVc7QUFDOUU7QUFDQSxnQkFBZ0IsaURBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscURBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlDQUF5QyxxREFBVSxHQUFHLCtDQUErQztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLHFEQUFVLEdBQUcsK0NBQStDO0FBQzdHIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2VzbS9jaGFjaGEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcHJldHRpZXItaWdub3JlXG5pbXBvcnQgeyB3cmFwQ2lwaGVyLCBjcmVhdGVWaWV3LCBlcXVhbEJ5dGVzLCBzZXRCaWdVaW50NjQsIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBwb2x5MTMwNSB9IGZyb20gJy4vX3BvbHkxMzA1LmpzJztcbmltcG9ydCB7IGNyZWF0ZUNpcGhlciwgcm90bCB9IGZyb20gJy4vX2FyeC5qcyc7XG5pbXBvcnQgeyBieXRlcyBhcyBhYnl0ZXMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuLy8gQ2hhQ2hhMjAgc3RyZWFtIGNpcGhlciB3YXMgcmVsZWFzZWQgaW4gMjAwOC4gQ2hhQ2hhIGFpbXMgdG8gaW5jcmVhc2Vcbi8vIHRoZSBkaWZmdXNpb24gcGVyIHJvdW5kLCBidXQgaGFkIHNsaWdodGx5IGxlc3MgY3J5cHRhbmFseXNpcy5cbi8vIGh0dHBzOi8vY3IueXAudG8vY2hhY2hhLmh0bWwsIGh0dHA6Ly9jci55cC50by9jaGFjaGEvY2hhY2hhLTIwMDgwMTI4LnBkZlxuLyoqXG4gKiBDaGFDaGEgY29yZSBmdW5jdGlvbi5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBjaGFjaGFDb3JlKHMsIGssIG4sIG91dCwgY250LCByb3VuZHMgPSAyMCkge1xuICAgIGxldCB5MDAgPSBzWzBdLCB5MDEgPSBzWzFdLCB5MDIgPSBzWzJdLCB5MDMgPSBzWzNdLCAvLyBcImV4cGFcIiAgIFwibmQgM1wiICBcIjItYnlcIiAgXCJ0ZSBrXCJcbiAgICB5MDQgPSBrWzBdLCB5MDUgPSBrWzFdLCB5MDYgPSBrWzJdLCB5MDcgPSBrWzNdLCAvLyBLZXkgICAgICBLZXkgICAgIEtleSAgICAgS2V5XG4gICAgeTA4ID0ga1s0XSwgeTA5ID0ga1s1XSwgeTEwID0ga1s2XSwgeTExID0ga1s3XSwgLy8gS2V5ICAgICAgS2V5ICAgICBLZXkgICAgIEtleVxuICAgIHkxMiA9IGNudCwgeTEzID0gblswXSwgeTE0ID0gblsxXSwgeTE1ID0gblsyXTsgLy8gQ291bnRlciAgQ291bnRlclx0Tm9uY2UgICBOb25jZVxuICAgIC8vIFNhdmUgc3RhdGUgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlc1xuICAgIGxldCB4MDAgPSB5MDAsIHgwMSA9IHkwMSwgeDAyID0geTAyLCB4MDMgPSB5MDMsIHgwNCA9IHkwNCwgeDA1ID0geTA1LCB4MDYgPSB5MDYsIHgwNyA9IHkwNywgeDA4ID0geTA4LCB4MDkgPSB5MDksIHgxMCA9IHkxMCwgeDExID0geTExLCB4MTIgPSB5MTIsIHgxMyA9IHkxMywgeDE0ID0geTE0LCB4MTUgPSB5MTU7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3VuZHM7IHIgKz0gMikge1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAwLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNCkgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMCwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAxLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNSkgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMSwgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAyLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNikgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMiwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAzLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNykgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMywgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDcpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAwLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNSkgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMCwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAxLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNikgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMSwgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAyLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNykgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMiwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAzLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNCkgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMywgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDcpO1xuICAgIH1cbiAgICAvLyBXcml0ZSBvdXRwdXRcbiAgICBsZXQgb2kgPSAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDAgKyB4MDApIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAxICsgeDAxKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMiArIHgwMikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDMgKyB4MDMpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA0ICsgeDA0KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNSArIHgwNSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDYgKyB4MDYpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA3ICsgeDA3KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwOCArIHgwOCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDkgKyB4MDkpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEwICsgeDEwKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMSArIHgxMSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTIgKyB4MTIpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEzICsgeDEzKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxNCArIHgxNCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTUgKyB4MTUpIHwgMDtcbn1cbi8qKlxuICogaGNoYWNoYSBoZWxwZXIgbWV0aG9kLCB1c2VkIHByaW1hcmlseSBpbiB4Y2hhY2hhLCB0byBoYXNoXG4gKiBrZXkgYW5kIG5vbmNlIGludG8ga2V5JyBhbmQgbm9uY2UnLlxuICogU2FtZSBhcyBjaGFjaGFDb3JlLCBidXQgdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgd2F5IHRvIG1vdmUgdGhlIGJsb2NrXG4gKiBvdXQgd2l0aG91dCAyNSUgcGVyZm9ybWFuY2UgaGl0LlxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBmdW5jdGlvbiBoY2hhY2hhKHMsIGssIGksIG8zMikge1xuICAgIGxldCB4MDAgPSBzWzBdLCB4MDEgPSBzWzFdLCB4MDIgPSBzWzJdLCB4MDMgPSBzWzNdLCB4MDQgPSBrWzBdLCB4MDUgPSBrWzFdLCB4MDYgPSBrWzJdLCB4MDcgPSBrWzNdLCB4MDggPSBrWzRdLCB4MDkgPSBrWzVdLCB4MTAgPSBrWzZdLCB4MTEgPSBrWzddLCB4MTIgPSBpWzBdLCB4MTMgPSBpWzFdLCB4MTQgPSBpWzJdLCB4MTUgPSBpWzNdO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgMjA7IHIgKz0gMikge1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAwLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNCkgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMCwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAxLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNSkgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMSwgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAyLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNikgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMiwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAzLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNykgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMywgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDcpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAwLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNSkgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMCwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAxLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNikgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMSwgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAyLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNykgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMiwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAzLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNCkgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMywgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDcpO1xuICAgIH1cbiAgICBsZXQgb2kgPSAwO1xuICAgIG8zMltvaSsrXSA9IHgwMDtcbiAgICBvMzJbb2krK10gPSB4MDE7XG4gICAgbzMyW29pKytdID0geDAyO1xuICAgIG8zMltvaSsrXSA9IHgwMztcbiAgICBvMzJbb2krK10gPSB4MTI7XG4gICAgbzMyW29pKytdID0geDEzO1xuICAgIG8zMltvaSsrXSA9IHgxNDtcbiAgICBvMzJbb2krK10gPSB4MTU7XG59XG4vKipcbiAqIE9yaWdpbmFsLCBub24tUkZDIGNoYWNoYTIwIGZyb20gREpCLiA4LWJ5dGUgbm9uY2UsIDgtYnl0ZSBjb3VudGVyLlxuICovXG5leHBvcnQgY29uc3QgY2hhY2hhMjBvcmlnID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNpcGhlcihjaGFjaGFDb3JlLCB7XG4gICAgY291bnRlclJpZ2h0OiBmYWxzZSxcbiAgICBjb3VudGVyTGVuZ3RoOiA4LFxuICAgIGFsbG93U2hvcnRLZXlzOiB0cnVlLFxufSk7XG4vKipcbiAqIENoYUNoYSBzdHJlYW0gY2lwaGVyLiBDb25mb3JtcyB0byBSRkMgODQzOSAoSUVURiwgVExTKS4gMTItYnl0ZSBub25jZSwgNC1ieXRlIGNvdW50ZXIuXG4gKiBXaXRoIDEyLWJ5dGUgbm9uY2UsIGl0J3Mgbm90IHNhZmUgdG8gdXNlIGZpbGwgaXQgd2l0aCByYW5kb20gKENTUFJORyksIGR1ZSB0byBjb2xsaXNpb24gY2hhbmNlLlxuICovXG5leHBvcnQgY29uc3QgY2hhY2hhMjAgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ2lwaGVyKGNoYWNoYUNvcmUsIHtcbiAgICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICAgIGNvdW50ZXJMZW5ndGg6IDQsXG4gICAgYWxsb3dTaG9ydEtleXM6IGZhbHNlLFxufSk7XG4vKipcbiAqIFhDaGFDaGEgZVh0ZW5kZWQtbm9uY2UgQ2hhQ2hhLiAyNC1ieXRlIG5vbmNlLlxuICogV2l0aCAyNC1ieXRlIG5vbmNlLCBpdCdzIHNhZmUgdG8gdXNlIGZpbGwgaXQgd2l0aCByYW5kb20gKENTUFJORykuXG4gKiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy14Y2hhY2hhXG4gKi9cbmV4cG9ydCBjb25zdCB4Y2hhY2hhMjAgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ2lwaGVyKGNoYWNoYUNvcmUsIHtcbiAgICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICAgIGNvdW50ZXJMZW5ndGg6IDgsXG4gICAgZXh0ZW5kTm9uY2VGbjogaGNoYWNoYSxcbiAgICBhbGxvd1Nob3J0S2V5czogZmFsc2UsXG59KTtcbi8qKlxuICogUmVkdWNlZCA4LXJvdW5kIGNoYWNoYSwgZGVzY3JpYmVkIGluIG9yaWdpbmFsIHBhcGVyLlxuICovXG5leHBvcnQgY29uc3QgY2hhY2hhOCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDaXBoZXIoY2hhY2hhQ29yZSwge1xuICAgIGNvdW50ZXJSaWdodDogZmFsc2UsXG4gICAgY291bnRlckxlbmd0aDogNCxcbiAgICByb3VuZHM6IDgsXG59KTtcbi8qKlxuICogUmVkdWNlZCAxMi1yb3VuZCBjaGFjaGEsIGRlc2NyaWJlZCBpbiBvcmlnaW5hbCBwYXBlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGNoYWNoYTEyID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNpcGhlcihjaGFjaGFDb3JlLCB7XG4gICAgY291bnRlclJpZ2h0OiBmYWxzZSxcbiAgICBjb3VudGVyTGVuZ3RoOiA0LFxuICAgIHJvdW5kczogMTIsXG59KTtcbmNvbnN0IFpFUk9TMTYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuLy8gUGFkIHRvIGRpZ2VzdCBzaXplIHdpdGggemVyb3NcbmNvbnN0IHVwZGF0ZVBhZGRlZCA9IChoLCBtc2cpID0+IHtcbiAgICBoLnVwZGF0ZShtc2cpO1xuICAgIGNvbnN0IGxlZnQgPSBtc2cubGVuZ3RoICUgMTY7XG4gICAgaWYgKGxlZnQpXG4gICAgICAgIGgudXBkYXRlKFpFUk9TMTYuc3ViYXJyYXkobGVmdCkpO1xufTtcbmNvbnN0IFpFUk9TMzIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuZnVuY3Rpb24gY29tcHV0ZVRhZyhmbiwga2V5LCBub25jZSwgZGF0YSwgQUFEKSB7XG4gICAgY29uc3QgYXV0aEtleSA9IGZuKGtleSwgbm9uY2UsIFpFUk9TMzIpO1xuICAgIGNvbnN0IGggPSBwb2x5MTMwNS5jcmVhdGUoYXV0aEtleSk7XG4gICAgaWYgKEFBRClcbiAgICAgICAgdXBkYXRlUGFkZGVkKGgsIEFBRCk7XG4gICAgdXBkYXRlUGFkZGVkKGgsIGRhdGEpO1xuICAgIGNvbnN0IG51bSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhudW0pO1xuICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCAwLCBCaWdJbnQoQUFEID8gQUFELmxlbmd0aCA6IDApLCB0cnVlKTtcbiAgICBzZXRCaWdVaW50NjQodmlldywgOCwgQmlnSW50KGRhdGEubGVuZ3RoKSwgdHJ1ZSk7XG4gICAgaC51cGRhdGUobnVtKTtcbiAgICBjb25zdCByZXMgPSBoLmRpZ2VzdCgpO1xuICAgIGF1dGhLZXkuZmlsbCgwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBBRUFEIGFsZ29yaXRobSBmcm9tIFJGQyA4NDM5LlxuICogU2Fsc2EyMCBhbmQgY2hhY2hhIChSRkMgODQzOSkgdXNlIHBvbHkxMzA1IGRpZmZlcmVudGx5LlxuICogV2UgY291bGQgaGF2ZSBjb21wb3NlZCB0aGVtIHNpbWlsYXIgdG86XG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL3NjdXJlLWJhc2UvYmxvYi9iMjY2YzczZGRlOTc3YjFkZDdlZjQwZWY3YTIzY2MxNWFhYjUyNmIzL2luZGV4LnRzI0wyNTBcbiAqIEJ1dCBpdCdzIGhhcmQgYmVjYXVzZSBvZiBhdXRoS2V5OlxuICogSW4gc2Fsc2EyMCwgYXV0aEtleSBjaGFuZ2VzIHBvc2l0aW9uIGluIHNhbHNhIHN0cmVhbS5cbiAqIEluIGNoYWNoYSwgYXV0aEtleSBjYW4ndCBiZSBjb21wdXRlZCBpbnNpZGUgY29tcHV0ZVRhZywgaXQgbW9kaWZpZXMgdGhlIGNvdW50ZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBfcG9seTEzMDVfYWVhZCA9ICh4b3JTdHJlYW0pID0+IChrZXksIG5vbmNlLCBBQUQpID0+IHtcbiAgICBjb25zdCB0YWdMZW5ndGggPSAxNjtcbiAgICBhYnl0ZXMoa2V5LCAzMik7XG4gICAgYWJ5dGVzKG5vbmNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0OiAocGxhaW50ZXh0LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBsZW5ndGggPSBwbGFpbnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgY2xlbmd0aCA9IHBsZW5ndGggKyB0YWdMZW5ndGg7XG4gICAgICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgYWJ5dGVzKG91dHB1dCwgY2xlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBuZXcgVWludDhBcnJheShjbGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhvclN0cmVhbShrZXksIG5vbmNlLCBwbGFpbnRleHQsIG91dHB1dCwgMSk7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBjb21wdXRlVGFnKHhvclN0cmVhbSwga2V5LCBub25jZSwgb3V0cHV0LnN1YmFycmF5KDAsIC10YWdMZW5ndGgpLCBBQUQpO1xuICAgICAgICAgICAgb3V0cHV0LnNldCh0YWcsIHBsZW5ndGgpOyAvLyBhcHBlbmQgdGFnXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICBkZWNyeXB0OiAoY2lwaGVydGV4dCwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbGVuZ3RoID0gY2lwaGVydGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBwbGVuZ3RoID0gY2xlbmd0aCAtIHRhZ0xlbmd0aDtcbiAgICAgICAgICAgIGlmIChjbGVuZ3RoIDwgdGFnTGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZW5jcnlwdGVkIGRhdGEgbXVzdCBiZSBhdCBsZWFzdCAke3RhZ0xlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICBhYnl0ZXMob3V0cHV0LCBwbGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KHBsZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgLXRhZ0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBwYXNzZWRUYWcgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KC10YWdMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgdGFnID0gY29tcHV0ZVRhZyh4b3JTdHJlYW0sIGtleSwgbm9uY2UsIGRhdGEsIEFBRCk7XG4gICAgICAgICAgICBpZiAoIWVxdWFsQnl0ZXMocGFzc2VkVGFnLCB0YWcpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0YWcnKTtcbiAgICAgICAgICAgIHhvclN0cmVhbShrZXksIG5vbmNlLCBkYXRhLCBvdXRwdXQsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbi8qKlxuICogQ2hhQ2hhMjAtUG9seTEzMDUgZnJvbSBSRkMgODQzOS5cbiAqIFdpdGggMTItYnl0ZSBub25jZSwgaXQncyBub3Qgc2FmZSB0byB1c2UgZmlsbCBpdCB3aXRoIHJhbmRvbSAoQ1NQUk5HKSwgZHVlIHRvIGNvbGxpc2lvbiBjaGFuY2UuXG4gKi9cbmV4cG9ydCBjb25zdCBjaGFjaGEyMHBvbHkxMzA1ID0gLyogQF9fUFVSRV9fICovIHdyYXBDaXBoZXIoeyBibG9ja1NpemU6IDY0LCBub25jZUxlbmd0aDogMTIsIHRhZ0xlbmd0aDogMTYgfSwgX3BvbHkxMzA1X2FlYWQoY2hhY2hhMjApKTtcbi8qKlxuICogWENoYUNoYTIwLVBvbHkxMzA1IGV4dGVuZGVkLW5vbmNlIGNoYWNoYS5cbiAqIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXhjaGFjaGFcbiAqIFdpdGggMjQtYnl0ZSBub25jZSwgaXQncyBzYWZlIHRvIHVzZSBmaWxsIGl0IHdpdGggcmFuZG9tIChDU1BSTkcpLlxuICovXG5leHBvcnQgY29uc3QgeGNoYWNoYTIwcG9seTEzMDUgPSAvKiBAX19QVVJFX18gKi8gd3JhcENpcGhlcih7IGJsb2NrU2l6ZTogNjQsIG5vbmNlTGVuZ3RoOiAyNCwgdGFnTGVuZ3RoOiAxNiB9LCBfcG9seTEzMDVfYWVhZCh4Y2hhY2hhMjApKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYWNoYS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/chacha.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/utils.js":
/*!****************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/utils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToUtf8: () => (/* binding */ bytesToUtf8),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   setBigUint64: () => (/* binding */ setBigUint64),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u16: () => (/* binding */ u16),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u64Lengths: () => (/* binding */ u64Lengths),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapCipher: () => (/* binding */ wrapCipher)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/_assert.js\");\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u16 = (arr) => new Uint16Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 2));\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`string expected, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    else if ((0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(data))\n        data = data.slice();\n    else\n        throw new Error(`Uint8Array expected, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts == null || typeof opts !== 'object')\n        throw new Error('options must be defined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n// For runtime check if class implements interface\nclass Hash {\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nconst wrapCipher = (params, c) => {\n    Object.assign(c, params);\n    return c;\n};\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\nfunction u64Lengths(ciphertext, AAD) {\n    const num = new Uint8Array(16);\n    const view = createView(num);\n    setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    setBigUint64(view, 8, BigInt(ciphertext.length), true);\n    return num;\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3dEO0FBQ3hEO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxpREFBTTtBQUNWO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0QsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGFBQWEsbURBQU87QUFDcEI7QUFDQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBLFFBQVEsaURBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9lc20vdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWNpcGhlcnMgLSBNSVQgTGljZW5zZSAoYykgMjAyMyBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGJ5dGVzIGFzIGFieXRlcywgaXNCeXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUxNiA9IChhcnIpID0+IG5ldyBVaW50MTZBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDIpKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGNpcGhlcnM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgX0E6IDY1LCBfRjogNzAsIF9hOiA5NywgX2Y6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl8wICYmIGNoYXIgPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2hhciAtIGFzY2lpcy5fMDtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX0EgJiYgY2hhciA8PSBhc2NpaXMuX0YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX2EgJiYgY2hhciA8PSBhc2NpaXMuX2YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fYSAtIDEwKTtcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RyaW5nIGV4cGVjdGVkLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb1V0ZjgobmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKSkgLy8gJ2FiYydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9VdGY4KGJ5dGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBlbHNlIGlmIChpc0J5dGVzKGRhdGEpKVxuICAgICAgICBkYXRhID0gZGF0YS5zbGljZSgpO1xuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVaW50OEFycmF5IGV4cGVjdGVkLCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PSBudWxsIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG4vLyBDb21wYXJlcyAyIHU4YS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWVcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmV4cG9ydCBjb25zdCB3cmFwQ2lwaGVyID0gKHBhcmFtcywgYykgPT4ge1xuICAgIE9iamVjdC5hc3NpZ24oYywgcGFyYW1zKTtcbiAgICByZXR1cm4gYztcbn07XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5leHBvcnQgZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1NjRMZW5ndGhzKGNpcGhlcnRleHQsIEFBRCkge1xuICAgIGNvbnN0IG51bSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBjb25zdCB2aWV3ID0gY3JlYXRlVmlldyhudW0pO1xuICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCAwLCBCaWdJbnQoQUFEID8gQUFELmxlbmd0aCA6IDApLCB0cnVlKTtcbiAgICBzZXRCaWdVaW50NjQodmlldywgOCwgQmlnSW50KGNpcGhlcnRleHQubGVuZ3RoKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG51bTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/utils.js":
/*!************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/ciphers/utils.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.u64Lengths = exports.setBigUint64 = exports.wrapCipher = exports.Hash = exports.equalBytes = exports.checkOpts = exports.concatBytes = exports.toBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.numberToBytesBE = exports.bytesToNumberBE = exports.hexToNumber = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.createView = exports.u32 = exports.u16 = exports.u8 = void 0;\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/_assert.js\");\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u16 = (arr) => new Uint16Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 2));\nexports.u16 = u16;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// big-endian hardware is rare. Just in case someone still decides to run ciphers:\n// early-throw an error because we don't support BE yet.\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!exports.isLE)\n    throw new Error('Non little-endian hardware is not supported');\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0, _assert_js_1.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\nexports.hexToNumber = hexToNumber;\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexports.bytesToNumberBE = bytesToNumberBE;\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexports.numberToBytesBE = numberToBytesBE;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`string expected, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\nexports.bytesToUtf8 = bytesToUtf8;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    else if ((0, _assert_js_1.isBytes)(data))\n        data = data.slice();\n    else\n        throw new Error(`Uint8Array expected, got ${typeof data}`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0, _assert_js_1.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexports.concatBytes = concatBytes;\nfunction checkOpts(defaults, opts) {\n    if (opts == null || typeof opts !== 'object')\n        throw new Error('options must be defined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\nexports.equalBytes = equalBytes;\n// For runtime check if class implements interface\nclass Hash {\n}\nexports.Hash = Hash;\n/**\n * @__NO_SIDE_EFFECTS__\n */\nconst wrapCipher = (params, c) => {\n    Object.assign(c, params);\n    return c;\n};\nexports.wrapCipher = wrapCipher;\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\nexports.setBigUint64 = setBigUint64;\nfunction u64Lengths(ciphertext, AAD) {\n    const num = new Uint8Array(16);\n    const view = (0, exports.createView)(num);\n    setBigUint64(view, 0, BigInt(AAD ? AAD.length : 0), true);\n    setBigUint64(view, 8, BigInt(ciphertext.length), true);\n    return num;\n}\nexports.u64Lengths = u64Lengths;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jaXBoZXJzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLFlBQVksR0FBRyxrQkFBa0IsR0FBRyxpQkFBaUIsR0FBRyxtQkFBbUIsR0FBRyxlQUFlLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsWUFBWSxHQUFHLGtCQUFrQixHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsVUFBVTtBQUNsYjtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLDRHQUFjO0FBQzNDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRCwwREFBMEQ7QUFDMUQ7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnU2NExlbmd0aHMgPSBleHBvcnRzLnNldEJpZ1VpbnQ2NCA9IGV4cG9ydHMud3JhcENpcGhlciA9IGV4cG9ydHMuSGFzaCA9IGV4cG9ydHMuZXF1YWxCeXRlcyA9IGV4cG9ydHMuY2hlY2tPcHRzID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb1V0ZjggPSBleHBvcnRzLnV0ZjhUb0J5dGVzID0gZXhwb3J0cy5hc3luY0xvb3AgPSBleHBvcnRzLm5leHRUaWNrID0gZXhwb3J0cy5udW1iZXJUb0J5dGVzQkUgPSBleHBvcnRzLmJ5dGVzVG9OdW1iZXJCRSA9IGV4cG9ydHMuaGV4VG9OdW1iZXIgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmlzTEUgPSBleHBvcnRzLmNyZWF0ZVZpZXcgPSBleHBvcnRzLnUzMiA9IGV4cG9ydHMudTE2ID0gZXhwb3J0cy51OCA9IHZvaWQgMDtcbi8qISBub2JsZS1jaXBoZXJzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjMgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy51OCA9IHU4O1xuY29uc3QgdTE2ID0gKGFycikgPT4gbmV3IFVpbnQxNkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gMikpO1xuZXhwb3J0cy51MTYgPSB1MTY7XG5jb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG5leHBvcnRzLnUzMiA9IHUzMjtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy5jcmVhdGVWaWV3ID0gY3JlYXRlVmlldztcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gY2lwaGVyczpcbi8vIGVhcmx5LXRocm93IGFuIGVycm9yIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBCRSB5ZXQuXG5leHBvcnRzLmlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFleHBvcnRzLmlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykoYnl0ZXMpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG5mdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG5leHBvcnRzLmhleFRvTnVtYmVyID0gaGV4VG9OdW1iZXI7XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXJCRSA9IGJ5dGVzVG9OdW1iZXJCRTtcbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydHMubnVtYmVyVG9CeXRlc0JFID0gbnVtYmVyVG9CeXRlc0JFO1xuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG5leHBvcnRzLm5leHRUaWNrID0gbmV4dFRpY2s7XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5hc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgKDAsIGV4cG9ydHMubmV4dFRpY2spKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuZXhwb3J0cy5hc3luY0xvb3AgPSBhc3luY0xvb3A7XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuZXhwb3J0cy51dGY4VG9CeXRlcyA9IHV0ZjhUb0J5dGVzO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvVXRmOChuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pKSAvLyAnYWJjJ1xuICovXG5mdW5jdGlvbiBieXRlc1RvVXRmOChieXRlcykge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuZXhwb3J0cy5ieXRlc1RvVXRmOCA9IGJ5dGVzVG9VdGY4O1xuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBlbHNlIGlmICgoMCwgX2Fzc2VydF9qc18xLmlzQnl0ZXMpKGRhdGEpKVxuICAgICAgICBkYXRhID0gZGF0YS5zbGljZSgpO1xuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVaW50OEFycmF5IGV4cGVjdGVkLCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbmV4cG9ydHMudG9CeXRlcyA9IHRvQnl0ZXM7XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT0gbnVsbCB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0cy5jaGVja09wdHMgPSBjaGVja09wdHM7XG4vLyBDb21wYXJlcyAyIHU4YS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWVcbmZ1bmN0aW9uIGVxdWFsQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZGlmZiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBkaWZmIHw9IGFbaV0gXiBiW2ldO1xuICAgIHJldHVybiBkaWZmID09PSAwO1xufVxuZXhwb3J0cy5lcXVhbEJ5dGVzID0gZXF1YWxCeXRlcztcbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5jbGFzcyBIYXNoIHtcbn1cbmV4cG9ydHMuSGFzaCA9IEhhc2g7XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmNvbnN0IHdyYXBDaXBoZXIgPSAocGFyYW1zLCBjKSA9PiB7XG4gICAgT2JqZWN0LmFzc2lnbihjLCBwYXJhbXMpO1xuICAgIHJldHVybiBjO1xufTtcbmV4cG9ydHMud3JhcENpcGhlciA9IHdyYXBDaXBoZXI7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuZXhwb3J0cy5zZXRCaWdVaW50NjQgPSBzZXRCaWdVaW50NjQ7XG5mdW5jdGlvbiB1NjRMZW5ndGhzKGNpcGhlcnRleHQsIEFBRCkge1xuICAgIGNvbnN0IG51bSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBjb25zdCB2aWV3ID0gKDAsIGV4cG9ydHMuY3JlYXRlVmlldykobnVtKTtcbiAgICBzZXRCaWdVaW50NjQodmlldywgMCwgQmlnSW50KEFBRCA/IEFBRC5sZW5ndGggOiAwKSwgdHJ1ZSk7XG4gICAgc2V0QmlnVWludDY0KHZpZXcsIDgsIEJpZ0ludChjaXBoZXJ0ZXh0Lmxlbmd0aCksIHRydWUpO1xuICAgIHJldHVybiBudW07XG59XG5leHBvcnRzLnU2NExlbmd0aHMgPSB1NjRMZW5ndGhzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/ciphers/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/_shortw_utils.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/_shortw_utils.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createCurve = exports.getHash = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst hmac_1 = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js\");\nconst weierstrass_js_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/weierstrass.js\");\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),\n        randomBytes: utils_1.randomBytes,\n    };\n}\nexports.getHash = getHash;\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\nexports.createCurve = createCurve;\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxlQUFlO0FBQ3JDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHlJQUFvQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQywySUFBcUI7QUFDN0MseUJBQXlCLG1CQUFPLENBQUMscUlBQTJCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxpRUFBaUUsK0JBQStCO0FBQ2hHLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9fc2hvcnR3X3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVDdXJ2ZSA9IGV4cG9ydHMuZ2V0SGFzaCA9IHZvaWQgMDtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IGhtYWNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2htYWNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCB3ZWllcnN0cmFzc19qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanNcIik7XG4vLyBjb25uZWN0cyBub2JsZS1jdXJ2ZXMgdG8gbm9ibGUtaGFzaGVzXG5mdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiAoMCwgaG1hY18xLmhtYWMpKGhhc2gsIGtleSwgKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKC4uLm1zZ3MpKSxcbiAgICAgICAgcmFuZG9tQnl0ZXM6IHV0aWxzXzEucmFuZG9tQnl0ZXMsXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0SGFzaCA9IGdldEhhc2g7XG5mdW5jdGlvbiBjcmVhdGVDdXJ2ZShjdXJ2ZURlZiwgZGVmSGFzaCkge1xuICAgIGNvbnN0IGNyZWF0ZSA9IChoYXNoKSA9PiAoMCwgd2VpZXJzdHJhc3NfanNfMS53ZWllcnN0cmFzcykoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVDdXJ2ZSA9IGNyZWF0ZUN1cnZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/curve.js":
/*!********************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/abstract/curve.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateBasic = exports.wNAF = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nconst modular_js_1 = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/modular.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/utils.js\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nexports.wNAF = wNAF;\nfunction validateBasic(curve) {\n    (0, modular_js_1.validateField)(curve.Fp);\n    (0, utils_js_1.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\nexports.validateBasic = validateBasic;\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcsWUFBWTtBQUNwQztBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsb0hBQWM7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsZ0hBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQseUNBQXlDO0FBQ3pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsS0FBSztBQUNMO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvY3VydmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlQmFzaWMgPSBleHBvcnRzLndOQUYgPSB2b2lkIDA7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuY29uc3QgbW9kdWxhcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxhci5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmFuZG9tIHBvaW50IGluc2lkZSBjdXJyZW50IHdpbmRvdyB0byBmLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgcHJlY29tcHV0ZXNNYXAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVyA9IFAuX1dJTkRPV19TSVpFIHx8IDE7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcHJlY29tcHV0ZXNNYXAuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb21wdXRlc01hcC5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLndOQUYgPSB3TkFGO1xuZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgICgwLCBtb2R1bGFyX2pzXzEudmFsaWRhdGVGaWVsZCkoY3VydmUuRnApO1xuICAgICgwLCB1dGlsc19qc18xLnZhbGlkYXRlT2JqZWN0KShjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLigwLCBtb2R1bGFyX2pzXzEubkxlbmd0aCkoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG5leHBvcnRzLnZhbGlkYXRlQmFzaWMgPSB2YWxpZGF0ZUJhc2ljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/hash-to-curve.js":
/*!****************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/abstract/hash-to-curve.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;\nconst modular_js_1 = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/modular.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/utils.js\");\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array)\n        return dst;\n    if (typeof dst === 'string')\n        return (0, utils_js_1.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = utils_js_1.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0, utils_js_1.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\nexports.expand_message_xmd = expand_message_xmd;\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\nexports.expand_message_xof = expand_message_xof;\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0, utils_js_1.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nexports.hash_to_field = hash_to_field;\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nexports.isogenyMap = isogenyMap;\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\nexports.createHasher = createHasher;\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRywwQkFBMEIsR0FBRywwQkFBMEI7QUFDM0gscUJBQXFCLG1CQUFPLENBQUMsb0hBQWM7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsZ0hBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU8sU0FBUyxPQUFPO0FBQ3hFO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckMsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2RUFBNkU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpREFBaUQ7QUFDakQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0NBQWtDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdDQUF3QztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUhhc2hlciA9IGV4cG9ydHMuaXNvZ2VueU1hcCA9IGV4cG9ydHMuaGFzaF90b19maWVsZCA9IGV4cG9ydHMuZXhwYW5kX21lc3NhZ2VfeG9mID0gZXhwb3J0cy5leHBhbmRfbWVzc2FnZV94bWQgPSB2b2lkIDA7XG5jb25zdCBtb2R1bGFyX2pzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGFyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVEU1QoZHN0KSB7XG4gICAgaWYgKGRzdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgaWYgKHR5cGVvZiBkc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEudXRmOFRvQnl0ZXMpKGRzdCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEU1QgbXVzdCBiZSBVaW50OEFycmF5IG9yIHN0cmluZycpO1xufVxuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMSA8PCAoOCAqIGxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgSTJPU1AgY2FsbDogdmFsdWU9JHt2YWx1ZX0gbGVuZ3RoPSR7bGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc1tpXSA9IHZhbHVlICYgMHhmZjtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzKTtcbn1cbmZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhW2ldIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGlzQnl0ZXMoaXRlbSkge1xuICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBpc051bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHNcbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjFcbmZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc0J5dGVzKERTVCk7XG4gICAgaXNOdW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKCgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSgoMCwgdXRpbHNfanNfMS51dGY4VG9CeXRlcykoJ0gyQy1PVkVSU0laRS1EU1QtJyksIERTVCkpO1xuICAgIGNvbnN0IHsgb3V0cHV0TGVuOiBiX2luX2J5dGVzLCBibG9ja0xlbjogcl9pbl9ieXRlcyB9ID0gSDtcbiAgICBjb25zdCBlbGwgPSBNYXRoLmNlaWwobGVuSW5CeXRlcyAvIGJfaW5fYnl0ZXMpO1xuICAgIGlmIChlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB4bWQgbGVuZ3RoJyk7XG4gICAgY29uc3QgRFNUX3ByaW1lID0gKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSCgoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKGJfMCwgaTJvc3AoMSwgMSksIERTVF9wcmltZSkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RyeG9yKGJfMCwgYltpIC0gMV0pLCBpMm9zcChpICsgMSwgMSksIERTVF9wcmltZV07XG4gICAgICAgIGJbaV0gPSBIKCgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSAoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG5leHBvcnRzLmV4cGFuZF9tZXNzYWdlX3htZCA9IGV4cGFuZF9tZXNzYWdlX3htZDtcbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuLy8gMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4vLyAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuLy8gICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4yXG5mdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNCeXRlcyhEU1QpO1xuICAgIGlzTnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKCgwLCB1dGlsc19qc18xLnV0ZjhUb0J5dGVzKSgnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbmV4cG9ydHMuZXhwYW5kX21lc3NhZ2VfeG9mID0gZXhwYW5kX21lc3NhZ2VfeG9mO1xuLyoqXG4gKiBIYXNoZXMgYXJiaXRyYXJ5LWxlbmd0aCBieXRlIHN0cmluZ3MgdG8gYSBsaXN0IG9mIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9mIGEgZmluaXRlIGZpZWxkIEZcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4yXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBoYXNoX3RvX2ZpZWxkKG1zZywgY291bnQsIG9wdGlvbnMpIHtcbiAgICAoMCwgdXRpbHNfanNfMS52YWxpZGF0ZU9iamVjdCkob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmdPclVpbnQ4QXJyYXknLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc051bShjb3VudCk7XG4gICAgY29uc3QgRFNUID0gdmFsaWRhdGVEU1QoX0RTVCk7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gKDAsIG1vZHVsYXJfanNfMS5tb2QpKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0cy5oYXNoX3RvX2ZpZWxkID0gaGFzaF90b19maWVsZDtcbmZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydHMuaXNvZ2VueU1hcCA9IGlzb2dlbnlNYXA7XG5mdW5jdGlvbiBjcmVhdGVIYXNoZXIoUG9pbnQsIG1hcFRvQ3VydmUsIGRlZikge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gaGFzaF90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMiwgeyAuLi5kZWYsIERTVDogZGVmLkRTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKTtcbiAgICAgICAgICAgIGNvbnN0IHUxID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMV0pKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSB1MC5hZGQodTEpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBlbmNvZGVfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgZW5jb2RlVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgeyAuLi5kZWYsIERTVDogZGVmLmVuY29kZURTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZUhhc2hlciA9IGNyZWF0ZUhhc2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/modular.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/abstract/modular.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\nexports.mod = mod;\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\nexports.pow = pow;\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\nexports.pow2 = pow2;\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nexports.invert = invert;\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nexports.tonelliShanks = tonelliShanks;\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\nexports.FpSqrt = FpSqrt;\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0, utils_js_1.validateObject)(field, opts);\n}\nexports.validateField = validateField;\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\nexports.FpPow = FpPow;\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nexports.FpInvertBatch = FpInvertBatch;\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\nexports.FpDiv = FpDiv;\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\nexports.FpIsSquare = FpIsSquare;\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\nexports.nLength = nLength;\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0, utils_js_1.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nexports.Field = Field;\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexports.FpSqrtOdd = FpSqrtOdd;\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\nexports.FpSqrtEven = FpSqrtEven;\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\nexports.hashToPrivateScalar = hashToPrivateScalar;\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\nexports.getFieldBytesLength = getFieldBytesLength;\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\nexports.getMinHashLength = getMinHashLength;\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);\n}\nexports.mapHashToField = mapHashToField;\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyx3QkFBd0IsR0FBRywyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyxrQkFBa0IsR0FBRyxpQkFBaUIsR0FBRyxhQUFhLEdBQUcsZUFBZSxHQUFHLGtCQUFrQixHQUFHLGFBQWEsR0FBRyxxQkFBcUIsR0FBRyxhQUFhLEdBQUcscUJBQXFCLEdBQUcsb0JBQW9CLEdBQUcsY0FBYyxHQUFHLHFCQUFxQixHQUFHLGNBQWMsR0FBRyxZQUFZLEdBQUcsV0FBVyxHQUFHLFdBQVc7QUFDelo7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLGdIQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsUUFBUSxNQUFNLE9BQU87QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU8sNEJBQTRCLFFBQVE7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU8sNEJBQTRCLElBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1hcEhhc2hUb0ZpZWxkID0gZXhwb3J0cy5nZXRNaW5IYXNoTGVuZ3RoID0gZXhwb3J0cy5nZXRGaWVsZEJ5dGVzTGVuZ3RoID0gZXhwb3J0cy5oYXNoVG9Qcml2YXRlU2NhbGFyID0gZXhwb3J0cy5GcFNxcnRFdmVuID0gZXhwb3J0cy5GcFNxcnRPZGQgPSBleHBvcnRzLkZpZWxkID0gZXhwb3J0cy5uTGVuZ3RoID0gZXhwb3J0cy5GcElzU3F1YXJlID0gZXhwb3J0cy5GcERpdiA9IGV4cG9ydHMuRnBJbnZlcnRCYXRjaCA9IGV4cG9ydHMuRnBQb3cgPSBleHBvcnRzLnZhbGlkYXRlRmllbGQgPSBleHBvcnRzLmlzTmVnYXRpdmVMRSA9IGV4cG9ydHMuRnBTcXJ0ID0gZXhwb3J0cy50b25lbGxpU2hhbmtzID0gZXhwb3J0cy5pbnZlcnQgPSBleHBvcnRzLnBvdzIgPSBleHBvcnRzLnBvdyA9IGV4cG9ydHMubW9kID0gdm9pZCAwO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzIGZvciBtb2R1bGFyIGFyaXRobWV0aWNzIGFuZCBmaW5pdGUgZmllbGRzXG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gQmlnSW50KDkpLCBfMTZuID0gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG5leHBvcnRzLm1vZCA9IG1vZDtcbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbi8vIFRPRE86IHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxuZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5wb3cgPSBwb3c7XG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5mdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5wb3cyID0gcG93Mjtcbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuIHx8IG1vZHVsbyA8PSBfMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICAvLyBFdWNsaWRlYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG5leHBvcnRzLmludmVydCA9IGludmVydDtcbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbmV4cG9ydHMudG9uZWxsaVNoYW5rcyA9IHRvbmVsbGlTaGFua3M7XG5mdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAgICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbmV4cG9ydHMuRnBTcXJ0ID0gRnBTcXJ0O1xuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5jb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuZXhwb3J0cy5pc05lZ2F0aXZlTEUgPSBpc05lZ2F0aXZlTEU7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuICgwLCB1dGlsc19qc18xLnZhbGlkYXRlT2JqZWN0KShmaWVsZCwgb3B0cyk7XG59XG5leHBvcnRzLnZhbGlkYXRlRmllbGQgPSB2YWxpZGF0ZUZpZWxkO1xuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXG4gICAgLy8gVE9ETzogYmVuY2htYXJrIVxuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIGYuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gZi5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcbiAgICAgICAgZCA9IGYuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbmV4cG9ydHMuRnBQb3cgPSBGcFBvdztcbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogYGludigwKWAgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaGVyZTogbWFrZSBzdXJlIHRvIHRocm93IGFuIGVycm9yLlxuICovXG5mdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydHMuRnBJbnZlcnRCYXRjaCA9IEZwSW52ZXJ0QmF0Y2g7XG5mdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbmV4cG9ydHMuRnBEaXYgPSBGcERpdjtcbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG5leHBvcnRzLkZwSXNTcXVhcmUgPSBGcElzU3F1YXJlO1xuLy8gQ1VSVkUubiBsZW5ndGhzXG5mdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuZXhwb3J0cy5uTGVuZ3RoID0gbkxlbmd0aDtcbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS4gKipOb24tcHJpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLioqXG4gKiBEbyBub3QgaW5pdCBpbiBsb29wOiBzbG93LiBWZXJ5IGZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqICogYikgc2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogKiBjKSBPYmplY3QuZnJlZXplXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6ICgwLCB1dGlsc19qc18xLmJpdE1hc2spKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAke3R5cGVvZiBudW19YCk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiBzcXJ0UChmLCBuKSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/ICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNMRSkobnVtLCBCWVRFUykgOiAoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzQkUpKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyTEUpKGJ5dGVzKSA6ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0cy5GaWVsZCA9IEZpZWxkO1xuZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydHMuRnBTcXJ0T2RkID0gRnBTcXJ0T2RkO1xuZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG5leHBvcnRzLkZwU3FydEV2ZW4gPSBGcFNxcnRFdmVuO1xuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5mdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyTEUpKGhhc2gpIDogKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG5leHBvcnRzLmhhc2hUb1ByaXZhdGVTY2FsYXIgPSBoYXNoVG9Qcml2YXRlU2NhbGFyO1xuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5mdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbmV4cG9ydHMuZ2V0RmllbGRCeXRlc0xlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGg7XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuZXhwb3J0cy5nZXRNaW5IYXNoTGVuZ3RoID0gZ2V0TWluSGFzaExlbmd0aDtcbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtsZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkoa2V5KSA6ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gKDAsIHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0xFKShyZWR1Y2VkLCBmaWVsZExlbikgOiAoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzQkUpKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbmV4cG9ydHMubWFwSGFzaFRvRmllbGQgPSBtYXBIYXNoVG9GaWVsZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/utils.js":
/*!********************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/abstract/utils.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nexports.numberToHexUnpadded = numberToHexUnpadded;\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\nexports.hexToNumber = hexToNumber;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexports.bytesToNumberBE = bytesToNumberBE;\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexports.bytesToNumberLE = bytesToNumberLE;\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexports.numberToBytesBE = numberToBytesBE;\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\nexports.numberToBytesLE = numberToBytesLE;\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\nexports.numberToVarBytesBE = numberToVarBytesBE;\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\nexports.ensureBytes = ensureBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\nexports.equalBytes = equalBytes;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\nexports.bitLen = bitLen;\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\nexports.bitGet = bitGet;\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\nexports.bitSet = bitSet;\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\nexports.createHmacDrbg = createHmacDrbg;\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\nexports.validateObject = validateObject;\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsc0JBQXNCLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLDBCQUEwQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLDJCQUEyQixHQUFHLGtCQUFrQjtBQUM5YTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLGlDQUFpQyxJQUFJLFlBQVksRUFBRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU8sV0FBVyxnQkFBZ0IsYUFBYSxJQUFJO0FBQzlFO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQixHQUFHLEtBQUssR0FBRyxXQUFXLGNBQWMsS0FBSztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsY0FBYyxXQUFXLFdBQVcsWUFBWSxJQUFJO0FBQ3BELGtDQUFrQyxvQkFBb0IsSUFBSSxhQUFhLEdBQUc7QUFDMUU7QUFDQSxrQ0FBa0MsVUFBVSxJQUFJLFNBQVM7QUFDekQsa0NBQWtDLG9CQUFvQixJQUFJLFNBQVM7QUFDbkUsa0NBQWtDLDJCQUEyQjtBQUM3RCxrQ0FBa0Msd0JBQXdCO0FBQzFEIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gZXhwb3J0cy5jcmVhdGVIbWFjRHJiZyA9IGV4cG9ydHMuYml0TWFzayA9IGV4cG9ydHMuYml0U2V0ID0gZXhwb3J0cy5iaXRHZXQgPSBleHBvcnRzLmJpdExlbiA9IGV4cG9ydHMudXRmOFRvQnl0ZXMgPSBleHBvcnRzLmVxdWFsQnl0ZXMgPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy5lbnN1cmVCeXRlcyA9IGV4cG9ydHMubnVtYmVyVG9WYXJCeXRlc0JFID0gZXhwb3J0cy5udW1iZXJUb0J5dGVzTEUgPSBleHBvcnRzLm51bWJlclRvQnl0ZXNCRSA9IGV4cG9ydHMuYnl0ZXNUb051bWJlckxFID0gZXhwb3J0cy5ieXRlc1RvTnVtYmVyQkUgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmhleFRvTnVtYmVyID0gZXhwb3J0cy5udW1iZXJUb0hleFVucGFkZGVkID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gdm9pZCAwO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG5mdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZXhwb3J0cy5udW1iZXJUb0hleFVucGFkZGVkID0gbnVtYmVyVG9IZXhVbnBhZGRlZDtcbmZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEJpZyBFbmRpYW5cbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cbmV4cG9ydHMuaGV4VG9OdW1iZXIgPSBoZXhUb051bWJlcjtcbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb051bWJlckJFID0gYnl0ZXNUb051bWJlckJFO1xuZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0cy5ieXRlc1RvTnVtYmVyTEUgPSBieXRlc1RvTnVtYmVyTEU7XG5mdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnRzLm51bWJlclRvQnl0ZXNCRSA9IG51bWJlclRvQnl0ZXNCRTtcbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuZXhwb3J0cy5udW1iZXJUb0J5dGVzTEUgPSBudW1iZXJUb0J5dGVzTEU7XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG5leHBvcnRzLm51bWJlclRvVmFyQnl0ZXNCRSA9IG51bWJlclRvVmFyQnl0ZXNCRTtcbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1OGEoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmVuc3VyZUJ5dGVzID0gZW5zdXJlQnl0ZXM7XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuZnVuY3Rpb24gZXF1YWxCeXRlcyhiMSwgYjIpIHtcbiAgICAvLyBXZSBkb24ndCBjYXJlIGFib3V0IHRpbWluZyBhdHRhY2tzIGhlcmVcbiAgICBpZiAoYjEubGVuZ3RoICE9PSBiMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIxLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoYjFbaV0gIT09IGIyW2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5lcXVhbEJ5dGVzID0gZXF1YWxCeXRlcztcbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG4vLyBCaXQgb3BlcmF0aW9uc1xuLyoqXG4gKiBDYWxjdWxhdGVzIGFtb3VudCBvZiBiaXRzIGluIGEgYmlnaW50LlxuICogU2FtZSBhcyBgbi50b1N0cmluZygyKS5sZW5ndGhgXG4gKi9cbmZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuZXhwb3J0cy5iaXRMZW4gPSBiaXRMZW47XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuZXhwb3J0cy5iaXRHZXQgPSBiaXRHZXQ7XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuY29uc3QgYml0U2V0ID0gKG4sIHBvcywgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn07XG5leHBvcnRzLmJpdFNldCA9IGJpdFNldDtcbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuZXhwb3J0cy5iaXRNYXNrID0gYml0TWFzaztcbi8vIERSQkdcbmNvbnN0IHU4biA9IChkYXRhKSA9PiBuZXcgVWludDhBcnJheShkYXRhKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuZXhwb3J0cy5jcmVhdGVIbWFjRHJiZyA9IGNyZWF0ZUhtYWNEcmJnO1xuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5mdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7dHlwZX1cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtICR7U3RyaW5nKGZpZWxkTmFtZSl9PSR7dmFsfSAoJHt0eXBlb2YgdmFsfSksIGV4cGVjdGVkICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbmV4cG9ydHMudmFsaWRhdGVPYmplY3QgPSB2YWxpZGF0ZU9iamVjdDtcbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/weierstrass.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/abstract/weierstrass.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\nconst mod = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/modular.js\");\nconst ut = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/utils.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/utils.js\");\nconst curve_js_1 = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/curve.js\");\nfunction validatePointOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexports.DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = exports.DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = exports.DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = ut.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = mod.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return ut.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nexports.weierstrassPoints = weierstrassPoints;\nfunction validateOpts(curve) {\n    const opts = (0, curve_js_1.validateBasic)(curve);\n    ut.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return mod.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return mod.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = ut.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = ut.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return ut.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return exports.DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return ut.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = mod.getMinHashLength(CURVE.n);\n            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return ut.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);\n        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof exports.DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\nexports.weierstrass = weierstrass;\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\nexports.SWUFpSqrtRatio = SWUFpSqrtRatio;\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    mod.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\nexports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsc0JBQXNCLEdBQUcsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsV0FBVztBQUNwSDtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLG9IQUFjO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyxnSEFBWTtBQUMvQixtQkFBbUIsbUJBQU8sQ0FBQyxnSEFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyxnSEFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQSxRQUFRLHdDQUF3QztBQUNoRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMENBQTBDO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7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QyxrQ0FBa0M7QUFDbEMsdUNBQXVDO0FBQ3ZDLCtDQUErQyxrQkFBa0I7QUFDakUseUNBQXlDO0FBQ3pDLDJDQUEyQztBQUMzQyxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCLGdDQUFnQztBQUNoQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1FQUFtRTtBQUNuRSxtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQixtQ0FBbUM7QUFDbkMsZ0NBQWdDO0FBQ2hDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsbUNBQW1DO0FBQ25DLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsZ0JBQWdCLGlCQUFpQix1QkFBdUI7QUFDeEQsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QixzQ0FBc0M7QUFDdEMsd0NBQXdDO0FBQ3hDLGdEQUFnRDtBQUNoRCx1Q0FBdUM7QUFDdkMsNEJBQTRCO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1hcFRvQ3VydmVTaW1wbGVTV1UgPSBleHBvcnRzLlNXVUZwU3FydFJhdGlvID0gZXhwb3J0cy53ZWllcnN0cmFzcyA9IGV4cG9ydHMud2VpZXJzdHJhc3NQb2ludHMgPSBleHBvcnRzLkRFUiA9IHZvaWQgMDtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiXG5jb25zdCBtb2QgPSByZXF1aXJlKFwiLi9tb2R1bGFyLmpzXCIpO1xuY29uc3QgdXQgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IGN1cnZlX2pzXzEgPSByZXF1aXJlKFwiLi9jdXJ2ZS5qc1wiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9ICgwLCBjdXJ2ZV9qc18xLnZhbGlkYXRlQmFzaWMpKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGE6ICdmaWVsZCcsXG4gICAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6ICdhcnJheScsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxuICAgICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvLCBGcCwgYSB9ID0gb3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmRvbW9ycGhpc20gY2FuIG9ubHkgYmUgZGVmaW5lZCBmb3IgS29ibGl0eiBjdXJ2ZXMgdGhhdCBoYXZlIGE9MCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLmJldGEgIT09ICdiaWdpbnQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5zcGxpdFNjYWxhciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlbmRvbW9ycGhpc20gd2l0aCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbi8vIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXNcbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG5leHBvcnRzLkRFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IGV4cG9ydHMuREVSO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT09IDB4MDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlciB0YWcnKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YVsxXTtcbiAgICAgICAgY29uc3QgcmVzID0gZGF0YS5zdWJhcnJheSgyLCBsZW4gKyAyKTtcbiAgICAgICAgaWYgKCFsZW4gfHwgcmVzLmxlbmd0aCAhPT0gbGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHdyb25nIGxlbmd0aCcpO1xuICAgICAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAgICAgLy8gc2luY2Ugd2UgYWx3YXlzIHVzZSBwb3NpdGl2ZSBpbnRlZ2VycyBoZXJlLiBJdCBtdXN0IGFsd2F5cyBiZSBlbXB0eTpcbiAgICAgICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAgICAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgICAgIGlmIChyZXNbMF0gJiAwYjEwMDAwMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgIGlmIChyZXNbMF0gPT09IDB4MDAgJiYgIShyZXNbMV0gJiAwYjEwMDAwMDAwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgcmV0dXJuIHsgZDogYjJuKHJlcyksIGw6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTsgLy8gZCBpcyBkYXRhLCBsIGlzIGxlZnRcbiAgICB9LFxuICAgIHRvU2lnKGhleCkge1xuICAgICAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBleHBvcnRzLkRFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaDJiKGhleCkgOiBoZXg7XG4gICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndWk4YSBleHBlY3RlZCcpO1xuICAgICAgICBsZXQgbCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAobCA8IDIgfHwgZGF0YVswXSAhPSAweDMwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIHRhZycpO1xuICAgICAgICBpZiAoZGF0YVsxXSAhPT0gbCAtIDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGluY29ycmVjdCBsZW5ndGgnKTtcbiAgICAgICAgY29uc3QgeyBkOiByLCBsOiBzQnl0ZXMgfSA9IGV4cG9ydHMuREVSLl9wYXJzZUludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICAgICAgY29uc3QgeyBkOiBzLCBsOiByQnl0ZXNMZWZ0IH0gPSBleHBvcnRzLkRFUi5fcGFyc2VJbnQoc0J5dGVzKTtcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgciwgcyB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVybyBpZiBmaXJzdCBieXRlIGhhcyBuZWdhdGl2ZSBiaXQgZW5hYmxlZC4gTW9yZSBkZXRhaWxzIGluICdfcGFyc2VJbnQnXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcbiAgICAgICAgY29uc3QgaCA9IChudW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZShoKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNobCA9IHMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcmhsID0gci5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICAgICAgY29uc3QgcmwgPSBoKHJobCk7XG4gICAgICAgIHJldHVybiBgMzAke2gocmhsICsgc2hsICsgNCl9MDIke3JsfSR7cn0wMiR7c2x9JHtzfWA7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5mdW5jdGlvbiB3ZWllcnN0cmFzc1BvaW50cyhvcHRzKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZVBvaW50T3B0cyhvcHRzKTtcbiAgICBjb25zdCB7IEZwIH0gPSBDVVJWRTsgLy8gQWxsIGN1cnZlcyBoYXMgc2FtZSBmaWVsZCAvIGdyb3VwIGxlbmd0aCBhcyBmb3Igbm93LCBidXQgdGhleSBjYW4gZGlmZmVyXG4gICAgY29uc3QgdG9CeXRlcyA9IENVUlZFLnRvQnl0ZXMgfHxcbiAgICAgICAgKChfYywgcG9pbnQsIF9pc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHV0LmNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuICAgICAgICAoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGFcbiAgICAgKiBAcmV0dXJucyB5wrJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geDIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geDMgKyBhICogeCArIGJcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgd2hldGhlciB0aGUgcGFzc2VkIGN1cnZlIHBhcmFtcyBhcmUgdmFsaWQuXG4gICAgLy8gV2UgY2hlY2sgaWYgY3VydmUgZXF1YXRpb24gd29ya3MgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICAvLyBgYXNzZXJ0VmFsaWRpdHkoKWAgd29uJ3Qgd29yazogYGlzVG9yc2lvbkZyZWUoKWAgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGluIGJsczEyLTM4MS5cbiAgICAvLyBQcm9qZWN0aXZlUG9pbnQgY2xhc3MgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldC5cbiAgICBpZiAoIUZwLmVxbChGcC5zcXIoQ1VSVkUuR3kpLCB3ZWllcnN0cmFzc0VxdWF0aW9uKENVUlZFLkd4KSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGdlbmVyYXRvciBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgIC8vIFZhbGlkIGdyb3VwIGVsZW1lbnRzIHJlc2lkZSBpbiByYW5nZSAxLi5uLTFcbiAgICBmdW5jdGlvbiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUubjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0R0UobnVtKSB7XG4gICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHZhbGlkIGJpZ2ludDogMCA8IGJpZ2ludCA8IGN1cnZlLm4nKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGVzIGlmIHByaXYga2V5IGlzIHZhbGlkIGFuZCBjb252ZXJ0cyBpdCB0byBiaWdpbnQuXG4gICAgLy8gU3VwcG9ydHMgb3B0aW9ucyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgYW5kIHdyYXBQcml2YXRlS2V5LlxuICAgIGZ1bmN0aW9uIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBsZW5ndGhzLCBuQnl0ZUxlbmd0aCwgd3JhcFByaXZhdGVLZXksIG4gfSA9IENVUlZFO1xuICAgICAgICBpZiAobGVuZ3RocyAmJiB0eXBlb2Yga2V5ICE9PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiB1dC5ieXRlc1RvTnVtYmVyQkUoKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdwcml2YXRlIGtleScsIGtleSwgbkJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJpdmF0ZSBrZXkgbXVzdCBiZSAke25CeXRlTGVuZ3RofSBieXRlcywgaGV4IG9yIGJpZ2ludCwgbm90ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcFByaXZhdGVLZXkpXG4gICAgICAgICAgICBudW0gPSBtb2QubW9kKG51bSwgbik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xuICAgICAgICBhc3NlcnRHRShudW0pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBhc3NlcnRQcmpQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIG9uLWN1cnZlLlxuICAgICAgICAvLyBVc2UgZnJvbUhleCBpbnN0ZWFkLCBvciBjYWxsIGFzc2VydFZhbGlkaXR5KCkgbGF0ZXIuXG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWZmaW5lIHBvaW50Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gKGkpID0+IEZwLmVxbChpLCBGcC5aRVJPKTtcbiAgICAgICAgICAgIC8vIGZyb21BZmZpbmUoeDowLCB5OjApIHdvdWxkIHByb2R1Y2UgKHg6MCwgeTowLCB6OjEpLCBidXQgd2UgbmVlZCAoeDowLCB5OjEsIHo6MClcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxuICAgICAgICAgKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxuICAgICAgICAgKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAgICAgICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSBoZXggc2hvcnQvbG9uZyBFQ0RTQSBoZXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZnJvbUJ5dGVzKCgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSkge1xuICAgICAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgd3JvbmcgcmVwcmVzZW50YXRpb24gb2YgWkVSTyBhbmQgaXMgYWx3YXlzIGludmFsaWQuXG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHRoaXMucHkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUobikge1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9ICgwLCBjdXJ2ZV9qc18xLndOQUYpKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG4gICAgLy8gVmFsaWRhdGUgaWYgZ2VuZXJhdG9yIHBvaW50IGlzIG9uIGN1cnZlXG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZXhwb3J0cy53ZWllcnN0cmFzc1BvaW50cyA9IHdlaWVyc3RyYXNzUG9pbnRzO1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9ICgwLCBjdXJ2ZV9qc18xLnZhbGlkYXRlQmFzaWMpKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICAgICAgaG1hYzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSwge1xuICAgICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgbG93UzogdHJ1ZSwgLi4ub3B0cyB9KTtcbn1cbmZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgIGNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBGcC5CWVRFUyArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgZnVuY3Rpb24gaXNWYWxpZEZpZWxkRWxlbWVudChudW0pIHtcbiAgICAgICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBGcC5PUkRFUjsgLy8gMCBpcyBiYW5uZWQgc2luY2UgaXQncyBub3QgaW52ZXJ0aWJsZSBGRVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0LmNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0gecKyIF4gKHArMSkvNFxuICAgICAgICAgICAgICAgIGNvbnN0IGlzWU9kZCA9ICh5ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICAgICAgICAgIC8vIEVDRFNBXG4gICAgICAgICAgICAgICAgY29uc3QgaXNIZWFkT2RkID0gKGhlYWQgJiAxKSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZWFkT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZCA9PT0gMHgwNCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2ludCBvZiBsZW5ndGggJHtsZW59IHdhcyBpbnZhbGlkLiBFeHBlY3RlZCAke2NvbXByZXNzZWRMZW59IGNvbXByZXNzZWQgYnl0ZXMgb3IgJHt1bmNvbXByZXNzZWRMZW59IHVuY29tcHJlc3NlZCBieXRlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IG51bVRvTkJ5dGVTdHIgPSAobnVtKSA9PiB1dC5ieXRlc1RvSGV4KHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKSk7XG4gICAgZnVuY3Rpb24gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKG51bWJlcikge1xuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkVfT1JERVIgPj4gXzFuO1xuICAgICAgICByZXR1cm4gbnVtYmVyID4gSEFMRjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUyhzKSB7XG4gICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykgPyBtb2ROKC1zKSA6IHM7XG4gICAgfVxuICAgIC8vIHNsaWNlIGJ5dGVzIG51bVxuICAgIGNvbnN0IHNsY051bSA9IChiLCBmcm9tLCB0bykgPT4gdXQuYnl0ZXNUb051bWJlckJFKGIuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICAvKipcbiAgICAgKiBFQ0RTQSBzaWduYXR1cmUgd2l0aCBpdHMgKHIsIHMpIHByb3BlcnRpZXMuIFN1cHBvcnRzIERFUiAmIGNvbXBhY3QgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuICAgIGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWlyIChieXRlcyBvZiByLCBieXRlcyBvZiBzKVxuICAgICAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBsID0gQ1VSVkUubkJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBoZXggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBleHBvcnRzLkRFUi50b1NpZygoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICAvLyBjYW4gdXNlIGFzc2VydEdFIGhlcmVcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyIG11c3QgYmUgMCA8IHIgPCBDVVJWRS5uJyk7XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUubicpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkRFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFkZGVkIGJ5dGVzIG9mIHIsIHRoZW4gcGFkZGVkIGJ5dGVzIG9mIHNcbiAgICAgICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtVG9OQnl0ZVN0cih0aGlzLnIpICsgbnVtVG9OQnl0ZVN0cih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHJpdmF0ZSBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgICAgICAgKiAoZ3JvdXBMZW4gKyBjZWlsKGdyb3VwTGVuIC8gMikpIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG1vZC5nZXRNaW5IYXNoTGVuZ3RoKENVUlZFLm4pO1xuICAgICAgICAgICAgcmV0dXJuIG1vZC5tYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVJfTUFTSykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJpZ2ludCBleHBlY3RlZCA8IDJeJHtDVVJWRS5uQml0TGVuZ3RofWApO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxuICAgIC8vIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3ByZWhhc2hlZCBtc2dIYXNoJywgaGFzaChtc2dIYXNoKSk7XG4gICAgICAgIC8vIFdlIGNhbid0IGxhdGVyIGNhbGwgYml0czJvY3RldHMsIHNpbmNlIG5lc3RlZCBiaXRzMmludCBpcyBicm9rZW4gZm9yIGN1cnZlc1xuICAgICAgICAvLyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cbiAgICAgICAgLy8gY29uc3QgYml0czJvY3RldHMgPSAoYml0cykgPT4gaW50Mm9jdGV0cyhiaXRzMmludF9tb2ROKGJpdHMpKVxuICAgICAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IGQgPSBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpOyAvLyB2YWxpZGF0ZSBwcml2YXRlIGtleSwgY29udmVydCB0byBiaWdpbnRcbiAgICAgICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgaW50Mm9jdGV0cyhoMWludCldO1xuICAgICAgICAvLyBleHRyYUVudHJvcHkuIFJGQzY5NzkgMy42OiBhZGRpdGlvbmFsIGsnIChvcHRpb25hbCkuXG4gICAgICAgIGlmIChlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaCgoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ2V4dHJhRW50cm9weScsIGUpKTsgLy8gY2hlY2sgZm9yIGJlaW5nIGJ5dGVzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlZCA9IHV0LmNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgICAgIGNvbnN0IG0gPSBoMWludDsgLy8gTk9URTogbm8gbmVlZCB0byBjYWxsIGJpdHMyaW50IHNlY29uZCB0aW1lIGhlcmUsIGl0IGlzIGluc2lkZSB0cnVuY2F0ZUhhc2ghXG4gICAgICAgIC8vIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbXMgaW50byBwb2ludCB3IHIvcywgY2hlY2tzIHJlc3VsdCBmb3IgdmFsaWRpdHkuXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xuICAgICAgICAgICAgLy8gUkZDIDY5NzkgU2VjdGlvbiAzLjIsIHN0ZXAgMzogayA9IGJpdHMyaW50KFQpXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbXBvcnRhbnQ6IGFsbCBtb2QoKSBjYWxscyBoZXJlIG11c3QgYmUgZG9uZSBvdmVyIE5cbiAgICAgICAgICAgIGNvbnN0IGlrID0gaW52TihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG4gICAgICAgICAgICBjb25zdCByID0gbW9kTihxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIg4oiIIFsxLHHiiJIxXSBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy83MzM3LzY1MDkuIFdlJ3ZlIGRlY2lkZWQgYWdhaW5zdCBpdDpcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICAgICAgY29uc3QgcyA9IG1vZE4oaWsgKiBtb2ROKG0gKyByICogZCkpOyAvLyBOb3QgdXNpbmcgYmxpbmRpbmcgaGVyZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBwcml2YXRlIGtleS5cbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQsIGspIHdoZXJlXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikvayBtb2QgblxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cbiAgICAgKiBAcGFyYW0gcHJpdktleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBvcHRzIGxvd1MgZm9yIG5vbi1tYWxsZWFibGUgc2lncy4gZXh0cmFFbnRyb3B5IGZvciBtaXhpbmcgcmFuZG9tbmVzcyBpbnRvIGsuIHByZWhhc2ggd2lsbCBoYXNoIGZpcnN0IGFyZy5cbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IEMgPSBDVVJWRTtcbiAgICAgICAgY29uc3QgZHJiZyA9IHV0LmNyZWF0ZUhtYWNEcmJnKEMuaGFzaC5vdXRwdXRMZW4sIEMubkJ5dGVMZW5ndGgsIEMuaG1hYyk7XG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgIH1cbiAgICAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbiAgICAvLyB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5CQVNFKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHRvIG92ZXJyaWRlLFxuICAgICAqIHNwZWNpZnkgb3B0aW9uIGB7bG93UzogZmFsc2V9YC4gSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cbiAgICAgKiAgIFUyID0gcnNeLTEgbW9kIG5cbiAgICAgKiAgIFIgPSBVMeKLhUcgLSBVMuKLhVBcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xuICAgICAgICBjb25zdCBzZyA9IHNpZ25hdHVyZTtcbiAgICAgICAgbXNnSGFzaCA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCB9ID0gb3B0cztcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBQO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgc2cgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gU2lnbmF0dXJlIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheXM6IGNvbXBhY3QgKDIqbkJ5dGVMZW5ndGgpICYgREVSICh2YXJpYWJsZS1sZW5ndGgpLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIERFUiBjYW4gYWxzbyBiZSAyKm5CeXRlTGVuZ3RoIGJ5dGVzLCB3ZSBjaGVjayBmb3IgaXQgZmlyc3QuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tREVSKHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRlckVycm9yIGluc3RhbmNlb2YgZXhwb3J0cy5ERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbmV4cG9ydHMud2VpZXJzdHJhc3MgPSB3ZWllcnN0cmFzcztcbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbmV4cG9ydHMuU1dVRnBTcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbztcbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZnVuY3Rpb24gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwgb3B0cykge1xuICAgIG1vZC52YWxpZGF0ZUZpZWxkKEZwKTtcbiAgICBpZiAoIUZwLmlzVmFsaWQob3B0cy5BKSB8fCAhRnAuaXNWYWxpZChvcHRzLkIpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuWikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZVNpbXBsZVNXVTogaW52YWxpZCBvcHRzJyk7XG4gICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIG9wdHMuWik7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhJyk7XG4gICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cbiAgICAvLyBPdXRwdXQ6ICh4LCB5KSwgYSBwb2ludCBvbiBFLlxuICAgIHJldHVybiAodSkgPT4ge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHR2MSwgdHYyLCB0djMsIHR2NCwgdHY1LCB0djYsIHgsIHk7XG4gICAgICAgIHR2MSA9IEZwLnNxcih1KTsgLy8gMS4gIHR2MSA9IHVeMlxuICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBvcHRzLlopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxuICAgICAgICB0djIgPSBGcC5zcXIodHYxKTsgLy8gMy4gIHR2MiA9IHR2MV4yXG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2MSk7IC8vIDQuICB0djIgPSB0djIgKyB0djFcbiAgICAgICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgb3B0cy5CKTsgLy8gNi4gIHR2MyA9IEIgKiB0djNcbiAgICAgICAgdHY0ID0gRnAuY21vdihvcHRzLlosIEZwLm5lZyh0djIpLCAhRnAuZXFsKHR2MiwgRnAuWkVSTykpOyAvLyA3LiAgdHY0ID0gQ01PVihaLCAtdHYyLCB0djIgIT0gMClcbiAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2Myk7IC8vIDkuICB0djIgPSB0djNeMlxuICAgICAgICB0djYgPSBGcC5zcXIodHY0KTsgLy8gMTAuIHR2NiA9IHR2NF4yXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDEyLiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gMTMuIHR2MiA9IHR2MiAqIHR2M1xuICAgICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQik7IC8vIDE1LiB0djUgPSBCICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDE2LiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTsgLy8gMTguIChpc19neDFfc3F1YXJlLCB5MSkgPSBzcXJ0X3JhdGlvKHR2MiwgdHY2KVxuICAgICAgICB5ID0gRnAubXVsKHR2MSwgdSk7IC8vIDE5LiAgIHkgPSB0djEgKiB1ICAtPiBaICogdV4zICogeTFcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcbiAgICAgICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkKTsgLy8gMjEuICAgeCA9IENNT1YoeCwgdHYzLCBpc19neDFfc3F1YXJlKVxuICAgICAgICB5ID0gRnAuY21vdih5LCB2YWx1ZSwgaXNWYWxpZCk7IC8vIDIyLiAgIHkgPSBDTU9WKHksIHkxLCBpc19neDFfc3F1YXJlKVxuICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuICAgICAgICB5ID0gRnAuY21vdihGcC5uZWcoeSksIHksIGUxKTsgLy8gMjQuICAgeSA9IENNT1YoLXksIHksIGUxKVxuICAgICAgICB4ID0gRnAuZGl2KHgsIHR2NCk7IC8vIDI1LiAgIHggPSB4IC8gdHY0XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0cy5tYXBUb0N1cnZlU2ltcGxlU1dVID0gbWFwVG9DdXJ2ZVNpbXBsZVNXVTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUMwQztBQUNxQjtBQUNQO0FBQ3hEO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0NBQWdDLHdEQUFJLFlBQVksZ0VBQVc7QUFDM0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixxRUFBVyxHQUFHLCtCQUErQjtBQUMxRSwyQkFBMkIsNEJBQTRCO0FBQ3ZEO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js":
/*!************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3NEO0FBQ1Y7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQseUNBQXlDO0FBQ3pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1AsSUFBSSwwREFBYTtBQUNqQixJQUFJLHlEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsb0RBQU87QUFDbEI7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuaW1wb3J0IHsgdmFsaWRhdGVGaWVsZCwgbkxlbmd0aCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4vLyAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5leHBvcnQgZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmFuZG9tIHBvaW50IGluc2lkZSBjdXJyZW50IHdpbmRvdyB0byBmLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgcHJlY29tcHV0ZXNNYXAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVyA9IFAuX1dJTkRPV19TSVpFIHx8IDE7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcHJlY29tcHV0ZXNNYXAuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb21wdXRlc01hcC5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!********************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array)\n        return dst;\n    if (typeof dst === 'string')\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtQztBQUNvRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzREFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTyxTQUFTLE9BQU87QUFDeEU7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQyw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVcsQ0FBQyxzREFBVztBQUN2QyxZQUFZLDhDQUE4QztBQUMxRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQVc7QUFDakM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxrQkFBa0Isc0RBQVc7QUFDN0IsYUFBYSxzREFBVztBQUN4QixvQkFBb0IsVUFBVTtBQUM5QjtBQUNBLGlCQUFpQixzREFBVztBQUM1QjtBQUNBLGdDQUFnQyxzREFBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTyxTQUFTLHNEQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZFQUE2RTtBQUNqRztBQUNBO0FBQ087QUFDUCxJQUFJLHlEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLG1CQUFtQixnREFBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpREFBaUQ7QUFDakQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQ0FBa0M7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0NBQXdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtb2QgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgdXRmOFRvQnl0ZXMsIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZURTVChkc3QpIHtcbiAgICBpZiAoZHN0IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICBpZiAodHlwZW9mIGRzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhkc3QpO1xuICAgIHRocm93IG5ldyBFcnJvcignRFNUIG11c3QgYmUgVWludDhBcnJheSBvciBzdHJpbmcnKTtcbn1cbi8vIE9jdGV0IFN0cmVhbSB0byBJbnRlZ2VyLiBcInNwZWNcIiBpbXBsZW1lbnRhdGlvbiBvZiBvczJpcCBpcyAyLjV4IHNsb3dlciB2cyBieXRlc1RvTnVtYmVyQkUuXG5jb25zdCBvczJpcCA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8vIEludGVnZXIgdG8gT2N0ZXQgU3RyZWFtIChudW1iZXJUb0J5dGVzQkUpXG5mdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBJMk9TUCBjYWxsOiB2YWx1ZT0ke3ZhbHVlfSBsZW5ndGg9JHtsZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gaXNCeXRlcyhpdGVtKSB7XG4gICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIGlzTnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0c1xuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMVxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc0J5dGVzKERTVCk7XG4gICAgaXNOdW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAoZWxsID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgeG1kIGxlbmd0aCcpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuLy8gMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4vLyAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuLy8gICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4yXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzQnl0ZXMoRFNUKTtcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNOdW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHZhbGlkYXRlRFNUKF9EU1QpO1xuICAgIGNvbnN0IGxvZzJwID0gcC50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgTCA9IE1hdGguY2VpbCgobG9nMnAgKyBrKSAvIDgpOyAvLyBzZWN0aW9uIDUuMSBvZiBpZXRmIGRyYWZ0IGxpbmsgYWJvdmVcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xuICAgIGxldCBwcmI7IC8vIHBzZXVkb19yYW5kb21fYnl0ZXNcbiAgICBpZiAoZXhwYW5kID09PSAneG1kJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ3hvZicpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGssIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICdfaW50ZXJuYWxfcGFzcycpIHtcbiAgICAgICAgLy8gZm9yIGludGVybmFsIHRlc3RzIG9ubHlcbiAgICAgICAgcHJiID0gbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmQgbXVzdCBiZSBcInhtZFwiIG9yIFwieG9mXCInKTtcbiAgICB9XG4gICAgY29uc3QgdSA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xuICAgICAgICAgICAgY29uc3QgdHYgPSBwcmIuc3ViYXJyYXkoZWxtX29mZnNldCwgZWxtX29mZnNldCArIEwpO1xuICAgICAgICAgICAgZVtqXSA9IG1vZChvczJpcCh0diksIHApO1xuICAgICAgICB9XG4gICAgICAgIHVbaV0gPSBlO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc29nZW55TWFwKGZpZWxkLCBtYXApIHtcbiAgICAvLyBNYWtlIHNhbWUgb3JkZXIgYXMgaW4gc3BlY1xuICAgIGNvbnN0IENPRUZGID0gbWFwLm1hcCgoaSkgPT4gQXJyYXkuZnJvbShpKS5yZXZlcnNlKCkpO1xuICAgIHJldHVybiAoeCwgeSkgPT4ge1xuICAgICAgICBjb25zdCBbeE51bSwgeERlbiwgeU51bSwgeURlbl0gPSBDT0VGRi5tYXAoKHZhbCkgPT4gdmFsLnJlZHVjZSgoYWNjLCBpKSA9PiBmaWVsZC5hZGQoZmllbGQubXVsKGFjYywgeCksIGkpKSk7XG4gICAgICAgIHggPSBmaWVsZC5kaXYoeE51bSwgeERlbik7IC8vIHhOdW0gLyB4RGVuXG4gICAgICAgIHkgPSBmaWVsZC5tdWwoeSwgZmllbGQuZGl2KHlOdW0sIHlEZW4pKTsgLy8geSAqICh5TnVtIC8geURldilcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWYpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmLCBEU1Q6IGRlZi5EU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzFdKSk7XG4gICAgICAgICAgICBjb25zdCBQID0gdTAuYWRkKHUxKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gZW5jb2RlX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmLCBEU1Q6IGRlZi5lbmNvZGVEU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC10by1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js":
/*!**************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUN1STtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EscUVBQXFFLFFBQVEsTUFBTSxPQUFPO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0Esa0JBQWtCLDJDQUEyQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxtQ0FBbUM7QUFDbkMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDRE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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU8sNEJBQTRCLElBQUk7QUFDM0UsdUJBQXVCLDBEQUFlLFFBQVEsMERBQWU7QUFDN0Q7QUFDQTtBQUNBLGtCQUFrQiwwREFBZSxzQkFBc0IsMERBQWU7QUFDdEU7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuaW1wb3J0IHsgYml0TWFzaywgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0J5dGVzTEUsIGJ5dGVzVG9OdW1iZXJCRSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gQmlnSW50KDkpLCBfMTZuID0gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuLy8gVE9ETzogdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRG9lcyB4IF4gKDIgXiBwb3dlcikgbW9kIHAuIHBvdzIoMzAsIDQpID09IDMwIF4gKDIgXiA0KVxuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKylcbiAgICAgICAgO1xuICAgIC8vIEZhc3QtcGF0aFxuICAgIGlmIChTID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBTbG93LXBhdGhcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIOKJoSAtMVxuICAgICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICBsZXQgciA9IFM7XG4gICAgICAgIC8vIFRPRE86IHdpbGwgZmFpbCBhdCBGcDIvZXRjXG4gICAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTsgLy8gd2lsbCB1cGRhdGUgYm90aCB4IGFuZCBiXG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICBsZXQgYiA9IEZwLnBvdyhuLCBRKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub25lbGxpJUUyJTgwJTkzU2hhbmtzX2FsZ29yaXRobSAoNC4gSWYgdCA9IDAsIHJldHVybiByID0gMClcbiAgICAgICAgICAgIC8vIEZpbmQgbSBzdWNoIGJeKDJebSk9PTFcbiAgICAgICAgICAgIGxldCBtID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IHQyID0gRnAuc3FyKGIpOyBtIDwgcjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcbiAgICAgICAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXG4gICAgICAgICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2VcbiAgICAgICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXG4gICAgICAgICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcbiAgICAgICAgICAgIHIgPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBOT1RFOiBkaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gICAgLy8gRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXG4gICAgLy8g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxuICAgICAgICAvLyBjb25zdCBPUkRFUiA9XG4gICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuICAgICAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgLy8gVGhyb3cgaWYgcm9vdCoqMiAhPSBuXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBdGtpbiBhbGdvcml0aG0gZm9yIHEg4omhIDUgKG1vZCA4KSwgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEwKVxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XG4gICAgICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFAg4omhIDkgKG1vZCAxNilcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bikge1xuICAgICAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XG4gICAgICAgIC8vIE1lYW5zIHdlIGNhbm5vdCB1c2Ugc3FydCBmb3IgY29uc3RhbnRzIGF0IGFsbCFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzMgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIC8vIHNxcnQgPSAoeCkgPT4ge1xuICAgICAgICAvLyAgIGxldCB0djEgPSBGcC5wb3coeCwgYzQpOyAgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4gICAgICAgIC8vICAgbGV0IHR2NCA9IEZwLm11bChjMywgdHYxKTsgICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUyID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djMpLCB4KTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUzID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vICAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICMgU2VsZWN0IHRoZSBzcXJ0IGZyb20gdHYxIGFuZCB0djJcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBPdGhlciBjYXNlczogVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIgPiAwJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIGBpbnYoMClgIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGhlcmU6IG1ha2Ugc3VyZSB0byB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmV4cG9ydCBmdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLiAqKk5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuKipcbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7bGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyQkUoa2V5KSA6IGJ5dGVzVG9OdW1iZXJMRShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyBudW1iZXJUb0J5dGVzTEUocmVkdWNlZCwgZmllbGRMZW4pIDogbnVtYmVyVG9CeXRlc0JFKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js":
/*!************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLGlDQUFpQyxJQUFJLFlBQVksRUFBRTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU8sV0FBVyxnQkFBZ0IsYUFBYSxJQUFJO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDTztBQUNQO0FBQ0EsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDbkQsOERBQThEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQixHQUFHLEtBQUssR0FBRyxXQUFXLGNBQWMsS0FBSztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVcsV0FBVyxZQUFZLElBQUk7QUFDcEQsa0NBQWtDLG9CQUFvQixJQUFJLGFBQWEsR0FBRztBQUMxRTtBQUNBLGtDQUFrQyxVQUFVLElBQUksU0FBUztBQUN6RCxrQ0FBa0Msb0JBQW9CLElBQUksU0FBUztBQUNuRSxrQ0FBa0MsMkJBQTJCO0FBQzdELGtDQUFrQyx3QkFBd0I7QUFDMUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1OGEoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xuICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGltaW5nIGF0dGFja3MgaGVyZVxuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGJpdFNldCA9IChuLCBwb3MsIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNvQztBQUNIO0FBQ1E7QUFDUTtBQUNqRDtBQUNBLGlCQUFpQix3REFBYTtBQUM5QixJQUFJLHFEQUFpQjtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQSxRQUFRLHdDQUF3QyxFQUFFLHNDQUFFO0FBQzdDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMENBQTBDO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCLElBQUksR0FBRyxFQUFFLEVBQUUsSUFBSSxHQUFHLEVBQUUsRUFBRTtBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFB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L25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGJcbmltcG9ydCAqIGFzIG1vZCBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgd05BRiwgdmFsaWRhdGVCYXNpYyB9IGZyb20gJy4vY3VydmUuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcbiAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aThhIGV4cGVjdGVkJyk7XG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgdGFnJyk7XG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgICAgICBjb25zdCB7IGQ6IHIsIGw6IHNCeXRlcyB9ID0gREVSLl9wYXJzZUludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICAgICAgY29uc3QgeyBkOiBzLCBsOiByQnl0ZXNMZWZ0IH0gPSBERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSAmIDBiMTAwMCA/ICcwMCcgKyBzIDogcyk7XG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIC8vIGBhc3NlcnRWYWxpZGl0eSgpYCB3b24ndCB3b3JrOiBgaXNUb3JzaW9uRnJlZSgpYCBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQgaW4gYmxzMTItMzgxLlxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRHRShudW0pIHtcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSkge1xuICAgICAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgd3JvbmcgcmVwcmVzZW50YXRpb24gb2YgWkVSTyBhbmQgaXMgYWx3YXlzIGludmFsaWQuXG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHRoaXMucHkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUobikge1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcbiAgICAvLyBWYWxpZGF0ZSBpZiBnZW5lcmF0b3IgcG9pbnQgaXMgb24gY3VydmVcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgICAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IEZwLk9SREVSOyAvLyAwIGlzIGJhbm5lZCBzaW5jZSBpdCdzIG5vdCBpbnZlcnRpYmxlIEZFXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLm1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLmludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdXQuYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBzZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r))\n            return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQzhDO0FBQ0k7QUFDTztBQUNPO0FBQ2lDO0FBQzFCO0FBQ3RCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxrQ0FBa0M7QUFDbEMsZ0JBQWdCLDBEQUFJO0FBQ3BCLGdCQUFnQiwwREFBSTtBQUNwQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsa0JBQWtCLDBEQUFJO0FBQ3RCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsZ0JBQWdCLDBEQUFJO0FBQ3BCLGdCQUFnQiwwREFBSTtBQUNwQixpQkFBaUIsMERBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJEQUFLLHFDQUFxQyxlQUFlO0FBQzdELGtCQUFrQiw2REFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQSxxQkFBcUIseURBQUc7QUFDeEIscUJBQXFCLHlEQUFHO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUMsRUFBRSx3REFBTTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDREQUFNO0FBQzNCLGVBQWUsK0RBQVc7QUFDMUI7QUFDQTtBQUNBLFdBQVcsNERBQU0sQ0FBQywrREFBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUVBQWU7QUFDdkMsb0JBQW9CLHlEQUFHO0FBQ3ZCLG9CQUFvQix5REFBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLHdDQUF3QztBQUN4Qyx3QkFBd0I7QUFDeEI7QUFDQSxzQkFBc0I7QUFDdEIsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1FQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnRUFBVztBQUMvRCxjQUFjLCtEQUFXO0FBQ3pCLFlBQVksdUJBQXVCLG1DQUFtQztBQUN0RSxjQUFjLCtEQUFXLDBCQUEwQjtBQUNuRCwyQkFBMkIsbUVBQWUsaUNBQWlDO0FBQzNFLHdEQUF3RDtBQUN4RCxvQkFBb0IsbUVBQWUsU0FBUztBQUM1QztBQUNBLG1EQUFtRDtBQUNuRCxZQUFZLHVCQUF1QiwyQkFBMkI7QUFDOUQsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQVc7QUFDM0IsY0FBYywrREFBVztBQUN6QixnQkFBZ0IsK0RBQVc7QUFDM0I7QUFDQSx5QkFBeUIsbUVBQWUsUUFBUSx3QkFBd0I7QUFDeEUsa0JBQWtCLG1FQUFlLHVCQUF1QiwyQkFBMkI7QUFDbkY7QUFDQTtBQUNBLGtCQUFrQixtRUFBZSx3QkFBd0IsNEJBQTRCO0FBQ3JGO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsMkNBQTJDO0FBQzNDO0FBQ0EsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkI7QUFDQSxXQUFXO0FBQ1gsS0FBSztBQUNMLENBQUM7QUFDRCxzQ0FBc0Msc0VBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkVBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsd0VBQVk7QUFDL0MsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0RBQU07QUFDaEIsQ0FBQztBQUNNO0FBQ0E7QUFDUCIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSAnLi9fc2hvcnR3X3V0aWxzLmpzJztcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuLyoqXG4gKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxuICovXG5mdW5jdGlvbiBzcXJ0TW9kKHkpIHtcbiAgICBjb25zdCBQID0gc2VjcDI1NmsxUDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwID0gRmllbGQoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcCxcbiAgICBuOiBzZWNwMjU2azFOLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gbW9kKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcbmNvbnN0IGdlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFOO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSBzaGEyNTYoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gc2hhMjU2KGNvbmNhdEJ5dGVzKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+IG51bWJlclRvQnl0ZXNCRShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgaWYgKCFmZSh4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgeDogbmVlZCAwIDwgeCA8IHAnKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihieXRlc1RvTnVtYmVyQkUocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goYnl0ZXNUb051bWJlckJFKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWZlKHIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFnZShzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTsgLy8gUiA9IHPii4VHIC0gZeKLhVBcbiAgICAgICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIC1lUCA9PSAobi1lKVBcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCB7XG4gICAgQTogQmlnSW50KCcweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzMnKSxcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js":
/*!****************************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nexports.bool = bool;\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = { number, bool, bytes, hash, exists, output };\nexports[\"default\"] = assert;\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRyxhQUFhLEdBQUcsWUFBWSxHQUFHLGNBQWM7QUFDOUY7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ0EsY0FBYztBQUNkLGlCQUFpQjtBQUNqQixrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX2Fzc2VydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3V0cHV0ID0gZXhwb3J0cy5leGlzdHMgPSBleHBvcnRzLmhhc2ggPSBleHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5ib29sID0gZXhwb3J0cy5udW1iZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZXhwb3J0cy5ib29sID0gYm9vbDtcbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmV4cG9ydHMuYnl0ZXMgPSBieXRlcztcbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmV4cG9ydHMuaGFzaCA9IGhhc2g7XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmV4cG9ydHMuZXhpc3RzID0gZXhpc3RzO1xuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydHMub3V0cHV0ID0gb3V0cHV0O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js":
/*!**************************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SHA2 = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, _assert_js_1.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.SHA2 = SHA2;\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3NoYTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLHFCQUFxQixtQkFBTyxDQUFDLHNJQUFjO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLGtJQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3NoYTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNIQTIgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5jbGFzcyBTSEEyIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcyk7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEub3V0cHV0KShvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5leHBvcnRzLlNIQTIgPSBTSEEyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3NoYTIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js":
/*!***************************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.crypto = void 0;\nexports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbmV4cG9ydHMuY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js":
/*!********************************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxtREFBbUQsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFFBQVEsa0JBQWtCLFNBQVM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixJQUFJO0FBQ3JGO0FBQ0E7QUFDcUQ7QUFDckQsaUJBQWlCO0FBQ2pCLGlFQUFlLE1BQU0sRUFBQztBQUN0QiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js":
/*!******************************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4QztBQUNTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLGdCQUFnQix5QkFBeUI7QUFDekMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmV4cG9ydCBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGNyeXB0byA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js":
/*!*****************************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRztBQUNyRDtBQUMzQztBQUNPLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQVU7QUFDbEIsb0JBQW9CLGtEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCLFFBQVEsaURBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIGJ5dGVzIGFzIGFzc2VydEJ5dGVzLCBleGlzdHMgYXMgYXNzZXJ0RXhpc3RzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydEJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ2lCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQyx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFEO0FBQ0EsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMERBQWU7QUFDOUMsK0JBQStCLDBEQUFlO0FBQ3JEIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js":
/*!******************************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUM5QztBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ1Q7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSx3REFBTSxXQUFXLHdEQUFNO0FBQy9CLGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js":
/*!*************************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hmac = exports.HMAC = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js\");\n// HMAC (RFC 2104)\nclass HMAC extends utils_js_1.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0, _assert_js_1.hash)(hash);\n        const key = (0, utils_js_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0, _assert_js_1.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0, _assert_js_1.exists)(this);\n        (0, _assert_js_1.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvaG1hYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsWUFBWTtBQUMzQixxQkFBcUIsbUJBQU8sQ0FBQyxzSUFBYztBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyxrSUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5obWFjID0gZXhwb3J0cy5ITUFDID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIEhNQUMgKFJGQyAyMTA0KVxuY2xhc3MgSE1BQyBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuaGFzaCkoaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuZXhwb3J0cy5ITUFDID0gSE1BQztcbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5jb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5leHBvcnRzLmhtYWMgPSBobWFjO1xuZXhwb3J0cy5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js":
/*!***************************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha224 = exports.sha256 = void 0;\nconst _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/_sha2.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js\");\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js_1.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\nexports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMjU2LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLGtJQUFZO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLGtJQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyNTYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYTIyNCA9IGV4cG9ydHMuc2hhMjU2ID0gdm9pZCAwO1xuY29uc3QgX3NoYTJfanNfMSA9IHJlcXVpcmUoXCIuL19zaGEyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIF9zaGEyX2pzXzEuU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShXMTUsIDcpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gKDAsIHV0aWxzX2pzXzEucm90cikoVzIsIDE3KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCA2KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDExKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAyKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDEzKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLnNoYTI1NiA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydHMuc2hhMjI0ID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js":
/*!**************************************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/crypto.js\");\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!exports.isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxrQ0FBa0MsR0FBRywrQkFBK0IsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsbUJBQW1CLEdBQUcsZUFBZSxHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLFlBQVksR0FBRyxZQUFZLEdBQUcsa0JBQWtCLEdBQUcsV0FBVyxHQUFHLFVBQVU7QUFDcFg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsNklBQXNCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGV4cG9ydHMud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSBleHBvcnRzLmNoZWNrT3B0cyA9IGV4cG9ydHMuSGFzaCA9IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBleHBvcnRzLnRvQnl0ZXMgPSBleHBvcnRzLnV0ZjhUb0J5dGVzID0gZXhwb3J0cy5hc3luY0xvb3AgPSBleHBvcnRzLm5leHRUaWNrID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5pc0xFID0gZXhwb3J0cy5yb3RyID0gZXhwb3J0cy5jcmVhdGVWaWV3ID0gZXhwb3J0cy51MzIgPSBleHBvcnRzLnU4ID0gdm9pZCAwO1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2NyeXB0b1wiKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMudTggPSB1ODtcbmNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmV4cG9ydHMudTMyID0gdTMyO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5jb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLmNyZWF0ZVZpZXcgPSBjcmVhdGVWaWV3O1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbmV4cG9ydHMucm90ciA9IHJvdHI7XG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGhhc2hlczpcbi8vIGVhcmx5LXRocm93IGFuIGVycm9yIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBCRSB5ZXQuXG5leHBvcnRzLmlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFleHBvcnRzLmlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG5leHBvcnRzLm5leHRUaWNrID0gbmV4dFRpY2s7XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5hc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgKDAsIGV4cG9ydHMubmV4dFRpY2spKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuZXhwb3J0cy5hc3luY0xvb3AgPSBhc3luY0xvb3A7XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuZXhwb3J0cy51dGY4VG9CeXRlcyA9IHV0ZjhUb0J5dGVzO1xuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIXU4YShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbmV4cG9ydHMudG9CeXRlcyA9IHRvQnl0ZXM7XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuZXhwb3J0cy5IYXNoID0gSGFzaDtcbmNvbnN0IHRvU3RyID0ge30udG9TdHJpbmc7XG5mdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0cy5jaGVja09wdHMgPSBjaGVja09wdHM7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSB3cmFwQ29uc3RydWN0b3I7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cztcbmZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzO1xuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/secp256k1.js":
/*!***************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/curves/secp256k1.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/sha256.js\");\nconst utils_1 = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/utils.js\");\nconst modular_js_1 = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/modular.js\");\nconst weierstrass_js_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/weierstrass.js\");\nconst utils_js_1 = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/utils.js\");\nconst hash_to_curve_js_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/abstract/hash-to-curve.js\");\nconst _shortw_utils_js_1 = __webpack_require__(/*! ./_shortw_utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/_shortw_utils.js\");\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0, modular_js_1.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nexports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, sha256_1.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);\nconst modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);\nconst modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);\nconst Point = exports.secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {\n    const m = (0, utils_js_1.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);\n    const m = (0, utils_js_1.ensureBytes)('message', message);\n    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r))\n            return false;\n        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nexports.schnorr = (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: utils_js_1.numberToBytesBE,\n        bytesToNumberBE: utils_js_1.bytesToNumberBE,\n        taggedHash,\n        mod: modular_js_1.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: sha256_1.sha256,\n}))();\nexports.hashToCurve = (() => htf.hashToCurve)();\nexports.encodeToCurve = (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxpQkFBaUI7QUFDakY7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyw2SUFBc0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsMklBQXFCO0FBQzdDLHFCQUFxQixtQkFBTyxDQUFDLDZIQUF1QjtBQUNwRCx5QkFBeUIsbUJBQU8sQ0FBQyxxSUFBMkI7QUFDNUQsbUJBQW1CLG1CQUFPLENBQUMseUhBQXFCO0FBQ2hELDJCQUEyQixtQkFBTyxDQUFDLHlJQUE2QjtBQUNoRSwyQkFBMkIsbUJBQU8sQ0FBQyx1SEFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxlQUFlO0FBQ3RGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esd0NBQXdDO0FBQ3hDLHdCQUF3QjtBQUN4QjtBQUNBLHNCQUFzQjtBQUN0QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QixtQ0FBbUM7QUFDdEUsbUVBQW1FO0FBQ25FLDJGQUEyRjtBQUMzRix3REFBd0Q7QUFDeEQsNERBQTREO0FBQzVEO0FBQ0EsbURBQW1EO0FBQ25ELFlBQVksdUJBQXVCLDJCQUEyQjtBQUM5RCxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHdCQUF3QjtBQUN4Rix3RUFBd0UsMkJBQTJCO0FBQ25HO0FBQ0E7QUFDQSx5RUFBeUUsNEJBQTRCO0FBQ3JHO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsMkNBQTJDO0FBQzNDO0FBQ0EsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGVUb0N1cnZlID0gZXhwb3J0cy5oYXNoVG9DdXJ2ZSA9IGV4cG9ydHMuc2Nobm9yciA9IGV4cG9ydHMuc2VjcDI1NmsxID0gdm9pZCAwO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCBtb2R1bGFyX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC9tb2R1bGFyLmpzXCIpO1xuY29uc3Qgd2VpZXJzdHJhc3NfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L3V0aWxzLmpzXCIpO1xuY29uc3QgaGFzaF90b19jdXJ2ZV9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qc1wiKTtcbmNvbnN0IF9zaG9ydHdfdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL19zaG9ydHdfdXRpbHMuanNcIik7XG5jb25zdCBzZWNwMjU2azFQID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKTtcbmNvbnN0IHNlY3AyNTZrMU4gPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgZGl2TmVhcmVzdCA9IChhLCBiKSA9PiAoYSArIGIgLyBfMm4pIC8gYjtcbi8qKlxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMVA7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHkpICUgUDsgLy8geF43XG4gICAgY29uc3QgYjYgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjksIF8ybiwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IGIyMiA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcbiAgICBjb25zdCBiNDQgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMjIsIF8yMm4sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgYjg4ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjQ0LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIxNzYgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiODgsIF84OG4sIFApICogYjg4KSAlIFA7XG4gICAgY29uc3QgYjIyMCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIxNzYsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjIyMyA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIyMjAsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IHQxID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCB0MiA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKHQxLCBfNm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCByb290ID0gKDAsIG1vZHVsYXJfanNfMS5wb3cyKSh0MiwgXzJuLCBQKTtcbiAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5jb25zdCBGcCA9ICgwLCBtb2R1bGFyX2pzXzEuRmllbGQpKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG5leHBvcnRzLnNlY3AyNTZrMSA9ICgwLCBfc2hvcnR3X3V0aWxzX2pzXzEuY3JlYXRlQ3VydmUpKHtcbiAgICBhOiBCaWdJbnQoMCksXG4gICAgYjogQmlnSW50KDcpLFxuICAgIEZwLFxuICAgIG46IHNlY3AyNTZrMU4sXG4gICAgLy8gQmFzZSBwb2ludCAoeCwgeSkgYWthIGdlbmVyYXRvciBwb2ludFxuICAgIEd4OiBCaWdJbnQoJzU1MDY2MjYzMDIyMjc3MzQzNjY5NTc4NzE4ODk1MTY4NTM0MzI2MjUwNjAzNDUzNzc3NTk0MTc1NTAwMTg3MzYwMzg5MTE2NzI5MjQwJyksXG4gICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcbiAgICBoOiBCaWdJbnQoMSksXG4gICAgbG93UzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBzZWNwMjU2azEgYmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5IGNvbXB1dGFibGUgZW5kb21vcnBoaXNtLlxuICAgICAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICAgICAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAgICAgKiBFeHBsYW5hdGlvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2XG4gICAgICovXG4gICAgZW5kbzoge1xuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSAoMCwgbW9kdWxhcl9qc18xLm1vZCkoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9ICgwLCBtb2R1bGFyX2pzXzEubW9kKSgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nl8xLnNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IGZlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFQO1xuY29uc3QgZ2UgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMU47XG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9ICgwLCBzaGEyNTZfMS5zaGEyNTYpKFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgdGFnUCA9ICgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSh0YWdILCB0YWdIKTtcbiAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgfVxuICAgIHJldHVybiAoMCwgc2hhMjU2XzEuc2hhMjU2KSgoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykodGFnUCwgLi4ubWVzc2FnZXMpKTtcbn1cbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gKDAsIHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0JFKShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+ICgwLCBtb2R1bGFyX2pzXzEubW9kKSh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gKDAsIG1vZHVsYXJfanNfMS5tb2QpKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBleHBvcnRzLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYik7XG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdikge1xuICAgIGxldCBkXyA9IGV4cG9ydHMuc2VjcDI1NmsxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdik7IC8vIHNhbWUgbWV0aG9kIGV4ZWN1dGVkIGluIGZyb21Qcml2YXRlS2V5XG4gICAgbGV0IHAgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShkXyk7IC8vIFAgPSBkJ+KLhUc7IDAgPCBkJyA8IG4gY2hlY2sgaXMgZG9uZSBpbnNpZGVcbiAgICBjb25zdCBzY2FsYXIgPSBwLmhhc0V2ZW5ZKCkgPyBkXyA6IG1vZE4oLWRfKTtcbiAgICByZXR1cm4geyBzY2FsYXI6IHNjYWxhciwgYnl0ZXM6IHBvaW50VG9CeXRlcyhwKSB9O1xufVxuLyoqXG4gKiBsaWZ0X3ggZnJvbSBCSVAzNDAuIENvbnZlcnQgMzItYnl0ZSB4IGNvb3JkaW5hdGUgdG8gZWxsaXB0aWMgY3VydmUgcG9pbnQuXG4gKiBAcmV0dXJucyB2YWxpZCBwb2ludCBjaGVja2VkIGZvciBiZWluZyBvbi1jdXJ2ZVxuICovXG5mdW5jdGlvbiBsaWZ0X3goeCkge1xuICAgIGlmICghZmUoeCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHg6IG5lZWQgMCA8IHggPCBwJyk7IC8vIEZhaWwgaWYgeCDiiaUgcC5cbiAgICBjb25zdCB4eCA9IG1vZFAoeCAqIHgpO1xuICAgIGNvbnN0IGMgPSBtb2RQKHh4ICogeCArIEJpZ0ludCg3KSk7IC8vIExldCBjID0geMKzICsgNyBtb2QgcC5cbiAgICBsZXQgeSA9IHNxcnRNb2QoYyk7IC8vIExldCB5ID0gY14ocCsxKS80IG1vZCBwLlxuICAgIGlmICh5ICUgXzJuICE9PSBfMG4pXG4gICAgICAgIHkgPSBtb2RQKC15KTsgLy8gUmV0dXJuIHRoZSB1bmlxdWUgcG9pbnQgUCBzdWNoIHRoYXQgeChQKSA9IHggYW5kXG4gICAgY29uc3QgcCA9IG5ldyBQb2ludCh4LCB5LCBfMW4pOyAvLyB5KFApID0geSBpZiB5IG1vZCAyID0gMCBvciB5KFApID0gcC15IG90aGVyd2lzZS5cbiAgICBwLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIENyZWF0ZSB0YWdnZWQgaGFzaCwgY29udmVydCBpdCB0byBiaWdpbnQsIHJlZHVjZSBtb2R1bG8tbi5cbiAqL1xuZnVuY3Rpb24gY2hhbGxlbmdlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbW9kTigoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSAoMCwgdXRpbHNfMS5yYW5kb21CeXRlcykoMzIpKSB7XG4gICAgY29uc3QgbSA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHsgYnl0ZXM6IHB4LCBzY2FsYXI6IGQgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSk7IC8vIGNoZWNrcyBmb3IgaXNXaXRoaW5DdXJ2ZU9yZGVyXG4gICAgY29uc3QgYSA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTigoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUpKHJhbmQpKTsgLy8gTGV0IGsnID0gaW50KHJhbmQpIG1vZCBuXG4gICAgaWYgKGtfID09PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbiBmYWlsZWQ6IGsgaXMgemVybycpOyAvLyBGYWlsIGlmIGsnID0gMC5cbiAgICBjb25zdCB7IGJ5dGVzOiByeCwgc2NhbGFyOiBrIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KGtfKTsgLy8gTGV0IFIgPSBrJ+KLhUcuXG4gICAgY29uc3QgZSA9IGNoYWxsZW5nZShyeCwgcHgsIG0pOyAvLyBMZXQgZSA9IGludChoYXNoL2NoYWxsZW5nZShieXRlcyhSKSB8fCBieXRlcyhQKSB8fCBtKSkgbW9kIG4uXG4gICAgY29uc3Qgc2lnID0gbmV3IFVpbnQ4QXJyYXkoNjQpOyAvLyBMZXQgc2lnID0gYnl0ZXMoUikgfHwgYnl0ZXMoKGsgKyBlZCkgbW9kIG4pLlxuICAgIHNpZy5zZXQocngsIDApO1xuICAgIHNpZy5zZXQobnVtVG8zMmIobW9kTihrICsgZSAqIGQpKSwgMzIpO1xuICAgIC8vIElmIFZlcmlmeShieXRlcyhQKSwgbSwgc2lnKSAoc2VlIGJlbG93KSByZXR1cm5zIGZhaWx1cmUsIGFib3J0XG4gICAgaWYgKCFzY2hub3JyVmVyaWZ5KHNpZywgbSwgcHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ246IEludmFsaWQgc2lnbmF0dXJlIHByb2R1Y2VkJyk7XG4gICAgcmV0dXJuIHNpZztcbn1cbi8qKlxuICogVmVyaWZpZXMgU2Nobm9yciBzaWduYXR1cmUuXG4gKiBXaWxsIHN3YWxsb3cgZXJyb3JzICYgcmV0dXJuIGZhbHNlIGV4Y2VwdCBmb3IgaW5pdGlhbCB0eXBlIHZhbGlkYXRpb24gb2YgYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KSB7XG4gICAgY29uc3Qgc2lnID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdwdWJsaWNLZXknLCBwdWJsaWNLZXksIDMyKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBQID0gbGlmdF94KCgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWZlKHIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShzaWcuc3ViYXJyYXkoMzIsIDY0KSk7IC8vIExldCBzID0gaW50KHNpZ1szMjo2NF0pOyBmYWlsIGlmIHMg4omlIG4uXG4gICAgICAgIGlmICghZ2UocykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UobnVtVG8zMmIociksIHBvaW50VG9CeXRlcyhQKSwgbSk7IC8vIGludChjaGFsbGVuZ2UoYnl0ZXMocil8fGJ5dGVzKFApfHxtKSklblxuICAgICAgICBjb25zdCBSID0gR211bEFkZChQLCBzLCBtb2ROKC1lKSk7IC8vIFIgPSBz4ouFRyAtIGXii4VQXG4gICAgICAgIGlmICghUiB8fCAhUi5oYXNFdmVuWSgpIHx8IFIudG9BZmZpbmUoKS54ICE9PSByKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyAtZVAgPT0gKG4tZSlQXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIOKJoCByLlxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuc2Nobm9yciA9ICgoKSA9PiAoe1xuICAgIGdldFB1YmxpY0tleTogc2Nobm9yckdldFB1YmxpY0tleSxcbiAgICBzaWduOiBzY2hub3JyU2lnbixcbiAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgdXRpbHM6IHtcbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogZXhwb3J0cy5zZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRTogdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzQkUsXG4gICAgICAgIGJ5dGVzVG9OdW1iZXJCRTogdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkUsXG4gICAgICAgIHRhZ2dlZEhhc2gsXG4gICAgICAgIG1vZDogbW9kdWxhcl9qc18xLm1vZCxcbiAgICB9LFxufSkpKCk7XG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICgwLCBoYXNoX3RvX2N1cnZlX2pzXzEuaXNvZ2VueU1hcCkoRnAsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICgwLCB3ZWllcnN0cmFzc19qc18xLm1hcFRvQ3VydmVTaW1wbGVTV1UpKEZwLCB7XG4gICAgQTogQmlnSW50KCcweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzMnKSxcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKDAsIGhhc2hfdG9fY3VydmVfanNfMS5jcmVhdGVIYXNoZXIpKGV4cG9ydHMuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludCwgKHNjYWxhcnMpID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFNXVShGcC5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgIHJldHVybiBpc29NYXAoeCwgeSk7XG59LCB7XG4gICAgRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgIHA6IEZwLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2XzEuc2hhMjU2LFxufSkpKCk7XG5leHBvcnRzLmhhc2hUb0N1cnZlID0gKCgpID0+IGh0Zi5oYXNoVG9DdXJ2ZSkoKTtcbmV4cG9ydHMuZW5jb2RlVG9DdXJ2ZSA9ICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/curves/secp256k1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/_assert.js":
/*!*************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/hashes/_assert.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nexports.bool = bool;\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output,\n};\nexports[\"default\"] = assert;\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRyxhQUFhLEdBQUcsWUFBWSxHQUFHLGNBQWM7QUFDOUY7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX2Fzc2VydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3V0cHV0ID0gZXhwb3J0cy5leGlzdHMgPSBleHBvcnRzLmhhc2ggPSBleHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5ib29sID0gZXhwb3J0cy5udW1iZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZXhwb3J0cy5ib29sID0gYm9vbDtcbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmV4cG9ydHMuYnl0ZXMgPSBieXRlcztcbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmV4cG9ydHMuaGFzaCA9IGhhc2g7XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmV4cG9ydHMuZXhpc3RzID0gZXhpc3RzO1xuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydHMub3V0cHV0ID0gb3V0cHV0O1xuY29uc3QgYXNzZXJ0ID0ge1xuICAgIG51bWJlcixcbiAgICBib29sLFxuICAgIGJ5dGVzLFxuICAgIGhhc2gsXG4gICAgZXhpc3RzLFxuICAgIG91dHB1dCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/_sha2.js":
/*!***********************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/hashes/_sha2.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SHA2 = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/utils.js\");\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends utils_js_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_js_1.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js_1.default.exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0, utils_js_1.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_js_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js_1.default.exists(this);\n        _assert_js_1.default.output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_js_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\nexports.SHA2 = SHA2;\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3NoYTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLHFCQUFxQixtQkFBTyxDQUFDLDJHQUFjO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLHVHQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3NoYTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNIQTIgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5jbGFzcyBTSEEyIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0Lm91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5leHBvcnRzLlNIQTIgPSBTSEEyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3NoYTIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/_sha2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/crypto.js":
/*!************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/hashes/crypto.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.crypto = void 0;\nexports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbmV4cG9ydHMuY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQSxtREFBbUQsRUFBRTtBQUNyRDtBQUNPO0FBQ1A7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EseURBQXlELFFBQVEsa0JBQWtCLFNBQVM7QUFDNUY7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixJQUFJO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5jb25zdCBhc3NlcnQgPSB7XG4gICAgbnVtYmVyLFxuICAgIGJvb2wsXG4gICAgYnl0ZXMsXG4gICAgaGFzaCxcbiAgICBleGlzdHMsXG4gICAgb3V0cHV0LFxufTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js":
/*!***************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrQztBQUNxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUJBQW1CLDJDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVU7QUFDOUI7QUFDQTtBQUNBLFFBQVEseURBQWE7QUFDckIsZ0JBQWdCLHlCQUF5QjtBQUN6QyxlQUFlLGtEQUFPO0FBQ3RCO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFEQUFVO0FBQzNDLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFhO0FBQ3JCLFFBQVEseURBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5leHBvcnQgY2xhc3MgU0hBMiBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnQub3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3NoYTIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/crypto.js":
/*!****************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/hashes/esm/crypto.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGNyeXB0byA9IHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js":
/*!**************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   expand: () => (/* binding */ expand),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   hkdf: () => (/* binding */ hkdf)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\");\n\n\n\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nfunction extract(hash, ikm, salt) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    // NOTE: some libraries treat zero-length array as 'not provided';\n    // we don't, since we have undefined as 'not provided'\n    // https://github.com/RustCrypto/KDFs/issues/15\n    if (salt === undefined)\n        salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n    return (0,_hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac)(hash, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(salt), (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(ikm));\n}\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = new Uint8Array([0]);\nconst EMPTY_BUFFER = new Uint8Array();\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nfunction expand(hash, prk, info, length = 32) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(length);\n    if (length > 255 * hash.outputLen)\n        throw new Error('Length should be <= 255*HashLen');\n    const blocks = Math.ceil(length / hash.outputLen);\n    if (info === undefined)\n        info = EMPTY_BUFFER;\n    // first L(ength) octets of T\n    const okm = new Uint8Array(blocks * hash.outputLen);\n    // Re-use HMAC instance between blocks\n    const HMAC = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, prk);\n    const HMACTmp = HMAC._cloneInto();\n    const T = new Uint8Array(HMAC.outputLen);\n    for (let counter = 0; counter < blocks; counter++) {\n        HKDF_COUNTER[0] = counter + 1;\n        // T(0) = empty string (zero length)\n        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n            .update(info)\n            .update(HKDF_COUNTER)\n            .digestInto(T);\n        okm.set(T, hash.outputLen * counter);\n        HMAC._cloneInto(HMACTmp);\n    }\n    HMAC.destroy();\n    HMACTmp.destroy();\n    T.fill(0);\n    HKDF_COUNTER.fill(0);\n    return okm.slice(0, length);\n}\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nconst hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);\n//# sourceMappingURL=hkdf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2hrZGYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtDO0FBQ0c7QUFDSjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSx1REFBVztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLFdBQVcsOENBQUksT0FBTyxrREFBTyxRQUFRLGtEQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHVEQUFXO0FBQ2YsSUFBSSx5REFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBDQUFJO0FBQ3JCO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaGtkZi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnLi9obWFjLmpzJztcbi8vIEhLREYgKFJGQyA1ODY5KVxuLy8gaHR0cHM6Ly9zb2F0b2suYmxvZy8yMDIxLzExLzE3L3VuZGVyc3RhbmRpbmctaGtkZi9cbi8qKlxuICogSEtERi1FeHRyYWN0KElLTSwgc2FsdCkgLT4gUFJLXG4gKiBBcmd1bWVudHMgcG9zaXRpb24gZGlmZmVycyBmcm9tIHNwZWMgKElLTSBpcyBmaXJzdCBvbmUsIHNpbmNlIGl0IGlzIG5vdCBvcHRpb25hbClcbiAqIEBwYXJhbSBoYXNoXG4gKiBAcGFyYW0gaWttXG4gKiBAcGFyYW0gc2FsdFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3QoaGFzaCwgaWttLCBzYWx0KSB7XG4gICAgYXNzZXJ0Lmhhc2goaGFzaCk7XG4gICAgLy8gTk9URTogc29tZSBsaWJyYXJpZXMgdHJlYXQgemVyby1sZW5ndGggYXJyYXkgYXMgJ25vdCBwcm92aWRlZCc7XG4gICAgLy8gd2UgZG9uJ3QsIHNpbmNlIHdlIGhhdmUgdW5kZWZpbmVkIGFzICdub3QgcHJvdmlkZWQnXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1J1c3RDcnlwdG8vS0RGcy9pc3N1ZXMvMTVcbiAgICBpZiAoc2FsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBzYWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGFzaC5vdXRwdXRMZW4pOyAvLyBpZiBub3QgcHJvdmlkZWQsIGl0IGlzIHNldCB0byBhIHN0cmluZyBvZiBIYXNoTGVuIHplcm9zXG4gICAgcmV0dXJuIGhtYWMoaGFzaCwgdG9CeXRlcyhzYWx0KSwgdG9CeXRlcyhpa20pKTtcbn1cbi8vIEhLREYtRXhwYW5kKFBSSywgaW5mbywgTCkgLT4gT0tNXG5jb25zdCBIS0RGX0NPVU5URVIgPSBuZXcgVWludDhBcnJheShbMF0pO1xuY29uc3QgRU1QVFlfQlVGRkVSID0gbmV3IFVpbnQ4QXJyYXkoKTtcbi8qKlxuICogSEtERi1leHBhbmQgZnJvbSB0aGUgc3BlYy5cbiAqIEBwYXJhbSBwcmsgLSBhIHBzZXVkb3JhbmRvbSBrZXkgb2YgYXQgbGVhc3QgSGFzaExlbiBvY3RldHMgKHVzdWFsbHksIHRoZSBvdXRwdXQgZnJvbSB0aGUgZXh0cmFjdCBzdGVwKVxuICogQHBhcmFtIGluZm8gLSBvcHRpb25hbCBjb250ZXh0IGFuZCBhcHBsaWNhdGlvbiBzcGVjaWZpYyBpbmZvcm1hdGlvbiAoY2FuIGJlIGEgemVyby1sZW5ndGggc3RyaW5nKVxuICogQHBhcmFtIGxlbmd0aCAtIGxlbmd0aCBvZiBvdXRwdXQga2V5aW5nIG1hdGVyaWFsIGluIG9jdGV0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kKGhhc2gsIHByaywgaW5mbywgbGVuZ3RoID0gMzIpIHtcbiAgICBhc3NlcnQuaGFzaChoYXNoKTtcbiAgICBhc3NlcnQubnVtYmVyKGxlbmd0aCk7XG4gICAgaWYgKGxlbmd0aCA+IDI1NSAqIGhhc2gub3V0cHV0TGVuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCBzaG91bGQgYmUgPD0gMjU1Kkhhc2hMZW4nKTtcbiAgICBjb25zdCBibG9ja3MgPSBNYXRoLmNlaWwobGVuZ3RoIC8gaGFzaC5vdXRwdXRMZW4pO1xuICAgIGlmIChpbmZvID09PSB1bmRlZmluZWQpXG4gICAgICAgIGluZm8gPSBFTVBUWV9CVUZGRVI7XG4gICAgLy8gZmlyc3QgTChlbmd0aCkgb2N0ZXRzIG9mIFRcbiAgICBjb25zdCBva20gPSBuZXcgVWludDhBcnJheShibG9ja3MgKiBoYXNoLm91dHB1dExlbik7XG4gICAgLy8gUmUtdXNlIEhNQUMgaW5zdGFuY2UgYmV0d2VlbiBibG9ja3NcbiAgICBjb25zdCBITUFDID0gaG1hYy5jcmVhdGUoaGFzaCwgcHJrKTtcbiAgICBjb25zdCBITUFDVG1wID0gSE1BQy5fY2xvbmVJbnRvKCk7XG4gICAgY29uc3QgVCA9IG5ldyBVaW50OEFycmF5KEhNQUMub3V0cHV0TGVuKTtcbiAgICBmb3IgKGxldCBjb3VudGVyID0gMDsgY291bnRlciA8IGJsb2NrczsgY291bnRlcisrKSB7XG4gICAgICAgIEhLREZfQ09VTlRFUlswXSA9IGNvdW50ZXIgKyAxO1xuICAgICAgICAvLyBUKDApID0gZW1wdHkgc3RyaW5nICh6ZXJvIGxlbmd0aClcbiAgICAgICAgLy8gVChOKSA9IEhNQUMtSGFzaChQUkssIFQoTi0xKSB8IGluZm8gfCBOKVxuICAgICAgICBITUFDVG1wLnVwZGF0ZShjb3VudGVyID09PSAwID8gRU1QVFlfQlVGRkVSIDogVClcbiAgICAgICAgICAgIC51cGRhdGUoaW5mbylcbiAgICAgICAgICAgIC51cGRhdGUoSEtERl9DT1VOVEVSKVxuICAgICAgICAgICAgLmRpZ2VzdEludG8oVCk7XG4gICAgICAgIG9rbS5zZXQoVCwgaGFzaC5vdXRwdXRMZW4gKiBjb3VudGVyKTtcbiAgICAgICAgSE1BQy5fY2xvbmVJbnRvKEhNQUNUbXApO1xuICAgIH1cbiAgICBITUFDLmRlc3Ryb3koKTtcbiAgICBITUFDVG1wLmRlc3Ryb3koKTtcbiAgICBULmZpbGwoMCk7XG4gICAgSEtERl9DT1VOVEVSLmZpbGwoMCk7XG4gICAgcmV0dXJuIG9rbS5zbGljZSgwLCBsZW5ndGgpO1xufVxuLyoqXG4gKiBIS0RGIChSRkMgNTg2OSk6IGV4dHJhY3QgKyBleHBhbmQgaW4gb25lIHN0ZXAuXG4gKiBAcGFyYW0gaGFzaCAtIGhhc2ggZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIChlLmcuIHNoYTI1NilcbiAqIEBwYXJhbSBpa20gLSBpbnB1dCBrZXlpbmcgbWF0ZXJpYWwsIHRoZSBpbml0aWFsIGtleVxuICogQHBhcmFtIHNhbHQgLSBvcHRpb25hbCBzYWx0IHZhbHVlIChhIG5vbi1zZWNyZXQgcmFuZG9tIHZhbHVlKVxuICogQHBhcmFtIGluZm8gLSBvcHRpb25hbCBjb250ZXh0IGFuZCBhcHBsaWNhdGlvbiBzcGVjaWZpYyBpbmZvcm1hdGlvblxuICogQHBhcmFtIGxlbmd0aCAtIGxlbmd0aCBvZiBvdXRwdXQga2V5aW5nIG1hdGVyaWFsIGluIG9jdGV0c1xuICovXG5leHBvcnQgY29uc3QgaGtkZiA9IChoYXNoLCBpa20sIHNhbHQsIGluZm8sIGxlbmd0aCkgPT4gZXhwYW5kKGhhc2gsIGV4dHJhY3QoaGFzaCwgaWttLCBzYWx0KSwgaW5mbywgbGVuZ3RoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhrZGYuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js":
/*!**************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNTO0FBQzNDO0FBQ08sbUJBQW1CLDJDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBVztBQUNuQixvQkFBb0Isa0RBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWE7QUFDckIsUUFBUSx3REFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0Lmhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYXNzZXJ0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydC5ieXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js":
/*!****************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ2lCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLHdCQUF3QixRQUFRO0FBQ2hDLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQSwyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGVBQWUsMERBQWU7QUFDOUIsZUFBZSwwREFBZTtBQUNyQyIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js":
/*!***************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUM5QztBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxZQUFZO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsd0RBQU0sV0FBVyx3REFBTTtBQUMvQixlQUFlLHdEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuLy8gQ2hlY2sgaWYgb2JqZWN0IGRvZW5zJ3QgaGF2ZSBjdXN0b20gY29uc3RydWN0b3IgKGxpa2UgVWludDhBcnJheS9BcnJheSlcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8ICFpc1BsYWluT2JqZWN0KG9wdHMpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/hkdf.js":
/*!**********************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/hashes/hkdf.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hkdf = exports.expand = exports.extract = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/utils.js\");\nconst hmac_js_1 = __webpack_require__(/*! ./hmac.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/hmac.js\");\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nfunction extract(hash, ikm, salt) {\n    _assert_js_1.default.hash(hash);\n    // NOTE: some libraries treat zero-length array as 'not provided';\n    // we don't, since we have undefined as 'not provided'\n    // https://github.com/RustCrypto/KDFs/issues/15\n    if (salt === undefined)\n        salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n    return (0, hmac_js_1.hmac)(hash, (0, utils_js_1.toBytes)(salt), (0, utils_js_1.toBytes)(ikm));\n}\nexports.extract = extract;\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = new Uint8Array([0]);\nconst EMPTY_BUFFER = new Uint8Array();\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nfunction expand(hash, prk, info, length = 32) {\n    _assert_js_1.default.hash(hash);\n    _assert_js_1.default.number(length);\n    if (length > 255 * hash.outputLen)\n        throw new Error('Length should be <= 255*HashLen');\n    const blocks = Math.ceil(length / hash.outputLen);\n    if (info === undefined)\n        info = EMPTY_BUFFER;\n    // first L(ength) octets of T\n    const okm = new Uint8Array(blocks * hash.outputLen);\n    // Re-use HMAC instance between blocks\n    const HMAC = hmac_js_1.hmac.create(hash, prk);\n    const HMACTmp = HMAC._cloneInto();\n    const T = new Uint8Array(HMAC.outputLen);\n    for (let counter = 0; counter < blocks; counter++) {\n        HKDF_COUNTER[0] = counter + 1;\n        // T(0) = empty string (zero length)\n        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n            .update(info)\n            .update(HKDF_COUNTER)\n            .digestInto(T);\n        okm.set(T, hash.outputLen * counter);\n        HMAC._cloneInto(HMACTmp);\n    }\n    HMAC.destroy();\n    HMACTmp.destroy();\n    T.fill(0);\n    HKDF_COUNTER.fill(0);\n    return okm.slice(0, length);\n}\nexports.expand = expand;\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nconst hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);\nexports.hkdf = hkdf;\n//# sourceMappingURL=hkdf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvaGtkZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsY0FBYyxHQUFHLGVBQWU7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsMkdBQWM7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsdUdBQVk7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMscUdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9oa2RmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oa2RmID0gZXhwb3J0cy5leHBhbmQgPSBleHBvcnRzLmV4dHJhY3QgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuY29uc3QgaG1hY19qc18xID0gcmVxdWlyZShcIi4vaG1hYy5qc1wiKTtcbi8vIEhLREYgKFJGQyA1ODY5KVxuLy8gaHR0cHM6Ly9zb2F0b2suYmxvZy8yMDIxLzExLzE3L3VuZGVyc3RhbmRpbmctaGtkZi9cbi8qKlxuICogSEtERi1FeHRyYWN0KElLTSwgc2FsdCkgLT4gUFJLXG4gKiBBcmd1bWVudHMgcG9zaXRpb24gZGlmZmVycyBmcm9tIHNwZWMgKElLTSBpcyBmaXJzdCBvbmUsIHNpbmNlIGl0IGlzIG5vdCBvcHRpb25hbClcbiAqIEBwYXJhbSBoYXNoXG4gKiBAcGFyYW0gaWttXG4gKiBAcGFyYW0gc2FsdFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdChoYXNoLCBpa20sIHNhbHQpIHtcbiAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5oYXNoKGhhc2gpO1xuICAgIC8vIE5PVEU6IHNvbWUgbGlicmFyaWVzIHRyZWF0IHplcm8tbGVuZ3RoIGFycmF5IGFzICdub3QgcHJvdmlkZWQnO1xuICAgIC8vIHdlIGRvbid0LCBzaW5jZSB3ZSBoYXZlIHVuZGVmaW5lZCBhcyAnbm90IHByb3ZpZGVkJ1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9SdXN0Q3J5cHRvL0tERnMvaXNzdWVzLzE1XG4gICAgaWYgKHNhbHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc2FsdCA9IG5ldyBVaW50OEFycmF5KGhhc2gub3V0cHV0TGVuKTsgLy8gaWYgbm90IHByb3ZpZGVkLCBpdCBpcyBzZXQgdG8gYSBzdHJpbmcgb2YgSGFzaExlbiB6ZXJvc1xuICAgIHJldHVybiAoMCwgaG1hY19qc18xLmhtYWMpKGhhc2gsICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKHNhbHQpLCAoMCwgdXRpbHNfanNfMS50b0J5dGVzKShpa20pKTtcbn1cbmV4cG9ydHMuZXh0cmFjdCA9IGV4dHJhY3Q7XG4vLyBIS0RGLUV4cGFuZChQUkssIGluZm8sIEwpIC0+IE9LTVxuY29uc3QgSEtERl9DT1VOVEVSID0gbmV3IFVpbnQ4QXJyYXkoWzBdKTtcbmNvbnN0IEVNUFRZX0JVRkZFUiA9IG5ldyBVaW50OEFycmF5KCk7XG4vKipcbiAqIEhLREYtZXhwYW5kIGZyb20gdGhlIHNwZWMuXG4gKiBAcGFyYW0gcHJrIC0gYSBwc2V1ZG9yYW5kb20ga2V5IG9mIGF0IGxlYXN0IEhhc2hMZW4gb2N0ZXRzICh1c3VhbGx5LCB0aGUgb3V0cHV0IGZyb20gdGhlIGV4dHJhY3Qgc3RlcClcbiAqIEBwYXJhbSBpbmZvIC0gb3B0aW9uYWwgY29udGV4dCBhbmQgYXBwbGljYXRpb24gc3BlY2lmaWMgaW5mb3JtYXRpb24gKGNhbiBiZSBhIHplcm8tbGVuZ3RoIHN0cmluZylcbiAqIEBwYXJhbSBsZW5ndGggLSBsZW5ndGggb2Ygb3V0cHV0IGtleWluZyBtYXRlcmlhbCBpbiBvY3RldHNcbiAqL1xuZnVuY3Rpb24gZXhwYW5kKGhhc2gsIHByaywgaW5mbywgbGVuZ3RoID0gMzIpIHtcbiAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5oYXNoKGhhc2gpO1xuICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0Lm51bWJlcihsZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPiAyNTUgKiBoYXNoLm91dHB1dExlbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggc2hvdWxkIGJlIDw9IDI1NSpIYXNoTGVuJyk7XG4gICAgY29uc3QgYmxvY2tzID0gTWF0aC5jZWlsKGxlbmd0aCAvIGhhc2gub3V0cHV0TGVuKTtcbiAgICBpZiAoaW5mbyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBpbmZvID0gRU1QVFlfQlVGRkVSO1xuICAgIC8vIGZpcnN0IEwoZW5ndGgpIG9jdGV0cyBvZiBUXG4gICAgY29uc3Qgb2ttID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tzICogaGFzaC5vdXRwdXRMZW4pO1xuICAgIC8vIFJlLXVzZSBITUFDIGluc3RhbmNlIGJldHdlZW4gYmxvY2tzXG4gICAgY29uc3QgSE1BQyA9IGhtYWNfanNfMS5obWFjLmNyZWF0ZShoYXNoLCBwcmspO1xuICAgIGNvbnN0IEhNQUNUbXAgPSBITUFDLl9jbG9uZUludG8oKTtcbiAgICBjb25zdCBUID0gbmV3IFVpbnQ4QXJyYXkoSE1BQy5vdXRwdXRMZW4pO1xuICAgIGZvciAobGV0IGNvdW50ZXIgPSAwOyBjb3VudGVyIDwgYmxvY2tzOyBjb3VudGVyKyspIHtcbiAgICAgICAgSEtERl9DT1VOVEVSWzBdID0gY291bnRlciArIDE7XG4gICAgICAgIC8vIFQoMCkgPSBlbXB0eSBzdHJpbmcgKHplcm8gbGVuZ3RoKVxuICAgICAgICAvLyBUKE4pID0gSE1BQy1IYXNoKFBSSywgVChOLTEpIHwgaW5mbyB8IE4pXG4gICAgICAgIEhNQUNUbXAudXBkYXRlKGNvdW50ZXIgPT09IDAgPyBFTVBUWV9CVUZGRVIgOiBUKVxuICAgICAgICAgICAgLnVwZGF0ZShpbmZvKVxuICAgICAgICAgICAgLnVwZGF0ZShIS0RGX0NPVU5URVIpXG4gICAgICAgICAgICAuZGlnZXN0SW50byhUKTtcbiAgICAgICAgb2ttLnNldChULCBoYXNoLm91dHB1dExlbiAqIGNvdW50ZXIpO1xuICAgICAgICBITUFDLl9jbG9uZUludG8oSE1BQ1RtcCk7XG4gICAgfVxuICAgIEhNQUMuZGVzdHJveSgpO1xuICAgIEhNQUNUbXAuZGVzdHJveSgpO1xuICAgIFQuZmlsbCgwKTtcbiAgICBIS0RGX0NPVU5URVIuZmlsbCgwKTtcbiAgICByZXR1cm4gb2ttLnNsaWNlKDAsIGxlbmd0aCk7XG59XG5leHBvcnRzLmV4cGFuZCA9IGV4cGFuZDtcbi8qKlxuICogSEtERiAoUkZDIDU4NjkpOiBleHRyYWN0ICsgZXhwYW5kIGluIG9uZSBzdGVwLlxuICogQHBhcmFtIGhhc2ggLSBoYXNoIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCAoZS5nLiBzaGEyNTYpXG4gKiBAcGFyYW0gaWttIC0gaW5wdXQga2V5aW5nIG1hdGVyaWFsLCB0aGUgaW5pdGlhbCBrZXlcbiAqIEBwYXJhbSBzYWx0IC0gb3B0aW9uYWwgc2FsdCB2YWx1ZSAoYSBub24tc2VjcmV0IHJhbmRvbSB2YWx1ZSlcbiAqIEBwYXJhbSBpbmZvIC0gb3B0aW9uYWwgY29udGV4dCBhbmQgYXBwbGljYXRpb24gc3BlY2lmaWMgaW5mb3JtYXRpb25cbiAqIEBwYXJhbSBsZW5ndGggLSBsZW5ndGggb2Ygb3V0cHV0IGtleWluZyBtYXRlcmlhbCBpbiBvY3RldHNcbiAqL1xuY29uc3QgaGtkZiA9IChoYXNoLCBpa20sIHNhbHQsIGluZm8sIGxlbmd0aCkgPT4gZXhwYW5kKGhhc2gsIGV4dHJhY3QoaGFzaCwgaWttLCBzYWx0KSwgaW5mbywgbGVuZ3RoKTtcbmV4cG9ydHMuaGtkZiA9IGhrZGY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oa2RmLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/hkdf.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/hmac.js":
/*!**********************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/hashes/hmac.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hmac = exports.HMAC = void 0;\nconst _assert_js_1 = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/_assert.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/utils.js\");\n// HMAC (RFC 2104)\nclass HMAC extends utils_js_1.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        _assert_js_1.default.hash(hash);\n        const key = (0, utils_js_1.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        _assert_js_1.default.exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        _assert_js_1.default.exists(this);\n        _assert_js_1.default.bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nexports.HMAC = HMAC;\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nexports.hmac = hmac;\nexports.hmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvaG1hYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsWUFBWTtBQUMzQixxQkFBcUIsbUJBQU8sQ0FBQywyR0FBYztBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyx1R0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5obWFjID0gZXhwb3J0cy5ITUFDID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIEhNQUMgKFJGQyAyMTA0KVxuY2xhc3MgSE1BQyBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0Lmhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQuYnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuZXhwb3J0cy5ITUFDID0gSE1BQztcbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5jb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5leHBvcnRzLmhtYWMgPSBobWFjO1xuZXhwb3J0cy5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/sha256.js":
/*!************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/hashes/sha256.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha224 = exports.sha256 = void 0;\nconst _sha2_js_1 = __webpack_require__(/*! ./_sha2.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/_sha2.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/utils.js\");\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js_1.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());\nexports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMjU2LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLHVHQUFZO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLHVHQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTI1Ni5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhMjI0ID0gZXhwb3J0cy5zaGEyNTYgPSB2b2lkIDA7XG5jb25zdCBfc2hhMl9qc18xID0gcmVxdWlyZShcIi4vX3NoYTIuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgX3NoYTJfanNfMS5TSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9ICgwLCB1dGlsc19qc18xLnJvdHIpKFcxNSwgNykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShXMiwgMTcpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9ICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDYpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgMTEpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9ICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDIpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMTMpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhMjU2ID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0cy5zaGEyMjQgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/utils.js":
/*!***********************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@noble/hashes/utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/crypto.js\");\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!exports.isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxrQ0FBa0MsR0FBRywrQkFBK0IsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsbUJBQW1CLEdBQUcsZUFBZSxHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLFlBQVksR0FBRyxZQUFZLEdBQUcsa0JBQWtCLEdBQUcsV0FBVyxHQUFHLFVBQVU7QUFDcFg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsa0hBQXNCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGV4cG9ydHMud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSBleHBvcnRzLmNoZWNrT3B0cyA9IGV4cG9ydHMuSGFzaCA9IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBleHBvcnRzLnRvQnl0ZXMgPSBleHBvcnRzLnV0ZjhUb0J5dGVzID0gZXhwb3J0cy5hc3luY0xvb3AgPSBleHBvcnRzLm5leHRUaWNrID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5pc0xFID0gZXhwb3J0cy5yb3RyID0gZXhwb3J0cy5jcmVhdGVWaWV3ID0gZXhwb3J0cy51MzIgPSBleHBvcnRzLnU4ID0gdm9pZCAwO1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2NyeXB0b1wiKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMudTggPSB1ODtcbmNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmV4cG9ydHMudTMyID0gdTMyO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5jb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLmNyZWF0ZVZpZXcgPSBjcmVhdGVWaWV3O1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbmV4cG9ydHMucm90ciA9IHJvdHI7XG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGhhc2hlczpcbi8vIGVhcmx5LXRocm93IGFuIGVycm9yIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBCRSB5ZXQuXG5leHBvcnRzLmlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFleHBvcnRzLmlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG5jb25zdCBoZXhlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5jb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCAoMCwgZXhwb3J0cy5uZXh0VGljaykoKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG5leHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuLy8gQ2hlY2sgaWYgb2JqZWN0IGRvZW5zJ3QgaGF2ZSBjdXN0b20gY29uc3RydWN0b3IgKGxpa2UgVWludDhBcnJheS9BcnJheSlcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5mdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgIWlzUGxhaW5PYmplY3Qob3B0cykpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0cy5jaGVja09wdHMgPSBjaGVja09wdHM7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSB3cmFwQ29uc3RydWN0b3I7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cztcbmZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzO1xuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@noble/hashes/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction chain(...args) {\n    const wrap = (a, b) => (c) => a(b(c));\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\nfunction convertRadix(data, from, to) {\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!digits[i])\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nconst utils = { alphabet, chain, checksum, radix, radix2, join, padding };\nconst base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nconst base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nconst base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nconst base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nconst base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nconst base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nconst base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nconst bech32 = genBech32('bech32');\nconst bech32m = genBech32('bech32m');\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nconst hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString;\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDTztBQUNQO0FBQ0EsMENBQTBDLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEdBQUcsYUFBYSxnQkFBZ0I7QUFDckc7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsT0FBTztBQUNsRjtBQUNBO0FBQ0Esd0RBQXdELE9BQU8sY0FBYyxTQUFTO0FBQ3RGO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEVBQUU7QUFDdkU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEtBQUs7QUFDekQ7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLGFBQWE7QUFDYjtBQUNPO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxnRUFBZ0UsVUFBVSxjQUFjLFNBQVM7QUFDakc7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLCtCQUErQjtBQUMxRjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9saWIvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGNoYWluKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB3cmFwID0gKGEsIGIpID0+IChjKSA9PiBhKGIoYykpO1xuICAgIGNvbnN0IGVuY29kZSA9IEFycmF5LmZyb20oYXJncylcbiAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAucmVkdWNlKChhY2MsIGkpID0+IChhY2MgPyB3cmFwKGFjYywgaS5lbmNvZGUpIDogaS5lbmNvZGUpLCB1bmRlZmluZWQpO1xuICAgIGNvbnN0IGRlY29kZSA9IGFyZ3MucmVkdWNlKChhY2MsIGkpID0+IChhY2MgPyB3cmFwKGFjYywgaS5kZWNvZGUpIDogaS5kZWNvZGUpLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlIH07XG59XG5mdW5jdGlvbiBhbHBoYWJldChhbHBoYWJldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydE51bWJlcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBhbHBoYWJldC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldDogJHtpfSAoYWxwaGFiZXQ6ICR7YWxwaGFiZXQubGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxwaGFiZXRbaV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgobGV0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXR0ZXIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmRlY29kZTogbm90IHN0cmluZyBlbGVtZW50PSR7bGV0dGVyfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYWxwaGFiZXQuaW5kZXhPZihsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtsZXR0ZXJ9XCIuIEFsbG93ZWQ6ICR7YWxwaGFiZXR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yID0gJycpIHtcbiAgICBpZiAodHlwZW9mIHNlcGFyYXRvciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbiBzZXBhcmF0b3Igc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmcm9tKSB8fCAoZnJvbS5sZW5ndGggJiYgdHlwZW9mIGZyb21bMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGZyb20pXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBqb2luLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKHRvKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZGVjb2RlIGlucHV0IHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB0by5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBwYWRkaW5nKGJpdHMsIGNociA9ICc9Jykge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAodHlwZW9mIGNociAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZyBjaHIgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICYmIHR5cGVvZiBkYXRhWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBkYXRhKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgd2hpbGUgKChkYXRhLmxlbmd0aCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2hyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGlucHV0KVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5kZWNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoZW5kICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgc2hvdWxkIGhhdmUgd2hvbGUgbnVtYmVyIG9mIGJ5dGVzJyk7XG4gICAgICAgICAgICBmb3IgKDsgZW5kID4gMCAmJiBpbnB1dFtlbmQgLSAxXSA9PT0gY2hyOyBlbmQtLSkge1xuICAgICAgICAgICAgICAgIGlmICghKCgoZW5kIC0gMSkgKiBiaXRzKSAlIDgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIGhhcyB0b28gbXVjaCBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3JtYWxpemUgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHsgZW5jb2RlOiAoZnJvbSkgPT4gZnJvbSwgZGVjb2RlOiAodG8pID0+IGZuKHRvKSB9O1xufVxuZnVuY3Rpb24gY29udmVydFJhZGl4KGRhdGEsIGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgZnJvbT0ke2Zyb219LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICh0byA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyB0bz0ke3RvfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmICghZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBkaWdpdHMgPSBBcnJheS5mcm9tKGRhdGEpO1xuICAgIGRpZ2l0cy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGFzc2VydE51bWJlcihkKTtcbiAgICAgICAgaWYgKGQgPCAwIHx8IGQgPj0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtkfWApO1xuICAgIH0pO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBjYXJyeSA9IDA7XG4gICAgICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlnaXQgPSBkaWdpdHNbaV07XG4gICAgICAgICAgICBjb25zdCBkaWdpdEJhc2UgPSBmcm9tICogY2FycnkgKyBkaWdpdDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRCYXNlKSB8fFxuICAgICAgICAgICAgICAgIChmcm9tICogY2FycnkpIC8gZnJvbSAhPT0gY2FycnkgfHxcbiAgICAgICAgICAgICAgICBkaWdpdEJhc2UgLSBkaWdpdCAhPT0gZnJvbSAqIGNhcnJ5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXJyeSA9IGRpZ2l0QmFzZSAlIHRvO1xuICAgICAgICAgICAgZGlnaXRzW2ldID0gTWF0aC5mbG9vcihkaWdpdEJhc2UgLyB0byk7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0c1tpXSkgfHwgZGlnaXRzW2ldICogdG8gKyBjYXJyeSAhPT0gZGlnaXRCYXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWRpZ2l0c1tpXSlcbiAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjYXJyeSk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxICYmIGRhdGFbaV0gPT09IDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMCk7XG4gICAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59XG5jb25zdCBnY2QgPSAoYSwgYikgPT4gKCFiID8gYSA6IGdjZChiLCBhICUgYikpO1xuY29uc3QgcmFkaXgyY2FycnkgPSAoZnJvbSwgdG8pID0+IGZyb20gKyAodG8gLSBnY2QoZnJvbSwgdG8pKTtcbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeDIoZGF0YSwgZnJvbSwgdG8sIHBhZGRpbmcpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4MjogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoZnJvbSA8PSAwIHx8IGZyb20gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyBmcm9tPSR7ZnJvbX1gKTtcbiAgICBpZiAodG8gPD0gMCB8fCB0byA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIHRvPSR7dG99YCk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KGZyb20sIHRvKSA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgZnJvbT0ke2Zyb219IHRvPSR7dG99IGNhcnJ5Qml0cz0ke3JhZGl4MmNhcnJ5KGZyb20sIHRvKX1gKTtcbiAgICB9XG4gICAgbGV0IGNhcnJ5ID0gMDtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCBtYXNrID0gMiAqKiB0byAtIDE7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKG4pO1xuICAgICAgICBpZiAobiA+PSAyICoqIGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGludmFsaWQgZGF0YSB3b3JkPSR7bn0gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IDw8IGZyb20pIHwgbjtcbiAgICAgICAgaWYgKHBvcyArIGZyb20gPiAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgcG9zPSR7cG9zfSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgcG9zICs9IGZyb207XG4gICAgICAgIGZvciAoOyBwb3MgPj0gdG87IHBvcyAtPSB0bylcbiAgICAgICAgICAgIHJlcy5wdXNoKCgoY2FycnkgPj4gKHBvcyAtIHRvKSkgJiBtYXNrKSA+Pj4gMCk7XG4gICAgICAgIGNhcnJ5ICY9IDIgKiogcG9zIC0gMTtcbiAgICB9XG4gICAgY2FycnkgPSAoY2FycnkgPDwgKHRvIC0gcG9zKSkgJiBtYXNrO1xuICAgIGlmICghcGFkZGluZyAmJiBwb3MgPj0gZnJvbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNlc3MgcGFkZGluZycpO1xuICAgIGlmICghcGFkZGluZyAmJiBjYXJyeSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gcmFkaXgobnVtKSB7XG4gICAgYXNzZXJ0TnVtYmVyKG51bSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgoQXJyYXkuZnJvbShieXRlcyksIDIgKiogOCwgbnVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4KGRpZ2l0cywgbnVtLCAyICoqIDgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmFkaXgyKGJpdHMsIHJldlBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAoYml0cyA8PSAwIHx8IGJpdHMgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl0nKTtcbiAgICBpZiAocmFkaXgyY2FycnkoOCwgYml0cykgPiAzMiB8fCByYWRpeDJjYXJyeShiaXRzLCA4KSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgyKEFycmF5LmZyb20oYnl0ZXMpLCA4LCBiaXRzLCAhcmV2UGFkZGluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgyKGRpZ2l0cywgYml0cywgOCwgcmV2UGFkZGluZykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiB1bnNhZmVXcmFwcGVyKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNhZmVXcmFwcGVyIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tzdW0obGVuLCBmbikge1xuICAgIGFzc2VydE51bWJlcihsZW4pO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0gZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gZm4oZGF0YSkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgbGVuKTtcbiAgICAgICAgICAgIHJlcy5zZXQoZGF0YSk7XG4gICAgICAgICAgICByZXMuc2V0KGNoZWNrc3VtLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZGVjb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc2xpY2UoMCwgLWxlbik7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGVja3N1bSA9IGZuKHBheWxvYWQpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCBvbGRDaGVja3N1bSA9IGRhdGEuc2xpY2UoLWxlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja3N1bVtpXSAhPT0gb2xkQ2hlY2tzdW1baV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGVja3N1bScpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCB1dGlscyA9IHsgYWxwaGFiZXQsIGNoYWluLCBjaGVja3N1bSwgcmFkaXgsIHJhZGl4Miwgam9pbiwgcGFkZGluZyB9O1xuZXhwb3J0IGNvbnN0IGJhc2UxNiA9IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUYnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXggPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyY3JvY2tmb3JkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVonKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4gcy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL08vZywgJzAnKS5yZXBsYWNlKC9bSUxdL2csICcxJykpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjQgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmwgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmNvbnN0IGdlbkJhc2U1OCA9IChhYmMpID0+IGNoYWluKHJhZGl4KDU4KSwgYWxwaGFiZXQoYWJjKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OCA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OGZsaWNrciA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhycCA9IGdlbkJhc2U1OCgncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eicpO1xuY29uc3QgWE1SX0JMT0NLX0xFTiA9IFswLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTFdO1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhtciA9IHtcbiAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBkYXRhLnN1YmFycmF5KGksIGkgKyA4KTtcbiAgICAgICAgICAgIHJlcyArPSBiYXNlNTguZW5jb2RlKGJsb2NrKS5wYWRTdGFydChYTVJfQkxPQ0tfTEVOW2Jsb2NrLmxlbmd0aF0sICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29kZShzdHIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3RyLnNsaWNlKGksIGkgKyAxMSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0xlbiA9IFhNUl9CTE9DS19MRU4uaW5kZXhPZihzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBiYXNlNTguZGVjb2RlKHNsaWNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2subGVuZ3RoIC0gYmxvY2tMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1tqXSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYXNlNTh4bXI6IHdyb25nIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoQXJyYXkuZnJvbShibG9jay5zbGljZShibG9jay5sZW5ndGggLSBibG9ja0xlbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcyk7XG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgYmFzZTU4Y2hlY2sgPSAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBiYXNlNTgpO1xuY29uc3QgQkVDSF9BTFBIQUJFVCA9IGNoYWluKGFscGhhYmV0KCdxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bCcpLCBqb2luKCcnKSk7XG5jb25zdCBQT0xZTU9EX0dFTkVSQVRPUlMgPSBbMHgzYjZhNTdiMiwgMHgyNjUwOGU2ZCwgMHgxZWExMTlmYSwgMHgzZDQyMzNkZCwgMHgyYTE0NjJiM107XG5mdW5jdGlvbiBiZWNoMzJQb2x5bW9kKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgbGV0IGNoayA9IChwcmUgJiAweDFmZmZmZmYpIDw8IDU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQT0xZTU9EX0dFTkVSQVRPUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCgoYiA+PiBpKSAmIDEpID09PSAxKVxuICAgICAgICAgICAgY2hrIF49IFBPTFlNT0RfR0VORVJBVE9SU1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbmZ1bmN0aW9uIGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBlbmNvZGluZ0NvbnN0ID0gMSkge1xuICAgIGNvbnN0IGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMzMgfHwgYyA+IDEyNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmVmaXggKCR7cHJlZml4fSlgKTtcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAocHJlZml4LmNoYXJDb2RlQXQoaSkgJiAweDFmKTtcbiAgICBmb3IgKGxldCB2IG9mIHdvcmRzKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiB2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgY2hrIF49IGVuY29kaW5nQ29uc3Q7XG4gICAgcmV0dXJuIEJFQ0hfQUxQSEFCRVQuZW5jb2RlKGNvbnZlcnRSYWRpeDIoW2NoayAlIDIgKiogMzBdLCAzMCwgNSwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIGdlbkJlY2gzMihlbmNvZGluZykge1xuICAgIGNvbnN0IEVOQ09ESU5HX0NPTlNUID0gZW5jb2RpbmcgPT09ICdiZWNoMzInID8gMSA6IDB4MmJjODMwYTM7XG4gICAgY29uc3QgX3dvcmRzID0gcmFkaXgyKDUpO1xuICAgIGNvbnN0IGZyb21Xb3JkcyA9IF93b3Jkcy5kZWNvZGU7XG4gICAgY29uc3QgdG9Xb3JkcyA9IF93b3Jkcy5lbmNvZGU7XG4gICAgY29uc3QgZnJvbVdvcmRzVW5zYWZlID0gdW5zYWZlV3JhcHBlcihmcm9tV29yZHMpO1xuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZml4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSBwcmVmaXggc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHByZWZpeH1gKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRzKSB8fCAod29yZHMubGVuZ3RoICYmIHR5cGVvZiB3b3Jkc1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHdvcmRzIHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzLCBub3QgJHt0eXBlb2Ygd29yZHN9YCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHByZWZpeC5sZW5ndGggKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobGltaXQgIT09IGZhbHNlICYmIGFjdHVhbExlbmd0aCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7YWN0dWFsTGVuZ3RofSBleGNlZWRzIGxpbWl0ICR7bGltaXR9YCk7XG4gICAgICAgIHByZWZpeCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fTEke0JFQ0hfQUxQSEFCRVQuZW5jb2RlKHdvcmRzKX0ke2JlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCl9YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gc3RyLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmluZyBtdXN0IGJlIGxvd2VyY2FzZSBvciB1cHBlcmNhc2VgKTtcbiAgICAgICAgc3RyID0gbG93ZXJlZDtcbiAgICAgICAgY29uc3Qgc2VwSW5kZXggPSBzdHIubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNlcEluZGV4ID09PSAwIHx8IHNlcEluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGV0dGVyIFwiMVwiIG11c3QgYmUgcHJlc2VudCBiZXR3ZWVuIHByZWZpeCBhbmQgZGF0YSBvbmx5YCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHN0ci5zbGljZSgwLCBzZXBJbmRleCk7XG4gICAgICAgIGNvbnN0IF93b3JkcyA9IHN0ci5zbGljZShzZXBJbmRleCArIDEpO1xuICAgICAgICBpZiAoX3dvcmRzLmxlbmd0aCA8IDYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMgbG9uZycpO1xuICAgICAgICBjb25zdCB3b3JkcyA9IEJFQ0hfQUxQSEFCRVQuZGVjb2RlKF93b3Jkcykuc2xpY2UoMCwgLTYpO1xuICAgICAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICBpZiAoIV93b3Jkcy5lbmRzV2l0aChzdW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoZWNrc3VtIGluICR7c3RyfTogZXhwZWN0ZWQgXCIke3N1bX1cImApO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzIH07XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZVVuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZGVjb2RlKTtcbiAgICBmdW5jdGlvbiBkZWNvZGVUb0J5dGVzKHN0cikge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgd29yZHMgfSA9IGRlY29kZShzdHIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcywgYnl0ZXM6IGZyb21Xb3Jkcyh3b3JkcykgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUsIGRlY29kZVRvQnl0ZXMsIGRlY29kZVVuc2FmZSwgZnJvbVdvcmRzLCBmcm9tV29yZHNVbnNhZmUsIHRvV29yZHMgfTtcbn1cbmV4cG9ydCBjb25zdCBiZWNoMzIgPSBnZW5CZWNoMzIoJ2JlY2gzMicpO1xuZXhwb3J0IGNvbnN0IGJlY2gzMm0gPSBnZW5CZWNoMzIoJ2JlY2gzMm0nKTtcbmV4cG9ydCBjb25zdCB1dGY4ID0ge1xuICAgIGVuY29kZTogKGRhdGEpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSxcbiAgICBkZWNvZGU6IChzdHIpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpLFxufTtcbmV4cG9ydCBjb25zdCBoZXggPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5YWJjZGVmJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xufSkpO1xuY29uc3QgQ09ERVJTID0ge1xuICAgIHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtclxufTtcbmNvbnN0IGNvZGVyVHlwZUVycm9yID0gYEludmFsaWQgZW5jb2RpbmcgdHlwZS4gQXZhaWxhYmxlIHR5cGVzOiAke09iamVjdC5rZXlzKENPREVSUykuam9pbignLCAnKX1gO1xuZXhwb3J0IGNvbnN0IGJ5dGVzVG9TdHJpbmcgPSAodHlwZSwgYnl0ZXMpID0+IHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnIHx8ICFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzVG9TdHJpbmcoKSBleHBlY3RzIFVpbnQ4QXJyYXknKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmVuY29kZShieXRlcyk7XG59O1xuZXhwb3J0IGNvbnN0IHN0ciA9IGJ5dGVzVG9TdHJpbmc7XG5leHBvcnQgY29uc3Qgc3RyaW5nVG9CeXRlcyA9ICh0eXBlLCBzdHIpID0+IHtcbiAgICBpZiAoIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmdUb0J5dGVzKCkgZXhwZWN0cyBzdHJpbmcnKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmRlY29kZShzdHIpO1xufTtcbmV4cG9ydCBjb25zdCBieXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../node_modules/nostr-tools/node_modules/@scure/base/lib/index.js":
/*!*************************************************************************!*\
  !*** ../node_modules/nostr-tools/node_modules/@scure/base/lib/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nexports.assertNumber = assertNumber;\nfunction chain(...args) {\n    const wrap = (a, b) => (c) => a(b(c));\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\nfunction convertRadix(data, from, to) {\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!digits[i])\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nexports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);\nexports.base58check = base58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst CODERS = {\n    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString;\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxxQkFBcUIsR0FBRyxXQUFXLEdBQUcscUJBQXFCLEdBQUcsV0FBVyxHQUFHLFlBQVksR0FBRyxlQUFlLEdBQUcsY0FBYyxHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLGNBQWMsR0FBRyxpQkFBaUIsR0FBRyxjQUFjLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsb0JBQW9CO0FBQzdZO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEdBQUcsYUFBYSxnQkFBZ0I7QUFDckc7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsT0FBTztBQUNsRjtBQUNBO0FBQ0Esd0RBQXdELE9BQU8sY0FBYyxTQUFTO0FBQ3RGO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEVBQUU7QUFDdkU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsU0FB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YTtBQUNoRztBQUNBO0FBQ0EsMENBQTBDLGNBQWMsZ0JBQWdCLE1BQU07QUFDOUU7QUFDQSxrQkFBa0IsT0FBTyxHQUFHLDRCQUE0QixFQUFFLDRDQUE0QztBQUN0RztBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsV0FBVztBQUNwRjtBQUNBLHdEQUF3RCxZQUFZLEdBQUcsSUFBSSxrQkFBa0IsTUFBTTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUksY0FBYyxJQUFJO0FBQ3pFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZCxlQUFlO0FBQ2YsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGdFQUFnRSxVQUFVLGNBQWMsU0FBUztBQUNqRztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsK0JBQStCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixhQUFhIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gZXhwb3J0cy5zdHIgPSBleHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBleHBvcnRzLmhleCA9IGV4cG9ydHMudXRmOCA9IGV4cG9ydHMuYmVjaDMybSA9IGV4cG9ydHMuYmVjaDMyID0gZXhwb3J0cy5iYXNlNThjaGVjayA9IGV4cG9ydHMuYmFzZTU4eG1yID0gZXhwb3J0cy5iYXNlNTh4cnAgPSBleHBvcnRzLmJhc2U1OGZsaWNrciA9IGV4cG9ydHMuYmFzZTU4ID0gZXhwb3J0cy5iYXNlNjR1cmwgPSBleHBvcnRzLmJhc2U2NCA9IGV4cG9ydHMuYmFzZTMyY3JvY2tmb3JkID0gZXhwb3J0cy5iYXNlMzJoZXggPSBleHBvcnRzLmJhc2UzMiA9IGV4cG9ydHMuYmFzZTE2ID0gZXhwb3J0cy51dGlscyA9IGV4cG9ydHMuYXNzZXJ0TnVtYmVyID0gdm9pZCAwO1xuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7bn1gKTtcbn1cbmV4cG9ydHMuYXNzZXJ0TnVtYmVyID0gYXNzZXJ0TnVtYmVyO1xuZnVuY3Rpb24gY2hhaW4oLi4uYXJncykge1xuICAgIGNvbnN0IHdyYXAgPSAoYSwgYikgPT4gKGMpID0+IGEoYihjKSk7XG4gICAgY29uc3QgZW5jb2RlID0gQXJyYXkuZnJvbShhcmdzKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgaSkgPT4gKGFjYyA/IHdyYXAoYWNjLCBpLmVuY29kZSkgOiBpLmVuY29kZSksIHVuZGVmaW5lZCk7XG4gICAgY29uc3QgZGVjb2RlID0gYXJncy5yZWR1Y2UoKGFjYywgaSkgPT4gKGFjYyA/IHdyYXAoYWNjLCBpLmRlY29kZSkgOiBpLmRlY29kZSksIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUgfTtcbn1cbmZ1bmN0aW9uIGFscGhhYmV0KGFscGhhYmV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IGFscGhhYmV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWdpdCBpbmRleCBvdXRzaWRlIGFscGhhYmV0OiAke2l9IChhbHBoYWJldDogJHthbHBoYWJldC5sZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYWJldFtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxldHRlciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxwaGFiZXQuZGVjb2RlOiBub3Qgc3RyaW5nIGVsZW1lbnQ9JHtsZXR0ZXJ9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhbHBoYWJldC5pbmRleE9mKGxldHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHthbHBoYWJldH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IgPSAnJykge1xuICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luIHNlcGFyYXRvciBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZyb20pIHx8IChmcm9tLmxlbmd0aCAmJiB0eXBlb2YgZnJvbVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZnJvbSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvaW4uZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBmcm9tLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAodG8pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhZGRpbmcoYml0cywgY2hyID0gJz0nKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmICh0eXBlb2YgY2hyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nIGNociBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSB8fCAoZGF0YS5sZW5ndGggJiYgdHlwZW9mIGRhdGFbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGRhdGEpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICB3aGlsZSAoKGRhdGEubGVuZ3RoICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChjaHIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgaW5wdXQpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmRlY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChlbmQgKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBzaG91bGQgaGF2ZSB3aG9sZSBudW1iZXIgb2YgYnl0ZXMnKTtcbiAgICAgICAgICAgIGZvciAoOyBlbmQgPiAwICYmIGlucHV0W2VuZCAtIDFdID09PSBjaHI7IGVuZC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoKChlbmQgLSAxKSAqIGJpdHMpICUgOCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgaGFzIHRvbyBtdWNoIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5zbGljZSgwLCBlbmQpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemUoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vcm1hbGl6ZSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4geyBlbmNvZGU6IChmcm9tKSA9PiBmcm9tLCBkZWNvZGU6ICh0bykgPT4gZm4odG8pIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgoZGF0YSwgZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyBmcm9tPSR7ZnJvbX0sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKHRvIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIHRvPSR7dG99LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKCFkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGRpZ2l0cyA9IEFycmF5LmZyb20oZGF0YSk7XG4gICAgZGlnaXRzLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKGQpO1xuICAgICAgICBpZiAoZCA8IDAgfHwgZCA+PSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke2R9YCk7XG4gICAgfSk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGNhcnJ5ID0gMDtcbiAgICAgICAgbGV0IGRvbmUgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWdpdCA9IGRpZ2l0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0QmFzZSA9IGZyb20gKiBjYXJyeSArIGRpZ2l0O1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaWdpdEJhc2UpIHx8XG4gICAgICAgICAgICAgICAgKGZyb20gKiBjYXJyeSkgLyBmcm9tICE9PSBjYXJyeSB8fFxuICAgICAgICAgICAgICAgIGRpZ2l0QmFzZSAtIGRpZ2l0ICE9PSBmcm9tICogY2FycnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhcnJ5ID0gZGlnaXRCYXNlICUgdG87XG4gICAgICAgICAgICBkaWdpdHNbaV0gPSBNYXRoLmZsb29yKGRpZ2l0QmFzZSAvIHRvKTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRzW2ldKSB8fCBkaWdpdHNbaV0gKiB0byArIGNhcnJ5ICE9PSBkaWdpdEJhc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmICghZGlnaXRzW2ldKVxuICAgICAgICAgICAgICAgIHBvcyA9IGk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5KTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDEgJiYgZGF0YVtpXSA9PT0gMDsgaSsrKVxuICAgICAgICByZXMucHVzaCgwKTtcbiAgICByZXR1cm4gcmVzLnJldmVyc2UoKTtcbn1cbmNvbnN0IGdjZCA9IChhLCBiKSA9PiAoIWIgPyBhIDogZ2NkKGIsIGEgJSBiKSk7XG5jb25zdCByYWRpeDJjYXJyeSA9IChmcm9tLCB0bykgPT4gZnJvbSArICh0byAtIGdjZChmcm9tLCB0bykpO1xuZnVuY3Rpb24gY29udmVydFJhZGl4MihkYXRhLCBmcm9tLCB0bywgcGFkZGluZykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXgyOiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICAgIGlmICh0byA8PSAwIHx8IHRvID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHt0b31gKTtcbiAgICBpZiAocmFkaXgyY2FycnkoZnJvbSwgdG8pID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWApO1xuICAgIH1cbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IG1hc2sgPSAyICoqIHRvIC0gMTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGF0YSkge1xuICAgICAgICBhc3NlcnROdW1iZXIobik7XG4gICAgICAgIGlmIChuID49IDIgKiogZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtufSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgPDwgZnJvbSkgfCBuO1xuICAgICAgICBpZiAocG9zICsgZnJvbSA+IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtwb3N9IGZyb209JHtmcm9tfWApO1xuICAgICAgICBwb3MgKz0gZnJvbTtcbiAgICAgICAgZm9yICg7IHBvcyA+PSB0bzsgcG9zIC09IHRvKVxuICAgICAgICAgICAgcmVzLnB1c2goKChjYXJyeSA+PiAocG9zIC0gdG8pKSAmIG1hc2spID4+PiAwKTtcbiAgICAgICAgY2FycnkgJj0gMiAqKiBwb3MgLSAxO1xuICAgIH1cbiAgICBjYXJyeSA9IChjYXJyeSA8PCAodG8gLSBwb3MpKSAmIG1hc2s7XG4gICAgaWYgKCFwYWRkaW5nICYmIHBvcyA+PSBmcm9tKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VzcyBwYWRkaW5nJyk7XG4gICAgaWYgKCFwYWRkaW5nICYmIGNhcnJ5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi16ZXJvIHBhZGRpbmc6ICR7Y2Fycnl9YCk7XG4gICAgaWYgKHBhZGRpbmcgJiYgcG9zID4gMClcbiAgICAgICAgcmVzLnB1c2goY2FycnkgPj4+IDApO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICBhc3NlcnROdW1iZXIobnVtKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgMiAqKiA4LCBudW0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIDIgKiogOCkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiByYWRpeDIoYml0cywgcmV2UGFkZGluZyA9IGZhbHNlKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmIChiaXRzIDw9IDAgfHwgYml0cyA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogYml0cyBzaG91bGQgYmUgaW4gKDAuLjMyXScpO1xuICAgIGlmIChyYWRpeDJjYXJyeSg4LCBiaXRzKSA+IDMyIHx8IHJhZGl4MmNhcnJ5KGJpdHMsIDgpID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBjYXJyeSBvdmVyZmxvdycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeDIoQXJyYXkuZnJvbShieXRlcyksIDgsIGJpdHMsICFyZXZQYWRkaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeDIoZGlnaXRzLCBiaXRzLCA4LCByZXZQYWRkaW5nKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVuc2FmZVdyYXBwZXIoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZVdyYXBwZXIgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja3N1bShsZW4sIGZuKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGxlbik7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZW5jb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBmbihkYXRhKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBsZW4pO1xuICAgICAgICAgICAgcmVzLnNldChkYXRhKTtcbiAgICAgICAgICAgIHJlcy5zZXQoY2hlY2tzdW0sIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5kZWNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YS5zbGljZSgwLCAtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoZWNrc3VtID0gZm4ocGF5bG9hZCkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENoZWNrc3VtID0gZGF0YS5zbGljZSgtbGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrc3VtW2ldICE9PSBvbGRDaGVja3N1bVtpXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJyk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy51dGlscyA9IHsgYWxwaGFiZXQsIGNoYWluLCBjaGVja3N1bSwgcmFkaXgsIHJhZGl4Miwgam9pbiwgcGFkZGluZyB9O1xuZXhwb3J0cy5iYXNlMTYgPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGJyksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTMyID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlMzJoZXggPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2UzMmNyb2NrZm9yZCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSEpLTU5QUVJTVFZXWFlaJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHMudG9VcHBlckNhc2UoKS5yZXBsYWNlKC9PL2csICcwJykucmVwbGFjZSgvW0lMXS9nLCAnMScpKSk7XG5leHBvcnRzLmJhc2U2NCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlNjR1cmwgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmNvbnN0IGdlbkJhc2U1OCA9IChhYmMpID0+IGNoYWluKHJhZGl4KDU4KSwgYWxwaGFiZXQoYWJjKSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlNTggPSBnZW5CYXNlNTgoJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonKTtcbmV4cG9ydHMuYmFzZTU4ZmxpY2tyID0gZ2VuQmFzZTU4KCcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJyk7XG5leHBvcnRzLmJhc2U1OHhycCA9IGdlbkJhc2U1OCgncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eicpO1xuY29uc3QgWE1SX0JMT0NLX0xFTiA9IFswLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTFdO1xuZXhwb3J0cy5iYXNlNTh4bXIgPSB7XG4gICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZGF0YS5zdWJhcnJheShpLCBpICsgOCk7XG4gICAgICAgICAgICByZXMgKz0gZXhwb3J0cy5iYXNlNTguZW5jb2RlKGJsb2NrKS5wYWRTdGFydChYTVJfQkxPQ0tfTEVOW2Jsb2NrLmxlbmd0aF0sICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29kZShzdHIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3RyLnNsaWNlKGksIGkgKyAxMSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0xlbiA9IFhNUl9CTE9DS19MRU4uaW5kZXhPZihzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBleHBvcnRzLmJhc2U1OC5kZWNvZGUoc2xpY2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9jay5sZW5ndGggLSBibG9ja0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrW2pdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2U1OHhtcjogd3JvbmcgcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChBcnJheS5mcm9tKGJsb2NrLnNsaWNlKGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVzKTtcbiAgICB9LFxufTtcbmNvbnN0IGJhc2U1OGNoZWNrID0gKHNoYTI1NikgPT4gY2hhaW4oY2hlY2tzdW0oNCwgKGRhdGEpID0+IHNoYTI1NihzaGEyNTYoZGF0YSkpKSwgZXhwb3J0cy5iYXNlNTgpO1xuZXhwb3J0cy5iYXNlNThjaGVjayA9IGJhc2U1OGNoZWNrO1xuY29uc3QgQkVDSF9BTFBIQUJFVCA9IGNoYWluKGFscGhhYmV0KCdxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bCcpLCBqb2luKCcnKSk7XG5jb25zdCBQT0xZTU9EX0dFTkVSQVRPUlMgPSBbMHgzYjZhNTdiMiwgMHgyNjUwOGU2ZCwgMHgxZWExMTlmYSwgMHgzZDQyMzNkZCwgMHgyYTE0NjJiM107XG5mdW5jdGlvbiBiZWNoMzJQb2x5bW9kKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgbGV0IGNoayA9IChwcmUgJiAweDFmZmZmZmYpIDw8IDU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQT0xZTU9EX0dFTkVSQVRPUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCgoYiA+PiBpKSAmIDEpID09PSAxKVxuICAgICAgICAgICAgY2hrIF49IFBPTFlNT0RfR0VORVJBVE9SU1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbmZ1bmN0aW9uIGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBlbmNvZGluZ0NvbnN0ID0gMSkge1xuICAgIGNvbnN0IGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMzMgfHwgYyA+IDEyNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmVmaXggKCR7cHJlZml4fSlgKTtcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAocHJlZml4LmNoYXJDb2RlQXQoaSkgJiAweDFmKTtcbiAgICBmb3IgKGxldCB2IG9mIHdvcmRzKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiB2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgY2hrIF49IGVuY29kaW5nQ29uc3Q7XG4gICAgcmV0dXJuIEJFQ0hfQUxQSEFCRVQuZW5jb2RlKGNvbnZlcnRSYWRpeDIoW2NoayAlIDIgKiogMzBdLCAzMCwgNSwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIGdlbkJlY2gzMihlbmNvZGluZykge1xuICAgIGNvbnN0IEVOQ09ESU5HX0NPTlNUID0gZW5jb2RpbmcgPT09ICdiZWNoMzInID8gMSA6IDB4MmJjODMwYTM7XG4gICAgY29uc3QgX3dvcmRzID0gcmFkaXgyKDUpO1xuICAgIGNvbnN0IGZyb21Xb3JkcyA9IF93b3Jkcy5kZWNvZGU7XG4gICAgY29uc3QgdG9Xb3JkcyA9IF93b3Jkcy5lbmNvZGU7XG4gICAgY29uc3QgZnJvbVdvcmRzVW5zYWZlID0gdW5zYWZlV3JhcHBlcihmcm9tV29yZHMpO1xuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZml4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSBwcmVmaXggc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHByZWZpeH1gKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRzKSB8fCAod29yZHMubGVuZ3RoICYmIHR5cGVvZiB3b3Jkc1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHdvcmRzIHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzLCBub3QgJHt0eXBlb2Ygd29yZHN9YCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHByZWZpeC5sZW5ndGggKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobGltaXQgIT09IGZhbHNlICYmIGFjdHVhbExlbmd0aCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7YWN0dWFsTGVuZ3RofSBleGNlZWRzIGxpbWl0ICR7bGltaXR9YCk7XG4gICAgICAgIHByZWZpeCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fTEke0JFQ0hfQUxQSEFCRVQuZW5jb2RlKHdvcmRzKX0ke2JlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCl9YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gc3RyLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmluZyBtdXN0IGJlIGxvd2VyY2FzZSBvciB1cHBlcmNhc2VgKTtcbiAgICAgICAgc3RyID0gbG93ZXJlZDtcbiAgICAgICAgY29uc3Qgc2VwSW5kZXggPSBzdHIubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNlcEluZGV4ID09PSAwIHx8IHNlcEluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGV0dGVyIFwiMVwiIG11c3QgYmUgcHJlc2VudCBiZXR3ZWVuIHByZWZpeCBhbmQgZGF0YSBvbmx5YCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHN0ci5zbGljZSgwLCBzZXBJbmRleCk7XG4gICAgICAgIGNvbnN0IF93b3JkcyA9IHN0ci5zbGljZShzZXBJbmRleCArIDEpO1xuICAgICAgICBpZiAoX3dvcmRzLmxlbmd0aCA8IDYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMgbG9uZycpO1xuICAgICAgICBjb25zdCB3b3JkcyA9IEJFQ0hfQUxQSEFCRVQuZGVjb2RlKF93b3Jkcykuc2xpY2UoMCwgLTYpO1xuICAgICAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICBpZiAoIV93b3Jkcy5lbmRzV2l0aChzdW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoZWNrc3VtIGluICR7c3RyfTogZXhwZWN0ZWQgXCIke3N1bX1cImApO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzIH07XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZVVuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZGVjb2RlKTtcbiAgICBmdW5jdGlvbiBkZWNvZGVUb0J5dGVzKHN0cikge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgd29yZHMgfSA9IGRlY29kZShzdHIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcywgYnl0ZXM6IGZyb21Xb3Jkcyh3b3JkcykgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUsIGRlY29kZVRvQnl0ZXMsIGRlY29kZVVuc2FmZSwgZnJvbVdvcmRzLCBmcm9tV29yZHNVbnNhZmUsIHRvV29yZHMgfTtcbn1cbmV4cG9ydHMuYmVjaDMyID0gZ2VuQmVjaDMyKCdiZWNoMzInKTtcbmV4cG9ydHMuYmVjaDMybSA9IGdlbkJlY2gzMignYmVjaDMybScpO1xuZXhwb3J0cy51dGY4ID0ge1xuICAgIGVuY29kZTogKGRhdGEpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSxcbiAgICBkZWNvZGU6IChzdHIpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpLFxufTtcbmV4cG9ydHMuaGV4ID0gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OWFiY2RlZicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJyB8fCBzLmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGhleC5kZWNvZGU6IGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN9IHdpdGggbGVuZ3RoICR7cy5sZW5ndGh9YCk7XG4gICAgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTtcbn0pKTtcbmNvbnN0IENPREVSUyA9IHtcbiAgICB1dGY4OiBleHBvcnRzLnV0ZjgsIGhleDogZXhwb3J0cy5oZXgsIGJhc2UxNjogZXhwb3J0cy5iYXNlMTYsIGJhc2UzMjogZXhwb3J0cy5iYXNlMzIsIGJhc2U2NDogZXhwb3J0cy5iYXNlNjQsIGJhc2U2NHVybDogZXhwb3J0cy5iYXNlNjR1cmwsIGJhc2U1ODogZXhwb3J0cy5iYXNlNTgsIGJhc2U1OHhtcjogZXhwb3J0cy5iYXNlNTh4bXJcbn07XG5jb25zdCBjb2RlclR5cGVFcnJvciA9IGBJbnZhbGlkIGVuY29kaW5nIHR5cGUuIEF2YWlsYWJsZSB0eXBlczogJHtPYmplY3Qua2V5cyhDT0RFUlMpLmpvaW4oJywgJyl9YDtcbmNvbnN0IGJ5dGVzVG9TdHJpbmcgPSAodHlwZSwgYnl0ZXMpID0+IHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnIHx8ICFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzVG9TdHJpbmcoKSBleHBlY3RzIFVpbnQ4QXJyYXknKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmVuY29kZShieXRlcyk7XG59O1xuZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gYnl0ZXNUb1N0cmluZztcbmV4cG9ydHMuc3RyID0gZXhwb3J0cy5ieXRlc1RvU3RyaW5nO1xuY29uc3Qgc3RyaW5nVG9CeXRlcyA9ICh0eXBlLCBzdHIpID0+IHtcbiAgICBpZiAoIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmdUb0J5dGVzKCkgZXhwZWN0cyBzdHJpbmcnKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmRlY29kZShzdHIpO1xufTtcbmV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG5leHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5zdHJpbmdUb0J5dGVzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../node_modules/nostr-tools/node_modules/@scure/base/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/deepmerge/dist/cjs.js":
/*!********************************************!*\
  !*** ./node_modules/deepmerge/dist/cjs.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC9janMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvZGVlcG1lcmdlL2Rpc3QvY2pzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzTWVyZ2VhYmxlT2JqZWN0ID0gZnVuY3Rpb24gaXNNZXJnZWFibGVPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSlcblx0XHQmJiAhaXNTcGVjaWFsKHZhbHVlKVxufTtcblxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuZnVuY3Rpb24gaXNTcGVjaWFsKHZhbHVlKSB7XG5cdHZhciBzdHJpbmdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cblx0cmV0dXJuIHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBSZWdFeHBdJ1xuXHRcdHx8IHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBEYXRlXSdcblx0XHR8fCBpc1JlYWN0RWxlbWVudCh2YWx1ZSlcbn1cblxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I1YWM5NjNmYjc5MWQxMjk4ZTdmMzk2MjM2MzgzYmM5NTVmOTE2YzEvc3JjL2lzb21vcnBoaWMvY2xhc3NpYy9lbGVtZW50L1JlYWN0RWxlbWVudC5qcyNMMjEtTDI1XG52YXIgY2FuVXNlU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGNhblVzZVN5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcblxuZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbn1cblxuZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyBbXSA6IHt9XG59XG5cbmZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zKSB7XG5cdHJldHVybiAob3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkpXG5cdFx0PyBkZWVwbWVyZ2UoZW1wdHlUYXJnZXQodmFsdWUpLCB2YWx1ZSwgb3B0aW9ucylcblx0XHQ6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRBcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoZWxlbWVudCwgb3B0aW9ucylcblx0fSlcbn1cblxuZnVuY3Rpb24gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcblx0aWYgKCFvcHRpb25zLmN1c3RvbU1lcmdlKSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZVxuXHR9XG5cdHZhciBjdXN0b21NZXJnZSA9IG9wdGlvbnMuY3VzdG9tTWVyZ2Uoa2V5KTtcblx0cmV0dXJuIHR5cGVvZiBjdXN0b21NZXJnZSA9PT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbU1lcmdlIDogZGVlcG1lcmdlXG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG5cdFx0PyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwgc3ltYm9sKVxuXHRcdH0pXG5cdFx0OiBbXVxufVxuXG5mdW5jdGlvbiBnZXRLZXlzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5jb25jYXQoZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUlzT25PYmplY3Qob2JqZWN0LCBwcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdHJldHVybiBwcm9wZXJ0eSBpbiBvYmplY3Rcblx0fSBjYXRjaChfKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuLy8gUHJvdGVjdHMgZnJvbSBwcm90b3R5cGUgcG9pc29uaW5nIGFuZCB1bmV4cGVjdGVkIG1lcmdpbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbi5cbmZ1bmN0aW9uIHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpIHtcblx0cmV0dXJuIHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgLy8gUHJvcGVydGllcyBhcmUgc2FmZSB0byBtZXJnZSBpZiB0aGV5IGRvbid0IGV4aXN0IGluIHRoZSB0YXJnZXQgeWV0LFxuXHRcdCYmICEoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpIC8vIHVuc2FmZSBpZiB0aGV5IGV4aXN0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4sXG5cdFx0XHQmJiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIGtleSkpIC8vIGFuZCBhbHNvIHVuc2FmZSBpZiB0aGV5J3JlIG5vbmVudW1lcmFibGUuXG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHZhciBkZXN0aW5hdGlvbiA9IHt9O1xuXHRpZiAob3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh0YXJnZXQpKSB7XG5cdFx0Z2V0S2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodGFyZ2V0W2tleV0sIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9XG5cdGdldEtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdGlmIChwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0aWYgKHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChzb3VyY2Vba2V5XSkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZGVzdGluYXRpb25cbn1cblxuZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRvcHRpb25zLmFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG5cdG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgPSBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IGlzTWVyZ2VhYmxlT2JqZWN0O1xuXHQvLyBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCBpcyBhZGRlZCB0byBgb3B0aW9uc2Agc28gdGhhdCBjdXN0b20gYXJyYXlNZXJnZSgpXG5cdC8vIGltcGxlbWVudGF0aW9ucyBjYW4gdXNlIGl0LiBUaGUgY2FsbGVyIG1heSBub3QgcmVwbGFjZSBpdC5cblx0b3B0aW9ucy5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkO1xuXG5cdHZhciBzb3VyY2VJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzb3VyY2UpO1xuXHR2YXIgdGFyZ2V0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcblx0dmFyIHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdGlmICghc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuXHRcdHJldHVybiBvcHRpb25zLmFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5cbmRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnMpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5Jylcblx0fVxuXG5cdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgbmV4dCkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9ucylcblx0fSwge30pXG59O1xuXG52YXIgZGVlcG1lcmdlXzEgPSBkZWVwbWVyZ2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcG1lcmdlXzE7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/deepmerge/dist/cjs.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/load-script/index.js":
/*!*******************************************!*\
  !*** ./node_modules/load-script/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nmodule.exports = function load (src, opts, cb) {\n  var head = document.head || document.getElementsByTagName('head')[0]\n  var script = document.createElement('script')\n\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  opts = opts || {}\n  cb = cb || function() {}\n\n  script.type = opts.type || 'text/javascript'\n  script.charset = opts.charset || 'utf8';\n  script.async = 'async' in opts ? !!opts.async : true\n  script.src = src\n\n  if (opts.attrs) {\n    setAttributes(script, opts.attrs)\n  }\n\n  if (opts.text) {\n    script.text = '' + opts.text\n  }\n\n  var onend = 'onload' in script ? stdOnEnd : ieOnEnd\n  onend(script, cb)\n\n  // some good legacy browsers (firefox) fail the 'in' detection above\n  // so as a fallback we always set onload\n  // old IE will ignore this and new IE will set onload\n  if (!script.onload) {\n    stdOnEnd(script, cb);\n  }\n\n  head.appendChild(script)\n}\n\nfunction setAttributes(script, attrs) {\n  for (var attr in attrs) {\n    script.setAttribute(attr, attrs[attr]);\n  }\n}\n\nfunction stdOnEnd (script, cb) {\n  script.onload = function () {\n    this.onerror = this.onload = null\n    cb(null, script)\n  }\n  script.onerror = function () {\n    // this.onload = null here is necessary\n    // because even IE9 works not like others\n    this.onerror = this.onload = null\n    cb(new Error('Failed to load ' + this.src), script)\n  }\n}\n\nfunction ieOnEnd (script, cb) {\n  script.onreadystatechange = function () {\n    if (this.readyState != 'complete' && this.readyState != 'loaded') return\n    this.onreadystatechange = null\n    cb(null, script) // there is no way to catch loading errors in IE8\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb2FkLXNjcmlwdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL2xvYWQtc2NyaXB0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb2FkIChzcmMsIG9wdHMsIGNiKSB7XG4gIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdXG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgY2IgPSBjYiB8fCBmdW5jdGlvbigpIHt9XG5cbiAgc2NyaXB0LnR5cGUgPSBvcHRzLnR5cGUgfHwgJ3RleHQvamF2YXNjcmlwdCdcbiAgc2NyaXB0LmNoYXJzZXQgPSBvcHRzLmNoYXJzZXQgfHwgJ3V0ZjgnO1xuICBzY3JpcHQuYXN5bmMgPSAnYXN5bmMnIGluIG9wdHMgPyAhIW9wdHMuYXN5bmMgOiB0cnVlXG4gIHNjcmlwdC5zcmMgPSBzcmNcblxuICBpZiAob3B0cy5hdHRycykge1xuICAgIHNldEF0dHJpYnV0ZXMoc2NyaXB0LCBvcHRzLmF0dHJzKVxuICB9XG5cbiAgaWYgKG9wdHMudGV4dCkge1xuICAgIHNjcmlwdC50ZXh0ID0gJycgKyBvcHRzLnRleHRcbiAgfVxuXG4gIHZhciBvbmVuZCA9ICdvbmxvYWQnIGluIHNjcmlwdCA/IHN0ZE9uRW5kIDogaWVPbkVuZFxuICBvbmVuZChzY3JpcHQsIGNiKVxuXG4gIC8vIHNvbWUgZ29vZCBsZWdhY3kgYnJvd3NlcnMgKGZpcmVmb3gpIGZhaWwgdGhlICdpbicgZGV0ZWN0aW9uIGFib3ZlXG4gIC8vIHNvIGFzIGEgZmFsbGJhY2sgd2UgYWx3YXlzIHNldCBvbmxvYWRcbiAgLy8gb2xkIElFIHdpbGwgaWdub3JlIHRoaXMgYW5kIG5ldyBJRSB3aWxsIHNldCBvbmxvYWRcbiAgaWYgKCFzY3JpcHQub25sb2FkKSB7XG4gICAgc3RkT25FbmQoc2NyaXB0LCBjYik7XG4gIH1cblxuICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhzY3JpcHQsIGF0dHJzKSB7XG4gIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcbiAgICBzY3JpcHQuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGRPbkVuZCAoc2NyaXB0LCBjYikge1xuICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub25lcnJvciA9IHRoaXMub25sb2FkID0gbnVsbFxuICAgIGNiKG51bGwsIHNjcmlwdClcbiAgfVxuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB0aGlzLm9ubG9hZCA9IG51bGwgaGVyZSBpcyBuZWNlc3NhcnlcbiAgICAvLyBiZWNhdXNlIGV2ZW4gSUU5IHdvcmtzIG5vdCBsaWtlIG90aGVyc1xuICAgIHRoaXMub25lcnJvciA9IHRoaXMub25sb2FkID0gbnVsbFxuICAgIGNiKG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgJyArIHRoaXMuc3JjKSwgc2NyaXB0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGllT25FbmQgKHNjcmlwdCwgY2IpIHtcbiAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9ICdjb21wbGV0ZScgJiYgdGhpcy5yZWFkeVN0YXRlICE9ICdsb2FkZWQnKSByZXR1cm5cbiAgICB0aGlzLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGxcbiAgICBjYihudWxsLCBzY3JpcHQpIC8vIHRoZXJlIGlzIG5vIHdheSB0byBjYXRjaCBsb2FkaW5nIGVycm9ycyBpbiBJRThcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/load-script/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/memoize-one/dist/memoize-one.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/memoize-one/dist/memoize-one.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (memoizeOne);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZW1vaXplLW9uZS9kaXN0L21lbW9pemUtb25lLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsVUFBVSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL21lbW9pemUtb25lL2Rpc3QvbWVtb2l6ZS1vbmUuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzYWZlSXNOYU4gPSBOdW1iZXIuaXNOYU4gfHxcbiAgICBmdW5jdGlvbiBwb255ZmlsbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gdmFsdWU7XG4gICAgfTtcbmZ1bmN0aW9uIGlzRXF1YWwoZmlyc3QsIHNlY29uZCkge1xuICAgIGlmIChmaXJzdCA9PT0gc2Vjb25kKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoc2FmZUlzTmFOKGZpcnN0KSAmJiBzYWZlSXNOYU4oc2Vjb25kKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYXJlSW5wdXRzRXF1YWwobmV3SW5wdXRzLCBsYXN0SW5wdXRzKSB7XG4gICAgaWYgKG5ld0lucHV0cy5sZW5ndGggIT09IGxhc3RJbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJbnB1dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFpc0VxdWFsKG5ld0lucHV0c1tpXSwgbGFzdElucHV0c1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWVtb2l6ZU9uZShyZXN1bHRGbiwgaXNFcXVhbCkge1xuICAgIGlmIChpc0VxdWFsID09PSB2b2lkIDApIHsgaXNFcXVhbCA9IGFyZUlucHV0c0VxdWFsOyB9XG4gICAgdmFyIGxhc3RUaGlzO1xuICAgIHZhciBsYXN0QXJncyA9IFtdO1xuICAgIHZhciBsYXN0UmVzdWx0O1xuICAgIHZhciBjYWxsZWRPbmNlID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gbWVtb2l6ZWQoKSB7XG4gICAgICAgIHZhciBuZXdBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBuZXdBcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxlZE9uY2UgJiYgbGFzdFRoaXMgPT09IHRoaXMgJiYgaXNFcXVhbChuZXdBcmdzLCBsYXN0QXJncykpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGxhc3RSZXN1bHQgPSByZXN1bHRGbi5hcHBseSh0aGlzLCBuZXdBcmdzKTtcbiAgICAgICAgY2FsbGVkT25jZSA9IHRydWU7XG4gICAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgICAgbGFzdEFyZ3MgPSBuZXdBcmdzO1xuICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZW1vaXplT25lO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/memoize-one/dist/memoize-one.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi4vY2xpZW50L2NvbXBvbmVudHMvbmF2aWdhdGlvbic7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar assign = Object.assign.bind(Object);\nmodule.exports = assign;\nmodule.exports[\"default\"] = module.exports;\n\n//# sourceMappingURL=object-assign.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL29iamVjdC1hc3NpZ24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EseUJBQXNCOztBQUV0QiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL29iamVjdC1hc3NpZ24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCk7XG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LWFzc2lnbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fscarnes%2Fworkspace%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!**********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fscarnes%2Fworkspace%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \**********************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/page.tsx */ \"(app-pages-browser)/./src/app/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZzY2FybmVzJTJGd29ya3NwYWNlJTJGc3JjJTJGYXBwJTJGcGFnZS50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSw4SkFBOEUiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9zcmMvYXBwL3BhZ2UudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fscarnes%2Fworkspace%2Fsrc%2Fapp%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n        case REACT_ACTIVITY_TYPE:\n          return \"Activity\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function UnknownOwner() {\n      return Error(\"react-stack-top-frame\");\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray,\n      createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          };\n    React = {\n      \"react-stack-bottom-frame\": function (callStackForError) {\n        return callStackForError();\n      }\n    };\n    var specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var unknownOwnerDebugStack = React[\"react-stack-bottom-frame\"].bind(\n      React,\n      UnknownOwner\n    )();\n    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      var trackActualOwner =\n        1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        trackActualOwner\n          ? Error(\"react-stack-top-frame\")\n          : unknownOwnerDebugStack,\n        trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCwrQ0FBK0MsNkJBQTZCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRDtBQUNoRSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsZ0NBQWdDLGtDQUFrQyxPQUFPO0FBQ3pFO0FBQ0EsZ0dBQWdHLFNBQVMsVUFBVSxzRkFBc0YsYUFBYSxVQUFVLFVBQVU7QUFDMU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgICBjYXNlIFJFQUNUX0FDVElWSVRZX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiQWN0aXZpdHlcIjtcbiAgICAgIH1cbiAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgc3dpdGNoIChcbiAgICAgICAgICAoXCJudW1iZXJcIiA9PT0gdHlwZW9mIHR5cGUudGFnICYmXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgdHlwZS4kJHR5cGVvZilcbiAgICAgICAgKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuICh0eXBlLl9jb250ZXh0LmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgdmFyIGlubmVyVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgICAgICgodHlwZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiKSxcbiAgICAgICAgICAgICAgKHR5cGUgPSBcIlwiICE9PSB0eXBlID8gXCJGb3J3YXJkUmVmKFwiICsgdHlwZSArIFwiKVwiIDogXCJGb3J3YXJkUmVmXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgID8gaW5uZXJUeXBlXG4gICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITA7XG4gICAgICB9XG4gICAgICBpZiAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGNvbnNvbGU7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZXJyb3I7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiZcbiAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuICAgICAgICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSkgfHxcbiAgICAgICAgICB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8XG4gICAgICAgICAgXCJPYmplY3RcIjtcbiAgICAgICAgSlNDb21waWxlcl90ZW1wX2NvbnN0LmNhbGwoXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LFxuICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDBcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRhc2tOYW1lKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSByZXR1cm4gXCI8PlwiO1xuICAgICAgaWYgKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICBudWxsICE9PSB0eXBlICYmXG4gICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRVxuICAgICAgKVxuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHJldHVybiBuYW1lID8gXCI8XCIgKyBuYW1lICsgXCI+XCIgOiBcIjwuLi4+XCI7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHJldHVybiBcIjwuLi4+XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE93bmVyKCkge1xuICAgICAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICAgICAgcmV0dXJuIG51bGwgPT09IGRpc3BhdGNoZXIgPyBudWxsIDogZGlzcGF0Y2hlci5nZXRPd25lcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmtub3duT3duZXIoKSB7XG4gICAgICByZXR1cm4gRXJyb3IoXCJyZWFjdC1zdGFjay10b3AtZnJhbWVcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KFxuICAgICAgdHlwZSxcbiAgICAgIGtleSxcbiAgICAgIHNlbGYsXG4gICAgICBzb3VyY2UsXG4gICAgICBvd25lcixcbiAgICAgIHByb3BzLFxuICAgICAgZGVidWdTdGFjayxcbiAgICAgIGRlYnVnVGFza1xuICAgICkge1xuICAgICAgc2VsZiA9IHByb3BzLnJlZjtcbiAgICAgIHR5cGUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgIF9vd25lcjogb3duZXJcbiAgICAgIH07XG4gICAgICBudWxsICE9PSAodm9pZCAwICE9PSBzZWxmID8gc2VsZiA6IG51bGwpXG4gICAgICAgID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgICAgZ2V0OiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZ1xuICAgICAgICAgIH0pXG4gICAgICAgIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwicmVmXCIsIHsgZW51bWVyYWJsZTogITEsIHZhbHVlOiBudWxsIH0pO1xuICAgICAgdHlwZS5fc3RvcmUgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogMFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdJbmZvXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnU3RhY2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdTdGFja1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdUYXNrXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IGRlYnVnVGFza1xuICAgICAgfSk7XG4gICAgICBPYmplY3QuZnJlZXplICYmIChPYmplY3QuZnJlZXplKHR5cGUucHJvcHMpLCBPYmplY3QuZnJlZXplKHR5cGUpKTtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBqc3hERVZJbXBsKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbGYsXG4gICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjb25maWcuY2hpbGRyZW47XG4gICAgICBpZiAodm9pZCAwICE9PSBjaGlsZHJlbilcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzQXJyYXlJbXBsKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPCBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4rK1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpc1N0YXRpY0NoaWxkcmVuXSk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiBZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuIFVzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgIGVsc2UgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4pO1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICBjaGlsZHJlbiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHJldHVybiBcImtleVwiICE9PSBrO1xuICAgICAgICB9KTtcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgMCA8IGtleXMubGVuZ3RoXG4gICAgICAgICAgICA/IFwie2tleTogc29tZUtleSwgXCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIlxuICAgICAgICAgICAgOiBcIntrZXk6IHNvbWVLZXl9XCI7XG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dIHx8XG4gICAgICAgICAgKChrZXlzID1cbiAgICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aCA/IFwie1wiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCIgOiBcInt9XCIpLFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAnQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyB7Li4ucHJvcHN9IC8+XFxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLFxuICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAga2V5cyxcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgKSxcbiAgICAgICAgICAoZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gPSAhMCkpO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgdm9pZCAwICE9PSBtYXliZUtleSAmJlxuICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBtYXliZUtleSkpO1xuICAgICAgaGFzVmFsaWRLZXkoY29uZmlnKSAmJlxuICAgICAgICAoY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIGNvbmZpZy5rZXkpKTtcbiAgICAgIGlmIChcImtleVwiIGluIGNvbmZpZykge1xuICAgICAgICBtYXliZUtleSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBjb25maWcpXG4gICAgICAgICAgXCJrZXlcIiAhPT0gcHJvcE5hbWUgJiYgKG1heWJlS2V5W3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV0pO1xuICAgICAgfSBlbHNlIG1heWJlS2V5ID0gY29uZmlnO1xuICAgICAgY2hpbGRyZW4gJiZcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIoXG4gICAgICAgICAgbWF5YmVLZXksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZVxuICAgICAgICAgICAgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBcIlVua25vd25cIlxuICAgICAgICAgICAgOiB0eXBlXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gUmVhY3RFbGVtZW50KFxuICAgICAgICB0eXBlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgc2VsZixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBnZXRPd25lcigpLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgZGVidWdTdGFjayxcbiAgICAgICAgZGVidWdUYXNrXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlKSB7XG4gICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuICAgICAgICBudWxsICE9PSBub2RlICYmXG4gICAgICAgIG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSAmJlxuICAgICAgICBub2RlLl9zdG9yZSAmJlxuICAgICAgICAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgfVxuICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIiksXG4gICAgICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG4gICAgICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLFxuICAgICAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik7XG4gICAgU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpO1xuICAgIHZhciBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnN1bWVyXCIpLFxuICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gICAgICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSxcbiAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICAgICAgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksXG4gICAgICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgICAgIFJFQUNUX0FDVElWSVRZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuYWN0aXZpdHlcIiksXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGNyZWF0ZVRhc2sgPSBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgPyBjb25zb2xlLmNyZWF0ZVRhc2tcbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9O1xuICAgIFJlYWN0ID0ge1xuICAgICAgXCJyZWFjdC1zdGFjay1ib3R0b20tZnJhbWVcIjogZnVuY3Rpb24gKGNhbGxTdGFja0ZvckVycm9yKSB7XG4gICAgICAgIHJldHVybiBjYWxsU3RhY2tGb3JFcnJvcigpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuICAgIHZhciBkaWRXYXJuQWJvdXRFbGVtZW50UmVmID0ge307XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnU3RhY2sgPSBSZWFjdFtcInJlYWN0LXN0YWNrLWJvdHRvbS1mcmFtZVwiXS5iaW5kKFxuICAgICAgUmVhY3QsXG4gICAgICBVbmtub3duT3duZXJcbiAgICApKCk7XG4gICAgdmFyIHVua25vd25Pd25lckRlYnVnVGFzayA9IGNyZWF0ZVRhc2soZ2V0VGFza05hbWUoVW5rbm93bk93bmVyKSk7XG4gICAgdmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuICAgIGV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuICAgIGV4cG9ydHMuanN4REVWID0gZnVuY3Rpb24gKFxuICAgICAgdHlwZSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIG1heWJlS2V5LFxuICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgIHNvdXJjZSxcbiAgICAgIHNlbGZcbiAgICApIHtcbiAgICAgIHZhciB0cmFja0FjdHVhbE93bmVyID1cbiAgICAgICAgMWU0ID4gUmVhY3RTaGFyZWRJbnRlcm5hbHMucmVjZW50bHlDcmVhdGVkT3duZXJTdGFja3MrKztcbiAgICAgIHJldHVybiBqc3hERVZJbXBsKFxuICAgICAgICB0eXBlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHNlbGYsXG4gICAgICAgIHRyYWNrQWN0dWFsT3duZXJcbiAgICAgICAgICA/IEVycm9yKFwicmVhY3Qtc3RhY2stdG9wLWZyYW1lXCIpXG4gICAgICAgICAgOiB1bmtub3duT3duZXJEZWJ1Z1N0YWNrLFxuICAgICAgICB0cmFja0FjdHVhbE93bmVyID8gY3JlYXRlVGFzayhnZXRUYXNrTmFtZSh0eXBlKSkgOiB1bmtub3duT3duZXJEZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = __webpack_require__(/*! ./lib/has */ \"(app-pages-browser)/./node_modules/prop-types/lib/has.js\");\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) { /**/ }\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +\n              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLDZHQUE0QjtBQUNqRTtBQUNBLFlBQVksbUJBQU8sQ0FBQywyRUFBVzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQVk7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB2YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHsgLyoqLyB9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICtcbiAgICAgICAgICAgICAgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"(app-pages-browser)/./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar has = __webpack_require__(/*! ./lib/has */ \"(app-pages-browser)/./node_modules/prop-types/lib/has.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js\");\n\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bigint: createPrimitiveTypeChecker('bigint'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message, data) {\n    this.message = message;\n    this.data = data && typeof data === 'object' ? data: {};\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError(\n          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),\n          {expectedType: expectedType}\n        );\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var expectedTypes = [];\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n        if (checkerResult == null) {\n          return null;\n        }\n        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {\n          expectedTypes.push(checkerResult.data.expectedType);\n        }\n      }\n      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function invalidValidatorError(componentName, location, propFullName, key, type) {\n    return new PropTypeError(\n      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +\n      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'\n    );\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (has(shapeTypes, key) && typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsc0VBQVU7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLG9HQUFlOztBQUVwQywyQkFBMkIsbUJBQU8sQ0FBQyw2R0FBNEI7QUFDL0QsVUFBVSxtQkFBTyxDQUFDLDJFQUFXO0FBQzdCLHFCQUFxQixtQkFBTyxDQUFDLHlGQUFrQjs7QUFFL0M7O0FBRUEsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw4QkFBOEI7QUFDOUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLEtBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLDRGQUE0RixDQUFNO0FBQzdJO0FBQ0E7O0FBRUEsb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlIQUFpSDtBQUNqSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL2xpYi9oYXMnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJpZ2ludDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2JpZ2ludCcpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlLCBkYXRhKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGE6IHt9O1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpLFxuICAgICAgICAgIHtleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZX1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICAgICAgICAgICAgJ0EgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzLCBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBTdHJpbmcocHJvcFZhbHVlKSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoaGFzKHByb3BWYWx1ZSwga2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgdmFyIGNoZWNrZXJSZXN1bHQgPSBjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoY2hlY2tlclJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQuZGF0YSAmJiBoYXMoY2hlY2tlclJlc3VsdC5kYXRhLCAnZXhwZWN0ZWRUeXBlJykpIHtcbiAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goY2hlY2tlclJlc3VsdC5kYXRhLmV4cGVjdGVkVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBleHBlY3RlZFR5cGVzTWVzc2FnZSA9IChleHBlY3RlZFR5cGVzLmxlbmd0aCA+IDApID8gJywgZXhwZWN0ZWQgb25lIG9mIHR5cGUgWycgKyBleHBlY3RlZFR5cGVzLmpvaW4oJywgJykgKyAnXSc6ICcnO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCcgKyBleHBlY3RlZFR5cGVzTWVzc2FnZSArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgdHlwZSkge1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5ICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlICsgJ2AuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIGdldFByZWNpc2VUeXBlKGNoZWNrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbSBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmIChoYXMoc2hhcGVUeXBlcywga2V5KSAmJiB0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ \"(app-pages-browser)/./node_modules/react-is/index.js\");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFVOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQywyR0FBMkI7QUFDdEQsRUFBRSxLQUFLLEVBSU4iLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/lib/has.js":
/*!********************************************!*\
  !*** ./node_modules/prop-types/lib/has.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("module.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanMiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/lib/has.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-fast-compare/index.js":
/*!**************************************************!*\
  !*** ./node_modules/react-fast-compare/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* global Map:readonly, Set:readonly, ArrayBuffer:readonly */\n\nvar hasElementType = typeof Element !== 'undefined';\nvar hasMap = typeof Map === 'function';\nvar hasSet = typeof Set === 'function';\nvar hasArrayBuffer = typeof ArrayBuffer === 'function' && !!ArrayBuffer.isView;\n\n// Note: We **don't** need `envHasBigInt64Array` in fde es6/index.js\n\nfunction equal(a, b) {\n  // START: fast-deep-equal es6/index.js 3.1.3\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    // START: Modifications:\n    // 1. Extra `has<Type> &&` helpers in initial condition allow es6 code\n    //    to co-exist with es5.\n    // 2. Replace `for of` with es5 compliant iteration using `for`.\n    //    Basically, take:\n    //\n    //    ```js\n    //    for (i of a.entries())\n    //      if (!b.has(i[0])) return false;\n    //    ```\n    //\n    //    ... and convert to:\n    //\n    //    ```js\n    //    it = a.entries();\n    //    while (!(i = it.next()).done)\n    //      if (!b.has(i.value[0])) return false;\n    //    ```\n    //\n    //    **Note**: `i` access switches to `i.value`.\n    var it;\n    if (hasMap && (a instanceof Map) && (b instanceof Map)) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n      while (!(i = it.next()).done)\n        if (!b.has(i.value[0])) return false;\n      it = a.entries();\n      while (!(i = it.next()).done)\n        if (!equal(i.value[1], b.get(i.value[0]))) return false;\n      return true;\n    }\n\n    if (hasSet && (a instanceof Set) && (b instanceof Set)) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n      while (!(i = it.next()).done)\n        if (!b.has(i.value[0])) return false;\n      return true;\n    }\n    // END: Modifications\n\n    if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (a[i] !== b[i]) return false;\n      return true;\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    // START: Modifications:\n    // Apply guards for `Object.create(null)` handling. See:\n    // - https://github.com/FormidableLabs/react-fast-compare/issues/64\n    // - https://github.com/epoberezkin/fast-deep-equal/issues/49\n    if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === 'function' && typeof b.valueOf === 'function') return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString && typeof a.toString === 'function' && typeof b.toString === 'function') return a.toString() === b.toString();\n    // END: Modifications\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    // END: fast-deep-equal\n\n    // START: react-fast-compare\n    // custom handling for DOM elements\n    if (hasElementType && a instanceof Element) return false;\n\n    // custom handling for React/Preact\n    for (i = length; i-- !== 0;) {\n      if ((keys[i] === '_owner' || keys[i] === '__v' || keys[i] === '__o') && a.$$typeof) {\n        // React-specific: avoid traversing React elements' _owner\n        // Preact-specific: avoid traversing Preact elements' __v and __o\n        //    __v = $_original / $_vnode\n        //    __o = $_owner\n        // These properties contain circular references and are not needed when\n        // comparing the actual elements (and not their owners)\n        // .$$typeof and ._store on just reasonable markers of elements\n\n        continue;\n      }\n\n      // all other properties should be traversed as usual\n      if (!equal(a[keys[i]], b[keys[i]])) return false;\n    }\n    // END: react-fast-compare\n\n    // START: fast-deep-equal\n    return true;\n  }\n\n  return a !== a && b !== b;\n}\n// end fast-deep-equal\n\nmodule.exports = function isEqual(a, b) {\n  try {\n    return equal(a, b);\n  } catch (error) {\n    if (((error.message || '').match(/stack|recursion/i))) {\n      // warn on circular references, don't crash\n      // browsers give this different errors name and messages:\n      // chrome/safari: \"RangeError\", \"Maximum call stack size exceeded\"\n      // firefox: \"InternalError\", too much recursion\"\n      // edge: \"Error\", \"Out of stack space\"\n      console.warn('react-fast-compare cannot handle circular refs');\n      return false;\n    }\n    // some other error. we should definitely know about these\n    throw error;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1mYXN0LWNvbXBhcmUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvcmVhY3QtZmFzdC1jb21wYXJlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBNYXA6cmVhZG9ubHksIFNldDpyZWFkb25seSwgQXJyYXlCdWZmZXI6cmVhZG9ubHkgKi9cblxudmFyIGhhc0VsZW1lbnRUeXBlID0gdHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIGhhc01hcCA9IHR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbic7XG52YXIgaGFzU2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJztcbnZhciBoYXNBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiAhIUFycmF5QnVmZmVyLmlzVmlldztcblxuLy8gTm90ZTogV2UgKipkb24ndCoqIG5lZWQgYGVudkhhc0JpZ0ludDY0QXJyYXlgIGluIGZkZSBlczYvaW5kZXguanNcblxuZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICAvLyBTVEFSVDogZmFzdC1kZWVwLWVxdWFsIGVzNi9pbmRleC5qcyAzLjEuM1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gU1RBUlQ6IE1vZGlmaWNhdGlvbnM6XG4gICAgLy8gMS4gRXh0cmEgYGhhczxUeXBlPiAmJmAgaGVscGVycyBpbiBpbml0aWFsIGNvbmRpdGlvbiBhbGxvdyBlczYgY29kZVxuICAgIC8vICAgIHRvIGNvLWV4aXN0IHdpdGggZXM1LlxuICAgIC8vIDIuIFJlcGxhY2UgYGZvciBvZmAgd2l0aCBlczUgY29tcGxpYW50IGl0ZXJhdGlvbiB1c2luZyBgZm9yYC5cbiAgICAvLyAgICBCYXNpY2FsbHksIHRha2U6XG4gICAgLy9cbiAgICAvLyAgICBgYGBqc1xuICAgIC8vICAgIGZvciAoaSBvZiBhLmVudHJpZXMoKSlcbiAgICAvLyAgICAgIGlmICghYi5oYXMoaVswXSkpIHJldHVybiBmYWxzZTtcbiAgICAvLyAgICBgYGBcbiAgICAvL1xuICAgIC8vICAgIC4uLiBhbmQgY29udmVydCB0bzpcbiAgICAvL1xuICAgIC8vICAgIGBgYGpzXG4gICAgLy8gICAgaXQgPSBhLmVudHJpZXMoKTtcbiAgICAvLyAgICB3aGlsZSAoIShpID0gaXQubmV4dCgpKS5kb25lKVxuICAgIC8vICAgICAgaWYgKCFiLmhhcyhpLnZhbHVlWzBdKSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vICAgIGBgYFxuICAgIC8vXG4gICAgLy8gICAgKipOb3RlKio6IGBpYCBhY2Nlc3Mgc3dpdGNoZXMgdG8gYGkudmFsdWVgLlxuICAgIHZhciBpdDtcbiAgICBpZiAoaGFzTWFwICYmIChhIGluc3RhbmNlb2YgTWFwKSAmJiAoYiBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaXQgPSBhLmVudHJpZXMoKTtcbiAgICAgIHdoaWxlICghKGkgPSBpdC5uZXh0KCkpLmRvbmUpXG4gICAgICAgIGlmICghYi5oYXMoaS52YWx1ZVswXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIGl0ID0gYS5lbnRyaWVzKCk7XG4gICAgICB3aGlsZSAoIShpID0gaXQubmV4dCgpKS5kb25lKVxuICAgICAgICBpZiAoIWVxdWFsKGkudmFsdWVbMV0sIGIuZ2V0KGkudmFsdWVbMF0pKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGhhc1NldCAmJiAoYSBpbnN0YW5jZW9mIFNldCkgJiYgKGIgaW5zdGFuY2VvZiBTZXQpKSB7XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHJldHVybiBmYWxzZTtcbiAgICAgIGl0ID0gYS5lbnRyaWVzKCk7XG4gICAgICB3aGlsZSAoIShpID0gaXQubmV4dCgpKS5kb25lKVxuICAgICAgICBpZiAoIWIuaGFzKGkudmFsdWVbMF0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRU5EOiBNb2RpZmljYXRpb25zXG5cbiAgICBpZiAoaGFzQXJyYXlCdWZmZXIgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIEFycmF5QnVmZmVyLmlzVmlldyhiKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgLy8gU1RBUlQ6IE1vZGlmaWNhdGlvbnM6XG4gICAgLy8gQXBwbHkgZ3VhcmRzIGZvciBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaGFuZGxpbmcuIFNlZTpcbiAgICAvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9Gb3JtaWRhYmxlTGFicy9yZWFjdC1mYXN0LWNvbXBhcmUvaXNzdWVzLzY0XG4gICAgLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZXBvYmVyZXpraW4vZmFzdC1kZWVwLWVxdWFsL2lzc3Vlcy80OVxuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZiAmJiB0eXBlb2YgYS52YWx1ZU9mID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiLnZhbHVlT2YgPT09ICdmdW5jdGlvbicpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgJiYgdHlwZW9mIGEudG9TdHJpbmcgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGIudG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcbiAgICAvLyBFTkQ6IE1vZGlmaWNhdGlvbnNcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gRU5EOiBmYXN0LWRlZXAtZXF1YWxcblxuICAgIC8vIFNUQVJUOiByZWFjdC1mYXN0LWNvbXBhcmVcbiAgICAvLyBjdXN0b20gaGFuZGxpbmcgZm9yIERPTSBlbGVtZW50c1xuICAgIGlmIChoYXNFbGVtZW50VHlwZSAmJiBhIGluc3RhbmNlb2YgRWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gY3VzdG9tIGhhbmRsaW5nIGZvciBSZWFjdC9QcmVhY3RcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGlmICgoa2V5c1tpXSA9PT0gJ19vd25lcicgfHwga2V5c1tpXSA9PT0gJ19fdicgfHwga2V5c1tpXSA9PT0gJ19fbycpICYmIGEuJCR0eXBlb2YpIHtcbiAgICAgICAgLy8gUmVhY3Qtc3BlY2lmaWM6IGF2b2lkIHRyYXZlcnNpbmcgUmVhY3QgZWxlbWVudHMnIF9vd25lclxuICAgICAgICAvLyBQcmVhY3Qtc3BlY2lmaWM6IGF2b2lkIHRyYXZlcnNpbmcgUHJlYWN0IGVsZW1lbnRzJyBfX3YgYW5kIF9fb1xuICAgICAgICAvLyAgICBfX3YgPSAkX29yaWdpbmFsIC8gJF92bm9kZVxuICAgICAgICAvLyAgICBfX28gPSAkX293bmVyXG4gICAgICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgY29udGFpbiBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCBhcmUgbm90IG5lZWRlZCB3aGVuXG4gICAgICAgIC8vIGNvbXBhcmluZyB0aGUgYWN0dWFsIGVsZW1lbnRzIChhbmQgbm90IHRoZWlyIG93bmVycylcbiAgICAgICAgLy8gLiQkdHlwZW9mIGFuZCAuX3N0b3JlIG9uIGp1c3QgcmVhc29uYWJsZSBtYXJrZXJzIG9mIGVsZW1lbnRzXG5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGFsbCBvdGhlciBwcm9wZXJ0aWVzIHNob3VsZCBiZSB0cmF2ZXJzZWQgYXMgdXN1YWxcbiAgICAgIGlmICghZXF1YWwoYVtrZXlzW2ldXSwgYltrZXlzW2ldXSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gRU5EOiByZWFjdC1mYXN0LWNvbXBhcmVcblxuICAgIC8vIFNUQVJUOiBmYXN0LWRlZXAtZXF1YWxcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBhICE9PSBhICYmIGIgIT09IGI7XG59XG4vLyBlbmQgZmFzdC1kZWVwLWVxdWFsXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVxdWFsKGEsIGIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmICgoKGVycm9yLm1lc3NhZ2UgfHwgJycpLm1hdGNoKC9zdGFja3xyZWN1cnNpb24vaSkpKSB7XG4gICAgICAvLyB3YXJuIG9uIGNpcmN1bGFyIHJlZmVyZW5jZXMsIGRvbid0IGNyYXNoXG4gICAgICAvLyBicm93c2VycyBnaXZlIHRoaXMgZGlmZmVyZW50IGVycm9ycyBuYW1lIGFuZCBtZXNzYWdlczpcbiAgICAgIC8vIGNocm9tZS9zYWZhcmk6IFwiUmFuZ2VFcnJvclwiLCBcIk1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCJcbiAgICAgIC8vIGZpcmVmb3g6IFwiSW50ZXJuYWxFcnJvclwiLCB0b28gbXVjaCByZWN1cnNpb25cIlxuICAgICAgLy8gZWRnZTogXCJFcnJvclwiLCBcIk91dCBvZiBzdGFjayBzcGFjZVwiXG4gICAgICBjb25zb2xlLndhcm4oJ3JlYWN0LWZhc3QtY29tcGFyZSBjYW5ub3QgaGFuZGxlIGNpcmN1bGFyIHJlZnMnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gc29tZSBvdGhlciBlcnJvci4gd2Ugc2hvdWxkIGRlZmluaXRlbHkga25vdyBhYm91dCB0aGVzZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-fast-compare/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n} // AsyncMode is deprecated along with isAsyncMode\n\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7OztBQUliLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osWUFBWTtBQUNaLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsY0FBYztBQUNkLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsMEJBQTBCO0FBQzFCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsb0pBQXlEO0FBQzNEIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-is/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-player/lib/Player.js":
/*!*************************************************!*\
  !*** ./node_modules/react-player/lib/Player.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar Player_exports = {};\n__export(Player_exports, {\n  default: () => Player\n});\nmodule.exports = __toCommonJS(Player_exports);\nvar import_react = __toESM(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar import_react_fast_compare = __toESM(__webpack_require__(/*! react-fast-compare */ \"(app-pages-browser)/./node_modules/react-fast-compare/index.js\"));\nvar import_props = __webpack_require__(/*! ./props */ \"(app-pages-browser)/./node_modules/react-player/lib/props.js\");\nvar import_utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/react-player/lib/utils.js\");\nconst SEEK_ON_PLAY_EXPIRY = 5e3;\nclass Player extends import_react.Component {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"mounted\", false);\n    __publicField(this, \"isReady\", false);\n    __publicField(this, \"isPlaying\", false);\n    // Track playing state internally to prevent bugs\n    __publicField(this, \"isLoading\", true);\n    // Use isLoading to prevent onPause when switching URL\n    __publicField(this, \"loadOnReady\", null);\n    __publicField(this, \"startOnPlay\", true);\n    __publicField(this, \"seekOnPlay\", null);\n    __publicField(this, \"onDurationCalled\", false);\n    __publicField(this, \"handlePlayerMount\", (player) => {\n      if (this.player) {\n        this.progress();\n        return;\n      }\n      this.player = player;\n      this.player.load(this.props.url);\n      this.progress();\n    });\n    __publicField(this, \"getInternalPlayer\", (key) => {\n      if (!this.player)\n        return null;\n      return this.player[key];\n    });\n    __publicField(this, \"progress\", () => {\n      if (this.props.url && this.player && this.isReady) {\n        const playedSeconds = this.getCurrentTime() || 0;\n        const loadedSeconds = this.getSecondsLoaded();\n        const duration = this.getDuration();\n        if (duration) {\n          const progress = {\n            playedSeconds,\n            played: playedSeconds / duration\n          };\n          if (loadedSeconds !== null) {\n            progress.loadedSeconds = loadedSeconds;\n            progress.loaded = loadedSeconds / duration;\n          }\n          if (progress.playedSeconds !== this.prevPlayed || progress.loadedSeconds !== this.prevLoaded) {\n            this.props.onProgress(progress);\n          }\n          this.prevPlayed = progress.playedSeconds;\n          this.prevLoaded = progress.loadedSeconds;\n        }\n      }\n      this.progressTimeout = setTimeout(this.progress, this.props.progressFrequency || this.props.progressInterval);\n    });\n    __publicField(this, \"handleReady\", () => {\n      if (!this.mounted)\n        return;\n      this.isReady = true;\n      this.isLoading = false;\n      const { onReady, playing, volume, muted } = this.props;\n      onReady();\n      if (!muted && volume !== null) {\n        this.player.setVolume(volume);\n      }\n      if (this.loadOnReady) {\n        this.player.load(this.loadOnReady, true);\n        this.loadOnReady = null;\n      } else if (playing) {\n        this.player.play();\n      }\n      this.handleDurationCheck();\n    });\n    __publicField(this, \"handlePlay\", () => {\n      this.isPlaying = true;\n      this.isLoading = false;\n      const { onStart, onPlay, playbackRate } = this.props;\n      if (this.startOnPlay) {\n        if (this.player.setPlaybackRate && playbackRate !== 1) {\n          this.player.setPlaybackRate(playbackRate);\n        }\n        onStart();\n        this.startOnPlay = false;\n      }\n      onPlay();\n      if (this.seekOnPlay) {\n        this.seekTo(this.seekOnPlay);\n        this.seekOnPlay = null;\n      }\n      this.handleDurationCheck();\n    });\n    __publicField(this, \"handlePause\", (e) => {\n      this.isPlaying = false;\n      if (!this.isLoading) {\n        this.props.onPause(e);\n      }\n    });\n    __publicField(this, \"handleEnded\", () => {\n      const { activePlayer, loop, onEnded } = this.props;\n      if (activePlayer.loopOnEnded && loop) {\n        this.seekTo(0);\n      }\n      if (!loop) {\n        this.isPlaying = false;\n        onEnded();\n      }\n    });\n    __publicField(this, \"handleError\", (...args) => {\n      this.isLoading = false;\n      this.props.onError(...args);\n    });\n    __publicField(this, \"handleDurationCheck\", () => {\n      clearTimeout(this.durationCheckTimeout);\n      const duration = this.getDuration();\n      if (duration) {\n        if (!this.onDurationCalled) {\n          this.props.onDuration(duration);\n          this.onDurationCalled = true;\n        }\n      } else {\n        this.durationCheckTimeout = setTimeout(this.handleDurationCheck, 100);\n      }\n    });\n    __publicField(this, \"handleLoaded\", () => {\n      this.isLoading = false;\n    });\n  }\n  componentDidMount() {\n    this.mounted = true;\n  }\n  componentWillUnmount() {\n    clearTimeout(this.progressTimeout);\n    clearTimeout(this.durationCheckTimeout);\n    if (this.isReady && this.props.stopOnUnmount) {\n      this.player.stop();\n      if (this.player.disablePIP) {\n        this.player.disablePIP();\n      }\n    }\n    this.mounted = false;\n  }\n  componentDidUpdate(prevProps) {\n    if (!this.player) {\n      return;\n    }\n    const { url, playing, volume, muted, playbackRate, pip, loop, activePlayer, disableDeferredLoading } = this.props;\n    if (!(0, import_react_fast_compare.default)(prevProps.url, url)) {\n      if (this.isLoading && !activePlayer.forceLoad && !disableDeferredLoading && !(0, import_utils.isMediaStream)(url)) {\n        console.warn(`ReactPlayer: the attempt to load ${url} is being deferred until the player has loaded`);\n        this.loadOnReady = url;\n        return;\n      }\n      this.isLoading = true;\n      this.startOnPlay = true;\n      this.onDurationCalled = false;\n      this.player.load(url, this.isReady);\n    }\n    if (!prevProps.playing && playing && !this.isPlaying) {\n      this.player.play();\n    }\n    if (prevProps.playing && !playing && this.isPlaying) {\n      this.player.pause();\n    }\n    if (!prevProps.pip && pip && this.player.enablePIP) {\n      this.player.enablePIP();\n    }\n    if (prevProps.pip && !pip && this.player.disablePIP) {\n      this.player.disablePIP();\n    }\n    if (prevProps.volume !== volume && volume !== null) {\n      this.player.setVolume(volume);\n    }\n    if (prevProps.muted !== muted) {\n      if (muted) {\n        this.player.mute();\n      } else {\n        this.player.unmute();\n        if (volume !== null) {\n          setTimeout(() => this.player.setVolume(volume));\n        }\n      }\n    }\n    if (prevProps.playbackRate !== playbackRate && this.player.setPlaybackRate) {\n      this.player.setPlaybackRate(playbackRate);\n    }\n    if (prevProps.loop !== loop && this.player.setLoop) {\n      this.player.setLoop(loop);\n    }\n  }\n  getDuration() {\n    if (!this.isReady)\n      return null;\n    return this.player.getDuration();\n  }\n  getCurrentTime() {\n    if (!this.isReady)\n      return null;\n    return this.player.getCurrentTime();\n  }\n  getSecondsLoaded() {\n    if (!this.isReady)\n      return null;\n    return this.player.getSecondsLoaded();\n  }\n  seekTo(amount, type, keepPlaying) {\n    if (!this.isReady) {\n      if (amount !== 0) {\n        this.seekOnPlay = amount;\n        setTimeout(() => {\n          this.seekOnPlay = null;\n        }, SEEK_ON_PLAY_EXPIRY);\n      }\n      return;\n    }\n    const isFraction = !type ? amount > 0 && amount < 1 : type === \"fraction\";\n    if (isFraction) {\n      const duration = this.player.getDuration();\n      if (!duration) {\n        console.warn(\"ReactPlayer: could not seek using fraction \\u2013\\xA0duration not yet available\");\n        return;\n      }\n      this.player.seekTo(duration * amount, keepPlaying);\n      return;\n    }\n    this.player.seekTo(amount, keepPlaying);\n  }\n  render() {\n    const Player2 = this.props.activePlayer;\n    if (!Player2) {\n      return null;\n    }\n    return /* @__PURE__ */ import_react.default.createElement(\n      Player2,\n      {\n        ...this.props,\n        onMount: this.handlePlayerMount,\n        onReady: this.handleReady,\n        onPlay: this.handlePlay,\n        onPause: this.handlePause,\n        onEnded: this.handleEnded,\n        onLoaded: this.handleLoaded,\n        onError: this.handleError\n      }\n    );\n  }\n}\n__publicField(Player, \"displayName\", \"Player\");\n__publicField(Player, \"propTypes\", import_props.propTypes);\n__publicField(Player, \"defaultProps\", import_props.defaultProps);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wbGF5ZXIvbGliL1BsYXllci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDJCQUEyQixtQkFBTyxDQUFDLG1GQUFPO0FBQzFDLHdDQUF3QyxtQkFBTyxDQUFDLDBGQUFvQjtBQUNwRSxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBUztBQUNwQyxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQ0FBa0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0NBQWdDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZGQUE2RjtBQUN6RztBQUNBO0FBQ0EseURBQXlELEtBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3JlYWN0LXBsYXllci9saWIvUGxheWVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBQbGF5ZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoUGxheWVyX2V4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gUGxheWVyXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKFBsYXllcl9leHBvcnRzKTtcbnZhciBpbXBvcnRfcmVhY3QgPSBfX3RvRVNNKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgaW1wb3J0X3JlYWN0X2Zhc3RfY29tcGFyZSA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0LWZhc3QtY29tcGFyZVwiKSk7XG52YXIgaW1wb3J0X3Byb3BzID0gcmVxdWlyZShcIi4vcHJvcHNcIik7XG52YXIgaW1wb3J0X3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBTRUVLX09OX1BMQVlfRVhQSVJZID0gNWUzO1xuY2xhc3MgUGxheWVyIGV4dGVuZHMgaW1wb3J0X3JlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1vdW50ZWRcIiwgZmFsc2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpc1JlYWR5XCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaXNQbGF5aW5nXCIsIGZhbHNlKTtcbiAgICAvLyBUcmFjayBwbGF5aW5nIHN0YXRlIGludGVybmFsbHkgdG8gcHJldmVudCBidWdzXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlzTG9hZGluZ1wiLCB0cnVlKTtcbiAgICAvLyBVc2UgaXNMb2FkaW5nIHRvIHByZXZlbnQgb25QYXVzZSB3aGVuIHN3aXRjaGluZyBVUkxcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9hZE9uUmVhZHlcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0YXJ0T25QbGF5XCIsIHRydWUpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZWVrT25QbGF5XCIsIG51bGwpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvbkR1cmF0aW9uQ2FsbGVkXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGFuZGxlUGxheWVyTW91bnRcIiwgKHBsYXllcikgPT4ge1xuICAgICAgaWYgKHRoaXMucGxheWVyKSB7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wbGF5ZXIgPSBwbGF5ZXI7XG4gICAgICB0aGlzLnBsYXllci5sb2FkKHRoaXMucHJvcHMudXJsKTtcbiAgICAgIHRoaXMucHJvZ3Jlc3MoKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0SW50ZXJuYWxQbGF5ZXJcIiwgKGtleSkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnBsYXllcilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5wbGF5ZXJba2V5XTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvZ3Jlc3NcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMucHJvcHMudXJsICYmIHRoaXMucGxheWVyICYmIHRoaXMuaXNSZWFkeSkge1xuICAgICAgICBjb25zdCBwbGF5ZWRTZWNvbmRzID0gdGhpcy5nZXRDdXJyZW50VGltZSgpIHx8IDA7XG4gICAgICAgIGNvbnN0IGxvYWRlZFNlY29uZHMgPSB0aGlzLmdldFNlY29uZHNMb2FkZWQoKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmdldER1cmF0aW9uKCk7XG4gICAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0ge1xuICAgICAgICAgICAgcGxheWVkU2Vjb25kcyxcbiAgICAgICAgICAgIHBsYXllZDogcGxheWVkU2Vjb25kcyAvIGR1cmF0aW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAobG9hZGVkU2Vjb25kcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvZ3Jlc3MubG9hZGVkU2Vjb25kcyA9IGxvYWRlZFNlY29uZHM7XG4gICAgICAgICAgICBwcm9ncmVzcy5sb2FkZWQgPSBsb2FkZWRTZWNvbmRzIC8gZHVyYXRpb247XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcm9ncmVzcy5wbGF5ZWRTZWNvbmRzICE9PSB0aGlzLnByZXZQbGF5ZWQgfHwgcHJvZ3Jlc3MubG9hZGVkU2Vjb25kcyAhPT0gdGhpcy5wcmV2TG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uUHJvZ3Jlc3MocHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnByZXZQbGF5ZWQgPSBwcm9ncmVzcy5wbGF5ZWRTZWNvbmRzO1xuICAgICAgICAgIHRoaXMucHJldkxvYWRlZCA9IHByb2dyZXNzLmxvYWRlZFNlY29uZHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucHJvZ3Jlc3NUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLnByb2dyZXNzLCB0aGlzLnByb3BzLnByb2dyZXNzRnJlcXVlbmN5IHx8IHRoaXMucHJvcHMucHJvZ3Jlc3NJbnRlcnZhbCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhhbmRsZVJlYWR5XCIsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5tb3VudGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHsgb25SZWFkeSwgcGxheWluZywgdm9sdW1lLCBtdXRlZCB9ID0gdGhpcy5wcm9wcztcbiAgICAgIG9uUmVhZHkoKTtcbiAgICAgIGlmICghbXV0ZWQgJiYgdm9sdW1lICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucGxheWVyLnNldFZvbHVtZSh2b2x1bWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubG9hZE9uUmVhZHkpIHtcbiAgICAgICAgdGhpcy5wbGF5ZXIubG9hZCh0aGlzLmxvYWRPblJlYWR5LCB0cnVlKTtcbiAgICAgICAgdGhpcy5sb2FkT25SZWFkeSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHBsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5wbGF5ZXIucGxheSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5oYW5kbGVEdXJhdGlvbkNoZWNrKCk7XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImhhbmRsZVBsYXlcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHsgb25TdGFydCwgb25QbGF5LCBwbGF5YmFja1JhdGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAodGhpcy5zdGFydE9uUGxheSkge1xuICAgICAgICBpZiAodGhpcy5wbGF5ZXIuc2V0UGxheWJhY2tSYXRlICYmIHBsYXliYWNrUmF0ZSAhPT0gMSkge1xuICAgICAgICAgIHRoaXMucGxheWVyLnNldFBsYXliYWNrUmF0ZShwbGF5YmFja1JhdGUpO1xuICAgICAgICB9XG4gICAgICAgIG9uU3RhcnQoKTtcbiAgICAgICAgdGhpcy5zdGFydE9uUGxheSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgb25QbGF5KCk7XG4gICAgICBpZiAodGhpcy5zZWVrT25QbGF5KSB7XG4gICAgICAgIHRoaXMuc2Vla1RvKHRoaXMuc2Vla09uUGxheSk7XG4gICAgICAgIHRoaXMuc2Vla09uUGxheSA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZUR1cmF0aW9uQ2hlY2soKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGFuZGxlUGF1c2VcIiwgKGUpID0+IHtcbiAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICBpZiAoIXRoaXMuaXNMb2FkaW5nKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25QYXVzZShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGFuZGxlRW5kZWRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgeyBhY3RpdmVQbGF5ZXIsIGxvb3AsIG9uRW5kZWQgfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoYWN0aXZlUGxheWVyLmxvb3BPbkVuZGVkICYmIGxvb3ApIHtcbiAgICAgICAgdGhpcy5zZWVrVG8oMCk7XG4gICAgICB9XG4gICAgICBpZiAoIWxvb3ApIHtcbiAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgb25FbmRlZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVFcnJvclwiLCAoLi4uYXJncykgPT4ge1xuICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMucHJvcHMub25FcnJvciguLi5hcmdzKTtcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGFuZGxlRHVyYXRpb25DaGVja1wiLCAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5kdXJhdGlvbkNoZWNrVGltZW91dCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuZ2V0RHVyYXRpb24oKTtcbiAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMub25EdXJhdGlvbkNhbGxlZCkge1xuICAgICAgICAgIHRoaXMucHJvcHMub25EdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgdGhpcy5vbkR1cmF0aW9uQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvbkNoZWNrVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVEdXJhdGlvbkNoZWNrLCAxMDApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVMb2FkZWRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnByb2dyZXNzVGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZHVyYXRpb25DaGVja1RpbWVvdXQpO1xuICAgIGlmICh0aGlzLmlzUmVhZHkgJiYgdGhpcy5wcm9wcy5zdG9wT25Vbm1vdW50KSB7XG4gICAgICB0aGlzLnBsYXllci5zdG9wKCk7XG4gICAgICBpZiAodGhpcy5wbGF5ZXIuZGlzYWJsZVBJUCkge1xuICAgICAgICB0aGlzLnBsYXllci5kaXNhYmxlUElQKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubW91bnRlZCA9IGZhbHNlO1xuICB9XG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBpZiAoIXRoaXMucGxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgdXJsLCBwbGF5aW5nLCB2b2x1bWUsIG11dGVkLCBwbGF5YmFja1JhdGUsIHBpcCwgbG9vcCwgYWN0aXZlUGxheWVyLCBkaXNhYmxlRGVmZXJyZWRMb2FkaW5nIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICghKDAsIGltcG9ydF9yZWFjdF9mYXN0X2NvbXBhcmUuZGVmYXVsdCkocHJldlByb3BzLnVybCwgdXJsKSkge1xuICAgICAgaWYgKHRoaXMuaXNMb2FkaW5nICYmICFhY3RpdmVQbGF5ZXIuZm9yY2VMb2FkICYmICFkaXNhYmxlRGVmZXJyZWRMb2FkaW5nICYmICEoMCwgaW1wb3J0X3V0aWxzLmlzTWVkaWFTdHJlYW0pKHVybCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBSZWFjdFBsYXllcjogdGhlIGF0dGVtcHQgdG8gbG9hZCAke3VybH0gaXMgYmVpbmcgZGVmZXJyZWQgdW50aWwgdGhlIHBsYXllciBoYXMgbG9hZGVkYCk7XG4gICAgICAgIHRoaXMubG9hZE9uUmVhZHkgPSB1cmw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc3RhcnRPblBsYXkgPSB0cnVlO1xuICAgICAgdGhpcy5vbkR1cmF0aW9uQ2FsbGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnBsYXllci5sb2FkKHVybCwgdGhpcy5pc1JlYWR5KTtcbiAgICB9XG4gICAgaWYgKCFwcmV2UHJvcHMucGxheWluZyAmJiBwbGF5aW5nICYmICF0aGlzLmlzUGxheWluZykge1xuICAgICAgdGhpcy5wbGF5ZXIucGxheSgpO1xuICAgIH1cbiAgICBpZiAocHJldlByb3BzLnBsYXlpbmcgJiYgIXBsYXlpbmcgJiYgdGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgIHRoaXMucGxheWVyLnBhdXNlKCk7XG4gICAgfVxuICAgIGlmICghcHJldlByb3BzLnBpcCAmJiBwaXAgJiYgdGhpcy5wbGF5ZXIuZW5hYmxlUElQKSB7XG4gICAgICB0aGlzLnBsYXllci5lbmFibGVQSVAoKTtcbiAgICB9XG4gICAgaWYgKHByZXZQcm9wcy5waXAgJiYgIXBpcCAmJiB0aGlzLnBsYXllci5kaXNhYmxlUElQKSB7XG4gICAgICB0aGlzLnBsYXllci5kaXNhYmxlUElQKCk7XG4gICAgfVxuICAgIGlmIChwcmV2UHJvcHMudm9sdW1lICE9PSB2b2x1bWUgJiYgdm9sdW1lICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBsYXllci5zZXRWb2x1bWUodm9sdW1lKTtcbiAgICB9XG4gICAgaWYgKHByZXZQcm9wcy5tdXRlZCAhPT0gbXV0ZWQpIHtcbiAgICAgIGlmIChtdXRlZCkge1xuICAgICAgICB0aGlzLnBsYXllci5tdXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBsYXllci51bm11dGUoKTtcbiAgICAgICAgaWYgKHZvbHVtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5wbGF5ZXIuc2V0Vm9sdW1lKHZvbHVtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV2UHJvcHMucGxheWJhY2tSYXRlICE9PSBwbGF5YmFja1JhdGUgJiYgdGhpcy5wbGF5ZXIuc2V0UGxheWJhY2tSYXRlKSB7XG4gICAgICB0aGlzLnBsYXllci5zZXRQbGF5YmFja1JhdGUocGxheWJhY2tSYXRlKTtcbiAgICB9XG4gICAgaWYgKHByZXZQcm9wcy5sb29wICE9PSBsb29wICYmIHRoaXMucGxheWVyLnNldExvb3ApIHtcbiAgICAgIHRoaXMucGxheWVyLnNldExvb3AobG9vcCk7XG4gICAgfVxuICB9XG4gIGdldER1cmF0aW9uKCkge1xuICAgIGlmICghdGhpcy5pc1JlYWR5KVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyLmdldER1cmF0aW9uKCk7XG4gIH1cbiAgZ2V0Q3VycmVudFRpbWUoKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVhZHkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5wbGF5ZXIuZ2V0Q3VycmVudFRpbWUoKTtcbiAgfVxuICBnZXRTZWNvbmRzTG9hZGVkKCkge1xuICAgIGlmICghdGhpcy5pc1JlYWR5KVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyLmdldFNlY29uZHNMb2FkZWQoKTtcbiAgfVxuICBzZWVrVG8oYW1vdW50LCB0eXBlLCBrZWVwUGxheWluZykge1xuICAgIGlmICghdGhpcy5pc1JlYWR5KSB7XG4gICAgICBpZiAoYW1vdW50ICE9PSAwKSB7XG4gICAgICAgIHRoaXMuc2Vla09uUGxheSA9IGFtb3VudDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZWVrT25QbGF5ID0gbnVsbDtcbiAgICAgICAgfSwgU0VFS19PTl9QTEFZX0VYUElSWSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzRnJhY3Rpb24gPSAhdHlwZSA/IGFtb3VudCA+IDAgJiYgYW1vdW50IDwgMSA6IHR5cGUgPT09IFwiZnJhY3Rpb25cIjtcbiAgICBpZiAoaXNGcmFjdGlvbikge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLnBsYXllci5nZXREdXJhdGlvbigpO1xuICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJSZWFjdFBsYXllcjogY291bGQgbm90IHNlZWsgdXNpbmcgZnJhY3Rpb24gXFx1MjAxM1xceEEwZHVyYXRpb24gbm90IHlldCBhdmFpbGFibGVcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGxheWVyLnNlZWtUbyhkdXJhdGlvbiAqIGFtb3VudCwga2VlcFBsYXlpbmcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBsYXllci5zZWVrVG8oYW1vdW50LCBrZWVwUGxheWluZyk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IFBsYXllcjIgPSB0aGlzLnByb3BzLmFjdGl2ZVBsYXllcjtcbiAgICBpZiAoIVBsYXllcjIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGltcG9ydF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBQbGF5ZXIyLFxuICAgICAge1xuICAgICAgICAuLi50aGlzLnByb3BzLFxuICAgICAgICBvbk1vdW50OiB0aGlzLmhhbmRsZVBsYXllck1vdW50LFxuICAgICAgICBvblJlYWR5OiB0aGlzLmhhbmRsZVJlYWR5LFxuICAgICAgICBvblBsYXk6IHRoaXMuaGFuZGxlUGxheSxcbiAgICAgICAgb25QYXVzZTogdGhpcy5oYW5kbGVQYXVzZSxcbiAgICAgICAgb25FbmRlZDogdGhpcy5oYW5kbGVFbmRlZCxcbiAgICAgICAgb25Mb2FkZWQ6IHRoaXMuaGFuZGxlTG9hZGVkLFxuICAgICAgICBvbkVycm9yOiB0aGlzLmhhbmRsZUVycm9yXG4gICAgICB9XG4gICAgKTtcbiAgfVxufVxuX19wdWJsaWNGaWVsZChQbGF5ZXIsIFwiZGlzcGxheU5hbWVcIiwgXCJQbGF5ZXJcIik7XG5fX3B1YmxpY0ZpZWxkKFBsYXllciwgXCJwcm9wVHlwZXNcIiwgaW1wb3J0X3Byb3BzLnByb3BUeXBlcyk7XG5fX3B1YmxpY0ZpZWxkKFBsYXllciwgXCJkZWZhdWx0UHJvcHNcIiwgaW1wb3J0X3Byb3BzLmRlZmF1bHRQcm9wcyk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-player/lib/Player.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-player/lib/ReactPlayer.js":
/*!******************************************************!*\
  !*** ./node_modules/react-player/lib/ReactPlayer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar ReactPlayer_exports = {};\n__export(ReactPlayer_exports, {\n  createReactPlayer: () => createReactPlayer\n});\nmodule.exports = __toCommonJS(ReactPlayer_exports);\nvar import_react = __toESM(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar import_deepmerge = __toESM(__webpack_require__(/*! deepmerge */ \"(app-pages-browser)/./node_modules/deepmerge/dist/cjs.js\"));\nvar import_memoize_one = __toESM(__webpack_require__(/*! memoize-one */ \"(app-pages-browser)/./node_modules/memoize-one/dist/memoize-one.esm.js\"));\nvar import_react_fast_compare = __toESM(__webpack_require__(/*! react-fast-compare */ \"(app-pages-browser)/./node_modules/react-fast-compare/index.js\"));\nvar import_props = __webpack_require__(/*! ./props */ \"(app-pages-browser)/./node_modules/react-player/lib/props.js\");\nvar import_utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/react-player/lib/utils.js\");\nvar import_Player = __toESM(__webpack_require__(/*! ./Player */ \"(app-pages-browser)/./node_modules/react-player/lib/Player.js\"));\nconst Preview = (0, import_utils.lazy)(() => __webpack_require__.e(/*! import() | reactPlayerPreview */ \"reactPlayerPreview\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./Preview */ \"(app-pages-browser)/./node_modules/react-player/lib/Preview.js\", 23)));\nconst IS_BROWSER = typeof window !== \"undefined\" && window.document && typeof document !== \"undefined\";\nconst IS_GLOBAL = typeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g.window && __webpack_require__.g.window.document;\nconst SUPPORTED_PROPS = Object.keys(import_props.propTypes);\nconst UniversalSuspense = IS_BROWSER || IS_GLOBAL ? import_react.Suspense : () => null;\nconst customPlayers = [];\nconst createReactPlayer = (players, fallback) => {\n  var _a;\n  return _a = class extends import_react.Component {\n    constructor() {\n      super(...arguments);\n      __publicField(this, \"state\", {\n        showPreview: !!this.props.light\n      });\n      // Use references, as refs is used by React\n      __publicField(this, \"references\", {\n        wrapper: (wrapper) => {\n          this.wrapper = wrapper;\n        },\n        player: (player) => {\n          this.player = player;\n        }\n      });\n      __publicField(this, \"handleClickPreview\", (e) => {\n        this.setState({ showPreview: false });\n        this.props.onClickPreview(e);\n      });\n      __publicField(this, \"showPreview\", () => {\n        this.setState({ showPreview: true });\n      });\n      __publicField(this, \"getDuration\", () => {\n        if (!this.player)\n          return null;\n        return this.player.getDuration();\n      });\n      __publicField(this, \"getCurrentTime\", () => {\n        if (!this.player)\n          return null;\n        return this.player.getCurrentTime();\n      });\n      __publicField(this, \"getSecondsLoaded\", () => {\n        if (!this.player)\n          return null;\n        return this.player.getSecondsLoaded();\n      });\n      __publicField(this, \"getInternalPlayer\", (key = \"player\") => {\n        if (!this.player)\n          return null;\n        return this.player.getInternalPlayer(key);\n      });\n      __publicField(this, \"seekTo\", (fraction, type, keepPlaying) => {\n        if (!this.player)\n          return null;\n        this.player.seekTo(fraction, type, keepPlaying);\n      });\n      __publicField(this, \"handleReady\", () => {\n        this.props.onReady(this);\n      });\n      __publicField(this, \"getActivePlayer\", (0, import_memoize_one.default)((url) => {\n        for (const player of [...customPlayers, ...players]) {\n          if (player.canPlay(url)) {\n            return player;\n          }\n        }\n        if (fallback) {\n          return fallback;\n        }\n        return null;\n      }));\n      __publicField(this, \"getConfig\", (0, import_memoize_one.default)((url, key) => {\n        const { config } = this.props;\n        return import_deepmerge.default.all([\n          import_props.defaultProps.config,\n          import_props.defaultProps.config[key] || {},\n          config,\n          config[key] || {}\n        ]);\n      }));\n      __publicField(this, \"getAttributes\", (0, import_memoize_one.default)((url) => {\n        return (0, import_utils.omit)(this.props, SUPPORTED_PROPS);\n      }));\n      __publicField(this, \"renderActivePlayer\", (url) => {\n        if (!url)\n          return null;\n        const player = this.getActivePlayer(url);\n        if (!player)\n          return null;\n        const config = this.getConfig(url, player.key);\n        return /* @__PURE__ */ import_react.default.createElement(\n          import_Player.default,\n          {\n            ...this.props,\n            key: player.key,\n            ref: this.references.player,\n            config,\n            activePlayer: player.lazyPlayer || player,\n            onReady: this.handleReady\n          }\n        );\n      });\n    }\n    shouldComponentUpdate(nextProps, nextState) {\n      return !(0, import_react_fast_compare.default)(this.props, nextProps) || !(0, import_react_fast_compare.default)(this.state, nextState);\n    }\n    componentDidUpdate(prevProps) {\n      const { light } = this.props;\n      if (!prevProps.light && light) {\n        this.setState({ showPreview: true });\n      }\n      if (prevProps.light && !light) {\n        this.setState({ showPreview: false });\n      }\n    }\n    renderPreview(url) {\n      if (!url)\n        return null;\n      const { light, playIcon, previewTabIndex, oEmbedUrl, previewAriaLabel } = this.props;\n      return /* @__PURE__ */ import_react.default.createElement(\n        Preview,\n        {\n          url,\n          light,\n          playIcon,\n          previewTabIndex,\n          previewAriaLabel,\n          oEmbedUrl,\n          onClick: this.handleClickPreview\n        }\n      );\n    }\n    render() {\n      const { url, style, width, height, fallback: fallback2, wrapper: Wrapper } = this.props;\n      const { showPreview } = this.state;\n      const attributes = this.getAttributes(url);\n      const wrapperRef = typeof Wrapper === \"string\" ? this.references.wrapper : void 0;\n      return /* @__PURE__ */ import_react.default.createElement(Wrapper, { ref: wrapperRef, style: { ...style, width, height }, ...attributes }, /* @__PURE__ */ import_react.default.createElement(UniversalSuspense, { fallback: fallback2 }, showPreview ? this.renderPreview(url) : this.renderActivePlayer(url)));\n    }\n  }, __publicField(_a, \"displayName\", \"ReactPlayer\"), __publicField(_a, \"propTypes\", import_props.propTypes), __publicField(_a, \"defaultProps\", import_props.defaultProps), __publicField(_a, \"addCustomPlayer\", (player) => {\n    customPlayers.push(player);\n  }), __publicField(_a, \"removeCustomPlayers\", () => {\n    customPlayers.length = 0;\n  }), __publicField(_a, \"canPlay\", (url) => {\n    for (const Player2 of [...customPlayers, ...players]) {\n      if (Player2.canPlay(url)) {\n        return true;\n      }\n    }\n    return false;\n  }), __publicField(_a, \"canEnablePIP\", (url) => {\n    for (const Player2 of [...customPlayers, ...players]) {\n      if (Player2.canEnablePIP && Player2.canEnablePIP(url)) {\n        return true;\n      }\n    }\n    return false;\n  }), _a;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wbGF5ZXIvbGliL1JlYWN0UGxheWVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsbUZBQU87QUFDMUMsK0JBQStCLG1CQUFPLENBQUMsMkVBQVc7QUFDbEQsaUNBQWlDLG1CQUFPLENBQUMsMkZBQWE7QUFDdEQsd0NBQXdDLG1CQUFPLENBQUMsMEZBQW9CO0FBQ3BFLG1CQUFtQixtQkFBTyxDQUFDLDZFQUFTO0FBQ3BDLG1CQUFtQixtQkFBTyxDQUFDLDZFQUFTO0FBQ3BDLDRCQUE0QixtQkFBTyxDQUFDLCtFQUFVO0FBQzlDLDZDQUE2Qyw2TkFHNUM7QUFDRDtBQUNBLHlCQUF5QixxQkFBTSxvQkFBb0IscUJBQU0sV0FBVyxxQkFBTTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdFQUFnRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtRUFBbUU7QUFDakYsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQSwyRUFBMkUsMEJBQTBCLHlCQUF5QixpQkFBaUIsMEVBQTBFLHFCQUFxQjtBQUM5TztBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3JlYWN0LXBsYXllci9saWIvUmVhY3RQbGF5ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBfX3B1YmxpY0ZpZWxkID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIFJlYWN0UGxheWVyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KFJlYWN0UGxheWVyX2V4cG9ydHMsIHtcbiAgY3JlYXRlUmVhY3RQbGF5ZXI6ICgpID0+IGNyZWF0ZVJlYWN0UGxheWVyXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKFJlYWN0UGxheWVyX2V4cG9ydHMpO1xudmFyIGltcG9ydF9yZWFjdCA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBpbXBvcnRfZGVlcG1lcmdlID0gX190b0VTTShyZXF1aXJlKFwiZGVlcG1lcmdlXCIpKTtcbnZhciBpbXBvcnRfbWVtb2l6ZV9vbmUgPSBfX3RvRVNNKHJlcXVpcmUoXCJtZW1vaXplLW9uZVwiKSk7XG52YXIgaW1wb3J0X3JlYWN0X2Zhc3RfY29tcGFyZSA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0LWZhc3QtY29tcGFyZVwiKSk7XG52YXIgaW1wb3J0X3Byb3BzID0gcmVxdWlyZShcIi4vcHJvcHNcIik7XG52YXIgaW1wb3J0X3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgaW1wb3J0X1BsYXllciA9IF9fdG9FU00ocmVxdWlyZShcIi4vUGxheWVyXCIpKTtcbmNvbnN0IFByZXZpZXcgPSAoMCwgaW1wb3J0X3V0aWxzLmxhenkpKCgpID0+IGltcG9ydChcbiAgLyogd2VicGFja0NodW5rTmFtZTogJ3JlYWN0UGxheWVyUHJldmlldycgKi9cbiAgXCIuL1ByZXZpZXdcIlxuKSk7XG5jb25zdCBJU19CUk9XU0VSID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgSVNfR0xPQkFMID0gdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwud2luZG93ICYmIGdsb2JhbC53aW5kb3cuZG9jdW1lbnQ7XG5jb25zdCBTVVBQT1JURURfUFJPUFMgPSBPYmplY3Qua2V5cyhpbXBvcnRfcHJvcHMucHJvcFR5cGVzKTtcbmNvbnN0IFVuaXZlcnNhbFN1c3BlbnNlID0gSVNfQlJPV1NFUiB8fCBJU19HTE9CQUwgPyBpbXBvcnRfcmVhY3QuU3VzcGVuc2UgOiAoKSA9PiBudWxsO1xuY29uc3QgY3VzdG9tUGxheWVycyA9IFtdO1xuY29uc3QgY3JlYXRlUmVhY3RQbGF5ZXIgPSAocGxheWVycywgZmFsbGJhY2spID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gX2EgPSBjbGFzcyBleHRlbmRzIGltcG9ydF9yZWFjdC5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGF0ZVwiLCB7XG4gICAgICAgIHNob3dQcmV2aWV3OiAhIXRoaXMucHJvcHMubGlnaHRcbiAgICAgIH0pO1xuICAgICAgLy8gVXNlIHJlZmVyZW5jZXMsIGFzIHJlZnMgaXMgdXNlZCBieSBSZWFjdFxuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlZmVyZW5jZXNcIiwge1xuICAgICAgICB3cmFwcGVyOiAod3JhcHBlcikgPT4ge1xuICAgICAgICAgIHRoaXMud3JhcHBlciA9IHdyYXBwZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHBsYXllcjogKHBsYXllcikgPT4ge1xuICAgICAgICAgIHRoaXMucGxheWVyID0gcGxheWVyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVDbGlja1ByZXZpZXdcIiwgKGUpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNob3dQcmV2aWV3OiBmYWxzZSB9KTtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrUHJldmlldyhlKTtcbiAgICAgIH0pO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNob3dQcmV2aWV3XCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNob3dQcmV2aWV3OiB0cnVlIH0pO1xuICAgICAgfSk7XG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0RHVyYXRpb25cIiwgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucGxheWVyKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5wbGF5ZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldEN1cnJlbnRUaW1lXCIsICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnBsYXllcilcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxheWVyLmdldEN1cnJlbnRUaW1lKCk7XG4gICAgICB9KTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRTZWNvbmRzTG9hZGVkXCIsICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnBsYXllcilcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxheWVyLmdldFNlY29uZHNMb2FkZWQoKTtcbiAgICAgIH0pO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldEludGVybmFsUGxheWVyXCIsIChrZXkgPSBcInBsYXllclwiKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5wbGF5ZXIpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnBsYXllci5nZXRJbnRlcm5hbFBsYXllcihrZXkpO1xuICAgICAgfSk7XG4gICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic2Vla1RvXCIsIChmcmFjdGlvbiwgdHlwZSwga2VlcFBsYXlpbmcpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnBsYXllcilcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdGhpcy5wbGF5ZXIuc2Vla1RvKGZyYWN0aW9uLCB0eXBlLCBrZWVwUGxheWluZyk7XG4gICAgICB9KTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVSZWFkeVwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMub25SZWFkeSh0aGlzKTtcbiAgICAgIH0pO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldEFjdGl2ZVBsYXllclwiLCAoMCwgaW1wb3J0X21lbW9pemVfb25lLmRlZmF1bHQpKCh1cmwpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBwbGF5ZXIgb2YgWy4uLmN1c3RvbVBsYXllcnMsIC4uLnBsYXllcnNdKSB7XG4gICAgICAgICAgaWYgKHBsYXllci5jYW5QbGF5KHVybCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwbGF5ZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pKTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRDb25maWdcIiwgKDAsIGltcG9ydF9tZW1vaXplX29uZS5kZWZhdWx0KSgodXJsLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3QgeyBjb25maWcgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiBpbXBvcnRfZGVlcG1lcmdlLmRlZmF1bHQuYWxsKFtcbiAgICAgICAgICBpbXBvcnRfcHJvcHMuZGVmYXVsdFByb3BzLmNvbmZpZyxcbiAgICAgICAgICBpbXBvcnRfcHJvcHMuZGVmYXVsdFByb3BzLmNvbmZpZ1trZXldIHx8IHt9LFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICBjb25maWdba2V5XSB8fCB7fVxuICAgICAgICBdKTtcbiAgICAgIH0pKTtcbiAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRBdHRyaWJ1dGVzXCIsICgwLCBpbXBvcnRfbWVtb2l6ZV9vbmUuZGVmYXVsdCkoKHVybCkgPT4ge1xuICAgICAgICByZXR1cm4gKDAsIGltcG9ydF91dGlscy5vbWl0KSh0aGlzLnByb3BzLCBTVVBQT1JURURfUFJPUFMpO1xuICAgICAgfSkpO1xuICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlbmRlckFjdGl2ZVBsYXllclwiLCAodXJsKSA9PiB7XG4gICAgICAgIGlmICghdXJsKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBwbGF5ZXIgPSB0aGlzLmdldEFjdGl2ZVBsYXllcih1cmwpO1xuICAgICAgICBpZiAoIXBsYXllcilcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5nZXRDb25maWcodXJsLCBwbGF5ZXIua2V5KTtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIGltcG9ydF9QbGF5ZXIuZGVmYXVsdCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAuLi50aGlzLnByb3BzLFxuICAgICAgICAgICAga2V5OiBwbGF5ZXIua2V5LFxuICAgICAgICAgICAgcmVmOiB0aGlzLnJlZmVyZW5jZXMucGxheWVyLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgYWN0aXZlUGxheWVyOiBwbGF5ZXIubGF6eVBsYXllciB8fCBwbGF5ZXIsXG4gICAgICAgICAgICBvblJlYWR5OiB0aGlzLmhhbmRsZVJlYWR5XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xuICAgICAgcmV0dXJuICEoMCwgaW1wb3J0X3JlYWN0X2Zhc3RfY29tcGFyZS5kZWZhdWx0KSh0aGlzLnByb3BzLCBuZXh0UHJvcHMpIHx8ICEoMCwgaW1wb3J0X3JlYWN0X2Zhc3RfY29tcGFyZS5kZWZhdWx0KSh0aGlzLnN0YXRlLCBuZXh0U3RhdGUpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICBjb25zdCB7IGxpZ2h0IH0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKCFwcmV2UHJvcHMubGlnaHQgJiYgbGlnaHQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNob3dQcmV2aWV3OiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZQcm9wcy5saWdodCAmJiAhbGlnaHQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNob3dQcmV2aWV3OiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyUHJldmlldyh1cmwpIHtcbiAgICAgIGlmICghdXJsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IHsgbGlnaHQsIHBsYXlJY29uLCBwcmV2aWV3VGFiSW5kZXgsIG9FbWJlZFVybCwgcHJldmlld0FyaWFMYWJlbCB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgUHJldmlldyxcbiAgICAgICAge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICBsaWdodCxcbiAgICAgICAgICBwbGF5SWNvbixcbiAgICAgICAgICBwcmV2aWV3VGFiSW5kZXgsXG4gICAgICAgICAgcHJldmlld0FyaWFMYWJlbCxcbiAgICAgICAgICBvRW1iZWRVcmwsXG4gICAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVDbGlja1ByZXZpZXdcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgY29uc3QgeyB1cmwsIHN0eWxlLCB3aWR0aCwgaGVpZ2h0LCBmYWxsYmFjazogZmFsbGJhY2syLCB3cmFwcGVyOiBXcmFwcGVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgeyBzaG93UHJldmlldyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0aGlzLmdldEF0dHJpYnV0ZXModXJsKTtcbiAgICAgIGNvbnN0IHdyYXBwZXJSZWYgPSB0eXBlb2YgV3JhcHBlciA9PT0gXCJzdHJpbmdcIiA/IHRoaXMucmVmZXJlbmNlcy53cmFwcGVyIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFdyYXBwZXIsIHsgcmVmOiB3cmFwcGVyUmVmLCBzdHlsZTogeyAuLi5zdHlsZSwgd2lkdGgsIGhlaWdodCB9LCAuLi5hdHRyaWJ1dGVzIH0sIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFVuaXZlcnNhbFN1c3BlbnNlLCB7IGZhbGxiYWNrOiBmYWxsYmFjazIgfSwgc2hvd1ByZXZpZXcgPyB0aGlzLnJlbmRlclByZXZpZXcodXJsKSA6IHRoaXMucmVuZGVyQWN0aXZlUGxheWVyKHVybCkpKTtcbiAgICB9XG4gIH0sIF9fcHVibGljRmllbGQoX2EsIFwiZGlzcGxheU5hbWVcIiwgXCJSZWFjdFBsYXllclwiKSwgX19wdWJsaWNGaWVsZChfYSwgXCJwcm9wVHlwZXNcIiwgaW1wb3J0X3Byb3BzLnByb3BUeXBlcyksIF9fcHVibGljRmllbGQoX2EsIFwiZGVmYXVsdFByb3BzXCIsIGltcG9ydF9wcm9wcy5kZWZhdWx0UHJvcHMpLCBfX3B1YmxpY0ZpZWxkKF9hLCBcImFkZEN1c3RvbVBsYXllclwiLCAocGxheWVyKSA9PiB7XG4gICAgY3VzdG9tUGxheWVycy5wdXNoKHBsYXllcik7XG4gIH0pLCBfX3B1YmxpY0ZpZWxkKF9hLCBcInJlbW92ZUN1c3RvbVBsYXllcnNcIiwgKCkgPT4ge1xuICAgIGN1c3RvbVBsYXllcnMubGVuZ3RoID0gMDtcbiAgfSksIF9fcHVibGljRmllbGQoX2EsIFwiY2FuUGxheVwiLCAodXJsKSA9PiB7XG4gICAgZm9yIChjb25zdCBQbGF5ZXIyIG9mIFsuLi5jdXN0b21QbGF5ZXJzLCAuLi5wbGF5ZXJzXSkge1xuICAgICAgaWYgKFBsYXllcjIuY2FuUGxheSh1cmwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pLCBfX3B1YmxpY0ZpZWxkKF9hLCBcImNhbkVuYWJsZVBJUFwiLCAodXJsKSA9PiB7XG4gICAgZm9yIChjb25zdCBQbGF5ZXIyIG9mIFsuLi5jdXN0b21QbGF5ZXJzLCAuLi5wbGF5ZXJzXSkge1xuICAgICAgaWYgKFBsYXllcjIuY2FuRW5hYmxlUElQICYmIFBsYXllcjIuY2FuRW5hYmxlUElQKHVybCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSksIF9hO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-player/lib/ReactPlayer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-player/lib/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-player/lib/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar src_exports = {};\n__export(src_exports, {\n  default: () => src_default\n});\nmodule.exports = __toCommonJS(src_exports);\nvar import_players = __toESM(__webpack_require__(/*! ./players */ \"(app-pages-browser)/./node_modules/react-player/lib/players/index.js\"));\nvar import_ReactPlayer = __webpack_require__(/*! ./ReactPlayer */ \"(app-pages-browser)/./node_modules/react-player/lib/ReactPlayer.js\");\nconst fallback = import_players.default[import_players.default.length - 1];\nvar src_default = (0, import_ReactPlayer.createReactPlayer)(import_players.default, fallback);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wbGF5ZXIvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2QkFBNkIsbUJBQU8sQ0FBQyx1RkFBVztBQUNoRCx5QkFBeUIsbUJBQU8sQ0FBQyx5RkFBZTtBQUNoRDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3JlYWN0LXBsYXllci9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgZGVmYXVsdDogKCkgPT4gc3JjX2RlZmF1bHRcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xudmFyIGltcG9ydF9wbGF5ZXJzID0gX190b0VTTShyZXF1aXJlKFwiLi9wbGF5ZXJzXCIpKTtcbnZhciBpbXBvcnRfUmVhY3RQbGF5ZXIgPSByZXF1aXJlKFwiLi9SZWFjdFBsYXllclwiKTtcbmNvbnN0IGZhbGxiYWNrID0gaW1wb3J0X3BsYXllcnMuZGVmYXVsdFtpbXBvcnRfcGxheWVycy5kZWZhdWx0Lmxlbmd0aCAtIDFdO1xudmFyIHNyY19kZWZhdWx0ID0gKDAsIGltcG9ydF9SZWFjdFBsYXllci5jcmVhdGVSZWFjdFBsYXllcikoaW1wb3J0X3BsYXllcnMuZGVmYXVsdCwgZmFsbGJhY2spO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-player/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-player/lib/patterns.js":
/*!***************************************************!*\
  !*** ./node_modules/react-player/lib/patterns.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar patterns_exports = {};\n__export(patterns_exports, {\n  AUDIO_EXTENSIONS: () => AUDIO_EXTENSIONS,\n  DASH_EXTENSIONS: () => DASH_EXTENSIONS,\n  FLV_EXTENSIONS: () => FLV_EXTENSIONS,\n  HLS_EXTENSIONS: () => HLS_EXTENSIONS,\n  MATCH_URL_DAILYMOTION: () => MATCH_URL_DAILYMOTION,\n  MATCH_URL_FACEBOOK: () => MATCH_URL_FACEBOOK,\n  MATCH_URL_FACEBOOK_WATCH: () => MATCH_URL_FACEBOOK_WATCH,\n  MATCH_URL_KALTURA: () => MATCH_URL_KALTURA,\n  MATCH_URL_MIXCLOUD: () => MATCH_URL_MIXCLOUD,\n  MATCH_URL_MUX: () => MATCH_URL_MUX,\n  MATCH_URL_SOUNDCLOUD: () => MATCH_URL_SOUNDCLOUD,\n  MATCH_URL_STREAMABLE: () => MATCH_URL_STREAMABLE,\n  MATCH_URL_TWITCH_CHANNEL: () => MATCH_URL_TWITCH_CHANNEL,\n  MATCH_URL_TWITCH_VIDEO: () => MATCH_URL_TWITCH_VIDEO,\n  MATCH_URL_VIDYARD: () => MATCH_URL_VIDYARD,\n  MATCH_URL_VIMEO: () => MATCH_URL_VIMEO,\n  MATCH_URL_WISTIA: () => MATCH_URL_WISTIA,\n  MATCH_URL_YOUTUBE: () => MATCH_URL_YOUTUBE,\n  VIDEO_EXTENSIONS: () => VIDEO_EXTENSIONS,\n  canPlay: () => canPlay\n});\nmodule.exports = __toCommonJS(patterns_exports);\nvar import_utils = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/react-player/lib/utils.js\");\nconst MATCH_URL_YOUTUBE = /(?:youtu\\.be\\/|youtube(?:-nocookie|education)?\\.com\\/(?:embed\\/|v\\/|watch\\/|watch\\?v=|watch\\?.+&v=|shorts\\/|live\\/))((\\w|-){11})|youtube\\.com\\/playlist\\?list=|youtube\\.com\\/user\\//;\nconst MATCH_URL_SOUNDCLOUD = /(?:soundcloud\\.com|snd\\.sc)\\/[^.]+$/;\nconst MATCH_URL_VIMEO = /vimeo\\.com\\/(?!progressive_redirect).+/;\nconst MATCH_URL_MUX = /stream\\.mux\\.com\\/(?!\\w+\\.m3u8)(\\w+)/;\nconst MATCH_URL_FACEBOOK = /^https?:\\/\\/(www\\.)?facebook\\.com.*\\/(video(s)?|watch|story)(\\.php?|\\/).+$/;\nconst MATCH_URL_FACEBOOK_WATCH = /^https?:\\/\\/fb\\.watch\\/.+$/;\nconst MATCH_URL_STREAMABLE = /streamable\\.com\\/([a-z0-9]+)$/;\nconst MATCH_URL_WISTIA = /(?:wistia\\.(?:com|net)|wi\\.st)\\/(?:medias|embed)\\/(?:iframe\\/)?([^?]+)/;\nconst MATCH_URL_TWITCH_VIDEO = /(?:www\\.|go\\.)?twitch\\.tv\\/videos\\/(\\d+)($|\\?)/;\nconst MATCH_URL_TWITCH_CHANNEL = /(?:www\\.|go\\.)?twitch\\.tv\\/([a-zA-Z0-9_]+)($|\\?)/;\nconst MATCH_URL_DAILYMOTION = /^(?:(?:https?):)?(?:\\/\\/)?(?:www\\.)?(?:(?:dailymotion\\.com(?:\\/embed)?\\/video)|dai\\.ly)\\/([a-zA-Z0-9]+)(?:_[\\w_-]+)?(?:[\\w.#_-]+)?/;\nconst MATCH_URL_MIXCLOUD = /mixcloud\\.com\\/([^/]+\\/[^/]+)/;\nconst MATCH_URL_VIDYARD = /vidyard.com\\/(?:watch\\/)?([a-zA-Z0-9-_]+)/;\nconst MATCH_URL_KALTURA = /^https?:\\/\\/[a-zA-Z]+\\.kaltura.(com|org)\\/p\\/([0-9]+)\\/sp\\/([0-9]+)00\\/embedIframeJs\\/uiconf_id\\/([0-9]+)\\/partner_id\\/([0-9]+)(.*)entry_id.([a-zA-Z0-9-_].*)$/;\nconst AUDIO_EXTENSIONS = /\\.(m4a|m4b|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx)($|\\?)/i;\nconst VIDEO_EXTENSIONS = /\\.(mp4|og[gv]|webm|mov|m4v)(#t=[,\\d+]+)?($|\\?)/i;\nconst HLS_EXTENSIONS = /\\.(m3u8)($|\\?)/i;\nconst DASH_EXTENSIONS = /\\.(mpd)($|\\?)/i;\nconst FLV_EXTENSIONS = /\\.(flv)($|\\?)/i;\nconst canPlayFile = (url) => {\n  if (url instanceof Array) {\n    for (const item of url) {\n      if (typeof item === \"string\" && canPlayFile(item)) {\n        return true;\n      }\n      if (canPlayFile(item.src)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  if ((0, import_utils.isMediaStream)(url) || (0, import_utils.isBlobUrl)(url)) {\n    return true;\n  }\n  return AUDIO_EXTENSIONS.test(url) || VIDEO_EXTENSIONS.test(url) || HLS_EXTENSIONS.test(url) || DASH_EXTENSIONS.test(url) || FLV_EXTENSIONS.test(url);\n};\nconst canPlay = {\n  youtube: (url) => {\n    if (url instanceof Array) {\n      return url.every((item) => MATCH_URL_YOUTUBE.test(item));\n    }\n    return MATCH_URL_YOUTUBE.test(url);\n  },\n  soundcloud: (url) => MATCH_URL_SOUNDCLOUD.test(url) && !AUDIO_EXTENSIONS.test(url),\n  vimeo: (url) => MATCH_URL_VIMEO.test(url) && !VIDEO_EXTENSIONS.test(url) && !HLS_EXTENSIONS.test(url),\n  mux: (url) => MATCH_URL_MUX.test(url),\n  facebook: (url) => MATCH_URL_FACEBOOK.test(url) || MATCH_URL_FACEBOOK_WATCH.test(url),\n  streamable: (url) => MATCH_URL_STREAMABLE.test(url),\n  wistia: (url) => MATCH_URL_WISTIA.test(url),\n  twitch: (url) => MATCH_URL_TWITCH_VIDEO.test(url) || MATCH_URL_TWITCH_CHANNEL.test(url),\n  dailymotion: (url) => MATCH_URL_DAILYMOTION.test(url),\n  mixcloud: (url) => MATCH_URL_MIXCLOUD.test(url),\n  vidyard: (url) => MATCH_URL_VIDYARD.test(url),\n  kaltura: (url) => MATCH_URL_KALTURA.test(url),\n  file: canPlayFile\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wbGF5ZXIvbGliL3BhdHRlcm5zLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsNkVBQVM7QUFDcEMsdUpBQXVKLEdBQUc7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL25vZGVfbW9kdWxlcy9yZWFjdC1wbGF5ZXIvbGliL3BhdHRlcm5zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG52YXIgcGF0dGVybnNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocGF0dGVybnNfZXhwb3J0cywge1xuICBBVURJT19FWFRFTlNJT05TOiAoKSA9PiBBVURJT19FWFRFTlNJT05TLFxuICBEQVNIX0VYVEVOU0lPTlM6ICgpID0+IERBU0hfRVhURU5TSU9OUyxcbiAgRkxWX0VYVEVOU0lPTlM6ICgpID0+IEZMVl9FWFRFTlNJT05TLFxuICBITFNfRVhURU5TSU9OUzogKCkgPT4gSExTX0VYVEVOU0lPTlMsXG4gIE1BVENIX1VSTF9EQUlMWU1PVElPTjogKCkgPT4gTUFUQ0hfVVJMX0RBSUxZTU9USU9OLFxuICBNQVRDSF9VUkxfRkFDRUJPT0s6ICgpID0+IE1BVENIX1VSTF9GQUNFQk9PSyxcbiAgTUFUQ0hfVVJMX0ZBQ0VCT09LX1dBVENIOiAoKSA9PiBNQVRDSF9VUkxfRkFDRUJPT0tfV0FUQ0gsXG4gIE1BVENIX1VSTF9LQUxUVVJBOiAoKSA9PiBNQVRDSF9VUkxfS0FMVFVSQSxcbiAgTUFUQ0hfVVJMX01JWENMT1VEOiAoKSA9PiBNQVRDSF9VUkxfTUlYQ0xPVUQsXG4gIE1BVENIX1VSTF9NVVg6ICgpID0+IE1BVENIX1VSTF9NVVgsXG4gIE1BVENIX1VSTF9TT1VORENMT1VEOiAoKSA9PiBNQVRDSF9VUkxfU09VTkRDTE9VRCxcbiAgTUFUQ0hfVVJMX1NUUkVBTUFCTEU6ICgpID0+IE1BVENIX1VSTF9TVFJFQU1BQkxFLFxuICBNQVRDSF9VUkxfVFdJVENIX0NIQU5ORUw6ICgpID0+IE1BVENIX1VSTF9UV0lUQ0hfQ0hBTk5FTCxcbiAgTUFUQ0hfVVJMX1RXSVRDSF9WSURFTzogKCkgPT4gTUFUQ0hfVVJMX1RXSVRDSF9WSURFTyxcbiAgTUFUQ0hfVVJMX1ZJRFlBUkQ6ICgpID0+IE1BVENIX1VSTF9WSURZQVJELFxuICBNQVRDSF9VUkxfVklNRU86ICgpID0+IE1BVENIX1VSTF9WSU1FTyxcbiAgTUFUQ0hfVVJMX1dJU1RJQTogKCkgPT4gTUFUQ0hfVVJMX1dJU1RJQSxcbiAgTUFUQ0hfVVJMX1lPVVRVQkU6ICgpID0+IE1BVENIX1VSTF9ZT1VUVUJFLFxuICBWSURFT19FWFRFTlNJT05TOiAoKSA9PiBWSURFT19FWFRFTlNJT05TLFxuICBjYW5QbGF5OiAoKSA9PiBjYW5QbGF5XG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHBhdHRlcm5zX2V4cG9ydHMpO1xudmFyIGltcG9ydF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgTUFUQ0hfVVJMX1lPVVRVQkUgPSAvKD86eW91dHVcXC5iZVxcL3x5b3V0dWJlKD86LW5vY29va2llfGVkdWNhdGlvbik/XFwuY29tXFwvKD86ZW1iZWRcXC98dlxcL3x3YXRjaFxcL3x3YXRjaFxcP3Y9fHdhdGNoXFw/Lismdj18c2hvcnRzXFwvfGxpdmVcXC8pKSgoXFx3fC0pezExfSl8eW91dHViZVxcLmNvbVxcL3BsYXlsaXN0XFw/bGlzdD18eW91dHViZVxcLmNvbVxcL3VzZXJcXC8vO1xuY29uc3QgTUFUQ0hfVVJMX1NPVU5EQ0xPVUQgPSAvKD86c291bmRjbG91ZFxcLmNvbXxzbmRcXC5zYylcXC9bXi5dKyQvO1xuY29uc3QgTUFUQ0hfVVJMX1ZJTUVPID0gL3ZpbWVvXFwuY29tXFwvKD8hcHJvZ3Jlc3NpdmVfcmVkaXJlY3QpLisvO1xuY29uc3QgTUFUQ0hfVVJMX01VWCA9IC9zdHJlYW1cXC5tdXhcXC5jb21cXC8oPyFcXHcrXFwubTN1OCkoXFx3KykvO1xuY29uc3QgTUFUQ0hfVVJMX0ZBQ0VCT09LID0gL15odHRwcz86XFwvXFwvKHd3d1xcLik/ZmFjZWJvb2tcXC5jb20uKlxcLyh2aWRlbyhzKT98d2F0Y2h8c3RvcnkpKFxcLnBocD98XFwvKS4rJC87XG5jb25zdCBNQVRDSF9VUkxfRkFDRUJPT0tfV0FUQ0ggPSAvXmh0dHBzPzpcXC9cXC9mYlxcLndhdGNoXFwvLiskLztcbmNvbnN0IE1BVENIX1VSTF9TVFJFQU1BQkxFID0gL3N0cmVhbWFibGVcXC5jb21cXC8oW2EtejAtOV0rKSQvO1xuY29uc3QgTUFUQ0hfVVJMX1dJU1RJQSA9IC8oPzp3aXN0aWFcXC4oPzpjb218bmV0KXx3aVxcLnN0KVxcLyg/Om1lZGlhc3xlbWJlZClcXC8oPzppZnJhbWVcXC8pPyhbXj9dKykvO1xuY29uc3QgTUFUQ0hfVVJMX1RXSVRDSF9WSURFTyA9IC8oPzp3d3dcXC58Z29cXC4pP3R3aXRjaFxcLnR2XFwvdmlkZW9zXFwvKFxcZCspKCR8XFw/KS87XG5jb25zdCBNQVRDSF9VUkxfVFdJVENIX0NIQU5ORUwgPSAvKD86d3d3XFwufGdvXFwuKT90d2l0Y2hcXC50dlxcLyhbYS16QS1aMC05X10rKSgkfFxcPykvO1xuY29uc3QgTUFUQ0hfVVJMX0RBSUxZTU9USU9OID0gL14oPzooPzpodHRwcz8pOik/KD86XFwvXFwvKT8oPzp3d3dcXC4pPyg/Oig/OmRhaWx5bW90aW9uXFwuY29tKD86XFwvZW1iZWQpP1xcL3ZpZGVvKXxkYWlcXC5seSlcXC8oW2EtekEtWjAtOV0rKSg/Ol9bXFx3Xy1dKyk/KD86W1xcdy4jXy1dKyk/LztcbmNvbnN0IE1BVENIX1VSTF9NSVhDTE9VRCA9IC9taXhjbG91ZFxcLmNvbVxcLyhbXi9dK1xcL1teL10rKS87XG5jb25zdCBNQVRDSF9VUkxfVklEWUFSRCA9IC92aWR5YXJkLmNvbVxcLyg/OndhdGNoXFwvKT8oW2EtekEtWjAtOS1fXSspLztcbmNvbnN0IE1BVENIX1VSTF9LQUxUVVJBID0gL15odHRwcz86XFwvXFwvW2EtekEtWl0rXFwua2FsdHVyYS4oY29tfG9yZylcXC9wXFwvKFswLTldKylcXC9zcFxcLyhbMC05XSspMDBcXC9lbWJlZElmcmFtZUpzXFwvdWljb25mX2lkXFwvKFswLTldKylcXC9wYXJ0bmVyX2lkXFwvKFswLTldKykoLiopZW50cnlfaWQuKFthLXpBLVowLTktX10uKikkLztcbmNvbnN0IEFVRElPX0VYVEVOU0lPTlMgPSAvXFwuKG00YXxtNGJ8bXA0YXxtcGdhfG1wMnxtcDJhfG1wM3xtMmF8bTNhfHdhdnx3ZWJhfGFhY3xvZ2F8c3B4KSgkfFxcPykvaTtcbmNvbnN0IFZJREVPX0VYVEVOU0lPTlMgPSAvXFwuKG1wNHxvZ1tndl18d2VibXxtb3Z8bTR2KSgjdD1bLFxcZCtdKyk/KCR8XFw/KS9pO1xuY29uc3QgSExTX0VYVEVOU0lPTlMgPSAvXFwuKG0zdTgpKCR8XFw/KS9pO1xuY29uc3QgREFTSF9FWFRFTlNJT05TID0gL1xcLihtcGQpKCR8XFw/KS9pO1xuY29uc3QgRkxWX0VYVEVOU0lPTlMgPSAvXFwuKGZsdikoJHxcXD8pL2k7XG5jb25zdCBjYW5QbGF5RmlsZSA9ICh1cmwpID0+IHtcbiAgaWYgKHVybCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHVybCkge1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiICYmIGNhblBsYXlGaWxlKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNhblBsYXlGaWxlKGl0ZW0uc3JjKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgoMCwgaW1wb3J0X3V0aWxzLmlzTWVkaWFTdHJlYW0pKHVybCkgfHwgKDAsIGltcG9ydF91dGlscy5pc0Jsb2JVcmwpKHVybCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gQVVESU9fRVhURU5TSU9OUy50ZXN0KHVybCkgfHwgVklERU9fRVhURU5TSU9OUy50ZXN0KHVybCkgfHwgSExTX0VYVEVOU0lPTlMudGVzdCh1cmwpIHx8IERBU0hfRVhURU5TSU9OUy50ZXN0KHVybCkgfHwgRkxWX0VYVEVOU0lPTlMudGVzdCh1cmwpO1xufTtcbmNvbnN0IGNhblBsYXkgPSB7XG4gIHlvdXR1YmU6ICh1cmwpID0+IHtcbiAgICBpZiAodXJsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHJldHVybiB1cmwuZXZlcnkoKGl0ZW0pID0+IE1BVENIX1VSTF9ZT1VUVUJFLnRlc3QoaXRlbSkpO1xuICAgIH1cbiAgICByZXR1cm4gTUFUQ0hfVVJMX1lPVVRVQkUudGVzdCh1cmwpO1xuICB9LFxuICBzb3VuZGNsb3VkOiAodXJsKSA9PiBNQVRDSF9VUkxfU09VTkRDTE9VRC50ZXN0KHVybCkgJiYgIUFVRElPX0VYVEVOU0lPTlMudGVzdCh1cmwpLFxuICB2aW1lbzogKHVybCkgPT4gTUFUQ0hfVVJMX1ZJTUVPLnRlc3QodXJsKSAmJiAhVklERU9fRVhURU5TSU9OUy50ZXN0KHVybCkgJiYgIUhMU19FWFRFTlNJT05TLnRlc3QodXJsKSxcbiAgbXV4OiAodXJsKSA9PiBNQVRDSF9VUkxfTVVYLnRlc3QodXJsKSxcbiAgZmFjZWJvb2s6ICh1cmwpID0+IE1BVENIX1VSTF9GQUNFQk9PSy50ZXN0KHVybCkgfHwgTUFUQ0hfVVJMX0ZBQ0VCT09LX1dBVENILnRlc3QodXJsKSxcbiAgc3RyZWFtYWJsZTogKHVybCkgPT4gTUFUQ0hfVVJMX1NUUkVBTUFCTEUudGVzdCh1cmwpLFxuICB3aXN0aWE6ICh1cmwpID0+IE1BVENIX1VSTF9XSVNUSUEudGVzdCh1cmwpLFxuICB0d2l0Y2g6ICh1cmwpID0+IE1BVENIX1VSTF9UV0lUQ0hfVklERU8udGVzdCh1cmwpIHx8IE1BVENIX1VSTF9UV0lUQ0hfQ0hBTk5FTC50ZXN0KHVybCksXG4gIGRhaWx5bW90aW9uOiAodXJsKSA9PiBNQVRDSF9VUkxfREFJTFlNT1RJT04udGVzdCh1cmwpLFxuICBtaXhjbG91ZDogKHVybCkgPT4gTUFUQ0hfVVJMX01JWENMT1VELnRlc3QodXJsKSxcbiAgdmlkeWFyZDogKHVybCkgPT4gTUFUQ0hfVVJMX1ZJRFlBUkQudGVzdCh1cmwpLFxuICBrYWx0dXJhOiAodXJsKSA9PiBNQVRDSF9VUkxfS0FMVFVSQS50ZXN0KHVybCksXG4gIGZpbGU6IGNhblBsYXlGaWxlXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-player/lib/patterns.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-player/lib/players/index.js":
/*!********************************************************!*\
  !*** ./node_modules/react-player/lib/players/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar players_exports = {};\n__export(players_exports, {\n  default: () => players_default\n});\nmodule.exports = __toCommonJS(players_exports);\nvar import_utils = __webpack_require__(/*! ../utils */ \"(app-pages-browser)/./node_modules/react-player/lib/utils.js\");\nvar import_patterns = __webpack_require__(/*! ../patterns */ \"(app-pages-browser)/./node_modules/react-player/lib/patterns.js\");\nvar players_default = [\n  {\n    key: \"youtube\",\n    name: \"YouTube\",\n    canPlay: import_patterns.canPlay.youtube,\n    lazyPlayer: (0, import_utils.lazy)(() => __webpack_require__.e(/*! import() | reactPlayerYouTube */ \"reactPlayerYouTube\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./YouTube */ \"(app-pages-browser)/./node_modules/react-player/lib/players/YouTube.js\", 23)))\n  },\n  {\n    key: \"soundcloud\",\n    name: \"SoundCloud\",\n    canPlay: import_patterns.canPlay.soundcloud,\n    lazyPlayer: (0, import_utils.lazy)(() => __webpack_require__.e(/*! import() | reactPlayerSoundCloud */ \"reactPlayerSoundCloud\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./SoundCloud */ \"(app-pages-browser)/./node_modules/react-player/lib/players/SoundCloud.js\", 23)))\n  },\n  {\n    key: \"vimeo\",\n    name: \"Vimeo\",\n    canPlay: import_patterns.canPlay.vimeo,\n    lazyPlayer: (0, import_utils.lazy)(() => __webpack_require__.e(/*! import() | reactPlayerVimeo */ \"reactPlayerVimeo\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./Vimeo */ \"(app-pages-browser)/./node_modules/react-player/lib/players/Vimeo.js\", 23)))\n  },\n  {\n    key: \"mux\",\n    name: \"Mux\",\n    canPlay: import_patterns.canPlay.mux,\n    lazyPlayer: (0, import_utils.lazy)(() => __webpack_require__.e(/*! import() | reactPlayerMux */ \"reactPlayerMux\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./Mux */ \"(app-pages-browser)/./node_modules/react-player/lib/players/Mux.js\", 23)))\n  },\n  {\n    key: \"facebook\",\n    name: \"Facebook\",\n    canPlay: import_patterns.canPlay.facebook,\n    lazyPlayer: (0, import_utils.lazy)(() => __webpack_require__.e(/*! import() | reactPlayerFacebook */ \"reactPlayerFacebook\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./Facebook */ \"(app-pages-browser)/./node_modules/react-player/lib/players/Facebook.js\", 23)))\n  },\n  {\n    key: \"streamable\",\n    name: \"Streamable\",\n    canPlay: import_patterns.canPlay.streamable,\n    lazyPlayer: (0, import_utils.lazy)(() => __webpack_require__.e(/*! import() | reactPlayerStreamable */ \"reactPlayerStreamable\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./Streamable */ \"(app-pages-browser)/./node_modules/react-player/lib/players/Streamable.js\", 23)))\n  },\n  {\n    key: \"wistia\",\n    name: \"Wistia\",\n    canPlay: import_patterns.canPlay.wistia,\n    lazyPlayer: (0, import_utils.lazy)(() => __webpack_require__.e(/*! import() | reactPlayerWistia */ \"reactPlayerWistia\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./Wistia */ \"(app-pages-browser)/./node_modules/react-player/lib/players/Wistia.js\", 23)))\n  },\n  {\n    key: \"twitch\",\n    name: \"Twitch\",\n    canPlay: import_patterns.canPlay.twitch,\n    lazyPlayer: (0, import_utils.lazy)(() => __webpack_require__.e(/*! import() | reactPlayerTwitch */ \"reactPlayerTwitch\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./Twitch */ \"(app-pages-browser)/./node_modules/react-player/lib/players/Twitch.js\", 23)))\n  },\n  {\n    key: \"dailymotion\",\n    name: \"DailyMotion\",\n    canPlay: import_patterns.canPlay.dailymotion,\n    lazyPlayer: (0, import_utils.lazy)(() => __webpack_require__.e(/*! import() | reactPlayerDailyMotion */ \"reactPlayerDailyMotion\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./DailyMotion */ \"(app-pages-browser)/./node_modules/react-player/lib/players/DailyMotion.js\", 23)))\n  },\n  {\n    key: \"mixcloud\",\n    name: \"Mixcloud\",\n    canPlay: import_patterns.canPlay.mixcloud,\n    lazyPlayer: (0, import_utils.lazy)(() => __webpack_require__.e(/*! import() | reactPlayerMixcloud */ \"reactPlayerMixcloud\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./Mixcloud */ \"(app-pages-browser)/./node_modules/react-player/lib/players/Mixcloud.js\", 23)))\n  },\n  {\n    key: \"vidyard\",\n    name: \"Vidyard\",\n    canPlay: import_patterns.canPlay.vidyard,\n    lazyPlayer: (0, import_utils.lazy)(() => __webpack_require__.e(/*! import() | reactPlayerVidyard */ \"reactPlayerVidyard\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./Vidyard */ \"(app-pages-browser)/./node_modules/react-player/lib/players/Vidyard.js\", 23)))\n  },\n  {\n    key: \"kaltura\",\n    name: \"Kaltura\",\n    canPlay: import_patterns.canPlay.kaltura,\n    lazyPlayer: (0, import_utils.lazy)(() => __webpack_require__.e(/*! import() | reactPlayerKaltura */ \"reactPlayerKaltura\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./Kaltura */ \"(app-pages-browser)/./node_modules/react-player/lib/players/Kaltura.js\", 23)))\n  },\n  {\n    key: \"file\",\n    name: \"FilePlayer\",\n    canPlay: import_patterns.canPlay.file,\n    canEnablePIP: (url) => {\n      return import_patterns.canPlay.file(url) && (document.pictureInPictureEnabled || (0, import_utils.supportsWebKitPresentationMode)()) && !import_patterns.AUDIO_EXTENSIONS.test(url);\n    },\n    lazyPlayer: (0, import_utils.lazy)(() => __webpack_require__.e(/*! import() | reactPlayerFilePlayer */ \"reactPlayerFilePlayer\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./FilePlayer */ \"(app-pages-browser)/./node_modules/react-player/lib/players/FilePlayer.js\", 23)))\n  }\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wbGF5ZXIvbGliL3BsYXllcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDhCQUE4QjtBQUN2RztBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFVO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLG9GQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscU9BR3hDO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlQQUd4QztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2TkFHeEM7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscU5BR3hDO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHlPQUd4QztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpUEFHeEM7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsaU9BR3hDO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlPQUd4QztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxUEFHeEM7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseU9BR3hDO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHFPQUd4QztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxT0FHeEM7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDZDQUE2QyxpUEFHeEM7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3JlYWN0LXBsYXllci9saWIvcGxheWVycy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHBsYXllcnNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocGxheWVyc19leHBvcnRzLCB7XG4gIGRlZmF1bHQ6ICgpID0+IHBsYXllcnNfZGVmYXVsdFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhwbGF5ZXJzX2V4cG9ydHMpO1xudmFyIGltcG9ydF91dGlscyA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBpbXBvcnRfcGF0dGVybnMgPSByZXF1aXJlKFwiLi4vcGF0dGVybnNcIik7XG52YXIgcGxheWVyc19kZWZhdWx0ID0gW1xuICB7XG4gICAga2V5OiBcInlvdXR1YmVcIixcbiAgICBuYW1lOiBcIllvdVR1YmVcIixcbiAgICBjYW5QbGF5OiBpbXBvcnRfcGF0dGVybnMuY2FuUGxheS55b3V0dWJlLFxuICAgIGxhenlQbGF5ZXI6ICgwLCBpbXBvcnRfdXRpbHMubGF6eSkoKCkgPT4gaW1wb3J0KFxuICAgICAgLyogd2VicGFja0NodW5rTmFtZTogJ3JlYWN0UGxheWVyWW91VHViZScgKi9cbiAgICAgIFwiLi9Zb3VUdWJlXCJcbiAgICApKVxuICB9LFxuICB7XG4gICAga2V5OiBcInNvdW5kY2xvdWRcIixcbiAgICBuYW1lOiBcIlNvdW5kQ2xvdWRcIixcbiAgICBjYW5QbGF5OiBpbXBvcnRfcGF0dGVybnMuY2FuUGxheS5zb3VuZGNsb3VkLFxuICAgIGxhenlQbGF5ZXI6ICgwLCBpbXBvcnRfdXRpbHMubGF6eSkoKCkgPT4gaW1wb3J0KFxuICAgICAgLyogd2VicGFja0NodW5rTmFtZTogJ3JlYWN0UGxheWVyU291bmRDbG91ZCcgKi9cbiAgICAgIFwiLi9Tb3VuZENsb3VkXCJcbiAgICApKVxuICB9LFxuICB7XG4gICAga2V5OiBcInZpbWVvXCIsXG4gICAgbmFtZTogXCJWaW1lb1wiLFxuICAgIGNhblBsYXk6IGltcG9ydF9wYXR0ZXJucy5jYW5QbGF5LnZpbWVvLFxuICAgIGxhenlQbGF5ZXI6ICgwLCBpbXBvcnRfdXRpbHMubGF6eSkoKCkgPT4gaW1wb3J0KFxuICAgICAgLyogd2VicGFja0NodW5rTmFtZTogJ3JlYWN0UGxheWVyVmltZW8nICovXG4gICAgICBcIi4vVmltZW9cIlxuICAgICkpXG4gIH0sXG4gIHtcbiAgICBrZXk6IFwibXV4XCIsXG4gICAgbmFtZTogXCJNdXhcIixcbiAgICBjYW5QbGF5OiBpbXBvcnRfcGF0dGVybnMuY2FuUGxheS5tdXgsXG4gICAgbGF6eVBsYXllcjogKDAsIGltcG9ydF91dGlscy5sYXp5KSgoKSA9PiBpbXBvcnQoXG4gICAgICAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiAncmVhY3RQbGF5ZXJNdXgnICovXG4gICAgICBcIi4vTXV4XCJcbiAgICApKVxuICB9LFxuICB7XG4gICAga2V5OiBcImZhY2Vib29rXCIsXG4gICAgbmFtZTogXCJGYWNlYm9va1wiLFxuICAgIGNhblBsYXk6IGltcG9ydF9wYXR0ZXJucy5jYW5QbGF5LmZhY2Vib29rLFxuICAgIGxhenlQbGF5ZXI6ICgwLCBpbXBvcnRfdXRpbHMubGF6eSkoKCkgPT4gaW1wb3J0KFxuICAgICAgLyogd2VicGFja0NodW5rTmFtZTogJ3JlYWN0UGxheWVyRmFjZWJvb2snICovXG4gICAgICBcIi4vRmFjZWJvb2tcIlxuICAgICkpXG4gIH0sXG4gIHtcbiAgICBrZXk6IFwic3RyZWFtYWJsZVwiLFxuICAgIG5hbWU6IFwiU3RyZWFtYWJsZVwiLFxuICAgIGNhblBsYXk6IGltcG9ydF9wYXR0ZXJucy5jYW5QbGF5LnN0cmVhbWFibGUsXG4gICAgbGF6eVBsYXllcjogKDAsIGltcG9ydF91dGlscy5sYXp5KSgoKSA9PiBpbXBvcnQoXG4gICAgICAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiAncmVhY3RQbGF5ZXJTdHJlYW1hYmxlJyAqL1xuICAgICAgXCIuL1N0cmVhbWFibGVcIlxuICAgICkpXG4gIH0sXG4gIHtcbiAgICBrZXk6IFwid2lzdGlhXCIsXG4gICAgbmFtZTogXCJXaXN0aWFcIixcbiAgICBjYW5QbGF5OiBpbXBvcnRfcGF0dGVybnMuY2FuUGxheS53aXN0aWEsXG4gICAgbGF6eVBsYXllcjogKDAsIGltcG9ydF91dGlscy5sYXp5KSgoKSA9PiBpbXBvcnQoXG4gICAgICAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiAncmVhY3RQbGF5ZXJXaXN0aWEnICovXG4gICAgICBcIi4vV2lzdGlhXCJcbiAgICApKVxuICB9LFxuICB7XG4gICAga2V5OiBcInR3aXRjaFwiLFxuICAgIG5hbWU6IFwiVHdpdGNoXCIsXG4gICAgY2FuUGxheTogaW1wb3J0X3BhdHRlcm5zLmNhblBsYXkudHdpdGNoLFxuICAgIGxhenlQbGF5ZXI6ICgwLCBpbXBvcnRfdXRpbHMubGF6eSkoKCkgPT4gaW1wb3J0KFxuICAgICAgLyogd2VicGFja0NodW5rTmFtZTogJ3JlYWN0UGxheWVyVHdpdGNoJyAqL1xuICAgICAgXCIuL1R3aXRjaFwiXG4gICAgKSlcbiAgfSxcbiAge1xuICAgIGtleTogXCJkYWlseW1vdGlvblwiLFxuICAgIG5hbWU6IFwiRGFpbHlNb3Rpb25cIixcbiAgICBjYW5QbGF5OiBpbXBvcnRfcGF0dGVybnMuY2FuUGxheS5kYWlseW1vdGlvbixcbiAgICBsYXp5UGxheWVyOiAoMCwgaW1wb3J0X3V0aWxzLmxhenkpKCgpID0+IGltcG9ydChcbiAgICAgIC8qIHdlYnBhY2tDaHVua05hbWU6ICdyZWFjdFBsYXllckRhaWx5TW90aW9uJyAqL1xuICAgICAgXCIuL0RhaWx5TW90aW9uXCJcbiAgICApKVxuICB9LFxuICB7XG4gICAga2V5OiBcIm1peGNsb3VkXCIsXG4gICAgbmFtZTogXCJNaXhjbG91ZFwiLFxuICAgIGNhblBsYXk6IGltcG9ydF9wYXR0ZXJucy5jYW5QbGF5Lm1peGNsb3VkLFxuICAgIGxhenlQbGF5ZXI6ICgwLCBpbXBvcnRfdXRpbHMubGF6eSkoKCkgPT4gaW1wb3J0KFxuICAgICAgLyogd2VicGFja0NodW5rTmFtZTogJ3JlYWN0UGxheWVyTWl4Y2xvdWQnICovXG4gICAgICBcIi4vTWl4Y2xvdWRcIlxuICAgICkpXG4gIH0sXG4gIHtcbiAgICBrZXk6IFwidmlkeWFyZFwiLFxuICAgIG5hbWU6IFwiVmlkeWFyZFwiLFxuICAgIGNhblBsYXk6IGltcG9ydF9wYXR0ZXJucy5jYW5QbGF5LnZpZHlhcmQsXG4gICAgbGF6eVBsYXllcjogKDAsIGltcG9ydF91dGlscy5sYXp5KSgoKSA9PiBpbXBvcnQoXG4gICAgICAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiAncmVhY3RQbGF5ZXJWaWR5YXJkJyAqL1xuICAgICAgXCIuL1ZpZHlhcmRcIlxuICAgICkpXG4gIH0sXG4gIHtcbiAgICBrZXk6IFwia2FsdHVyYVwiLFxuICAgIG5hbWU6IFwiS2FsdHVyYVwiLFxuICAgIGNhblBsYXk6IGltcG9ydF9wYXR0ZXJucy5jYW5QbGF5LmthbHR1cmEsXG4gICAgbGF6eVBsYXllcjogKDAsIGltcG9ydF91dGlscy5sYXp5KSgoKSA9PiBpbXBvcnQoXG4gICAgICAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiAncmVhY3RQbGF5ZXJLYWx0dXJhJyAqL1xuICAgICAgXCIuL0thbHR1cmFcIlxuICAgICkpXG4gIH0sXG4gIHtcbiAgICBrZXk6IFwiZmlsZVwiLFxuICAgIG5hbWU6IFwiRmlsZVBsYXllclwiLFxuICAgIGNhblBsYXk6IGltcG9ydF9wYXR0ZXJucy5jYW5QbGF5LmZpbGUsXG4gICAgY2FuRW5hYmxlUElQOiAodXJsKSA9PiB7XG4gICAgICByZXR1cm4gaW1wb3J0X3BhdHRlcm5zLmNhblBsYXkuZmlsZSh1cmwpICYmIChkb2N1bWVudC5waWN0dXJlSW5QaWN0dXJlRW5hYmxlZCB8fCAoMCwgaW1wb3J0X3V0aWxzLnN1cHBvcnRzV2ViS2l0UHJlc2VudGF0aW9uTW9kZSkoKSkgJiYgIWltcG9ydF9wYXR0ZXJucy5BVURJT19FWFRFTlNJT05TLnRlc3QodXJsKTtcbiAgICB9LFxuICAgIGxhenlQbGF5ZXI6ICgwLCBpbXBvcnRfdXRpbHMubGF6eSkoKCkgPT4gaW1wb3J0KFxuICAgICAgLyogd2VicGFja0NodW5rTmFtZTogJ3JlYWN0UGxheWVyRmlsZVBsYXllcicgKi9cbiAgICAgIFwiLi9GaWxlUGxheWVyXCJcbiAgICApKVxuICB9XG5dO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-player/lib/players/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-player/lib/props.js":
/*!************************************************!*\
  !*** ./node_modules/react-player/lib/props.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar props_exports = {};\n__export(props_exports, {\n  defaultProps: () => defaultProps,\n  propTypes: () => propTypes\n});\nmodule.exports = __toCommonJS(props_exports);\nvar import_prop_types = __toESM(__webpack_require__(/*! prop-types */ \"(app-pages-browser)/./node_modules/prop-types/index.js\"));\nconst { string, bool, number, array, oneOfType, shape, object, func, node } = import_prop_types.default;\nconst propTypes = {\n  url: oneOfType([string, array, object]),\n  playing: bool,\n  loop: bool,\n  controls: bool,\n  volume: number,\n  muted: bool,\n  playbackRate: number,\n  width: oneOfType([string, number]),\n  height: oneOfType([string, number]),\n  style: object,\n  progressInterval: number,\n  playsinline: bool,\n  pip: bool,\n  stopOnUnmount: bool,\n  light: oneOfType([bool, string, object]),\n  playIcon: node,\n  previewTabIndex: number,\n  previewAriaLabel: string,\n  fallback: node,\n  oEmbedUrl: string,\n  wrapper: oneOfType([\n    string,\n    func,\n    shape({ render: func.isRequired })\n  ]),\n  config: shape({\n    soundcloud: shape({\n      options: object\n    }),\n    youtube: shape({\n      playerVars: object,\n      embedOptions: object,\n      onUnstarted: func\n    }),\n    facebook: shape({\n      appId: string,\n      version: string,\n      playerId: string,\n      attributes: object\n    }),\n    dailymotion: shape({\n      params: object\n    }),\n    vimeo: shape({\n      playerOptions: object,\n      title: string\n    }),\n    mux: shape({\n      attributes: object,\n      version: string\n    }),\n    file: shape({\n      attributes: object,\n      tracks: array,\n      forceVideo: bool,\n      forceAudio: bool,\n      forceHLS: bool,\n      forceSafariHLS: bool,\n      forceDisableHls: bool,\n      forceDASH: bool,\n      forceFLV: bool,\n      hlsOptions: object,\n      hlsVersion: string,\n      dashVersion: string,\n      flvVersion: string\n    }),\n    wistia: shape({\n      options: object,\n      playerId: string,\n      customControls: array\n    }),\n    mixcloud: shape({\n      options: object\n    }),\n    twitch: shape({\n      options: object,\n      playerId: string\n    }),\n    vidyard: shape({\n      options: object\n    })\n  }),\n  onReady: func,\n  onStart: func,\n  onPlay: func,\n  onPause: func,\n  onBuffer: func,\n  onBufferEnd: func,\n  onEnded: func,\n  onError: func,\n  onDuration: func,\n  onSeek: func,\n  onPlaybackRateChange: func,\n  onPlaybackQualityChange: func,\n  onProgress: func,\n  onClickPreview: func,\n  onEnablePIP: func,\n  onDisablePIP: func\n};\nconst noop = () => {\n};\nconst defaultProps = {\n  playing: false,\n  loop: false,\n  controls: false,\n  volume: null,\n  muted: false,\n  playbackRate: 1,\n  width: \"640px\",\n  height: \"360px\",\n  style: {},\n  progressInterval: 1e3,\n  playsinline: false,\n  pip: false,\n  stopOnUnmount: true,\n  light: false,\n  fallback: null,\n  wrapper: \"div\",\n  previewTabIndex: 0,\n  previewAriaLabel: \"\",\n  oEmbedUrl: \"https://noembed.com/embed?url={url}\",\n  config: {\n    soundcloud: {\n      options: {\n        visual: true,\n        // Undocumented, but makes player fill container and look better\n        buying: false,\n        liking: false,\n        download: false,\n        sharing: false,\n        show_comments: false,\n        show_playcount: false\n      }\n    },\n    youtube: {\n      playerVars: {\n        playsinline: 1,\n        showinfo: 0,\n        rel: 0,\n        iv_load_policy: 3,\n        modestbranding: 1\n      },\n      embedOptions: {},\n      onUnstarted: noop\n    },\n    facebook: {\n      appId: \"1309697205772819\",\n      version: \"v3.3\",\n      playerId: null,\n      attributes: {}\n    },\n    dailymotion: {\n      params: {\n        api: 1,\n        \"endscreen-enable\": false\n      }\n    },\n    vimeo: {\n      playerOptions: {\n        autopause: false,\n        byline: false,\n        portrait: false,\n        title: false\n      },\n      title: null\n    },\n    mux: {\n      attributes: {},\n      version: \"2\"\n    },\n    file: {\n      attributes: {},\n      tracks: [],\n      forceVideo: false,\n      forceAudio: false,\n      forceHLS: false,\n      forceDASH: false,\n      forceFLV: false,\n      hlsOptions: {},\n      hlsVersion: \"1.1.4\",\n      dashVersion: \"3.1.3\",\n      flvVersion: \"1.5.0\",\n      forceDisableHls: false\n    },\n    wistia: {\n      options: {},\n      playerId: null,\n      customControls: null\n    },\n    mixcloud: {\n      options: {\n        hide_cover: 1\n      }\n    },\n    twitch: {\n      options: {},\n      playerId: null\n    },\n    vidyard: {\n      options: {}\n    }\n  },\n  onReady: noop,\n  onStart: noop,\n  onPlay: noop,\n  onPause: noop,\n  onBuffer: noop,\n  onBufferEnd: noop,\n  onEnded: noop,\n  onError: noop,\n  onDuration: noop,\n  onSeek: noop,\n  onPlaybackRateChange: noop,\n  onPlaybackQualityChange: noop,\n  onProgress: noop,\n  onClickPreview: noop,\n  onEnablePIP: noop,\n  onDisablePIP: noop\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wbGF5ZXIvbGliL3Byb3BzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdDQUFnQyxtQkFBTyxDQUFDLDBFQUFZO0FBQ3BELFFBQVEsb0VBQW9FO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLElBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHNCQUFzQjtBQUN0QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvbm9kZV9tb2R1bGVzL3JlYWN0LXBsYXllci9saWIvcHJvcHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcbnZhciBwcm9wc19leHBvcnRzID0ge307XG5fX2V4cG9ydChwcm9wc19leHBvcnRzLCB7XG4gIGRlZmF1bHRQcm9wczogKCkgPT4gZGVmYXVsdFByb3BzLFxuICBwcm9wVHlwZXM6ICgpID0+IHByb3BUeXBlc1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhwcm9wc19leHBvcnRzKTtcbnZhciBpbXBvcnRfcHJvcF90eXBlcyA9IF9fdG9FU00ocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuY29uc3QgeyBzdHJpbmcsIGJvb2wsIG51bWJlciwgYXJyYXksIG9uZU9mVHlwZSwgc2hhcGUsIG9iamVjdCwgZnVuYywgbm9kZSB9ID0gaW1wb3J0X3Byb3BfdHlwZXMuZGVmYXVsdDtcbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgdXJsOiBvbmVPZlR5cGUoW3N0cmluZywgYXJyYXksIG9iamVjdF0pLFxuICBwbGF5aW5nOiBib29sLFxuICBsb29wOiBib29sLFxuICBjb250cm9sczogYm9vbCxcbiAgdm9sdW1lOiBudW1iZXIsXG4gIG11dGVkOiBib29sLFxuICBwbGF5YmFja1JhdGU6IG51bWJlcixcbiAgd2lkdGg6IG9uZU9mVHlwZShbc3RyaW5nLCBudW1iZXJdKSxcbiAgaGVpZ2h0OiBvbmVPZlR5cGUoW3N0cmluZywgbnVtYmVyXSksXG4gIHN0eWxlOiBvYmplY3QsXG4gIHByb2dyZXNzSW50ZXJ2YWw6IG51bWJlcixcbiAgcGxheXNpbmxpbmU6IGJvb2wsXG4gIHBpcDogYm9vbCxcbiAgc3RvcE9uVW5tb3VudDogYm9vbCxcbiAgbGlnaHQ6IG9uZU9mVHlwZShbYm9vbCwgc3RyaW5nLCBvYmplY3RdKSxcbiAgcGxheUljb246IG5vZGUsXG4gIHByZXZpZXdUYWJJbmRleDogbnVtYmVyLFxuICBwcmV2aWV3QXJpYUxhYmVsOiBzdHJpbmcsXG4gIGZhbGxiYWNrOiBub2RlLFxuICBvRW1iZWRVcmw6IHN0cmluZyxcbiAgd3JhcHBlcjogb25lT2ZUeXBlKFtcbiAgICBzdHJpbmcsXG4gICAgZnVuYyxcbiAgICBzaGFwZSh7IHJlbmRlcjogZnVuYy5pc1JlcXVpcmVkIH0pXG4gIF0pLFxuICBjb25maWc6IHNoYXBlKHtcbiAgICBzb3VuZGNsb3VkOiBzaGFwZSh7XG4gICAgICBvcHRpb25zOiBvYmplY3RcbiAgICB9KSxcbiAgICB5b3V0dWJlOiBzaGFwZSh7XG4gICAgICBwbGF5ZXJWYXJzOiBvYmplY3QsXG4gICAgICBlbWJlZE9wdGlvbnM6IG9iamVjdCxcbiAgICAgIG9uVW5zdGFydGVkOiBmdW5jXG4gICAgfSksXG4gICAgZmFjZWJvb2s6IHNoYXBlKHtcbiAgICAgIGFwcElkOiBzdHJpbmcsXG4gICAgICB2ZXJzaW9uOiBzdHJpbmcsXG4gICAgICBwbGF5ZXJJZDogc3RyaW5nLFxuICAgICAgYXR0cmlidXRlczogb2JqZWN0XG4gICAgfSksXG4gICAgZGFpbHltb3Rpb246IHNoYXBlKHtcbiAgICAgIHBhcmFtczogb2JqZWN0XG4gICAgfSksXG4gICAgdmltZW86IHNoYXBlKHtcbiAgICAgIHBsYXllck9wdGlvbnM6IG9iamVjdCxcbiAgICAgIHRpdGxlOiBzdHJpbmdcbiAgICB9KSxcbiAgICBtdXg6IHNoYXBlKHtcbiAgICAgIGF0dHJpYnV0ZXM6IG9iamVjdCxcbiAgICAgIHZlcnNpb246IHN0cmluZ1xuICAgIH0pLFxuICAgIGZpbGU6IHNoYXBlKHtcbiAgICAgIGF0dHJpYnV0ZXM6IG9iamVjdCxcbiAgICAgIHRyYWNrczogYXJyYXksXG4gICAgICBmb3JjZVZpZGVvOiBib29sLFxuICAgICAgZm9yY2VBdWRpbzogYm9vbCxcbiAgICAgIGZvcmNlSExTOiBib29sLFxuICAgICAgZm9yY2VTYWZhcmlITFM6IGJvb2wsXG4gICAgICBmb3JjZURpc2FibGVIbHM6IGJvb2wsXG4gICAgICBmb3JjZURBU0g6IGJvb2wsXG4gICAgICBmb3JjZUZMVjogYm9vbCxcbiAgICAgIGhsc09wdGlvbnM6IG9iamVjdCxcbiAgICAgIGhsc1ZlcnNpb246IHN0cmluZyxcbiAgICAgIGRhc2hWZXJzaW9uOiBzdHJpbmcsXG4gICAgICBmbHZWZXJzaW9uOiBzdHJpbmdcbiAgICB9KSxcbiAgICB3aXN0aWE6IHNoYXBlKHtcbiAgICAgIG9wdGlvbnM6IG9iamVjdCxcbiAgICAgIHBsYXllcklkOiBzdHJpbmcsXG4gICAgICBjdXN0b21Db250cm9sczogYXJyYXlcbiAgICB9KSxcbiAgICBtaXhjbG91ZDogc2hhcGUoe1xuICAgICAgb3B0aW9uczogb2JqZWN0XG4gICAgfSksXG4gICAgdHdpdGNoOiBzaGFwZSh7XG4gICAgICBvcHRpb25zOiBvYmplY3QsXG4gICAgICBwbGF5ZXJJZDogc3RyaW5nXG4gICAgfSksXG4gICAgdmlkeWFyZDogc2hhcGUoe1xuICAgICAgb3B0aW9uczogb2JqZWN0XG4gICAgfSlcbiAgfSksXG4gIG9uUmVhZHk6IGZ1bmMsXG4gIG9uU3RhcnQ6IGZ1bmMsXG4gIG9uUGxheTogZnVuYyxcbiAgb25QYXVzZTogZnVuYyxcbiAgb25CdWZmZXI6IGZ1bmMsXG4gIG9uQnVmZmVyRW5kOiBmdW5jLFxuICBvbkVuZGVkOiBmdW5jLFxuICBvbkVycm9yOiBmdW5jLFxuICBvbkR1cmF0aW9uOiBmdW5jLFxuICBvblNlZWs6IGZ1bmMsXG4gIG9uUGxheWJhY2tSYXRlQ2hhbmdlOiBmdW5jLFxuICBvblBsYXliYWNrUXVhbGl0eUNoYW5nZTogZnVuYyxcbiAgb25Qcm9ncmVzczogZnVuYyxcbiAgb25DbGlja1ByZXZpZXc6IGZ1bmMsXG4gIG9uRW5hYmxlUElQOiBmdW5jLFxuICBvbkRpc2FibGVQSVA6IGZ1bmNcbn07XG5jb25zdCBub29wID0gKCkgPT4ge1xufTtcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgcGxheWluZzogZmFsc2UsXG4gIGxvb3A6IGZhbHNlLFxuICBjb250cm9sczogZmFsc2UsXG4gIHZvbHVtZTogbnVsbCxcbiAgbXV0ZWQ6IGZhbHNlLFxuICBwbGF5YmFja1JhdGU6IDEsXG4gIHdpZHRoOiBcIjY0MHB4XCIsXG4gIGhlaWdodDogXCIzNjBweFwiLFxuICBzdHlsZToge30sXG4gIHByb2dyZXNzSW50ZXJ2YWw6IDFlMyxcbiAgcGxheXNpbmxpbmU6IGZhbHNlLFxuICBwaXA6IGZhbHNlLFxuICBzdG9wT25Vbm1vdW50OiB0cnVlLFxuICBsaWdodDogZmFsc2UsXG4gIGZhbGxiYWNrOiBudWxsLFxuICB3cmFwcGVyOiBcImRpdlwiLFxuICBwcmV2aWV3VGFiSW5kZXg6IDAsXG4gIHByZXZpZXdBcmlhTGFiZWw6IFwiXCIsXG4gIG9FbWJlZFVybDogXCJodHRwczovL25vZW1iZWQuY29tL2VtYmVkP3VybD17dXJsfVwiLFxuICBjb25maWc6IHtcbiAgICBzb3VuZGNsb3VkOiB7XG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHZpc3VhbDogdHJ1ZSxcbiAgICAgICAgLy8gVW5kb2N1bWVudGVkLCBidXQgbWFrZXMgcGxheWVyIGZpbGwgY29udGFpbmVyIGFuZCBsb29rIGJldHRlclxuICAgICAgICBidXlpbmc6IGZhbHNlLFxuICAgICAgICBsaWtpbmc6IGZhbHNlLFxuICAgICAgICBkb3dubG9hZDogZmFsc2UsXG4gICAgICAgIHNoYXJpbmc6IGZhbHNlLFxuICAgICAgICBzaG93X2NvbW1lbnRzOiBmYWxzZSxcbiAgICAgICAgc2hvd19wbGF5Y291bnQ6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICB5b3V0dWJlOiB7XG4gICAgICBwbGF5ZXJWYXJzOiB7XG4gICAgICAgIHBsYXlzaW5saW5lOiAxLFxuICAgICAgICBzaG93aW5mbzogMCxcbiAgICAgICAgcmVsOiAwLFxuICAgICAgICBpdl9sb2FkX3BvbGljeTogMyxcbiAgICAgICAgbW9kZXN0YnJhbmRpbmc6IDFcbiAgICAgIH0sXG4gICAgICBlbWJlZE9wdGlvbnM6IHt9LFxuICAgICAgb25VbnN0YXJ0ZWQ6IG5vb3BcbiAgICB9LFxuICAgIGZhY2Vib29rOiB7XG4gICAgICBhcHBJZDogXCIxMzA5Njk3MjA1NzcyODE5XCIsXG4gICAgICB2ZXJzaW9uOiBcInYzLjNcIixcbiAgICAgIHBsYXllcklkOiBudWxsLFxuICAgICAgYXR0cmlidXRlczoge31cbiAgICB9LFxuICAgIGRhaWx5bW90aW9uOiB7XG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgYXBpOiAxLFxuICAgICAgICBcImVuZHNjcmVlbi1lbmFibGVcIjogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIHZpbWVvOiB7XG4gICAgICBwbGF5ZXJPcHRpb25zOiB7XG4gICAgICAgIGF1dG9wYXVzZTogZmFsc2UsXG4gICAgICAgIGJ5bGluZTogZmFsc2UsXG4gICAgICAgIHBvcnRyYWl0OiBmYWxzZSxcbiAgICAgICAgdGl0bGU6IGZhbHNlXG4gICAgICB9LFxuICAgICAgdGl0bGU6IG51bGxcbiAgICB9LFxuICAgIG11eDoge1xuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICB2ZXJzaW9uOiBcIjJcIlxuICAgIH0sXG4gICAgZmlsZToge1xuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICB0cmFja3M6IFtdLFxuICAgICAgZm9yY2VWaWRlbzogZmFsc2UsXG4gICAgICBmb3JjZUF1ZGlvOiBmYWxzZSxcbiAgICAgIGZvcmNlSExTOiBmYWxzZSxcbiAgICAgIGZvcmNlREFTSDogZmFsc2UsXG4gICAgICBmb3JjZUZMVjogZmFsc2UsXG4gICAgICBobHNPcHRpb25zOiB7fSxcbiAgICAgIGhsc1ZlcnNpb246IFwiMS4xLjRcIixcbiAgICAgIGRhc2hWZXJzaW9uOiBcIjMuMS4zXCIsXG4gICAgICBmbHZWZXJzaW9uOiBcIjEuNS4wXCIsXG4gICAgICBmb3JjZURpc2FibGVIbHM6IGZhbHNlXG4gICAgfSxcbiAgICB3aXN0aWE6IHtcbiAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgcGxheWVySWQ6IG51bGwsXG4gICAgICBjdXN0b21Db250cm9sczogbnVsbFxuICAgIH0sXG4gICAgbWl4Y2xvdWQ6IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgaGlkZV9jb3ZlcjogMVxuICAgICAgfVxuICAgIH0sXG4gICAgdHdpdGNoOiB7XG4gICAgICBvcHRpb25zOiB7fSxcbiAgICAgIHBsYXllcklkOiBudWxsXG4gICAgfSxcbiAgICB2aWR5YXJkOiB7XG4gICAgICBvcHRpb25zOiB7fVxuICAgIH1cbiAgfSxcbiAgb25SZWFkeTogbm9vcCxcbiAgb25TdGFydDogbm9vcCxcbiAgb25QbGF5OiBub29wLFxuICBvblBhdXNlOiBub29wLFxuICBvbkJ1ZmZlcjogbm9vcCxcbiAgb25CdWZmZXJFbmQ6IG5vb3AsXG4gIG9uRW5kZWQ6IG5vb3AsXG4gIG9uRXJyb3I6IG5vb3AsXG4gIG9uRHVyYXRpb246IG5vb3AsXG4gIG9uU2Vlazogbm9vcCxcbiAgb25QbGF5YmFja1JhdGVDaGFuZ2U6IG5vb3AsXG4gIG9uUGxheWJhY2tRdWFsaXR5Q2hhbmdlOiBub29wLFxuICBvblByb2dyZXNzOiBub29wLFxuICBvbkNsaWNrUHJldmlldzogbm9vcCxcbiAgb25FbmFibGVQSVA6IG5vb3AsXG4gIG9uRGlzYWJsZVBJUDogbm9vcFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-player/lib/props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-player/lib/utils.js":
/*!************************************************!*\
  !*** ./node_modules/react-player/lib/utils.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\nvar utils_exports = {};\n__export(utils_exports, {\n  callPlayer: () => callPlayer,\n  getConfig: () => getConfig,\n  getSDK: () => getSDK,\n  isBlobUrl: () => isBlobUrl,\n  isMediaStream: () => isMediaStream,\n  lazy: () => lazy,\n  omit: () => omit,\n  parseEndTime: () => parseEndTime,\n  parseStartTime: () => parseStartTime,\n  queryString: () => queryString,\n  randomString: () => randomString,\n  supportsWebKitPresentationMode: () => supportsWebKitPresentationMode\n});\nmodule.exports = __toCommonJS(utils_exports);\nvar import_react = __toESM(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nvar import_load_script = __toESM(__webpack_require__(/*! load-script */ \"(app-pages-browser)/./node_modules/load-script/index.js\"));\nvar import_deepmerge = __toESM(__webpack_require__(/*! deepmerge */ \"(app-pages-browser)/./node_modules/deepmerge/dist/cjs.js\"));\nconst lazy = (componentImportFn) => import_react.default.lazy(async () => {\n  const obj = await componentImportFn();\n  return typeof obj.default === \"function\" ? obj : obj.default;\n});\nconst MATCH_START_QUERY = /[?&#](?:start|t)=([0-9hms]+)/;\nconst MATCH_END_QUERY = /[?&#]end=([0-9hms]+)/;\nconst MATCH_START_STAMP = /(\\d+)(h|m|s)/g;\nconst MATCH_NUMERIC = /^\\d+$/;\nfunction parseTimeParam(url, pattern) {\n  if (url instanceof Array) {\n    return void 0;\n  }\n  const match = url.match(pattern);\n  if (match) {\n    const stamp = match[1];\n    if (stamp.match(MATCH_START_STAMP)) {\n      return parseTimeString(stamp);\n    }\n    if (MATCH_NUMERIC.test(stamp)) {\n      return parseInt(stamp);\n    }\n  }\n  return void 0;\n}\nfunction parseTimeString(stamp) {\n  let seconds = 0;\n  let array = MATCH_START_STAMP.exec(stamp);\n  while (array !== null) {\n    const [, count, period] = array;\n    if (period === \"h\")\n      seconds += parseInt(count, 10) * 60 * 60;\n    if (period === \"m\")\n      seconds += parseInt(count, 10) * 60;\n    if (period === \"s\")\n      seconds += parseInt(count, 10);\n    array = MATCH_START_STAMP.exec(stamp);\n  }\n  return seconds;\n}\nfunction parseStartTime(url) {\n  return parseTimeParam(url, MATCH_START_QUERY);\n}\nfunction parseEndTime(url) {\n  return parseTimeParam(url, MATCH_END_QUERY);\n}\nfunction randomString() {\n  return Math.random().toString(36).substr(2, 5);\n}\nfunction queryString(object) {\n  return Object.keys(object).map((key) => `${key}=${object[key]}`).join(\"&\");\n}\nfunction getGlobal(key) {\n  if (window[key]) {\n    return window[key];\n  }\n  if (window.exports && window.exports[key]) {\n    return window.exports[key];\n  }\n  if (window.module && window.module.exports && window.module.exports[key]) {\n    return window.module.exports[key];\n  }\n  return null;\n}\nconst requests = {};\nconst getSDK = enableStubOn(function getSDK2(url, sdkGlobal, sdkReady = null, isLoaded = () => true, fetchScript = import_load_script.default) {\n  const existingGlobal = getGlobal(sdkGlobal);\n  if (existingGlobal && isLoaded(existingGlobal)) {\n    return Promise.resolve(existingGlobal);\n  }\n  return new Promise((resolve, reject) => {\n    if (requests[url]) {\n      requests[url].push({ resolve, reject });\n      return;\n    }\n    requests[url] = [{ resolve, reject }];\n    const onLoaded = (sdk) => {\n      requests[url].forEach((request) => request.resolve(sdk));\n    };\n    if (sdkReady) {\n      const previousOnReady = window[sdkReady];\n      window[sdkReady] = function() {\n        if (previousOnReady)\n          previousOnReady();\n        onLoaded(getGlobal(sdkGlobal));\n      };\n    }\n    fetchScript(url, (err) => {\n      if (err) {\n        requests[url].forEach((request) => request.reject(err));\n        requests[url] = null;\n      } else if (!sdkReady) {\n        onLoaded(getGlobal(sdkGlobal));\n      }\n    });\n  });\n});\nfunction getConfig(props, defaultProps) {\n  return (0, import_deepmerge.default)(defaultProps.config, props.config);\n}\nfunction omit(object, ...arrays) {\n  const omitKeys = [].concat(...arrays);\n  const output = {};\n  const keys = Object.keys(object);\n  for (const key of keys) {\n    if (omitKeys.indexOf(key) === -1) {\n      output[key] = object[key];\n    }\n  }\n  return output;\n}\nfunction callPlayer(method, ...args) {\n  if (!this.player || !this.player[method]) {\n    let message = `ReactPlayer: ${this.constructor.displayName} player could not call %c${method}%c \\u2013 `;\n    if (!this.player) {\n      message += \"The player was not available\";\n    } else if (!this.player[method]) {\n      message += \"The method was not available\";\n    }\n    console.warn(message, \"font-weight: bold\", \"\");\n    return null;\n  }\n  return this.player[method](...args);\n}\nfunction isMediaStream(url) {\n  return typeof window !== \"undefined\" && typeof window.MediaStream !== \"undefined\" && url instanceof window.MediaStream;\n}\nfunction isBlobUrl(url) {\n  return /^blob:/.test(url);\n}\nfunction supportsWebKitPresentationMode(video = document.createElement(\"video\")) {\n  const notMobile = /iPhone|iPod/.test(navigator.userAgent) === false;\n  return video.webkitSupportsPresentationMode && typeof video.webkitSetPresentationMode === \"function\" && notMobile;\n}\nfunction enableStubOn(fn) {\n  if (false) {}\n  return fn;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wbGF5ZXIvbGliL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsbUZBQU87QUFDMUMsaUNBQWlDLG1CQUFPLENBQUMsNEVBQWE7QUFDdEQsK0JBQStCLG1CQUFPLENBQUMsMkVBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxJQUFJLEdBQUcsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOEJBQThCLDBCQUEwQixPQUFPO0FBQ2pHO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFLLEVBQUUsRUFJVjtBQUNIO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9ub2RlX21vZHVsZXMvcmVhY3QtcGxheWVyL2xpYi91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhcbiAgLy8gSWYgdGhlIGltcG9ydGVyIGlzIGluIG5vZGUgY29tcGF0aWJpbGl0eSBtb2RlIG9yIHRoaXMgaXMgbm90IGFuIEVTTVxuICAvLyBmaWxlIHRoYXQgaGFzIGJlZW4gY29udmVydGVkIHRvIGEgQ29tbW9uSlMgZmlsZSB1c2luZyBhIEJhYmVsLVxuICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgLy8gXCJkZWZhdWx0XCIgdG8gdGhlIENvbW1vbkpTIFwibW9kdWxlLmV4cG9ydHNcIiBmb3Igbm9kZSBjb21wYXRpYmlsaXR5LlxuICBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldCxcbiAgbW9kXG4pKTtcbnZhciBfX3RvQ29tbW9uSlMgPSAobW9kKSA9PiBfX2NvcHlQcm9wcyhfX2RlZlByb3Aoe30sIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pLCBtb2QpO1xudmFyIHV0aWxzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHV0aWxzX2V4cG9ydHMsIHtcbiAgY2FsbFBsYXllcjogKCkgPT4gY2FsbFBsYXllcixcbiAgZ2V0Q29uZmlnOiAoKSA9PiBnZXRDb25maWcsXG4gIGdldFNESzogKCkgPT4gZ2V0U0RLLFxuICBpc0Jsb2JVcmw6ICgpID0+IGlzQmxvYlVybCxcbiAgaXNNZWRpYVN0cmVhbTogKCkgPT4gaXNNZWRpYVN0cmVhbSxcbiAgbGF6eTogKCkgPT4gbGF6eSxcbiAgb21pdDogKCkgPT4gb21pdCxcbiAgcGFyc2VFbmRUaW1lOiAoKSA9PiBwYXJzZUVuZFRpbWUsXG4gIHBhcnNlU3RhcnRUaW1lOiAoKSA9PiBwYXJzZVN0YXJ0VGltZSxcbiAgcXVlcnlTdHJpbmc6ICgpID0+IHF1ZXJ5U3RyaW5nLFxuICByYW5kb21TdHJpbmc6ICgpID0+IHJhbmRvbVN0cmluZyxcbiAgc3VwcG9ydHNXZWJLaXRQcmVzZW50YXRpb25Nb2RlOiAoKSA9PiBzdXBwb3J0c1dlYktpdFByZXNlbnRhdGlvbk1vZGVcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlModXRpbHNfZXhwb3J0cyk7XG52YXIgaW1wb3J0X3JlYWN0ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIGltcG9ydF9sb2FkX3NjcmlwdCA9IF9fdG9FU00ocmVxdWlyZShcImxvYWQtc2NyaXB0XCIpKTtcbnZhciBpbXBvcnRfZGVlcG1lcmdlID0gX190b0VTTShyZXF1aXJlKFwiZGVlcG1lcmdlXCIpKTtcbmNvbnN0IGxhenkgPSAoY29tcG9uZW50SW1wb3J0Rm4pID0+IGltcG9ydF9yZWFjdC5kZWZhdWx0LmxhenkoYXN5bmMgKCkgPT4ge1xuICBjb25zdCBvYmogPSBhd2FpdCBjb21wb25lbnRJbXBvcnRGbigpO1xuICByZXR1cm4gdHlwZW9mIG9iai5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgPyBvYmogOiBvYmouZGVmYXVsdDtcbn0pO1xuY29uc3QgTUFUQ0hfU1RBUlRfUVVFUlkgPSAvWz8mI10oPzpzdGFydHx0KT0oWzAtOWhtc10rKS87XG5jb25zdCBNQVRDSF9FTkRfUVVFUlkgPSAvWz8mI11lbmQ9KFswLTlobXNdKykvO1xuY29uc3QgTUFUQ0hfU1RBUlRfU1RBTVAgPSAvKFxcZCspKGh8bXxzKS9nO1xuY29uc3QgTUFUQ0hfTlVNRVJJQyA9IC9eXFxkKyQvO1xuZnVuY3Rpb24gcGFyc2VUaW1lUGFyYW0odXJsLCBwYXR0ZXJuKSB7XG4gIGlmICh1cmwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2gocGF0dGVybik7XG4gIGlmIChtYXRjaCkge1xuICAgIGNvbnN0IHN0YW1wID0gbWF0Y2hbMV07XG4gICAgaWYgKHN0YW1wLm1hdGNoKE1BVENIX1NUQVJUX1NUQU1QKSkge1xuICAgICAgcmV0dXJuIHBhcnNlVGltZVN0cmluZyhzdGFtcCk7XG4gICAgfVxuICAgIGlmIChNQVRDSF9OVU1FUklDLnRlc3Qoc3RhbXApKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoc3RhbXApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gcGFyc2VUaW1lU3RyaW5nKHN0YW1wKSB7XG4gIGxldCBzZWNvbmRzID0gMDtcbiAgbGV0IGFycmF5ID0gTUFUQ0hfU1RBUlRfU1RBTVAuZXhlYyhzdGFtcCk7XG4gIHdoaWxlIChhcnJheSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IFssIGNvdW50LCBwZXJpb2RdID0gYXJyYXk7XG4gICAgaWYgKHBlcmlvZCA9PT0gXCJoXCIpXG4gICAgICBzZWNvbmRzICs9IHBhcnNlSW50KGNvdW50LCAxMCkgKiA2MCAqIDYwO1xuICAgIGlmIChwZXJpb2QgPT09IFwibVwiKVxuICAgICAgc2Vjb25kcyArPSBwYXJzZUludChjb3VudCwgMTApICogNjA7XG4gICAgaWYgKHBlcmlvZCA9PT0gXCJzXCIpXG4gICAgICBzZWNvbmRzICs9IHBhcnNlSW50KGNvdW50LCAxMCk7XG4gICAgYXJyYXkgPSBNQVRDSF9TVEFSVF9TVEFNUC5leGVjKHN0YW1wKTtcbiAgfVxuICByZXR1cm4gc2Vjb25kcztcbn1cbmZ1bmN0aW9uIHBhcnNlU3RhcnRUaW1lKHVybCkge1xuICByZXR1cm4gcGFyc2VUaW1lUGFyYW0odXJsLCBNQVRDSF9TVEFSVF9RVUVSWSk7XG59XG5mdW5jdGlvbiBwYXJzZUVuZFRpbWUodXJsKSB7XG4gIHJldHVybiBwYXJzZVRpbWVQYXJhbSh1cmwsIE1BVENIX0VORF9RVUVSWSk7XG59XG5mdW5jdGlvbiByYW5kb21TdHJpbmcoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgNSk7XG59XG5mdW5jdGlvbiBxdWVyeVN0cmluZyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkubWFwKChrZXkpID0+IGAke2tleX09JHtvYmplY3Rba2V5XX1gKS5qb2luKFwiJlwiKTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbChrZXkpIHtcbiAgaWYgKHdpbmRvd1trZXldKSB7XG4gICAgcmV0dXJuIHdpbmRvd1trZXldO1xuICB9XG4gIGlmICh3aW5kb3cuZXhwb3J0cyAmJiB3aW5kb3cuZXhwb3J0c1trZXldKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5leHBvcnRzW2tleV07XG4gIH1cbiAgaWYgKHdpbmRvdy5tb2R1bGUgJiYgd2luZG93Lm1vZHVsZS5leHBvcnRzICYmIHdpbmRvdy5tb2R1bGUuZXhwb3J0c1trZXldKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5tb2R1bGUuZXhwb3J0c1trZXldO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuY29uc3QgcmVxdWVzdHMgPSB7fTtcbmNvbnN0IGdldFNESyA9IGVuYWJsZVN0dWJPbihmdW5jdGlvbiBnZXRTREsyKHVybCwgc2RrR2xvYmFsLCBzZGtSZWFkeSA9IG51bGwsIGlzTG9hZGVkID0gKCkgPT4gdHJ1ZSwgZmV0Y2hTY3JpcHQgPSBpbXBvcnRfbG9hZF9zY3JpcHQuZGVmYXVsdCkge1xuICBjb25zdCBleGlzdGluZ0dsb2JhbCA9IGdldEdsb2JhbChzZGtHbG9iYWwpO1xuICBpZiAoZXhpc3RpbmdHbG9iYWwgJiYgaXNMb2FkZWQoZXhpc3RpbmdHbG9iYWwpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShleGlzdGluZ0dsb2JhbCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAocmVxdWVzdHNbdXJsXSkge1xuICAgICAgcmVxdWVzdHNbdXJsXS5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXF1ZXN0c1t1cmxdID0gW3sgcmVzb2x2ZSwgcmVqZWN0IH1dO1xuICAgIGNvbnN0IG9uTG9hZGVkID0gKHNkaykgPT4ge1xuICAgICAgcmVxdWVzdHNbdXJsXS5mb3JFYWNoKChyZXF1ZXN0KSA9PiByZXF1ZXN0LnJlc29sdmUoc2RrKSk7XG4gICAgfTtcbiAgICBpZiAoc2RrUmVhZHkpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzT25SZWFkeSA9IHdpbmRvd1tzZGtSZWFkeV07XG4gICAgICB3aW5kb3dbc2RrUmVhZHldID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChwcmV2aW91c09uUmVhZHkpXG4gICAgICAgICAgcHJldmlvdXNPblJlYWR5KCk7XG4gICAgICAgIG9uTG9hZGVkKGdldEdsb2JhbChzZGtHbG9iYWwpKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZldGNoU2NyaXB0KHVybCwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXF1ZXN0c1t1cmxdLmZvckVhY2goKHJlcXVlc3QpID0+IHJlcXVlc3QucmVqZWN0KGVycikpO1xuICAgICAgICByZXF1ZXN0c1t1cmxdID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXNka1JlYWR5KSB7XG4gICAgICAgIG9uTG9hZGVkKGdldEdsb2JhbChzZGtHbG9iYWwpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTtcbmZ1bmN0aW9uIGdldENvbmZpZyhwcm9wcywgZGVmYXVsdFByb3BzKSB7XG4gIHJldHVybiAoMCwgaW1wb3J0X2RlZXBtZXJnZS5kZWZhdWx0KShkZWZhdWx0UHJvcHMuY29uZmlnLCBwcm9wcy5jb25maWcpO1xufVxuZnVuY3Rpb24gb21pdChvYmplY3QsIC4uLmFycmF5cykge1xuICBjb25zdCBvbWl0S2V5cyA9IFtdLmNvbmNhdCguLi5hcnJheXMpO1xuICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAob21pdEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgb3V0cHV0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIGNhbGxQbGF5ZXIobWV0aG9kLCAuLi5hcmdzKSB7XG4gIGlmICghdGhpcy5wbGF5ZXIgfHwgIXRoaXMucGxheWVyW21ldGhvZF0pIHtcbiAgICBsZXQgbWVzc2FnZSA9IGBSZWFjdFBsYXllcjogJHt0aGlzLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lfSBwbGF5ZXIgY291bGQgbm90IGNhbGwgJWMke21ldGhvZH0lYyBcXHUyMDEzIGA7XG4gICAgaWYgKCF0aGlzLnBsYXllcikge1xuICAgICAgbWVzc2FnZSArPSBcIlRoZSBwbGF5ZXIgd2FzIG5vdCBhdmFpbGFibGVcIjtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnBsYXllclttZXRob2RdKSB7XG4gICAgICBtZXNzYWdlICs9IFwiVGhlIG1ldGhvZCB3YXMgbm90IGF2YWlsYWJsZVwiO1xuICAgIH1cbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSwgXCJmb250LXdlaWdodDogYm9sZFwiLCBcIlwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdGhpcy5wbGF5ZXJbbWV0aG9kXSguLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIGlzTWVkaWFTdHJlYW0odXJsKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuTWVkaWFTdHJlYW0gIT09IFwidW5kZWZpbmVkXCIgJiYgdXJsIGluc3RhbmNlb2Ygd2luZG93Lk1lZGlhU3RyZWFtO1xufVxuZnVuY3Rpb24gaXNCbG9iVXJsKHVybCkge1xuICByZXR1cm4gL15ibG9iOi8udGVzdCh1cmwpO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNXZWJLaXRQcmVzZW50YXRpb25Nb2RlKHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpKSB7XG4gIGNvbnN0IG5vdE1vYmlsZSA9IC9pUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSA9PT0gZmFsc2U7XG4gIHJldHVybiB2aWRlby53ZWJraXRTdXBwb3J0c1ByZXNlbnRhdGlvbk1vZGUgJiYgdHlwZW9mIHZpZGVvLndlYmtpdFNldFByZXNlbnRhdGlvbk1vZGUgPT09IFwiZnVuY3Rpb25cIiAmJiBub3RNb2JpbGU7XG59XG5mdW5jdGlvbiBlbmFibGVTdHViT24oZm4pIHtcbiAgaWYgKGZhbHNlKSB7XG4gICAgY29uc3Qgd3JhcCA9ICguLi5hcmdzKSA9PiB3cmFwLnN0dWIoLi4uYXJncyk7XG4gICAgd3JhcC5zdHViID0gZm47XG4gICAgcmV0dXJuIHdyYXA7XG4gIH1cbiAgcmV0dXJuIGZuO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-player/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/chat/page.tsx":
/*!*******************************!*\
  !*** ./src/app/chat/page.tsx ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ChatPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _hooks_useNostr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/hooks/useNostr */ \"(app-pages-browser)/./src/hooks/useNostr.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _page__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../page */ \"(app-pages-browser)/./src/app/page.tsx\");\n/* harmony import */ var _components_shared_ErrorMessage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/shared/ErrorMessage */ \"(app-pages-browser)/./src/components/shared/ErrorMessage.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction ChatPage() {\n    _s();\n    const { pubkey, events, error, login, post } = (0,_hooks_useNostr__WEBPACK_IMPORTED_MODULE_1__.useNostr)();\n    const [content, setContent] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [isSending, setIsSending] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [sendError, setSendError] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const chatEndRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const LOCAL_KEY = \"nostr_global_chat_local\";\n    // Only show kind 1 events (global chat posts)\n    const relayChatEvents = events.filter((ev)=>ev.kind === 1);\n    const [localChatEvents, setLocalChatEvents] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    // On mount, load local chat events\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"ChatPage.useEffect\": ()=>{\n            try {\n                const raw = localStorage.getItem(LOCAL_KEY);\n                if (raw) {\n                    setLocalChatEvents(JSON.parse(raw));\n                }\n            } catch (e) {}\n        }\n    }[\"ChatPage.useEffect\"], []);\n    // Merge relay and local events, deduplicate by id\n    const chatEvents = [\n        ...relayChatEvents,\n        ...localChatEvents.filter((ev)=>!relayChatEvents.some((e)=>e.id === ev.id))\n    ].sort((a, b)=>a.created_at - b.created_at);\n    // Scroll to bottom on new message\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"ChatPage.useEffect\": ()=>{\n            var _chatEndRef_current;\n            (_chatEndRef_current = chatEndRef.current) === null || _chatEndRef_current === void 0 ? void 0 : _chatEndRef_current.scrollIntoView({\n                behavior: \"smooth\"\n            });\n        }\n    }[\"ChatPage.useEffect\"], [\n        chatEvents.length\n    ]);\n    const handleSend = async (e)=>{\n        e.preventDefault();\n        if (!content.trim()) return;\n        setIsSending(true);\n        setSendError(null);\n        try {\n            const before = Date.now();\n            await post(content);\n            setContent(\"\");\n            // Save to localStorage for persistence\n            const newEvent = {\n                id: \"local-\".concat(before),\n                pubkey,\n                content,\n                created_at: Math.floor(before / 1000),\n                kind: 1,\n                tags: [],\n                profile: undefined\n            };\n            setLocalChatEvents((prev)=>{\n                const updated = [\n                    ...prev,\n                    newEvent\n                ];\n                localStorage.setItem(LOCAL_KEY, JSON.stringify(updated));\n                return updated;\n            });\n        } catch (err) {\n            setSendError(\"Failed to send message\");\n        } finally{\n            setIsSending(false);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full h-full max-w-2xl px-2 sm:px-6 py-8 bg-gray-950 border border-gray-800 shadow-xl rounded-xl flex flex-col flex-shrink-0\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                className: \"flex items-center gap-2 mb-4\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-xl font-bold text-white\",\n                        children: \"# global-chat\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                        lineNumber: 74,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"ml-auto text-xs text-gray-400\",\n                        children: \"Nostr Global Chat\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                        lineNumber: 75,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                lineNumber: 73,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex-1 overflow-y-auto space-y-4\",\n                children: [\n                    error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_shared_ErrorMessage__WEBPACK_IMPORTED_MODULE_4__.ErrorMessage, {\n                        message: error\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                        lineNumber: 79,\n                        columnNumber: 27\n                    }, this),\n                    chatEvents.length === 0 && !error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-center text-gray-400\",\n                        children: \"No messages yet. Start the conversation!\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                        lineNumber: 81,\n                        columnNumber: 21\n                    }, this),\n                    chatEvents.map((ev)=>{\n                        var _ev_profile, _ev_profile1;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex items-start gap-3 group hover:bg-gray-900/60 rounded-lg px-2 py-1 transition\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                    src: ((_ev_profile = ev.profile) === null || _ev_profile === void 0 ? void 0 : _ev_profile.picture) || \"/file.svg\",\n                                    alt: \"avatar\",\n                                    className: \"w-10 h-10 rounded-full border border-gray-800 bg-black\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                                    lineNumber: 85,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex-1 min-w-0\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"flex items-center gap-2\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"font-semibold text-white text-sm truncate\",\n                                                    children: ((_ev_profile1 = ev.profile) === null || _ev_profile1 === void 0 ? void 0 : _ev_profile1.display_name) || ev.pubkey.slice(0, 8)\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                                                    lineNumber: 92,\n                                                    columnNumber: 33\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"text-xs text-gray-500\",\n                                                    children: new Date(ev.created_at * 1000).toLocaleTimeString()\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                                                    lineNumber: 95,\n                                                    columnNumber: 33\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                                            lineNumber: 91,\n                                            columnNumber: 29\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"text-gray-200 text-base whitespace-pre-line break-words\",\n                                            children: (0,_page__WEBPACK_IMPORTED_MODULE_3__.formatNostrAddresses)(ev.content)\n                                        }, void 0, false, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                                            lineNumber: 97,\n                                            columnNumber: 29\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                                    lineNumber: 90,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, ev.id, true, {\n                            fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                            lineNumber: 84,\n                            columnNumber: 21\n                        }, this);\n                    }),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        ref: chatEndRef\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                        lineNumber: 103,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                lineNumber: 78,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                onSubmit: handleSend,\n                className: \"flex items-center gap-3 mt-4\",\n                children: !pubkey ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    type: \"button\",\n                    onClick: login,\n                    className: \"px-4 py-2 rounded-full bg-blue-500 text-white font-semibold hover:bg-blue-600 transition\",\n                    children: \"Login with NOSTR\"\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                    lineNumber: 108,\n                    columnNumber: 21\n                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"text\",\n                            value: content,\n                            onChange: (e)=>setContent(e.target.value),\n                            placeholder: \"Type your message...\",\n                            className: \"flex-1 px-4 py-2 rounded-full bg-gray-900 border border-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-blue-500/30 focus:border-blue-500/30 placeholder-gray-400\",\n                            disabled: isSending,\n                            maxLength: 500,\n                            autoFocus: true\n                        }, void 0, false, {\n                            fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                            lineNumber: 117,\n                            columnNumber: 25\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            type: \"submit\",\n                            className: \"px-4 py-2 rounded-full bg-blue-500 text-white font-semibold hover:bg-blue-600 transition disabled:opacity-50\",\n                            disabled: isSending || !content.trim(),\n                            children: \"Send\"\n                        }, void 0, false, {\n                            fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                            lineNumber: 127,\n                            columnNumber: 25\n                        }, this)\n                    ]\n                }, void 0, true)\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                lineNumber: 106,\n                columnNumber: 13\n            }, this),\n            sendError && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-red-500 text-center py-2\",\n                children: sendError\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n                lineNumber: 137,\n                columnNumber: 27\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/app/chat/page.tsx\",\n        lineNumber: 71,\n        columnNumber: 9\n    }, this);\n}\n_s(ChatPage, \"aVObNjeThUeIpMyMluZxtWYajzk=\", false, function() {\n    return [\n        _hooks_useNostr__WEBPACK_IMPORTED_MODULE_1__.useNostr\n    ];\n});\n_c = ChatPage;\nvar _c;\n$RefreshReg$(_c, \"ChatPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY2hhdC9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFNEM7QUFDUTtBQUNMO0FBQ2lCO0FBRWpELFNBQVNNOztJQUNwQixNQUFNLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFLEdBQUdYLHlEQUFRQTtJQUN2RCxNQUFNLENBQUNZLFNBQVNDLFdBQVcsR0FBR1YsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDVyxXQUFXQyxhQUFhLEdBQUdaLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ2EsV0FBV0MsYUFBYSxHQUFHZCwrQ0FBUUEsQ0FBZ0I7SUFDMUQsTUFBTWUsYUFBYWhCLDZDQUFNQSxDQUFpQjtJQUMxQyxNQUFNaUIsWUFBWTtJQUVsQiw4Q0FBOEM7SUFDOUMsTUFBTUMsa0JBQWtCWixPQUFPYSxNQUFNLENBQUNDLENBQUFBLEtBQU0sR0FBWUMsSUFBSSxLQUFLO0lBQ2pFLE1BQU0sQ0FBQ0MsaUJBQWlCQyxtQkFBbUIsR0FBR3RCLCtDQUFRQSxDQUFRLEVBQUU7SUFFaEUsbUNBQW1DO0lBQ25DRixnREFBU0E7OEJBQUM7WUFDTixJQUFJO2dCQUNBLE1BQU15QixNQUFNQyxhQUFhQyxPQUFPLENBQUNUO2dCQUNqQyxJQUFJTyxLQUFLO29CQUNMRCxtQkFBbUJJLEtBQUtDLEtBQUssQ0FBQ0o7Z0JBQ2xDO1lBQ0osRUFBRSxVQUFNLENBQUM7UUFDYjs2QkFBRyxFQUFFO0lBRUwsa0RBQWtEO0lBQ2xELE1BQU1LLGFBQWE7V0FBSVg7V0FBb0JJLGdCQUFnQkgsTUFBTSxDQUFDQyxDQUFBQSxLQUFNLENBQUNGLGdCQUFnQlksSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxFQUFFLEtBQUtaLEdBQUdZLEVBQUU7S0FBRyxDQUMvR0MsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUVFLFVBQVUsR0FBR0QsRUFB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QUNadEIsV0FBVTs0QkFDVnVCLFVBQVV0RTs0QkFDVnVFLFdBQVc7NEJBQ1hDLFNBQVM7Ozs7OztzQ0FFYiw4REFBQ1Y7NEJBQ0dDLE1BQUs7NEJBQ0xoQixXQUFVOzRCQUNWdUIsVUFBVXRFLGFBQWEsQ0FBQ0YsUUFBUWlDLElBQUk7c0NBQ3ZDOzs7Ozs7Ozs7Ozs7O1lBTVo3QiwyQkFBYSw4REFBQzRDO2dCQUFJQyxXQUFVOzBCQUFpQzdDOzs7Ozs7Ozs7Ozs7QUFHMUU7R0FwSXdCVjs7UUFDMkJOLHFEQUFRQTs7O0tBRG5DTSIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL3NyYy9hcHAvY2hhdC9wYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlTm9zdHIgfSBmcm9tIFwiQC9ob29rcy91c2VOb3N0clwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBmb3JtYXROb3N0ckFkZHJlc3NlcyB9IGZyb20gXCIuLi9wYWdlXCI7XG5pbXBvcnQgeyBFcnJvck1lc3NhZ2UgfSBmcm9tIFwiQC9jb21wb25lbnRzL3NoYXJlZC9FcnJvck1lc3NhZ2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2hhdFBhZ2UoKSB7XG4gICAgY29uc3QgeyBwdWJrZXksIGV2ZW50cywgZXJyb3IsIGxvZ2luLCBwb3N0IH0gPSB1c2VOb3N0cigpO1xuICAgIGNvbnN0IFtjb250ZW50LCBzZXRDb250ZW50XSA9IHVzZVN0YXRlKFwiXCIpO1xuICAgIGNvbnN0IFtpc1NlbmRpbmcsIHNldElzU2VuZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3NlbmRFcnJvciwgc2V0U2VuZEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IGNoYXRFbmRSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICAgIGNvbnN0IExPQ0FMX0tFWSA9IFwibm9zdHJfZ2xvYmFsX2NoYXRfbG9jYWxcIjtcblxuICAgIC8vIE9ubHkgc2hvdyBraW5kIDEgZXZlbnRzIChnbG9iYWwgY2hhdCBwb3N0cylcbiAgICBjb25zdCByZWxheUNoYXRFdmVudHMgPSBldmVudHMuZmlsdGVyKGV2ID0+IChldiBhcyBhbnkpLmtpbmQgPT09IDEpO1xuICAgIGNvbnN0IFtsb2NhbENoYXRFdmVudHMsIHNldExvY2FsQ2hhdEV2ZW50c10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pO1xuXG4gICAgLy8gT24gbW91bnQsIGxvYWQgbG9jYWwgY2hhdCBldmVudHNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmF3ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oTE9DQUxfS0VZKTtcbiAgICAgICAgICAgIGlmIChyYXcpIHtcbiAgICAgICAgICAgICAgICBzZXRMb2NhbENoYXRFdmVudHMoSlNPTi5wYXJzZShyYXcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7fVxuICAgIH0sIFtdKTtcblxuICAgIC8vIE1lcmdlIHJlbGF5IGFuZCBsb2NhbCBldmVudHMsIGRlZHVwbGljYXRlIGJ5IGlkXG4gICAgY29uc3QgY2hhdEV2ZW50cyA9IFsuLi5yZWxheUNoYXRFdmVudHMsIC4uLmxvY2FsQ2hhdEV2ZW50cy5maWx0ZXIoZXYgPT4gIXJlbGF5Q2hhdEV2ZW50cy5zb21lKGUgPT4gZS5pZCA9PT0gZXYuaWQpKV1cbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuY3JlYXRlZF9hdCAtIGIuY3JlYXRlZF9hdCk7XG5cbiAgICAvLyBTY3JvbGwgdG8gYm90dG9tIG9uIG5ldyBtZXNzYWdlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY2hhdEVuZFJlZi5jdXJyZW50Py5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW9yOiBcInNtb290aFwiIH0pO1xuICAgIH0sIFtjaGF0RXZlbnRzLmxlbmd0aF0pO1xuXG4gICAgY29uc3QgaGFuZGxlU2VuZCA9IGFzeW5jIChlOiBSZWFjdC5Gb3JtRXZlbnQpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoIWNvbnRlbnQudHJpbSgpKSByZXR1cm47XG4gICAgICAgIHNldElzU2VuZGluZyh0cnVlKTtcbiAgICAgICAgc2V0U2VuZEVycm9yKG51bGwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGF3YWl0IHBvc3QoY29udGVudCk7XG4gICAgICAgICAgICBzZXRDb250ZW50KFwiXCIpO1xuICAgICAgICAgICAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2UgZm9yIHBlcnNpc3RlbmNlXG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudCA9IHtcbiAgICAgICAgICAgICAgICBpZDogYGxvY2FsLSR7YmVmb3JlfWAsXG4gICAgICAgICAgICAgICAgcHVia2V5LFxuICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihiZWZvcmUgLyAxMDAwKSxcbiAgICAgICAgICAgICAgICBraW5kOiAxLFxuICAgICAgICAgICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICAgICAgICAgIHByb2ZpbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZXRMb2NhbENoYXRFdmVudHMocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZCA9IFsuLi5wcmV2LCBuZXdFdmVudF07XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oTE9DQUxfS0VZLCBKU09OLnN0cmluZ2lmeSh1cGRhdGVkKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIHNldFNlbmRFcnJvcihcIkZhaWxlZCB0byBzZW5kIG1lc3NhZ2VcIik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc1NlbmRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCBtYXgtdy0yeGwgcHgtMiBzbTpweC02IHB5LTggYmctZ3JheS05NTAgYm9yZGVyIGJvcmRlci1ncmF5LTgwMCBzaGFkb3cteGwgcm91bmRlZC14bCBmbGV4IGZsZXgtY29sIGZsZXgtc2hyaW5rLTBcIj5cbiAgICAgICAgICAgIHsvKiBIZWFkZXIgKi99XG4gICAgICAgICAgICA8aGVhZGVyIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0yIG1iLTRcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtYm9sZCB0ZXh0LXdoaXRlXCI+IyBnbG9iYWwtY2hhdDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJtbC1hdXRvIHRleHQteHMgdGV4dC1ncmF5LTQwMFwiPk5vc3RyIEdsb2JhbCBDaGF0PC9zcGFuPlxuICAgICAgICAgICAgPC9oZWFkZXI+XG4gICAgICAgICAgICB7LyogQ2hhdCBtZXNzYWdlcyAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC0xIG92ZXJmbG93LXktYXV0byBzcGFjZS15LTRcIj5cbiAgICAgICAgICAgICAgICB7ZXJyb3IgJiYgPEVycm9yTWVzc2FnZSBtZXNzYWdlPXtlcnJvcn0gLz59XG4gICAgICAgICAgICAgICAge2NoYXRFdmVudHMubGVuZ3RoID09PSAwICYmICFlcnJvciAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgdGV4dC1ncmF5LTQwMFwiPk5vIG1lc3NhZ2VzIHlldC4gU3RhcnQgdGhlIGNvbnZlcnNhdGlvbiE8L2Rpdj5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIHtjaGF0RXZlbnRzLm1hcChldiA9PiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtldi5pZH0gY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1zdGFydCBnYXAtMyBncm91cCBob3ZlcjpiZy1ncmF5LTkwMC82MCByb3VuZGVkLWxnIHB4LTIgcHktMSB0cmFuc2l0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjPXtldi5wcm9maWxlPy5waWN0dXJlIHx8IFwiL2ZpbGUuc3ZnXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0PVwiYXZhdGFyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTEwIGgtMTAgcm91bmRlZC1mdWxsIGJvcmRlciBib3JkZXItZ3JheS04MDAgYmctYmxhY2tcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC0xIG1pbi13LTBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGQgdGV4dC13aGl0ZSB0ZXh0LXNtIHRydW5jYXRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZXYucHJvZmlsZT8uZGlzcGxheV9uYW1lIHx8IGV2LnB1YmtleS5zbGljZSgwLCA4KX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS01MDBcIj57bmV3IERhdGUoZXYuY3JlYXRlZF9hdCAqIDEwMDApLnRvTG9jYWxlVGltZVN0cmluZygpfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtZ3JheS0yMDAgdGV4dC1iYXNlIHdoaXRlc3BhY2UtcHJlLWxpbmUgYnJlYWstd29yZHNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2Zvcm1hdE5vc3RyQWRkcmVzc2VzKGV2LmNvbnRlbnQpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgIDxkaXYgcmVmPXtjaGF0RW5kUmVmfSAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7LyogTWVzc2FnZSBpbnB1dCAqL31cbiAgICAgICAgICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTZW5kfSBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMyBtdC00XCI+XG4gICAgICAgICAgICAgICAgeyFwdWJrZXkgPyAoXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17bG9naW59XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgcm91bmRlZC1mdWxsIGJnLWJsdWUtNTAwIHRleHQtd2hpdGUgZm9udC1zZW1pYm9sZCBob3ZlcjpiZy1ibHVlLTYwMCB0cmFuc2l0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgTG9naW4gd2l0aCBOT1NUUlxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtjb250ZW50fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHNldENvbnRlbnQoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVHlwZSB5b3VyIG1lc3NhZ2UuLi5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXgtMSBweC00IHB5LTIgcm91bmRlZC1mdWxsIGJnLWdyYXktOTAwIGJvcmRlciBib3JkZXItZ3JheS03MDAgdGV4dC13aGl0ZSBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctYmx1ZS01MDAvMzAgZm9jdXM6Ym9yZGVyLWJsdWUtNTAwLzMwIHBsYWNlaG9sZGVyLWdyYXktNDAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17aXNTZW5kaW5nfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heExlbmd0aD17NTAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9Gb2N1c1xuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwic3VibWl0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgcm91bmRlZC1mdWxsIGJnLWJsdWUtNTAwIHRleHQtd2hpdGUgZm9udC1zZW1pYm9sZCBob3ZlcjpiZy1ibHVlLTYwMCB0cmFuc2l0aW9uIGRpc2FibGVkOm9wYWNpdHktNTBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2FibGVkPXtpc1NlbmRpbmcgfHwgIWNvbnRlbnQudHJpbSgpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9mb3JtPlxuICAgICAgICAgICAge3NlbmRFcnJvciAmJiA8ZGl2IGNsYXNzTmFtZT1cInRleHQtcmVkLTUwMCB0ZXh0LWNlbnRlciBweS0yXCI+e3NlbmRFcnJvcn08L2Rpdj59XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59XG4iXSwibmFtZXMiOlsidXNlTm9zdHIiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImZvcm1hdE5vc3RyQWRkcmVzc2VzIiwiRXJyb3JNZXNzYWdlIiwiQ2hhdFBhZ2UiLCJwdWJrZXkiLCJldmVudHMiLCJlcnJvciIsImxvZ2luIiwicG9zdCIsImNvbnRlbnQiLCJzZXRDb250ZW50IiwiaXNTZW5kaW5nIiwic2V0SXNTZW5kaW5nIiwic2VuZEVycm9yIiwic2V0U2VuZEVycm9yIiwiY2hhdEVuZFJlZiIsIkxPQ0FMX0tFWSIsInJlbGF5Q2hhdEV2ZW50cyIsImZpbHRlciIsImV2Iiwia2luZCIsImxvY2FsQ2hhdEV2ZW50cyIsInNldExvY2FsQ2hhdEV2ZW50cyIsInJhdyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJjaGF0RXZlbnRzIiwic29tZSIsImUiLCJpZCIsInNvcnQiLCJhIiwiYiIsImNyZWF0ZWRfYXQiLCJjdXJyZW50Iiwic2Nyb2xsSW50b1ZpZXciLCJiZWhhdmlvciIsImxlbmd0aCIsImhhbmRsZVNlbmQiLCJwcmV2ZW50RGVmYXVsdCIsInRyaW0iLCJiZWZvcmUiLCJEYXRlIiwibm93IiwibmV3RXZlbnQiLCJNYXRoIiwiZmxvb3IiLCJ0YWdzIiwicHJvZmlsZSIsInVuZGVmaW5lZCIsInByZXYiLCJ1cGRhdGVkIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImVyciIsImRpdiIsImNsYXNzTmFtZSIsImhlYWRlciIsInNwYW4iLCJtZXNzYWdlIiwibWFwIiwiaW1nIiwic3JjIiwicGljdHVyZSIsImFsdCIsImRpc3BsYXlfbmFtZSIsInNsaWNlIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwicmVmIiwiZm9ybSIsIm9uU3VibWl0IiwiYnV0dG9uIiwidHlwZSIsIm9uQ2xpY2siLCJpbnB1dCIsInZhbHVlIiwib25DaGFuZ2UiLCJ0YXJnZXQiLCJwbGFjZWhvbGRlciIsImRpc2FibGVkIiwibWF4TGVuZ3RoIiwiYXV0b0ZvY3VzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/chat/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/explore/page.tsx":
/*!**********************************!*\
  !*** ./src/app/explore/page.tsx ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ExplorePage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_ui_tabs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/ui/tabs */ \"(app-pages-browser)/./src/components/ui/tabs.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nconst FEEDS = [\n    {\n        title: \"Technology Reads\",\n        desc: \"Technology-related long form notes\",\n        stats: {\n            likes: 76\n        },\n        free: true\n    },\n    {\n        title: \"Food Reads\",\n        desc: \"Food-related long form notes\",\n        stats: {\n            likes: 53\n        },\n        free: true\n    },\n    {\n        title: \"Latest from Free-Floating Intelligence\",\n        desc: \"Latest blog posts from Free-Floating Intelligence\",\n        stats: {\n            likes: 18\n        },\n        free: true\n    },\n    {\n        title: \"Your topics (beta)\",\n        desc: \"Personalized feed based on your topics\",\n        stats: {\n            likes: 96\n        },\n        free: true\n    },\n    {\n        title: \"Gaming Reads\",\n        desc: \"Gaming-related long form notes\",\n        stats: {\n            likes: 56\n        },\n        free: true\n    },\n    {\n        title: \"Popular Pareto Articles (Alpha Version)\",\n        desc: \"Most popular posts on Pareto\",\n        stats: {\n            likes: 15\n        },\n        free: true\n    },\n    {\n        title: \"Nostr Reads\",\n        desc: \"Nostr-related long form notes\",\n        stats: {\n            likes: 65\n        },\n        free: true\n    },\n    {\n        title: \"Photography Reads\",\n        desc: \"Photography-related long form notes\",\n        stats: {\n            likes: 54\n        },\n        free: true\n    },\n    {\n        title: \"Philosophy Reads\",\n        desc: \"Philosophy-related long form notes\",\n        stats: {\n            likes: 150\n        },\n        free: true\n    },\n    {\n        title: \"Sports Reads\",\n        desc: \"Sports-related long form notes\",\n        stats: {\n            likes: 120\n        },\n        free: true\n    }\n];\nconst PEOPLE = [\n    {\n        name: \"BlekDimon (Anilist)\",\n        desc: \"My top 10 favourite anime of 2023\",\n        followers: 5,\n        likes: 146\n    },\n    {\n        name: \"craigraw\",\n        desc: \"Creator of Sparrow Wallet\",\n        followers: 39500,\n        likes: 87\n    },\n    {\n        name: \"Lyn Alden\",\n        desc: \"Founder of Lyn Alden Investment Strategy\",\n        followers: 97000,\n        likes: 52\n    },\n    {\n        name: \"HODL\",\n        desc: \"A new world is struggling to be born.\",\n        followers: 48200,\n        likes: 50\n    },\n    {\n        name: \"Gigi\",\n        desc: \"Not reading DMs. Aspiring Saunameister.\",\n        followers: 17000,\n        likes: 50\n    },\n    {\n        name: \"Erik Cason\",\n        desc: \"I like to talk about bitcoin and philosophy...\",\n        followers: 36100,\n        likes: 50\n    },\n    {\n        name: \"jack mallers\",\n        desc: \"yo\",\n        followers: 144000,\n        likes: 50\n    },\n    {\n        name: \"Max DeMarco\",\n        desc: \"Bitcoin Filmmaker\",\n        followers: 50100,\n        likes: 50\n    }\n];\nconst ZAPS = [\n    {\n        user: \"Jor\",\n        amount: 21000,\n        time: \"15 hr.\",\n        text: \"You're not buying Bitcoin. Or sats. Or bits...\"\n    },\n    {\n        user: \"Heidi\",\n        amount: 21000,\n        time: \"14 hr.\",\n        text: \"hi nostr\"\n    },\n    {\n        user: \"thepurpose\",\n        amount: 11716,\n        time: \"1 hr.\",\n        text: \"Finally publishing my book...\"\n    },\n    {\n        user: \"art.\",\n        amount: 10000,\n        time: \"5 hr.\",\n        text: \"Almost 3 years ago...\"\n    },\n    {\n        user: \"Uno\",\n        amount: 10000,\n        time: \"12 hr.\",\n        text: \"-\"\n    },\n    {\n        user: \"sourcenode\",\n        amount: 10000,\n        time: \"2 hr.\",\n        text: \"here's your sign\"\n    }\n];\nconst TOPICS = [\n    {\n        tag: \"#Sports\",\n        notes: 4361\n    },\n    {\n        tag: \"#Politics\",\n        notes: 2560\n    },\n    {\n        tag: \"#Bitcoin\",\n        notes: 2033\n    },\n    {\n        tag: \"#Business\",\n        notes: 1314\n    },\n    {\n        tag: \"#Technology\",\n        notes: 1226\n    },\n    {\n        tag: \"#News\",\n        notes: 1074\n    },\n    {\n        tag: \"#World\",\n        notes: 1012\n    },\n    {\n        tag: \"#Donaldtrump\",\n        notes: 957\n    },\n    {\n        tag: \"#Unitedstates\",\n        notes: 675\n    },\n    {\n        tag: \"#Israel\",\n        notes: 565\n    }\n];\nfunction ExplorePage() {\n    _s();\n    const [tab, setTab] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"feeds\");\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full max-w-2xl px-2 sm:px-6 py-8\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-center gap-4 mb-6\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        className: \"flex-1 px-4 py-2 rounded bg-gray-900 border border-gray-700 text-lg focus:outline-none\",\n                        placeholder: \"Search...\",\n                        type: \"text\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                        lineNumber: 56,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-pink-500 font-semibold cursor-pointer\",\n                        children: \"Advanced Search\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                        lineNumber: 61,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                lineNumber: 55,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mb-6\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_tabs__WEBPACK_IMPORTED_MODULE_2__.Tabs, {\n                    defaultValue: tab,\n                    onValueChange: (val)=>setTab(val),\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_tabs__WEBPACK_IMPORTED_MODULE_2__.TabsList, {\n                        className: \"flex gap-2 bg-gray-900 rounded-lg p-1\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_tabs__WEBPACK_IMPORTED_MODULE_2__.TabsTrigger, {\n                                value: \"feeds\",\n                                children: \"Feeds\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                lineNumber: 66,\n                                columnNumber: 25\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_tabs__WEBPACK_IMPORTED_MODULE_2__.TabsTrigger, {\n                                value: \"people\",\n                                children: \"People\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                lineNumber: 67,\n                                columnNumber: 25\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_tabs__WEBPACK_IMPORTED_MODULE_2__.TabsTrigger, {\n                                value: \"zaps\",\n                                children: \"Zaps\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                lineNumber: 68,\n                                columnNumber: 25\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_tabs__WEBPACK_IMPORTED_MODULE_2__.TabsTrigger, {\n                                value: \"media\",\n                                children: \"Media\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                lineNumber: 69,\n                                columnNumber: 25\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_tabs__WEBPACK_IMPORTED_MODULE_2__.TabsTrigger, {\n                                value: \"topics\",\n                                children: \"Topics\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                lineNumber: 70,\n                                columnNumber: 25\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                        lineNumber: 65,\n                        columnNumber: 21\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                    lineNumber: 64,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                lineNumber: 63,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    display: tab === \"feeds\" ? undefined : \"none\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"grid grid-cols-1 md:grid-cols-2 gap-4\",\n                    children: FEEDS.map((feed)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"bg-gray-900 rounded-lg p-4 flex flex-col gap-2 border border-gray-800\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex items-center gap-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-xs bg-gray-800 px-2 py-1 rounded text-pink-400 font-bold\",\n                                            children: feed.free ? \"FREE\" : \"PREMIUM\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                            lineNumber: 80,\n                                            columnNumber: 33\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"font-semibold text-lg\",\n                                            children: feed.title\n                                        }, void 0, false, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                            lineNumber: 81,\n                                            columnNumber: 33\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                    lineNumber: 79,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"text-gray-400 text-sm\",\n                                    children: feed.desc\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                    lineNumber: 83,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex gap-4 text-gray-500 text-xs mt-2\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: [\n                                            \"❤ \",\n                                            feed.stats.likes\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                        lineNumber: 85,\n                                        columnNumber: 33\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                    lineNumber: 84,\n                                    columnNumber: 29\n                                }, this)\n                            ]\n                        }, feed.title, true, {\n                            fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                            lineNumber: 78,\n                            columnNumber: 25\n                        }, this))\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                    lineNumber: 76,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                lineNumber: 75,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    display: tab === \"people\" ? undefined : \"none\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"grid grid-cols-1 md:grid-cols-2 gap-4\",\n                    children: PEOPLE.map((person)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"bg-gray-900 rounded-lg p-4 flex flex-col gap-2 border border-gray-800\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex items-center gap-2\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"font-semibold text-lg\",\n                                        children: person.name\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                        lineNumber: 96,\n                                        columnNumber: 33\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                    lineNumber: 95,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"text-gray-400 text-sm\",\n                                    children: person.desc\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                    lineNumber: 98,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex gap-4 text-gray-500 text-xs mt-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            children: [\n                                                \"\\uD83D\\uDC65 \",\n                                                person.followers.toLocaleString(),\n                                                \" followers\"\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                            lineNumber: 100,\n                                            columnNumber: 33\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            children: [\n                                                \"❤ \",\n                                                person.likes\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                            lineNumber: 101,\n                                            columnNumber: 33\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                    lineNumber: 99,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    className: \"mt-2 px-3 py-1 rounded bg-pink-500 text-white text-sm font-semibold w-fit\",\n                                    children: \"Follow\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                    lineNumber: 103,\n                                    columnNumber: 29\n                                }, this)\n                            ]\n                        }, person.name, true, {\n                            fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                            lineNumber: 94,\n                            columnNumber: 25\n                        }, this))\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                    lineNumber: 92,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                lineNumber: 91,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    display: tab === \"zaps\" ? undefined : \"none\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex flex-col gap-3\",\n                    children: ZAPS.map((zap, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"bg-gray-900 rounded-lg p-4 flex items-center gap-4 border border-gray-800\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"text-2xl\",\n                                    children: \"⚡\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                    lineNumber: 112,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex-1\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"font-semibold\",\n                                            children: zap.user\n                                        }, void 0, false, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                            lineNumber: 114,\n                                            columnNumber: 33\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"text-gray-400 text-sm\",\n                                            children: zap.text\n                                        }, void 0, false, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                            lineNumber: 115,\n                                            columnNumber: 33\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                    lineNumber: 113,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"text-pink-400 font-bold text-lg\",\n                                    children: zap.amount.toLocaleString()\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                    lineNumber: 117,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"text-gray-500 text-xs\",\n                                    children: zap.time\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                    lineNumber: 118,\n                                    columnNumber: 29\n                                }, this)\n                            ]\n                        }, i, true, {\n                            fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                            lineNumber: 111,\n                            columnNumber: 25\n                        }, this))\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                    lineNumber: 109,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                lineNumber: 108,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    display: tab === \"media\" ? undefined : \"none\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-gray-400 text-center py-12\",\n                    children: \"Media tab coming soon...\"\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                    lineNumber: 124,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                lineNumber: 123,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    display: tab === \"topics\" ? undefined : \"none\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"grid grid-cols-1 md:grid-cols-2 gap-4\",\n                    children: TOPICS.map((topic)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"bg-gray-900 rounded-lg p-4 flex items-center justify-between border border-gray-800\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"font-semibold\",\n                                    children: topic.tag\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                    lineNumber: 130,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"text-gray-400 text-sm\",\n                                    children: [\n                                        topic.notes.toLocaleString(),\n                                        \" notes\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                                    lineNumber: 131,\n                                    columnNumber: 29\n                                }, this)\n                            ]\n                        }, topic.tag, true, {\n                            fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                            lineNumber: 129,\n                            columnNumber: 25\n                        }, this))\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                    lineNumber: 127,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n                lineNumber: 126,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/app/explore/page.tsx\",\n        lineNumber: 54,\n        columnNumber: 9\n    }, this);\n}\n_s(ExplorePage, \"iQ6VqfjJculb4zE7uX6jXbTwwdY=\");\n_c = ExplorePage;\nvar _c;\n$RefreshReg$(_c, \"ExplorePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZXhwbG9yZS9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ2lDO0FBQ3NDO0FBRXZFLE1BQU1JLFFBQVE7SUFDVjtRQUFFQyxPQUFPO1FBQW9CQyxNQUFNO1FBQXNDQyxPQUFPO1lBQUVDLE9BQU87UUFBRztRQUFHQyxNQUFNO0lBQUs7SUFDMUc7UUFBRUosT0FBTztRQUFjQyxNQUFNO1FBQWdDQyxPQUFPO1lBQUVDLE9BQU87UUFBRztRQUFHQyxNQUFNO0lBQUs7SUFDOUY7UUFBRUosT0FBTztRQUEwQ0MsTUFBTTtRQUFxREMsT0FBTztZQUFFQyxPQUFPO1FBQUc7UUFBR0MsTUFBTTtJQUFLO0lBQy9JO1FBQUVKLE9BQU87UUFBc0JDLE1BQU07UUFBMENDLE9BQU87WUFBRUMsT0FBTztRQUFHO1FBQUdDLE1BQU07SUFBSztJQUNoSDtRQUFFSixPQUFPO1FBQWdCQyxNQUFNO1FBQWtDQyxPQUFPO1lBQUVDLE9BQU87UUFBRztRQUFHQyxNQUFNO0lBQUs7SUFDbEc7UUFBRUosT0FBTztRQUEyQ0MsTUFBTTtRQUFnQ0MsT0FBTztZQUFFQyxPQUFPO1FBQUc7UUFBR0MsTUFBTTtJQUFLO0lBQzNIO1FBQUVKLE9BQU87UUFBZUMsTUFBTTtRQUFpQ0MsT0FBTztZQUFFQyxPQUFPO1FBQUc7UUFBR0MsTUFBTTtJQUFLO0lBQ2hHO1FBQUVKLE9BQU87UUFBcUJDLE1BQU07UUFBdUNDLE9BQU87WUFBRUMsT0FBTztRQUFHO1FBQUdDLE1BQU07SUFBSztJQUM1RztRQUFFSixPQUFPO1FBQW9CQyxNQUFNO1FBQXNDQyxPQUFPO1lBQUVDLE9BQU87UUFBSTtRQUFHQyxNQUFNO0lBQUs7SUFDM0c7UUFBRUosT0FBTztRQUFnQkMsTUFBTTtRQUFrQ0MsT0FBTztZQUFFQyxPQUFPO1FBQUk7UUFBR0MsTUFBTTtJQUFLO0NBQ3RHO0FBRUQsTUFBTUMsU0FBUztJQUNYO1FBQUVDLE1BQU07UUFBdUJMLE1BQU07UUFB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cy9zY2FybmVzL3dvcmtzcGFjZS9zcmMvYXBwL2V4cGxvcmUvcGFnZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgVGFicywgVGFic0xpc3QsIFRhYnNUcmlnZ2VyIH0gZnJvbSBcIi4uLy4uL2NvbXBvbmVudHMvdWkvdGFic1wiO1xuXG5jb25zdCBGRUVEUyA9IFtcbiAgICB7IHRpdGxlOiBcIlRlY2hub2xvZ3kgUmVhZHNcIiwgZGVzYzogXCJUZWNobm9sb2d5LXJlbGF0ZWQgbG9uZyBmb3JtIG5vdGVzXCIsIHN0YXRzOiB7IGxpa2VzOiA3NiB9LCBmcmVlOiB0cnVlIH0sXG4gICAgeyB0aXRsZTogXCJGb29kIFJlYWRzXCIsIGRlc2M6IFwiRm9vZC1yZWxhdGVkIGxvbmcgZm9ybSBub3Rlc1wiLCBzdGF0czogeyBsaWtlczogNTMgfSwgZnJlZTogdHJ1ZSB9LFxuICAgIHsgdGl0bGU6IFwiTGF0ZXN0IGZyb20gRnJlZS1GbG9hdGluZyBJbnRlbGxpZ2VuY2VcIiwgZGVzYzogXCJMYXRlc3QgYmxvZyBwb3N0cyBmcm9tIEZyZWUtRmxvYXRpbmcgSW50ZWxsaWdlbmNlXCIsIHN0YXRzOiB7IGxpa2VzOiAxOCB9LCBmcmVlOiB0cnVlIH0sXG4gICAgeyB0aXRsZTogXCJZb3VyIHRvcGljcyAoYmV0YSlcIiwgZGVzYzogXCJQZXJzb25hbGl6ZWQgZmVlZCBiYXNlZCBvbiB5b3VyIHRvcGljc1wiLCBzdGF0czogeyBsaWtlczogOTYgfSwgZnJlZTogdHJ1ZSB9LFxuICAgIHsgdGl0bGU6IFwiR2FtaW5nIFJlYWRzXCIsIGRlc2M6IFwiR2FtaW5nLXJlbGF0ZWQgbG9uZyBmb3JtIG5vdGVzXCIsIHN0YXRzOiB7IGxpa2VzOiA1NiB9LCBmcmVlOiB0cnVlIH0sXG4gICAgeyB0aXRsZTogXCJQb3B1bGFyIFBhcmV0byBBcnRpY2xlcyAoQWxwaGEgVmVyc2lvbilcIiwgZGVzYzogXCJNb3N0IHBvcHVsYXIgcG9zdHMgb24gUGFyZXRvXCIsIHN0YXRzOiB7IGxpa2VzOiAxNSB9LCBmcmVlOiB0cnVlIH0sXG4gICAgeyB0aXRsZTogXCJOb3N0ciBSZWFkc1wiLCBkZXNjOiBcIk5vc3RyLXJlbGF0ZWQgbG9uZyBmb3JtIG5vdGVzXCIsIHN0YXRzOiB7IGxpa2VzOiA2NSB9LCBmcmVlOiB0cnVlIH0sXG4gICAgeyB0aXRsZTogXCJQaG90b2dyYXBoeSBSZWFkc1wiLCBkZXNjOiBcIlBob3RvZ3JhcGh5LXJlbGF0ZWQgbG9uZyBmb3JtIG5vdGVzXCIsIHN0YXRzOiB7IGxpa2VzOiA1NCB9LCBmcmVlOiB0cnVlIH0sXG4gICAgeyB0aXRsZTogXCJQaGlsb3NvcGh5IFJlYWRzXCIsIGRlc2M6IFwiUGhpbG9zb3BoeS1yZWxhdGVkIGxvbmcgZm9ybSBub3Rlc1wiLCBzdGF0czogeyBsaWtlczogMTUwIH0sIGZyZWU6IHRydWUgfSxcbiAgICB7IHRpdGxlOiBcIlNwb3J0cyBSZWFkc1wiLCBkZXNjOiBcIlNwb3J0cy1yZWxhdGVkIGxvbmcgZm9ybSBub3Rlc1wiLCBzdGF0czogeyBsaWtlczogMTIwIH0sIGZyZWU6IHRydWUgfSxcbl07XG5cbmNvbnN0IFBFT1BMRSA9IFtcbiAgICB7IG5hbWU6IFwiQmxla0RpbW9uIChBbmlsaXN0KVwiLCBkZXNjOiBcIk15IHRvcCAxMCBmYXZvdXJpdGUgYW5pbWUgb2YgMjAyM1wiLCBmb2xsb3dlcnM6IDUsIGxpa2VzOiAxNDYgfSxcbiAgICB7IG5hbWU6IFwiY3JhaWdyYXdcIiwgZGVzYzogXCJDcmVhdG9yIG9mIFNwYXJyb3cgV2FsbGV0XCIsIGZvbGxvd2VyczogMzk1MDAsIGxpa2VzOiA4NyB9LFxuICAgIHsgbmFtZTogXCJMeW4gQWxkZW5cIiwgZGVzYzogXCJGb3VuZGVyIG9mIEx5biBBbGRlbiBJbnZlc3RtZW50IFN0cmF0ZWd5XCIsIGZvbGxvd2VyczogOTcwMDAsIGxpa2VzOiA1MiB9LFxuICAgIHsgbmFtZTogXCJIT0RMXCIsIGRlc2M6IFwiQSBuZXcgd29ybGQgaXMgc3RydWdnbGluZyB0byBiZSBib3JuLlwiLCBmb2xsb3dlcnM6IDQ4MjAwLCBsaWtlczogNTAgfSxcbiAgICB7IG5hbWU6IFwiR2lnaVwiLCBkZXNjOiBcIk5vdCByZWFkaW5nIERNcy4gQXNwaXJpbmcgU2F1bmFtZWlzdGVyLlwiLCBmb2xsb3dlcnM6IDE3MDAwLCBsaWtlczogNTAgfSxcbiAgICB7IG5hbWU6IFwiRXJpayBDYXNvblwiLCBkZXNjOiBcIkkgbGlrZSB0byB0YWxrIGFib3V0IGJpdGNvaW4gYW5kIHBoaWxvc29waHkuLi5cIiwgZm9sbG93ZXJzOiAzNjEwMCwgbGlrZXM6IDUwIH0sXG4gICAgeyBuYW1lOiBcImphY2sgbWFsbGVyc1wiLCBkZXNjOiBcInlvXCIsIGZvbGxvd2VyczogMTQ0MDAwLCBsaWtlczogNTAgfSxcbiAgICB7IG5hbWU6IFwiTWF4IERlTWFyY29cIiwgZGVzYzogXCJCaXRjb2luIEZpbG1tYWtlclwiLCBmb2xsb3dlcnM6IDUwMTAwLCBsaWtlczogNTAgfSxcbl07XG5cbmNvbnN0IFpBUFMgPSBbXG4gICAgeyB1c2VyOiBcIkpvclwiLCBhbW91bnQ6IDIxMDAwLCB0aW1lOiBcIjE1IGhyLlwiLCB0ZXh0OiBcIllvdSdyZSBub3QgYnV5aW5nIEJpdGNvaW4uIE9yIHNhdHMuIE9yIGJpdHMuLi5cIiB9LFxuICAgIHsgdXNlcjogXCJIZWlkaVwiLCBhbW91bnQ6IDIxMDAwLCB0aW1lOiBcIjE0IGhyLlwiLCB0ZXh0OiBcImhpIG5vc3RyXCIgfSxcbiAgICB7IHVzZXI6IFwidGhlcHVycG9zZVwiLCBhbW91bnQ6IDExNzE2LCB0aW1lOiBcIjEgaHIuXCIsIHRleHQ6IFwiRmluYWxseSBwdWJsaXNoaW5nIG15IGJvb2suLi5cIiB9LFxuICAgIHsgdXNlcjogXCJhcnQuXCIsIGFtb3VudDogMTAwMDAsIHRpbWU6IFwiNSBoci5cIiwgdGV4dDogXCJBbG1vc3QgMyB5ZWFycyBhZ28uLi5cIiB9LFxuICAgIHsgdXNlcjogXCJVbm9cIiwgYW1vdW50OiAxMDAwMCwgdGltZTogXCIxMiBoci5cIiwgdGV4dDogXCItXCIgfSxcbiAgICB7IHVzZXI6IFwic291cmNlbm9kZVwiLCBhbW91bnQ6IDEwMDAwLCB0aW1lOiBcIjIgaHIuXCIsIHRleHQ6IFwiaGVyZSdzIHlvdXIgc2lnblwiIH0sXG5dO1xuXG5jb25zdCBUT1BJQ1MgPSBbXG4gICAgeyB0YWc6IFwiI1Nwb3J0c1wiLCBub3RlczogNDM2MSB9LFxuICAgIHsgdGFnOiBcIiNQb2xpdGljc1wiLCBub3RlczogMjU2MCB9LFxuICAgIHsgdGFnOiBcIiNCaXRjb2luXCIsIG5vdGVzOiAyMDMzIH0sXG4gICAgeyB0YWc6IFwiI0J1c2luZXNzXCIsIG5vdGVzOiAxMzE0IH0sXG4gICAgeyB0YWc6IFwiI1RlY2hub2xvZ3lcIiwgbm90ZXM6IDEyMjYgfSxcbiAgICB7IHRhZzogXCIjTmV3c1wiLCBub3RlczogMTA3NCB9LFxuICAgIHsgdGFnOiBcIiNXb3JsZFwiLCBub3RlczogMTAxMiB9LFxuICAgIHsgdGFnOiBcIiNEb25hbGR0cnVtcFwiLCBub3RlczogOTU3IH0sXG4gICAgeyB0YWc6IFwiI1VuaXRlZHN0YXRlc1wiLCBub3RlczogNjc1IH0sXG4gICAgeyB0YWc6IFwiI0lzcmFlbFwiLCBub3RlczogNTY1IH0sXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFeHBsb3JlUGFnZSgpIHtcbiAgICBjb25zdCBbdGFiLCBzZXRUYWJdID0gdXNlU3RhdGUoXCJmZWVkc1wiKTtcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtYXgtdy0yeGwgcHgtMiBzbTpweC02IHB5LThcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTQgbWItNlwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmbGV4LTEgcHgtNCBweS0yIHJvdW5kZWQgYmctZ3JheS05MDAgYm9yZGVyIGJvcmRlci1ncmF5LTcwMCB0ZXh0LWxnIGZvY3VzOm91dGxpbmUtbm9uZVwiXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiU2VhcmNoLi4uXCJcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1waW5rLTUwMCBmb250LXNlbWlib2xkIGN1cnNvci1wb2ludGVyXCI+QWR2YW5jZWQgU2VhcmNoPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTZcIj5cbiAgICAgICAgICAgICAgICA8VGFicyBkZWZhdWx0VmFsdWU9e3RhYn0gb25WYWx1ZUNoYW5nZT17dmFsID0+IHNldFRhYih2YWwpfT5cbiAgICAgICAgICAgICAgICAgICAgPFRhYnNMaXN0IGNsYXNzTmFtZT1cImZsZXggZ2FwLTIgYmctZ3JheS05MDAgcm91bmRlZC1sZyBwLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWJzVHJpZ2dlciB2YWx1ZT1cImZlZWRzXCI+RmVlZHM8L1RhYnNUcmlnZ2VyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYnNUcmlnZ2VyIHZhbHVlPVwicGVvcGxlXCI+UGVvcGxlPC9UYWJzVHJpZ2dlcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWJzVHJpZ2dlciB2YWx1ZT1cInphcHNcIj5aYXBzPC9UYWJzVHJpZ2dlcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWJzVHJpZ2dlciB2YWx1ZT1cIm1lZGlhXCI+TWVkaWE8L1RhYnNUcmlnZ2VyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYnNUcmlnZ2VyIHZhbHVlPVwidG9waWNzXCI+VG9waWNzPC9UYWJzVHJpZ2dlcj5cbiAgICAgICAgICAgICAgICAgICAgPC9UYWJzTGlzdD5cbiAgICAgICAgICAgICAgICA8L1RhYnM+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHsvKiBUYWIgY29udGVudCBiZWxvdywgYWx3YXlzIHJlbmRlcmVkLCBidXQgb25seSB2aXNpYmxlIGlmIGFjdGl2ZSAqL31cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogdGFiID09PSBcImZlZWRzXCIgPyB1bmRlZmluZWQgOiBcIm5vbmVcIiB9fT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTEgbWQ6Z3JpZC1jb2xzLTIgZ2FwLTRcIj5cbiAgICAgICAgICAgICAgICAgICAge0ZFRURTLm1hcChmZWVkID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXtmZWVkLnRpdGxlfSBjbGFzc05hbWU9XCJiZy1ncmF5LTkwMCByb3VuZGVkLWxnIHAtNCBmbGV4IGZsZXgtY29sIGdhcC0yIGJvcmRlciBib3JkZXItZ3JheS04MDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQteHMgYmctZ3JheS04MDAgcHgtMiBweS0xIHJvdW5kZWQgdGV4dC1waW5rLTQwMCBmb250LWJvbGRcIj57ZmVlZC5mcmVlID8gXCJGUkVFXCIgOiBcIlBSRU1JVU1cIn08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGQgdGV4dC1sZ1wiPntmZWVkLnRpdGxlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtZ3JheS00MDAgdGV4dC1zbVwiPntmZWVkLmRlc2N9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGdhcC00IHRleHQtZ3JheS01MDAgdGV4dC14cyBtdC0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPuKdpCB7ZmVlZC5zdGF0cy5saWtlc308L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogdGFiID09PSBcInBlb3BsZVwiID8gdW5kZWZpbmVkIDogXCJub25lXCIgfX0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0xIG1kOmdyaWQtY29scy0yIGdhcC00XCI+XG4gICAgICAgICAgICAgICAgICAgIHtQRU9QTEUubWFwKHBlcnNvbiA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17cGVyc29uLm5hbWV9IGNsYXNzTmFtZT1cImJnLWdyYXktOTAwIHJvdW5kZWQtbGcgcC00IGZsZXggZmxleC1jb2wgZ2FwLTIgYm9yZGVyIGJvcmRlci1ncmF5LTgwMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZCB0ZXh0LWxnXCI+e3BlcnNvbi5uYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtZ3JheS00MDAgdGV4dC1zbVwiPntwZXJzb24uZGVzY308L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZ2FwLTQgdGV4dC1ncmF5LTUwMCB0ZXh0LXhzIG10LTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+8J+RpSB7cGVyc29uLmZvbGxvd2Vycy50b0xvY2FsZVN0cmluZygpfSBmb2xsb3dlcnM8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPuKdpCB7cGVyc29uLmxpa2VzfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cIm10LTIgcHgtMyBweS0xIHJvdW5kZWQgYmctcGluay01MDAgdGV4dC13aGl0ZSB0ZXh0LXNtIGZvbnQtc2VtaWJvbGQgdy1maXRcIj5Gb2xsb3c8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiB0YWIgPT09IFwiemFwc1wiID8gdW5kZWZpbmVkIDogXCJub25lXCIgfX0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC0zXCI+XG4gICAgICAgICAgICAgICAgICAgIHtaQVBTLm1hcCgoemFwLCBpKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17aX0gY2xhc3NOYW1lPVwiYmctZ3JheS05MDAgcm91bmRlZC1sZyBwLTQgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTQgYm9yZGVyIGJvcmRlci1ncmF5LTgwMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC0yeGxcIj7imqE8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgtMVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGRcIj57emFwLnVzZXJ9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTQwMCB0ZXh0LXNtXCI+e3phcC50ZXh0fTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1waW5rLTQwMCBmb250LWJvbGQgdGV4dC1sZ1wiPnt6YXAuYW1vdW50LnRvTG9jYWxlU3RyaW5nKCl9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNTAwIHRleHQteHNcIj57emFwLnRpbWV9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZGlzcGxheTogdGFiID09PSBcIm1lZGlhXCIgPyB1bmRlZmluZWQgOiBcIm5vbmVcIiB9fT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtZ3JheS00MDAgdGV4dC1jZW50ZXIgcHktMTJcIj5NZWRpYSB0YWIgY29taW5nIHNvb24uLi48L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBkaXNwbGF5OiB0YWIgPT09IFwidG9waWNzXCIgPyB1bmRlZmluZWQgOiBcIm5vbmVcIiB9fT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTEgbWQ6Z3JpZC1jb2xzLTIgZ2FwLTRcIj5cbiAgICAgICAgICAgICAgICAgICAge1RPUElDUy5tYXAodG9waWMgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e3RvcGljLnRhZ30gY2xhc3NOYW1lPVwiYmctZ3JheS05MDAgcm91bmRlZC1sZyBwLTQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIGJvcmRlciBib3JkZXItZ3JheS04MDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkXCI+e3RvcGljLnRhZ308L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1ncmF5LTQwMCB0ZXh0LXNtXCI+e3RvcGljLm5vdGVzLnRvTG9jYWxlU3RyaW5nKCl9IG5vdGVzPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJUYWJzIiwiVGFic0xpc3QiLCJUYWJzVHJpZ2dlciIsIkZFRURTIiwidGl0bGUiLCJkZXNjIiwic3RhdHMiLCJsaWtlcyIsImZyZWUiLCJQRU9QTEUiLCJuYW1lIiwiZm9sbG93ZXJzIiwiWkFQUyIsInVzZXIiLCJhbW91bnQiLCJ0aW1lIiwidGV4dCIsIlRPUElDUyIsInRhZyIsIm5vdGVzIiwiRXhwbG9yZVBhZ2UiLCJ0YWIiLCJzZXRUYWIiLCJkaXYiLCJjbGFzc05hbWUiLCJpbnB1dCIsInBsYWNlaG9sZGVyIiwidHlwZSIsInNwYW4iLCJkZWZhdWx0VmFsdWUiLCJvblZhbHVlQ2hhbmdlIiwidmFsIiwidmFsdWUiLCJzdHlsZSIsImRpc3BsYXkiLCJ1bmRlZmluZWQiLCJtYXAiLCJmZWVkIiwicGVyc29uIiwidG9Mb2NhbGVTdHJpbmciLCJidXR0b24iLCJ6YXAiLCJpIiwidG9waWMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/explore/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/page.tsx":
/*!**************************!*\
  !*** ./src/app/page.tsx ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home),\n/* harmony export */   formatNostrAddresses: () => (/* binding */ formatNostrAddresses)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _hooks_useNostr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/hooks/useNostr */ \"(app-pages-browser)/./src/hooks/useNostr.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _lib_utils_link_preview__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/utils/link-preview */ \"(app-pages-browser)/./src/lib/utils/link-preview.ts\");\n/* harmony import */ var _components_chat_ChatBox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/components/chat/ChatBox */ \"(app-pages-browser)/./src/components/chat/ChatBox.tsx\");\n/* harmony import */ var _components_shared_ErrorMessage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/shared/ErrorMessage */ \"(app-pages-browser)/./src/components/shared/ErrorMessage.tsx\");\n/* harmony import */ var _components_shared_MediaPlayer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/shared/MediaPlayer */ \"(app-pages-browser)/./src/components/shared/MediaPlayer.tsx\");\n/* harmony import */ var _lib_nostr_relay__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/lib/nostr/relay */ \"(app-pages-browser)/./src/lib/nostr/relay.ts\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/../node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var _app_profile_page__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/app/profile/page */ \"(app-pages-browser)/./src/app/profile/page.tsx\");\n/* harmony import */ var _app_explore_page__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/app/explore/page */ \"(app-pages-browser)/./src/app/explore/page.tsx\");\n/* harmony import */ var _app_wallet_page__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @/app/wallet/page */ \"(app-pages-browser)/./src/app/wallet/page.tsx\");\n/* harmony import */ var _app_chat_page__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @/app/chat/page */ \"(app-pages-browser)/./src/app/chat/page.tsx\");\n/* harmony import */ var _components_layout_Sidebar__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @/components/layout/Sidebar */ \"(app-pages-browser)/./src/components/layout/Sidebar.tsx\");\n/* harmony import */ var _components_layout_RightSidebar__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @/components/layout/RightSidebar */ \"(app-pages-browser)/./src/components/layout/RightSidebar.tsx\");\n/* __next_internal_client_entry_do_not_use__ formatNostrAddresses,default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction relativeTime(timestamp) {\n    const now = Date.now();\n    const diff = Math.floor((now - (timestamp * 1000 || timestamp)) / 1000);\n    if (diff < 60) return \"\".concat(diff, \"s ago\");\n    if (diff < 3600) return \"\".concat(Math.floor(diff / 60), \"m ago\");\n    if (diff < 86400) return \"\".concat(Math.floor(diff / 3600), \"h ago\");\n    return new Date(timestamp * 1000 || timestamp).toLocaleDateString();\n}\nfunction renderLinkPreview(preview) {\n    return(// Replace inline style with Tailwind for anchor\n    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n        href: preview.url,\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        className: \"block rounded-xl border border-gray-800 bg-gray-950 hover:bg-gray-900 transition shadow flex gap-4 p-4 mt-2 max-w-xl no-underline\",\n        children: [\n            preview.image && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                src: preview.image,\n                alt: preview.title || preview.url,\n                className: \"w-24 h-24 object-cover rounded-lg border border-gray-800 bg-black flex-shrink-0\"\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                lineNumber: 44,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col min-w-0\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-base font-semibold text-white truncate\",\n                        children: preview.title || preview.url\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                        lineNumber: 51,\n                        columnNumber: 9\n                    }, this),\n                    preview.siteName && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-xs text-gray-400 mb-1 truncate flex items-center gap-1\",\n                        children: [\n                            preview.favicon && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                src: preview.favicon,\n                                alt: \"favicon\",\n                                className: \"inline w-4 h-4 mr-1 align-middle rounded\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                lineNumber: 54,\n                                columnNumber: 33\n                            }, this),\n                            \" \",\n                            preview.siteName\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                        lineNumber: 53,\n                        columnNumber: 11\n                    }, this),\n                    preview.description && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-sm text-gray-300 truncate\",\n                        children: preview.description\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                        lineNumber: 58,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-xs text-blue-400 truncate mt-1\",\n                        children: preview.url\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                        lineNumber: 60,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                lineNumber: 50,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n        lineNumber: 37,\n        columnNumber: 5\n    }, this));\n}\n// Utility to format NOSTR addresses in text\nfunction formatNostrAddresses(text) {\n    // Regex for hex pubkey (64 hex chars) and npub1... bech32 NOSTR addresses\n    const nostrRegex = /(npub1[0-9a-z]{59}|[a-f0-9]{64})/gi;\n    return text.split(nostrRegex).map((part, i)=>{\n        if (part.match(nostrRegex)) {\n            return part; // No special formatting or linking\n        }\n        return part;\n    });\n}\n// Helper for advanced relay queries (like likes, reposts, hashtag search)\nasync function queryRelayEvents(filter) {\n    const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_7__.getHealthyRelays)();\n    const pool = new nostr_tools__WEBPACK_IMPORTED_MODULE_14__.SimplePool();\n    try {\n        return await pool.querySync(healthyRelays, filter);\n    } finally{\n        pool.close(healthyRelays);\n    }\n}\nfunction Home() {\n    _s();\n    var _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n    const { pubkey, events, error, login, fetchEvents, post, followUser, unfollowUser, isFollowing, relayStats } = (0,_hooks_useNostr__WEBPACK_IMPORTED_MODULE_1__.useNostr)();\n    const [content, setContent] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [linkPreviews, setLinkPreviews] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({});\n    const [activeChatPostId, setActiveChatPostId] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [closingChatId, setClosingChatId] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [chatCounts, setChatCounts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({});\n    const [isLoadingMore, setIsLoadingMore] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [hasMore, setHasMore] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(true);\n    const [retryCount, setRetryCount] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(0);\n    const [profilePaneOpen, setProfilePaneOpen] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [search, setSearch] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [searchResults, setSearchResults] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [searchFocused, setSearchFocused] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [hashtag, setHashtag] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [hashtagResults, setHashtagResults] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [filterTag, setFilterTag] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [showFilter, setShowFilter] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [showFullProfile, setShowFullProfile] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const searchTimeout = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const observerRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const lastPostRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    const globalPostCount = useGlobalNostrPostCount();\n    const [likeCounts, setLikeCounts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({});\n    const [likedPosts, setLikedPosts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({});\n    const [repostCounts, setRepostCounts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({});\n    const [repostedPosts, setRepostedPosts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({});\n    const [lightboxMedia, setLightboxMedia] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [stats, setStats] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [loadingStats, setLoadingStats] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(true);\n    const [activePane, setActivePane] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [sidePaneComponent, setSidePaneComponent] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [profilePanePubkey, setProfilePanePubkey] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    // Handle sidebar navigation\n    const handleNav = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)({\n        \"Home.useCallback[handleNav]\": (key)=>{\n            if (activePane === key) {\n                setActivePane(null);\n                setSidePaneComponent(null);\n                return;\n            }\n            setActivePane(key);\n            setSidePaneComponent(null); // Reset side pane content\n        }\n    }[\"Home.useCallback[handleNav]\"], [\n        activePane\n    ]);\n    // Search logic: filter all known profiles by displayName, username, or pubkey\n    const allProfiles = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)({\n        \"Home.useMemo[allProfiles]\": ()=>{\n            const seen = new Set();\n            return events.map({\n                \"Home.useMemo[allProfiles]\": (ev)=>ev.profile || {\n                        pubkey: ev.pubkey\n                    }\n            }[\"Home.useMemo[allProfiles]\"]).filter({\n                \"Home.useMemo[allProfiles]\": (p)=>{\n                    if (!p.pubkey || seen.has(p.pubkey)) return false;\n                    seen.add(p.pubkey);\n                    return true;\n                }\n            }[\"Home.useMemo[allProfiles]\"]);\n        }\n    }[\"Home.useMemo[allProfiles]\"], [\n        events\n    ]);\n    // Debounced search\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            if (searchTimeout.current) clearTimeout(searchTimeout.current);\n            if (!search.trim()) {\n                setSearchResults([]);\n                return;\n            }\n            searchTimeout.current = setTimeout({\n                \"Home.useEffect\": ()=>{\n                    const q = search.trim().toLowerCase();\n                    const results = allProfiles.filter({\n                        \"Home.useEffect.results\": (p)=>p.display_name && p.display_name.toLowerCase().includes(q) || p.username && p.username.toLowerCase().includes(q) || p.pubkey && p.pubkey.toLowerCase().includes(q)\n                    }[\"Home.useEffect.results\"]).slice(0, 10); // Top 10\n                    setSearchResults(results);\n                }\n            }[\"Home.useEffect\"], 150);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"Home.useEffect\"], [\n        search,\n        allProfiles\n    ]);\n    // Close dropdown on outside click\n    const searchRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            function handleClick(e) {\n                if (searchRef.current && !searchRef.current.contains(e.target)) {\n                    setSearchFocused(false);\n                }\n            }\n            if (searchFocused) document.addEventListener(\"mousedown\", handleClick);\n            return ({\n                \"Home.useEffect\": ()=>document.removeEventListener(\"mousedown\", handleClick)\n            })[\"Home.useEffect\"];\n        }\n    }[\"Home.useEffect\"], [\n        searchFocused\n    ]);\n    // Handle infinite scrolling\n    const handleObserver = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)({\n        \"Home.useCallback[handleObserver]\": (entries)=>{\n            const target = entries[0];\n            if (target.isIntersecting && !isLoadingMore && hasMore) {\n                const oldestEvent = events[events.length - 1];\n                if (oldestEvent) {\n                    setIsLoadingMore(true);\n                    fetchEvents({\n                        until: oldestEvent.created_at\n                    }).then({\n                        \"Home.useCallback[handleObserver]\": (hasNewEvents)=>{\n                            setHasMore(hasNewEvents);\n                            setIsLoadingMore(false);\n                            setRetryCount(0); // Reset retry count on successful fetch\n                        }\n                    }[\"Home.useCallback[handleObserver]\"]).catch({\n                        \"Home.useCallback[handleObserver]\": ()=>{\n                            setIsLoadingMore(false);\n                            setRetryCount({\n                                \"Home.useCallback[handleObserver]\": (prev)=>prev + 1\n                            }[\"Home.useCallback[handleObserver]\"]);\n                        }\n                    }[\"Home.useCallback[handleObserver]\"]);\n                }\n            }\n        }\n    }[\"Home.useCallback[handleObserver]\"], [\n        events,\n        fetchEvents,\n        isLoadingMore,\n        hasMore\n    ]);\n    // Setup intersection observer\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            if (lastPostRef.current && !observerRef.current) {\n                observerRef.current = new IntersectionObserver(handleObserver, {\n                    root: null,\n                    rootMargin: \"100px\",\n                    threshold: 0.1\n                });\n            }\n            if (lastPostRef.current) {\n                var _observerRef_current;\n                (_observerRef_current = observerRef.current) === null || _observerRef_current === void 0 ? void 0 : _observerRef_current.observe(lastPostRef.current);\n            }\n            return ({\n                \"Home.useEffect\": ()=>{\n                    var _observerRef_current;\n                    (_observerRef_current = observerRef.current) === null || _observerRef_current === void 0 ? void 0 : _observerRef_current.disconnect();\n                }\n            })[\"Home.useEffect\"];\n        }\n    }[\"Home.useEffect\"], [\n        handleObserver\n    ]);\n    // Handle chat closing with animation\n    const handleChatClose = (postId)=>{\n        setClosingChatId(postId);\n        setTimeout(()=>{\n            setActiveChatPostId(null);\n            setClosingChatId(null);\n        }, 300);\n    };\n    // Initial fetch\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            // 1. Fetch a small batch for fast initial render\n            fetchEvents().then({\n                \"Home.useEffect\": ()=>{\n                    // 2. In the background, fetch more posts and append\n                    setTimeout({\n                        \"Home.useEffect\": ()=>{\n                            if (events.length > 0) {\n                                const oldest = events[events.length - 1];\n                                if (oldest) {\n                                    fetchEvents({\n                                        until: oldest.created_at,\n                                        limit: 40\n                                    });\n                                }\n                            }\n                        }\n                    }[\"Home.useEffect\"], 100); // slight delay to allow first render\n                }\n            }[\"Home.useEffect\"]);\n            // Live polling every 30 seconds for new posts\n            const interval = setInterval({\n                \"Home.useEffect.interval\": ()=>{\n                    fetchEvents();\n                }\n            }[\"Home.useEffect.interval\"], 30000);\n            return ({\n                \"Home.useEffect\": ()=>clearInterval(interval)\n            })[\"Home.useEffect\"];\n        }\n    }[\"Home.useEffect\"], [\n        fetchEvents\n    ]);\n    // Fetch link previews for all unique links in events\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            const allLinks = Array.from(new Set(events.flatMap({\n                \"Home.useEffect.allLinks\": (ev)=>(ev.media || []).filter({\n                        \"Home.useEffect.allLinks\": (url)=>!url.match(/\\.(jpeg|jpg|gif|png|mp4|webm)$/i)\n                    }[\"Home.useEffect.allLinks\"])\n            }[\"Home.useEffect.allLinks\"])));\n            allLinks.forEach({\n                \"Home.useEffect\": async (url)=>{\n                    if (!linkPreviews[url]) {\n                        const preview = await (0,_lib_utils_link_preview__WEBPACK_IMPORTED_MODULE_3__.fetchLinkPreview)(url);\n                        setLinkPreviews({\n                            \"Home.useEffect\": (prev)=>({\n                                    ...prev,\n                                    [url]: preview\n                                })\n                        }[\"Home.useEffect\"]);\n                    }\n                }\n            }[\"Home.useEffect\"]);\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }\n    }[\"Home.useEffect\"], [\n        events\n    ]);\n    // Enhanced hashtag extraction\n    const extractHashtags = (event)=>{\n        // 1. From content: #hashtag, #hash_tag, #hash123, Unicode, and quoted hashtags\n        const contentTags = Array.from(new Set([\n            // Standard hashtags (letters, numbers, underscores, Unicode)\n            ...(event.content.match(RegExp(\"#([\\\\p{L}\\\\p{N}_-]{2,50})\", \"gu\")) || []).map((h)=>h.slice(1).toLowerCase()),\n            // Quoted hashtags: \"#hashtag\"\n            ...(event.content.match(RegExp('\"#([\\\\p{L}\\\\p{N}_-]{2,50})\"', \"gu\")) || []).map((h)=>h.replace(/\"/g, '').slice(1).toLowerCase()),\n            // Hashtags in URLs (e.g., https://.../#hashtag)\n            ...(event.content.match(RegExp(\"\\\\/#([\\\\p{L}\\\\p{N}_-]{2,50})\", \"gu\")) || []).map((h)=>h.replace('/#', '').toLowerCase())\n        ]));\n        // 2. From tags array: all tag types with a value that looks like a hashtag\n        const tagTags = (event.tags || []).filter((t)=>t[1] && RegExp(\"^([\\\\p{L}\\\\p{N}_-]{2,50})$\", \"u\").test(t[1])).map((t)=>t[1].toLowerCase());\n        return Array.from(new Set([\n            ...contentTags,\n            ...tagTags\n        ]));\n    };\n    // Memoized map of postId -> hashtags\n    const eventHashtagsRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)({});\n    const eventHashtags = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)({\n        \"Home.useMemo[eventHashtags]\": ()=>{\n            if (!events.length) return eventHashtagsRef.current;\n            const map = {};\n            events.forEach({\n                \"Home.useMemo[eventHashtags]\": (ev)=>{\n                    map[ev.id] = extractHashtags(ev);\n                }\n            }[\"Home.useMemo[eventHashtags]\"]);\n            eventHashtagsRef.current = map;\n            return map;\n        }\n    }[\"Home.useMemo[eventHashtags]\"], [\n        events\n    ]);\n    // Hashtag search (NIP-12)\n    const searchHashtag = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)({\n        \"Home.useCallback[searchHashtag]\": async (tag)=>{\n            setHashtag(tag);\n            setHashtagResults([]);\n            setSearch(\"\");\n            setSearchResults([]);\n            // NIP-12 filter\n            const filter = {\n                kinds: [\n                    1\n                ],\n                \"#t\": [\n                    tag.toLowerCase()\n                ],\n                limit: 50\n            };\n            const posts = await queryRelayEvents(filter);\n            setHashtagResults(posts || []);\n        }\n    }[\"Home.useCallback[searchHashtag]\"], []);\n    // Render hashtags for a post\n    function renderHashtags(ev) {\n        const tags = eventHashtags[ev.id] || [];\n        if (!tags.length) return null;\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"flex flex-wrap gap-2 mt-2\",\n            children: tags.map((tag)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    className: \"text-blue-400 hover:underline bg-blue-900/20 rounded px-2 py-0.5 text-xs font-mono\",\n                    onClick: (e)=>{\n                        e.stopPropagation();\n                        searchHashtag(tag);\n                    },\n                    children: [\n                        \"#\",\n                        tag\n                    ]\n                }, tag, true, {\n                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                    lineNumber: 316,\n                    columnNumber: 11\n                }, this))\n        }, void 0, false, {\n            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n            lineNumber: 314,\n            columnNumber: 7\n        }, this);\n    }\n    // Enhanced filter: filter posts by tag\n    const filteredEvents = (hashtagResults.length > 0 ? hashtagResults : events).filter((ev)=>{\n        if (!filterTag) return true;\n        // Check if event content or tags include the filterTag\n        const tagMatch = ev.content && ev.content.toLowerCase().includes(filterTag.toLowerCase());\n        const tagArray = (ev.tags || []).map((t)=>{\n            var _t__toLowerCase, _t_;\n            return ((_t_ = t[1]) === null || _t_ === void 0 ? void 0 : (_t__toLowerCase = _t_.toLowerCase) === null || _t__toLowerCase === void 0 ? void 0 : _t__toLowerCase.call(_t_)) || \"\";\n        });\n        return tagMatch || tagArray.includes(filterTag.toLowerCase());\n    });\n    // Trending hashtags calculation\n    const trendingHashtags = (0,react__WEBPACK_IMPORTED_MODULE_2__.useMemo)({\n        \"Home.useMemo[trendingHashtags]\": ()=>{\n            const tagCounts = {};\n            events.forEach({\n                \"Home.useMemo[trendingHashtags]\": (ev)=>{\n                    const tags = eventHashtags[ev.id] || [];\n                    tags.forEach({\n                        \"Home.useMemo[trendingHashtags]\": (tag)=>{\n                            tagCounts[tag] = (tagCounts[tag] || 0) + 1;\n                        }\n                    }[\"Home.useMemo[trendingHashtags]\"]);\n                }\n            }[\"Home.useMemo[trendingHashtags]\"]);\n            // Sort by frequency, descending\n            return Object.entries(tagCounts).sort({\n                \"Home.useMemo[trendingHashtags]\": (a, b)=>b[1] - a[1]\n            }[\"Home.useMemo[trendingHashtags]\"]).slice(0, 10);\n        }\n    }[\"Home.useMemo[trendingHashtags]\"], [\n        events,\n        eventHashtags\n    ]);\n    // Fetch like counts for visible posts\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            let isMounted = true;\n            ({\n                \"Home.useEffect\": async ()=>{\n                    const postIds = filteredEvents.map({\n                        \"Home.useEffect.postIds\": (ev)=>ev.id\n                    }[\"Home.useEffect.postIds\"]);\n                    if (postIds.length === 0) return;\n                    // Query for kind 7 (like) events referencing these posts\n                    const likeEvents = await queryRelayEvents({\n                        kinds: [\n                            7\n                        ],\n                        '#e': postIds,\n                        limit: 1000\n                    });\n                    if (!isMounted) return;\n                    // Count likes per post\n                    const counts = {};\n                    const liked = {};\n                    likeEvents === null || likeEvents === void 0 ? void 0 : likeEvents.forEach({\n                        \"Home.useEffect\": (ev)=>{\n                            const refId = (ev.tags.find({\n                                \"Home.useEffect\": (t)=>t[0] === 'e'\n                            }[\"Home.useEffect\"]) || [])[1];\n                            if (refId) {\n                                counts[refId] = (counts[refId] || 0) + 1;\n                                if (ev.pubkey === pubkey) liked[refId] = true;\n                            }\n                        }\n                    }[\"Home.useEffect\"]);\n                    setLikeCounts(counts);\n                    setLikedPosts(liked);\n                }\n            })[\"Home.useEffect\"]();\n            return ({\n                \"Home.useEffect\": ()=>{\n                    isMounted = false;\n                }\n            })[\"Home.useEffect\"];\n        }\n    }[\"Home.useEffect\"], [\n        filteredEvents,\n        pubkey\n    ]);\n    // Like a post (publish kind 7 event)\n    const handleLike = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)({\n        \"Home.useCallback[handleLike]\": async (postId, postPubkey)=>{\n            if (!pubkey || !window.nostr) return;\n            // Optimistically update UI\n            setLikeCounts({\n                \"Home.useCallback[handleLike]\": (prev)=>({\n                        ...prev,\n                        [postId]: (prev[postId] || 0) + 1\n                    })\n            }[\"Home.useCallback[handleLike]\"]);\n            setLikedPosts({\n                \"Home.useCallback[handleLike]\": (prev)=>({\n                        ...prev,\n                        [postId]: true\n                    })\n            }[\"Home.useCallback[handleLike]\"]);\n            // Build like event\n            const event = {\n                kind: 7,\n                pubkey,\n                created_at: Math.floor(Date.now() / 1000),\n                tags: [\n                    [\n                        \"e\",\n                        postId\n                    ],\n                    [\n                        \"p\",\n                        postPubkey\n                    ]\n                ],\n                content: \"+\",\n                sig: \"\"\n            };\n            // Sign and publish\n            try {\n                const signed = await window.nostr.signEvent(event);\n            // TODO: Publish signed event to relay\n            } catch (err) {\n                // Rollback optimistic update on error\n                setLikeCounts({\n                    \"Home.useCallback[handleLike]\": (prev)=>({\n                            ...prev,\n                            [postId]: Math.max((prev[postId] || 1) - 1, 0)\n                        })\n                }[\"Home.useCallback[handleLike]\"]);\n                setLikedPosts({\n                    \"Home.useCallback[handleLike]\": (prev)=>({\n                            ...prev,\n                            [postId]: false\n                        })\n                }[\"Home.useCallback[handleLike]\"]);\n            }\n        }\n    }[\"Home.useCallback[handleLike]\"], [\n        pubkey\n    ]);\n    // Fetch repost counts for visible posts\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            let isMounted = true;\n            ({\n                \"Home.useEffect\": async ()=>{\n                    const postIds = filteredEvents.map({\n                        \"Home.useEffect.postIds\": (ev)=>ev.id\n                    }[\"Home.useEffect.postIds\"]);\n                    if (postIds.length === 0) return;\n                    // Query for kind 6 (repost) events referencing these posts\n                    const repostEvents = await queryRelayEvents({\n                        kinds: [\n                            6\n                        ],\n                        '#e': postIds,\n                        limit: 1000\n                    });\n                    if (!isMounted) return;\n                    // Count reposts per post\n                    const counts = {};\n                    const reposted = {};\n                    repostEvents === null || repostEvents === void 0 ? void 0 : repostEvents.forEach({\n                        \"Home.useEffect\": (ev)=>{\n                            const refId = (ev.tags.find({\n                                \"Home.useEffect\": (t)=>t[0] === 'e'\n                            }[\"Home.useEffect\"]) || [])[1];\n                            if (refId) {\n                                counts[refId] = (counts[refId] || 0) + 1;\n                                if (ev.pubkey === pubkey) reposted[refId] = true;\n                            }\n                        }\n                    }[\"Home.useEffect\"]);\n                    setRepostCounts(counts);\n                    setRepostedPosts(reposted);\n                }\n            })[\"Home.useEffect\"]();\n            return ({\n                \"Home.useEffect\": ()=>{\n                    isMounted = false;\n                }\n            })[\"Home.useEffect\"];\n        }\n    }[\"Home.useEffect\"], [\n        filteredEvents,\n        pubkey\n    ]);\n    // Repost a post (publish kind 6 event)\n    const handleRepost = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)({\n        \"Home.useCallback[handleRepost]\": async (postId, postPubkey, postContent)=>{\n            if (!pubkey || !window.nostr) return;\n            // Optimistically update UI\n            setRepostCounts({\n                \"Home.useCallback[handleRepost]\": (prev)=>({\n                        ...prev,\n                        [postId]: (prev[postId] || 0) + 1\n                    })\n            }[\"Home.useCallback[handleRepost]\"]);\n            setRepostedPosts({\n                \"Home.useCallback[handleRepost]\": (prev)=>({\n                        ...prev,\n                        [postId]: true\n                    })\n            }[\"Home.useCallback[handleRepost]\"]);\n            // Build repost event\n            const event = {\n                kind: 6,\n                pubkey,\n                created_at: Math.floor(Date.now() / 1000),\n                tags: [\n                    [\n                        \"e\",\n                        postId\n                    ],\n                    [\n                        \"p\",\n                        postPubkey\n                    ]\n                ],\n                content: postContent,\n                sig: \"\"\n            };\n            // Sign and publish\n            try {\n                const signed = await window.nostr.signEvent(event);\n            // TODO: Publish signed event to relay\n            } catch (err) {\n                // Rollback optimistic update on error\n                setRepostCounts({\n                    \"Home.useCallback[handleRepost]\": (prev)=>({\n                            ...prev,\n                            [postId]: Math.max((prev[postId] || 1) - 1, 0)\n                        })\n                }[\"Home.useCallback[handleRepost]\"]);\n                setRepostedPosts({\n                    \"Home.useCallback[handleRepost]\": (prev)=>({\n                            ...prev,\n                            [postId]: false\n                        })\n                }[\"Home.useCallback[handleRepost]\"]);\n            }\n        }\n    }[\"Home.useCallback[handleRepost]\"], [\n        pubkey\n    ]);\n    // Update renderMediaWithPreview to accept setLightboxMedia as a prop\n    function renderMediaWithPreview(media, linkPreviews, setLightboxMedia) {\n        if (!media || media.length === 0) return null;\n        const images = media.filter((url)=>url.match(/\\.(jpeg|jpg|gif|png)$/i));\n        // Detect YouTube and SoundCloud links\n        const youTubeRegex = /(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/)[\\w-]+/i;\n        const soundCloudRegex = /soundcloud\\.com\\//i;\n        const videos = media.filter((url)=>url.match(/\\.(mp4|webm)$/i) || youTubeRegex.test(url));\n        const audios = media.filter((url)=>url.match(/\\.(mp3|wav|ogg)$/i) || soundCloudRegex.test(url));\n        const mediaSet = new Set([\n            ...images,\n            ...videos,\n            ...audios\n        ]);\n        const links = media.filter((url)=>!mediaSet.has(url) && !url.match(/\\.(jpeg|jpg|gif|png|mp4|webm|mp3|wav|ogg)$/i) && !youTubeRegex.test(url) && !soundCloudRegex.test(url));\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"flex flex-col gap-2 mt-2\",\n            children: [\n                images.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"grid gap-2 \".concat(images.length === 1 ? \"grid-cols-1\" : images.length === 2 ? \"grid-cols-2\" : \"grid-cols-2\"),\n                    children: images.slice(0, 4).map((url, idx)=>// Replace inline style with Tailwind for image\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                            src: url,\n                            alt: \"media\",\n                            className: \"rounded-xl object-cover border border-gray-800 bg-black w-full h-60 cursor-pointer aspect-square object-cover\",\n                            onClick: (e)=>{\n                                e.stopPropagation();\n                                setLightboxMedia(url);\n                            }\n                        }, idx, false, {\n                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                            lineNumber: 477,\n                            columnNumber: 15\n                        }, this))\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                    lineNumber: 474,\n                    columnNumber: 11\n                }, this),\n                (videos.length > 0 || audios.length > 0) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex flex-col gap-2\",\n                    children: [\n                        ...videos,\n                        ...audios\n                    ].map((url, idx)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"relative\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_shared_MediaPlayer__WEBPACK_IMPORTED_MODULE_6__.MediaPlayer, {\n                                    url: url,\n                                    className: \"rounded-xl border border-gray-800 bg-black w-full shadow-lg\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                    lineNumber: 491,\n                                    columnNumber: 17\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"absolute top-2 left-2 bg-black/60 text-white text-xs px-2 py-1 rounded\",\n                                    children: url.match(/\\.(mp4|webm)$/i) || youTubeRegex.test(url) ? \"Video\" : \"Audio\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                    lineNumber: 492,\n                                    columnNumber: 17\n                                }, this)\n                            ]\n                        }, idx, true, {\n                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                            lineNumber: 490,\n                            columnNumber: 15\n                        }, this))\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                    lineNumber: 488,\n                    columnNumber: 11\n                }, this),\n                links.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex flex-col gap-2\",\n                    children: links.map((url, idx)=>linkPreviews[url] ? linkPreviews[url] && renderLinkPreview(linkPreviews[url]) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                            href: url,\n                            target: \"_blank\",\n                            rel: \"noopener noreferrer\",\n                            className: \"text-blue-400 underline break-all hover:text-blue-300\",\n                            children: url\n                        }, idx, false, {\n                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                            lineNumber: 505,\n                            columnNumber: 17\n                        }, this))\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                    lineNumber: 500,\n                    columnNumber: 11\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n            lineNumber: 472,\n            columnNumber: 7\n        }, this);\n    }\n    function ProfileDropdown(param) {\n        let { children, menu } = param;\n        _s1();\n        const [open, setOpen] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n        const ref = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n        // Close dropdown on outside click\n        (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n            \"Home.ProfileDropdown.useEffect\": ()=>{\n                function handleClick(e) {\n                    if (ref.current && !ref.current.contains(e.target)) setOpen(false);\n                }\n                if (open) document.addEventListener(\"mousedown\", handleClick);\n                return ({\n                    \"Home.ProfileDropdown.useEffect\": ()=>document.removeEventListener(\"mousedown\", handleClick)\n                })[\"Home.ProfileDropdown.useEffect\"];\n            }\n        }[\"Home.ProfileDropdown.useEffect\"], [\n            open\n        ]);\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"relative\",\n            ref: ref,\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    onClick: ()=>setOpen((v)=>!v),\n                    className: \"cursor-pointer\",\n                    children: children\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                    lineNumber: 536,\n                    columnNumber: 9\n                }, this),\n                open && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"absolute left-0 mt-2 z-20 bg-gray-900 border border-gray-800 rounded-xl shadow-lg min-w-[120px] p-2 flex flex-col\",\n                    children: menu\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                    lineNumber: 540,\n                    columnNumber: 11\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n            lineNumber: 534,\n            columnNumber: 7\n        }, this);\n    }\n    _s1(ProfileDropdown, \"wl9VvfhnMVWQ+kCekFjcRPEi3/0=\");\n    function useGlobalNostrPostCount() {\n        _s2();\n        const [totalCount, setTotalCount] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n        (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n            \"Home.useGlobalNostrPostCount.useEffect\": ()=>{\n                const fetchCount = {\n                    \"Home.useGlobalNostrPostCount.useEffect.fetchCount\": async ()=>{\n                        try {\n                            // Get healthy relays\n                            const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_7__.getHealthyRelays)();\n                            // Fetch a large number of events and deduplicate by id for an estimate\n                            const result = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_7__.fetchNostrFeed)(healthyRelays, {\n                                limit: 1000\n                            });\n                            // Deduplicate by event id\n                            const uniqueIds = new Set((result || []).map({\n                                \"Home.useGlobalNostrPostCount.useEffect.fetchCount\": (ev)=>ev.id\n                            }[\"Home.useGlobalNostrPostCount.useEffect.fetchCount\"]));\n                            setTotalCount(uniqueIds.size);\n                        } catch (e) {\n                            setTotalCount(null);\n                        }\n                    }\n                }[\"Home.useGlobalNostrPostCount.useEffect.fetchCount\"];\n                fetchCount();\n            }\n        }[\"Home.useGlobalNostrPostCount.useEffect\"], []);\n        return totalCount;\n    }\n    _s2(useGlobalNostrPostCount, \"nvnM//iRfr/MB+ZM6fF8BsMZLbs=\");\n    // Fetch NOSTR Band stats on component mount\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            // Remove fetchNostrBandStats usage or replace with correct implementation if needed\n            setLoadingStats(false);\n        }\n    }[\"Home.useEffect\"], []);\n    // Open profile pane with a given pubkey\n    const openProfilePane = (pubkey)=>{\n        setProfilePanePubkey(pubkey);\n        setActivePane(\"profile\");\n        setSidePaneComponent(null); // Will be set in useEffect\n    };\n    // Dynamic import logic for side pane\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            if (!activePane) {\n                setSidePaneComponent(null);\n                return;\n            }\n            let component = null;\n            if (activePane === \"explore\") {\n                component = /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_app_explore_page__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {}, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                    lineNumber: 594,\n                    columnNumber: 19\n                }, this);\n            } else if (activePane === \"wallet\") {\n                component = /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_app_wallet_page__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {}, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                    lineNumber: 596,\n                    columnNumber: 19\n                }, this);\n            } else if (activePane === \"chat\") {\n                component = /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_app_chat_page__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {}, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                    lineNumber: 598,\n                    columnNumber: 19\n                }, this);\n            } else if (activePane === \"profile\" && profilePanePubkey) {\n                component = /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_app_profile_page__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                    userOverride: profilePanePubkey,\n                    onClose: {\n                        \"Home.useEffect\": ()=>setActivePane(null)\n                    }[\"Home.useEffect\"]\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                    lineNumber: 600,\n                    columnNumber: 19\n                }, this);\n            } else {\n                // Placeholder for other panes\n                component = /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"p-8 text-white\",\n                    children: \"Coming soon...\"\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                    lineNumber: 603,\n                    columnNumber: 19\n                }, this);\n            }\n            setSidePaneComponent(component);\n        }\n    }[\"Home.useEffect\"], [\n        activePane,\n        profilePanePubkey\n    ]);\n    // --- Layout Refactor Start ---\n    // Relay health state\n    const [healthyRelayCount, setHealthyRelayCount] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [checkingRelays, setCheckingRelays] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            let mounted = true;\n            async function checkRelays() {\n                setCheckingRelays(true);\n                try {\n                    const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_7__.getHealthyRelays)();\n                    if (mounted) setHealthyRelayCount(healthyRelays.length);\n                } catch (e) {\n                    if (mounted) setHealthyRelayCount(null);\n                } finally{\n                    if (mounted) setCheckingRelays(false);\n                }\n            }\n            checkRelays();\n            // Optionally, re-check every 2 minutes\n            const interval = setInterval(checkRelays, 120000);\n            return ({\n                \"Home.useEffect\": ()=>{\n                    mounted = false;\n                    clearInterval(interval);\n                }\n            })[\"Home.useEffect\"];\n        }\n    }[\"Home.useEffect\"], []);\n    // --- Layout Refactor Start ---\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-h-screen w-full bg-black flex flex-row\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"aside\", {\n                className: \"hidden md:flex flex-col w-[80px] xl:w-[240px] h-screen sticky top-0 left-0 z-30 border-r border-gray-800 bg-gray-950\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_layout_Sidebar__WEBPACK_IMPORTED_MODULE_12__[\"default\"], {\n                    onNav: handleNav,\n                    activePane: activePane\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                    lineNumber: 636,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                lineNumber: 635,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex-1 flex justify-center\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex flex-row w-full max-w-[calc(100vw-400px)] xl:max-w-[calc(100vw-400px)] 2xl:max-w-[1800px] transition-all duration-300 \".concat(activePane && sidePaneComponent ? \"gap-8\" : \"\", \" justify-center\"),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"w-full max-w-2xl px-2 sm:px-6 py-8 bg-gray-950 border border-gray-800 shadow-xl rounded-xl transition-all duration-300 flex-shrink-0 \".concat(activePane && sidePaneComponent ? \"\" : \"mx-auto\", \" overflow-y-auto h-[calc(100vh-32px)]\"),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"mb-6\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"flex flex-col sm:flex-row gap-4\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"flex-1\",\n                                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                        type: \"text\",\n                                                        value: search,\n                                                        onChange: (e)=>setSearch(e.target.value),\n                                                        onFocus: ()=>setSearchFocused(true),\n                                                        placeholder: \"Search users by name, username, or npub...\",\n                                                        className: \"w-full px-4 py-2 rounded-full bg-gray-900 border border-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-blue-500/30 focus:border-blue-500/30 placeholder-gray-500\",\n                                                        autoComplete: \"off\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                        lineNumber: 652,\n                                                        columnNumber: 19\n                                                    }, this)\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 651,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    className: \"ml-0 sm:ml-2 px-4 py-2 rounded-full border border-blue-500 text-blue-400 bg-blue-900/20 hover:bg-blue-900/40 transition font-semibold \".concat(showFilter ? 'ring-2 ring-blue-400' : ''),\n                                                    onClick: ()=>setShowFilter((v)=>!v),\n                                                    children: showFilter ? 'Hide Filters' : 'Filter by Tag'\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 662,\n                                                    columnNumber: 17\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                            lineNumber: 650,\n                                            columnNumber: 15\n                                        }, this),\n                                        showFilter && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"mb-6 flex gap-2 items-center\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                    type: \"text\",\n                                                    value: filterTag,\n                                                    onChange: (e)=>setFilterTag(e.target.value),\n                                                    placeholder: \"Enter tag (e.g. bitcoin, nostr, ai)\",\n                                                    className: \"px-4 py-2 rounded-full bg-gray-900 border border-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-blue-500/30 focus:border-blue-500/30 placeholder-gray-500 w-full\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 671,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    className: \"px-4 py-2 rounded-full bg-blue-500 text-white hover:bg-blue-600 transition font-semibold\",\n                                                    onClick: ()=>setFilterTag(\"\"),\n                                                    children: \"Clear\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 678,\n                                                    columnNumber: 19\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                            lineNumber: 670,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                                            className: \"flex items-center justify-between mb-6\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                                    className: \"text-2xl font-bold\",\n                                                    children: \"RAW.ROCKS\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 689,\n                                                    columnNumber: 17\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    children: !pubkey && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                        onClick: login,\n                                                        className: \"px-4 py-2 rounded-full bg-blue-500 text-white font-medium hover:bg-blue-600 shadow-lg shadow-blue-500/20 transition\",\n                                                        children: \"Login with NOSTR\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                        lineNumber: 692,\n                                                        columnNumber: 21\n                                                    }, this)\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 690,\n                                                    columnNumber: 17\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                            lineNumber: 688,\n                                            columnNumber: 15\n                                        }, this),\n                                        globalPostCount !== null ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"text-xs text-gray-400 mb-2 text-center\",\n                                            children: [\n                                                \"\\uD83C\\uDF0E Global Nostr Posts: \",\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"font-bold\",\n                                                    children: globalPostCount.toLocaleString()\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 705,\n                                                    columnNumber: 42\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                            lineNumber: 704,\n                                            columnNumber: 17\n                                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"text-xs text-gray-400 mb-2 text-center\",\n                                            children: \"Loading global post count...\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                            lineNumber: 708,\n                                            columnNumber: 17\n                                        }, this),\n                                        healthyRelayCount !== null && healthyRelayCount < 3 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"mb-4 p-3 rounded-xl bg-yellow-900/80 border border-yellow-600 text-yellow-200 text-center flex flex-col items-center gap-2\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    className: \"font-semibold\",\n                                                    children: \"⚠️ Low relay connectivity\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 714,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    children: [\n                                                        \"Only \",\n                                                        healthyRelayCount,\n                                                        \" healthy relay\",\n                                                        healthyRelayCount === 1 ? '' : 's',\n                                                        \" detected. Some posts may be missing or delayed.\"\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 715,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    className: \"mt-1 px-3 py-1 rounded bg-yellow-700 text-white hover:bg-yellow-800 text-xs font-semibold\",\n                                                    onClick: ()=>{\n                                                        setHealthyRelayCount(null);\n                                                        setCheckingRelays(true);\n                                                        (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_7__.getHealthyRelays)().then((param)=>{\n                                                            let { healthyRelays } = param;\n                                                            setHealthyRelayCount(healthyRelays.length);\n                                                            setCheckingRelays(false);\n                                                        }).catch(()=>setCheckingRelays(false));\n                                                    },\n                                                    disabled: checkingRelays,\n                                                    children: checkingRelays ? 'Checking...' : 'Retry Relays'\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 716,\n                                                    columnNumber: 19\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                            lineNumber: 713,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                    lineNumber: 649,\n                                    columnNumber: 13\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                                    className: \"flex flex-col gap-6\",\n                                    children: [\n                                        error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_shared_ErrorMessage__WEBPACK_IMPORTED_MODULE_5__.ErrorMessage, {\n                                            message: error,\n                                            relayStats: relayStats,\n                                            onRetry: ()=>fetchEvents(),\n                                            onClearRelays: ()=>{\n                                                (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_7__.clearBadRelayCache)();\n                                                fetchEvents();\n                                            }\n                                        }, void 0, false, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                            lineNumber: 738,\n                                            columnNumber: 17\n                                        }, this),\n                                        events.length === 0 && !isLoadingMore && !error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"text-center text-gray-500 py-12\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    className: \"mb-4\",\n                                                    children: \"No posts yet. Be the first to post!\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 752,\n                                                    columnNumber: 19\n                                                }, this),\n                                                !pubkey && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: login,\n                                                    className: \"px-6 py-2 bg-blue-500/20 hover:bg-blue-500/30 rounded-full text-blue-400 transition\",\n                                                    children: \"Connect with NOSTR to Post\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 754,\n                                                    columnNumber: 21\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                            lineNumber: 751,\n                                            columnNumber: 17\n                                        }, this),\n                                        filteredEvents.map((ev, index)=>{\n                                            var _ev_profile, _ev_profile1, _ev_profile2, _ev_profile3, _ev_profile4, _ev_profile5, _ev_profile6, _ev_profile7, _ev_profile8, _ev_profile9;\n                                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                ref: hashtagResults.length === 0 && index === events.length - 1 ? lastPostRef : null,\n                                                className: \"relative\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        onClick: ()=>{\n                                                            if (activeChatPostId === ev.id) {\n                                                                handleChatClose(ev.id);\n                                                            } else {\n                                                                if (activeChatPostId) {\n                                                                    handleChatClose(activeChatPostId);\n                                                                    setTimeout(()=>setActiveChatPostId(ev.id), 300);\n                                                                } else {\n                                                                    setActiveChatPostId(ev.id);\n                                                                }\n                                                            }\n                                                        },\n                                                        className: \"bg-gray-900/40 backdrop-blur-sm border border-white/10 rounded-xl p-5 shadow-lg flex flex-col gap-2 cursor-pointer transition hover:bg-gray-900/60 hover:border-white/20 \".concat(activeChatPostId === ev.id ? 'rounded-b-none border-b-0' : ''),\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                className: \"flex items-center gap-4 mb-1\",\n                                                                children: [\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ProfileDropdown, {\n                                                                        menu: pubkey && ev.pubkey !== pubkey ? isFollowing(ev.pubkey) ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                                            className: \"text-xs px-3 py-1 rounded bg-gray-800 border border-gray-600 text-gray-300 hover:bg-gray-700 w-full text-left\",\n                                                                            onClick: (e)=>{\n                                                                                e.stopPropagation();\n                                                                                unfollowUser(ev.pubkey);\n                                                                            },\n                                                                            children: \"Unfollow\"\n                                                                        }, void 0, false, {\n                                                                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                            lineNumber: 791,\n                                                                            columnNumber: 29\n                                                                        }, void 0) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                                            className: \"text-xs px-3 py-1 rounded bg-blue-500 text-white hover:bg-blue-600 w-full text-left\",\n                                                                            onClick: (e)=>{\n                                                                                e.stopPropagation();\n                                                                                followUser(ev.pubkey);\n                                                                            },\n                                                                            children: \"Follow\"\n                                                                        }, void 0, false, {\n                                                                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                            lineNumber: 796,\n                                                                            columnNumber: 29\n                                                                        }, void 0) : null,\n                                                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                                                            src: ((_ev_profile = ev.profile) === null || _ev_profile === void 0 ? void 0 : _ev_profile.picture) || \"/file.svg\",\n                                                                            alt: \"avatar\",\n                                                                            className: \"w-12 h-12 rounded-full border border-gray-800\"\n                                                                        }, void 0, false, {\n                                                                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                            lineNumber: 803,\n                                                                            columnNumber: 25\n                                                                        }, this)\n                                                                    }, void 0, false, {\n                                                                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                        lineNumber: 788,\n                                                                        columnNumber: 23\n                                                                    }, this),\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                        className: \"min-w-0 flex flex-col\",\n                                                                        children: [\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                                                type: \"button\",\n                                                                                className: \"font-semibold text-white truncate hover:underline text-left outline-none bg-transparent border-0 p-0 m-0 cursor-pointer\",\n                                                                                onClick: (e)=>{\n                                                                                    e.stopPropagation();\n                                                                                    openProfilePane(ev.pubkey);\n                                                                                },\n                                                                                tabIndex: 0,\n                                                                                \"aria-label\": \"Open profile for \".concat(((_ev_profile1 = ev.profile) === null || _ev_profile1 === void 0 ? void 0 : _ev_profile1.display_name) || ((_ev_profile2 = ev.profile) === null || _ev_profile2 === void 0 ? void 0 : _ev_profile2.name) || ((_ev_profile3 = ev.profile) === null || _ev_profile3 === void 0 ? void 0 : _ev_profile3.username) || ev.pubkey),\n                                                                                children: ((_ev_profile4 = ev.profile) === null || _ev_profile4 === void 0 ? void 0 : _ev_profile4.display_name) || ((_ev_profile5 = ev.profile) === null || _ev_profile5 === void 0 ? void 0 : _ev_profile5.name) || ((_ev_profile6 = ev.profile) === null || _ev_profile6 === void 0 ? void 0 : _ev_profile6.username) || ev.pubkey.slice(0, 8) + \"...\"\n                                                                            }, void 0, false, {\n                                                                                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                                lineNumber: 811,\n                                                                                columnNumber: 25\n                                                                            }, this),\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                                className: \"text-sm text-gray-400 flex items-center gap-2\",\n                                                                                children: [\n                                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                                        children: [\n                                                                                            \"@\",\n                                                                                            ((_ev_profile7 = ev.profile) === null || _ev_profile7 === void 0 ? void 0 : _ev_profile7.name) || ((_ev_profile8 = ev.profile) === null || _ev_profile8 === void 0 ? void 0 : _ev_profile8.username) || (((_ev_profile9 = ev.profile) === null || _ev_profile9 === void 0 ? void 0 : _ev_profile9.pubkey) ? \"\".concat(ev.profile.pubkey.slice(0, 6), \"...\").concat(ev.profile.pubkey.slice(-4)) : ev.pubkey.slice(0, 6) + '...' + ev.pubkey.slice(-4))\n                                                                                        ]\n                                                                                    }, void 0, true, {\n                                                                                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                                        lineNumber: 824,\n                                                                                        columnNumber: 27\n                                                                                    }, this),\n                                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                                        className: \"text-xs text-gray-500\",\n                                                                                        children: relativeTime(ev.created_at)\n                                                                                    }, void 0, false, {\n                                                                                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                                        lineNumber: 827,\n                                                                                        columnNumber: 27\n                                                                                    }, this)\n                                                                                ]\n                                                                            }, void 0, true, {\n                                                                                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                                lineNumber: 823,\n                                                                                columnNumber: 25\n                                                                            }, this)\n                                                                        ]\n                                                                    }, void 0, true, {\n                                                                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                        lineNumber: 809,\n                                                                        columnNumber: 23\n                                                                    }, this),\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                        className: \"flex-1\"\n                                                                    }, void 0, false, {\n                                                                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                        lineNumber: 830,\n                                                                        columnNumber: 23\n                                                                    }, this),\n                                                                    chatCounts[ev.id] > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                        className: \"px-2 py-1 rounded-full bg-blue-500/10 text-blue-400 text-sm flex items-center gap-1\",\n                                                                        children: [\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                                children: \"\\uD83D\\uDCAC\"\n                                                                            }, void 0, false, {\n                                                                                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                                lineNumber: 835,\n                                                                                columnNumber: 27\n                                                                            }, this),\n                                                                            chatCounts[ev.id]\n                                                                        ]\n                                                                    }, void 0, true, {\n                                                                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                        lineNumber: 834,\n                                                                        columnNumber: 25\n                                                                    }, this)\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                lineNumber: 787,\n                                                                columnNumber: 21\n                                                            }, this),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                className: \"text-lg text-white whitespace-pre-line break-words mb-1\",\n                                                                children: formatNostrAddresses(ev.content)\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                lineNumber: 842,\n                                                                columnNumber: 21\n                                                            }, this),\n                                                            renderMediaWithPreview(ev.media, linkPreviews, setLightboxMedia),\n                                                            renderHashtags(ev),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                className: \"flex gap-6 mt-2 text-sm text-gray-400 border-t border-gray-800 pt-3\",\n                                                                children: [\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                        className: \"flex items-center gap-2 transition \".concat(activeChatPostId === ev.id ? 'text-blue-400' : 'hover:text-blue-400'),\n                                                                        children: [\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                                children: \"\\uD83D\\uDCAC\"\n                                                                            }, void 0, false, {\n                                                                                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                                lineNumber: 851,\n                                                                                columnNumber: 25\n                                                                            }, this),\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                                children: [\n                                                                                    \"Chat\",\n                                                                                    chatCounts[ev.id] > 0 ? \" (\".concat(chatCounts[ev.id], \")\") : ''\n                                                                                ]\n                                                                            }, void 0, true, {\n                                                                                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                                lineNumber: 852,\n                                                                                columnNumber: 25\n                                                                            }, this)\n                                                                        ]\n                                                                    }, void 0, true, {\n                                                                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                        lineNumber: 850,\n                                                                        columnNumber: 23\n                                                                    }, this),\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                                        className: \"flex items-center gap-2 hover:text-pink-400 transition \".concat(likedPosts[ev.id] ? 'text-pink-400 font-bold' : ''),\n                                                                        onClick: (e)=>{\n                                                                            e.stopPropagation();\n                                                                            if (!likedPosts[ev.id]) handleLike(ev.id, ev.pubkey);\n                                                                        },\n                                                                        disabled: !!likedPosts[ev.id],\n                                                                        \"aria-label\": likedPosts[ev.id] ? 'Liked' : 'Like',\n                                                                        type: \"button\",\n                                                                        children: [\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                                children: \"❤️\"\n                                                                            }, void 0, false, {\n                                                                                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                                lineNumber: 861,\n                                                                                columnNumber: 25\n                                                                            }, this),\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                                children: [\n                                                                                    \"Like\",\n                                                                                    likeCounts[ev.id] ? \" (\".concat(likeCounts[ev.id], \")\") : ''\n                                                                                ]\n                                                                            }, void 0, true, {\n                                                                                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                                lineNumber: 862,\n                                                                                columnNumber: 25\n                                                                            }, this)\n                                                                        ]\n                                                                    }, void 0, true, {\n                                                                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                        lineNumber: 854,\n                                                                        columnNumber: 23\n                                                                    }, this),\n                                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                                        className: \"flex items-center gap-2 hover:text-green-400 transition \".concat(repostedPosts[ev.id] ? 'text-green-400 font-bold' : ''),\n                                                                        onClick: (e)=>{\n                                                                            e.stopPropagation();\n                                                                            if (!repostedPosts[ev.id]) handleRepost(ev.id, ev.pubkey, ev.content);\n                                                                        },\n                                                                        disabled: !!repostedPosts[ev.id],\n                                                                        \"aria-label\": repostedPosts[ev.id] ? 'Reposted' : 'Repost',\n                                                                        type: \"button\",\n                                                                        children: [\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                                children: \"\\uD83D\\uDD01\"\n                                                                            }, void 0, false, {\n                                                                                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                                lineNumber: 871,\n                                                                                columnNumber: 25\n                                                                            }, this),\n                                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                                children: [\n                                                                                    \"Repost\",\n                                                                                    repostCounts[ev.id] ? \" (\".concat(repostCounts[ev.id], \")\") : ''\n                                                                                ]\n                                                                            }, void 0, true, {\n                                                                                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                                lineNumber: 872,\n                                                                                columnNumber: 25\n                                                                            }, this)\n                                                                        ]\n                                                                    }, void 0, true, {\n                                                                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                        lineNumber: 864,\n                                                                        columnNumber: 23\n                                                                    }, this)\n                                                                ]\n                                                            }, void 0, true, {\n                                                                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                                lineNumber: 849,\n                                                                columnNumber: 21\n                                                            }, this)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                        lineNumber: 771,\n                                                        columnNumber: 19\n                                                    }, this),\n                                                    activeChatPostId === ev.id && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_chat_ChatBox__WEBPACK_IMPORTED_MODULE_4__.ChatBox, {\n                                                        postId: ev.id,\n                                                        pubkey: pubkey,\n                                                        onClose: ()=>handleChatClose(ev.id),\n                                                        isAnimating: closingChatId === ev.id\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                        lineNumber: 879,\n                                                        columnNumber: 21\n                                                    }, this)\n                                                ]\n                                            }, ev.id, true, {\n                                                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                lineNumber: 766,\n                                                columnNumber: 17\n                                            }, this);\n                                        }),\n                                        isLoadingMore && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"text-center py-4\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \"inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 891,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    className: \"mt-2 text-gray-400 text-sm\",\n                                                    children: \"Loading more posts...\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 892,\n                                                    columnNumber: 19\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                            lineNumber: 890,\n                                            columnNumber: 17\n                                        }, this),\n                                        !hasMore && events.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"text-center py-8 text-gray-500\",\n                                            children: \"You've reached the end!\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                            lineNumber: 898,\n                                            columnNumber: 17\n                                        }, this),\n                                        retryCount > 0 && !isLoadingMore && hasMore && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"text-center py-4\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                    className: \"text-gray-400 mb-2\",\n                                                    children: \"Failed to load more posts\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 906,\n                                                    columnNumber: 19\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: ()=>{\n                                                        const oldestEvent = events[events.length - 1];\n                                                        if (oldestEvent) {\n                                                            setIsLoadingMore(true);\n                                                            fetchEvents({\n                                                                until: oldestEvent.created_at\n                                                            }).then((hasNewEvents)=>{\n                                                                setHasMore(hasNewEvents);\n                                                                setIsLoadingMore(false);\n                                                                setRetryCount(0);\n                                                            }).catch(()=>{\n                                                                setIsLoadingMore(false);\n                                                                setRetryCount((prev)=>prev + 1);\n                                                            });\n                                                        }\n                                                    },\n                                                    className: \"px-4 py-2 bg-blue-500/20 hover:bg-blue-500/30 rounded-full text-sm transition\",\n                                                    children: \"Try Again\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                                    lineNumber: 907,\n                                                    columnNumber: 19\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                            lineNumber: 905,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                                    lineNumber: 735,\n                                    columnNumber: 13\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                            lineNumber: 645,\n                            columnNumber: 11\n                        }, this),\n                        activePane && sidePaneComponent && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                            className: \"hidden lg:block w-full max-w-2xl px-2 sm:px-6 py-8 bg-gray-950 border border-gray-800 shadow-xl rounded-xl overflow-y-auto relative animate-slide-in-left flex-shrink-0 h-[calc(100vh-32px)]\",\n                            children: sidePaneComponent\n                        }, void 0, false, {\n                            fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                            lineNumber: 935,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                    lineNumber: 641,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                lineNumber: 640,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"aside\", {\n                className: \"hidden xl:flex flex-col w-[320px] h-screen sticky top-0 right-0 z-30 border-l border-gray-800 bg-gray-950\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_layout_RightSidebar__WEBPACK_IMPORTED_MODULE_13__[\"default\"], {\n                    trendingHashtags: trendingHashtags,\n                    searchHashtag: searchHashtag\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                    lineNumber: 944,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n                lineNumber: 943,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/app/page.tsx\",\n        lineNumber: 633,\n        columnNumber: 5\n    }, this);\n}\n_s(Home, \"ucQklnDh7F02D2Vtr0PHH+d26ac=\", true, function() {\n    return [\n        _hooks_useNostr__WEBPACK_IMPORTED_MODULE_1__.useNostr\n    ];\n});\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcGFnZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFNEM7QUFDOEI7QUFDZDtBQUVSO0FBSVk7QUFHRjtBQUMyQjtBQUNoRDtBQUVJO0FBQ0E7QUFDRjtBQUNKO0FBQ1c7QUFDVTtBQUU1RCxTQUFTb0IsYUFBYUMsU0FBaUI7SUFDckMsTUFBTUMsTUFBTUMsS0FBS0QsR0FBRztJQUNwQixNQUFNRSxPQUFPQyxLQUFLQyxLQUFLLENBQUMsQ0FBQ0osTUFBT0QsQ0FBQUEsWUFBWSxRQUFRQSxTQUFRLENBQUMsSUFBSztJQUNsRSxJQUFJRyxPQUFPLElBQUksT0FBTyxHQUFRLE9BQUxBLE1BQUs7SUFDOUIsSUFBSUEsT0FBTyxNQUFNLE9BQU8sR0FBeUIsT0FBdEJDLEtBQUtDLEtBQUssQ0FBQ0YsT0FBTyxLQUFJO0lBQ2pELElBQUlBLE9BQU8sT0FBTyxPQUFPLEdBQTJCLE9BQXhCQyxLQUFLQyxLQUFLLENBQUNGLE9BQU8sT0FBTTtJQUNwRCxPQUFPLElBQUlELEtBQUtGLFlBQVksUUFBUUEsV0FBV00sa0JBQWtCO0FBQ25FO0FBRUEsU0FBU0Msa0JBQWtCQyxPQUFvQjtJQUM3QyxPQUNFLGdEQUFnRDtrQkFDaEQsOERBQUNDO1FBQ0NDLE1BQU1GLFFBQVFHLEdBQUc7UUFDakJDLFFBQU87UUFDUEMsS0FBSTtRQUNKQyxXQUFVOztZQUVUTixRQUFRTyxLQUFLLGtCQUNaLDhEQUFDQztnQkFDQ0MsS0FBS1QsUUFBUU8sS0FBSztnQkFDbEJHLEtBQUtWLFFBQVFXLEtBQUssSUFBSVgsUUFBUUcsR0FBRztnQkFDakNHLFdBQVU7Ozs7OzswQkFHZCw4REFBQ007Z0JBQUlOLFdBQVU7O2tDQUNiLDhEQUFDTTt3QkFBSU4sV0FBVTtrQ0FBK0NOLFFBQVFXLEtBQUssSUFBSVgsUUFBUUcsR0FBRzs7Ozs7O29CQUN6RkgsUUFBUWEsUUFBUSxrQkFDZiw4REFBQ0Q7d0JBQUlOLFdBQVU7OzRCQUNaTixRQUFRYyxPQUFPLGtCQUFJLDhEQUFDTjtnQ0FBSUMsS0FBS1QsUUFBUWMsT0FBTztnQ0FBRUosS0FBSTtnQ0FBVUosV0FBVTs7Ozs7OzRCQUE4Qzs0QkFBRU4sUUFBUWEsUUFBUTs7Ozs7OztvQkFHMUliLFFBQVFlLFdBQVcsa0JBQ2xCLDhEQUFDSDt3QkFBSU4sV0FBVTtrQ0FBa0NOLFFBQVFlLFdBQVc7Ozs7OztrQ0FFdEUsOERBQUNIO3dCQUFJTixXQUFVO2tDQUF1Q04sUUFBUUcsR0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSXpFO0FBRUEsNENBQTRDO0FBQ3JDLFNBQVNhLHFCQUFxQkMsSUFBWTtJQUMvQywwRUFBMEU7SUFDMUUsTUFBTUMsYUFBYTtJQUNuQixPQUFPRCxLQUFLRSxLQUFLLENBQUNELFlBQVlFLEdBQUcsQ0FBQyxDQUFDQyxNQUFNQztRQUN2QyxJQUFJRCxLQUFLRSxLQUFLLENBQUNMLGFBQWE7WUFDMUIsT0FBT0csTUFBTSxtQ0FBbUM7UUFDbEQ7UUFDQSxPQUFPQTtJQUNUO0FBQ0Y7QUFFQSwwRUFBMEU7QUFDMUUsZUFBZUcsaUJBQWlCQyxNQUFXO0lBQ3pDLE1BQU0sRUFBRUMsYUFBYSxFQUFFLEdBQUcsTUFBTTdDLGtFQUFnQkE7SUFDaEQsTUFBTThDLE9BQU8sSUFBSTNDLG9EQUFVQTtJQUMzQixJQUFJO1FBQ0YsT0FBTyxNQUFNMkMsS0FBS0MsU0FBUyxDQUFDRixlQUFlRDtJQUM3QyxTQUFVO1FBQ1JFLEtBQUtFLEtBQUssQ0FBQ0g7SUFDYjtBQUNGO0FBRWUsU0FBU0k7OztJQUN0QixNQUFNLEVBQUVDLE1BQU0sRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsV0FBVyxFQUFFQyxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsWUFBWSxFQUFFQyxXQUFXLEVBQUVDLFVBQVUsRUFBRSxHQUFHckUseURBQVFBO0lBQ3ZILE1BQU0sQ0FBQ3NFLFNBQVNDLFdBQVcsR0FBR3JFLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQ3NFLGNBQWNDLGdCQUFnQixHQUFHdkUsK0NBQVFBLENBQXdDLENBQUM7SUFDekYsTUFBTSxDQUFDd0Usa0JBQWtCQyxvQkFBb0IsR0FBR3pFLCtDQUFRQSxDQUFnQjtJQUN4RSxNQUFNLENBQUMwRSxlQUFlQyxpQkFBaUIsR0FBRzNFLCtDQUFRQSxDQUFnQjtJQUNsRSxNQUFNLENBQUM0RSxZQUFZQyxjQUFjLEdBQUc3RSwrQ0FBUUEsQ0FBK0IsQ0FBQztJQUM1RSxNQUFNLENBQUM4RSxlQUFlQyxpQkFBaUIsR0FBRy9FLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ2dGLFNBQVNDLFdBQVcsR0FBR2pGLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQ2tGLFlBQVlDLGNBQWMsR0FBR25GLCtDQUFRQSxDQUFDO0lBQzdDLE1BQU0sQ0FBQ29GLGlCQUFpQkMsbUJBQW1CLEdBQUdyRiwrQ0FBUUEsQ0FBQztJQUN2RCxNQUFNLENBQUNzRixRQUFRQyxVQUFVLEdBQUd2RiwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNLENBQUN3RixlQUFlQyxpQkFBaUIsR0FBR3pGLCtDQUFRQSxDQUFRLEVBQUU7SUFDNUQsTUFBTSxDQUFDMEYsZUFBZUMsaUJBQWlCLEdBQUczRiwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUM0RixTQUFTQyxXQUFXLEdBQUc3RiwrQ0FBUUEsQ0FBUztJQUMvQyxNQUFNLENBQUM4RixnQkFBZ0JDLGtCQUFrQixHQUFHL0YsK0NBQVFBLENBQVEsRUFBRTtJQUM5RCxNQUFNLENBQUNnRyxXQUFXQyxhQUFhLEdBQUdqRywrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNrRyxZQUFZQyxjQUFjLEdBQUduRywrQ0FBUUEsQ0FBQztJQUM3QyxNQUFNLENBQUNvRyxpQkFBaUJDLG1CQUFtQixHQUFHckcsK0NBQVFBLENBQUM7SUFDdkQsTUFBTXNHLGdCQUFnQnJHLDZDQUFNQSxDQUF3QjtJQUNwRCxNQUFNc0csY0FBY3RHLDZDQUFNQSxDQUE4QjtJQUN4RCxNQUFNdUcsY0FBY3ZHLDZDQUFNQSxDQUF3QjtJQUNsRCxNQUFNd0csa0JBQWtCQztJQUN4QixNQUFNLENBQUNDLFlBQVlDLGNBQWMsR0FBRzVHLCtDQUFRQSxDQUErQixDQUFDO0lBQzVFLE1BQU0sQ0FBQzZHLFlBQVlDLGNBQWMsR0FBRzlHLCtDQUFRQSxDQUFnQyxDQUFDO0lBQzdFLE1BQU0sQ0FBQytHLGNBQWNDLGdCQUFnQixHQUFHaEgsK0NBQVFBLENBQStCLENBQUM7SUFDaEYsTUFBTSxDQUFDaUgsZUFBZUMsaUJBQWlCLEdBQUdsSCwrQ0FBUUEsQ0FBZ0MsQ0FBQztJQUNuRixNQUFNLENBQUNtSCxlQUFlQyxpQkFBaUIsR0FBR3BILCtDQUFRQSxDQUFnQjtJQUNsRSxNQUFNLENBQUNxSCxPQUFPQyxTQUFTLEdBQUd0SCwrQ0FBUUEsQ0FBTTtJQUN4QyxNQUFNLENBQUN1SCxjQUFjQyxnQkFBZ0IsR0FBR3hILCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ3lILFlBQVlDLGNBQWMsR0FBRzFILCtDQUFRQSxDQUFnQjtJQUM1RCxNQUFNLENBQUMySCxtQkFBbUJDLHFCQUFxQixHQUFHNUgsK0NBQVFBLENBQWtCO0lBQzVFLE1BQU0sQ0FBQzZILG1CQUFtQkMscUJBQXFCLEdBQUc5SCwrQ0FBUUEsQ0FBZ0I7SUFFMUUsNEJBQTRCO0lBQzVCLE1BQU0rSCxZQUFZN0gsa0RBQVdBO3VDQUFDLENBQUM4SDtZQUM3QixJQUFJUCxlQUFlTyxLQUFLO2dCQUN0Qk4sY0FBYztnQkFDZEUscUJBQXFCO2dCQUNyQjtZQUNGO1lBQ0FGLGNBQWNNO1lBQ2RKLHFCQUFxQixPQUFPLDBCQUEwQjtRQUN4RDtzQ0FBRztRQUFDSDtLQUFXO0lBRWYsOEVBQThFO0lBQzlFLE1BQU1RLGNBQWM5SCw4Q0FBT0E7cUNBQUM7WUFDMUIsTUFBTStILE9BQU8sSUFBSUM7WUFDakIsT0FBT3hFLE9BQ0paLEdBQUc7NkNBQUNxRixDQUFBQSxLQUFNQSxHQUFHQyxPQUFPLElBQUk7d0JBQUUzRSxRQUFRMEUsR0FBRzFFLE1BQU07b0JBQUM7NENBQzVDTixNQUFNOzZDQUFDa0YsQ0FBQUE7b0JBQ04sSUFBSSxDQUFDQSxFQUFFNUUsTUFBTSxJQUFJd0UsS0FBS0ssR0FBRyxDQUFDRCxFQUFFNUUsTUFBTSxHQUFHLE9BQU87b0JBQzVDd0UsS0FBS00sR0FBRyxDQUFDRixFQUFFNUUsTUFBTTtvQkFDakIsT0FBTztnQkFDVDs7UUFDSjtvQ0FBRztRQUFDQztLQUFPO0lBRVgsbUJBQW1CO0lBQ25CNUQsZ0RBQVNBOzBCQUFDO1lBQ1IsSUFBSXVHLGNBQWNtQyxPQUFPLEVBQUVDLGFBQWFwQyxjQUFjbUMsT0FBTztZQUM3RCxJQUFJLENBQUNuRCxPQUFPcUQsSUFBSSxJQUFJO2dCQUNsQmxELGlCQUFpQixFQUFFO2dCQUNuQjtZQUNGO1lBQ0FhLGNBQWNtQyxPQUFPLEdBQUdHO2tDQUFXO29CQUNqQyxNQUFNQyxJQUFJdkQsT0FBT3FELElBQUksR0FBR0csV0FBVztvQkFDbkMsTUFBTUMsVUFBVWQsWUFBWTdFLE1BQU07a0RBQUNrRixDQUFBQSxJQUNqQyxFQUFHVSxZQUFZLElBQUlWLEVBQUVVLFlBQVksQ0FBQ0YsV0FBVyxHQUFHRyxRQUFRLENBQUNKLE1BQ3hEUCxFQUFFWSxRQUFRLElBQUlaLEVBQUVZLFFBQVEsQ0FBQ0osV0FBVyxHQUFHRyxRQUFRLENBQUNKLE1BQ2hEUCxFQUFFNUUsTUFBTSxJQUFJNEUsRUFBRTVFLE1BQU0sQ0FBQ29GLFdBQVcsR0FBR0csUUFBUSxDQUFDSjtpREFDN0NNLEtBQUssQ0FBQyxHQUFHLEtBQUssU0FBUztvQkFDekIxRCxpQkFBaUJzRDtnQkFDbkI7aUNBQUc7UUFDSCx1REFBdUQ7UUFDekQ7eUJBQUc7UUFBQ3pEO1FBQVEyQztLQUFZO0lBRXhCLGtDQUFrQztJQUNsQyxNQUFNbUIsWUFBWW5KLDZDQUFNQSxDQUFpQjtJQUN6Q0YsZ0RBQVNBOzBCQUFDO1lBQ1IsU0FBU3NKLFlBQVlDLENBQWE7Z0JBQ2hDLElBQUlGLFVBQVVYLE9BQU8sSUFBSSxDQUFDVyxVQUFVWCxPQUFPLENBQUNjLFFBQVEsQ0FBQ0QsRUFBRXZILE1BQU0sR0FBVztvQkFDdEU0RCxpQkFBaUI7Z0JBQ25CO1lBQ0Y7WUFDQSxJQUFJRCxlQUFlOEQsU0FBU0MsZ0JBQWdCLENBQUMsYUFBYUo7WUFDMUQ7a0NBQU8sSUFBTUcsU0FBU0UsbUJBQW1CLENBQUMsYUFBYUw7O1FBQ3pEO3lCQUFHO1FBQUMzRDtLQUFjO0lBRWxCLDRCQUE0QjtJQUM1QixNQUFNaUUsaUJBQWlCekosa0RBQVdBOzRDQUFDLENBQUMwSjtZQUNsQyxNQUFNN0gsU0FBUzZILE9BQU8sQ0FBQyxFQUFFO1lBQ3pCLElBQUk3SCxPQUFPOEgsY0FBYyxJQUFJLENBQUMvRSxpQkFBaUJFLFNBQVM7Z0JBQ3RELE1BQU04RSxjQUFjbkcsTUFBTSxDQUFDQSxPQUFPb0csTUFBTSxHQUFHLEVBQUU7Z0JBQzdDLElBQUlELGFBQWE7b0JBQ2YvRSxpQkFBaUI7b0JBQ2pCakIsWUFBWTt3QkFBRWtHLE9BQU9GLFlBQVlHLFVBQVU7b0JBQUMsR0FDekNDLElBQUk7NERBQUNDLENBQUFBOzRCQUNKbEYsV0FBV2tGOzRCQUNYcEYsaUJBQWlCOzRCQUNqQkksY0FBYyxJQUFJLHdDQUF3Qzt3QkFDNUQ7MkRBQ0NpRixLQUFLOzREQUFDOzRCQUNMckYsaUJBQWlCOzRCQUNqQkk7b0VBQWNrRixDQUFBQSxPQUFRQSxPQUFPOzt3QkFDL0I7O2dCQUNKO1lBQ0Y7UUFDRjsyQ0FBRztRQUFDMUc7UUFBUUc7UUFBYWdCO1FBQWVFO0tBQVE7SUFFaEQsOEJBQThCO0lBQzlCakYsZ0RBQVNBOzBCQUFDO1lBQ1IsSUFBSXlHLFlBQVlpQyxPQUFPLElBQUksQ0FBQ2xDLFlBQVlrQyxPQUFPLEVBQUU7Z0JBQy9DbEMsWUFBWWtDLE9BQU8sR0FBRyxJQUFJNkIscUJBQXFCWCxnQkFBZ0I7b0JBQzdEWSxNQUFNO29CQUNOQyxZQUFZO29CQUNaQyxXQUFXO2dCQUNiO1lBQ0Y7WUFFQSxJQUFJakUsWUFBWWlDLE9BQU8sRUFBRTtvQkFDdkJsQztpQkFBQUEsdUJBQUFBLFlBQVlrQyxPQUFPLGNBQW5CbEMsMkNBQUFBLHFCQUFxQm1FLE9BQU8sQ0FBQ2xFLFlBQVlpQyxPQUFPO1lBQ2xEO1lBRUE7a0NBQU87d0JBQ0xsQztxQkFBQUEsdUJBQUFBLFlBQVlrQyxPQUFPLGNBQW5CbEMsMkNBQUFBLHFCQUFxQm9FLFVBQVU7Z0JBQ2pDOztRQUNGO3lCQUFHO1FBQUNoQjtLQUFlO0lBRW5CLHFDQUFxQztJQUNyQyxNQUFNaUIsa0JBQWtCLENBQUNDO1FBQ3ZCbEcsaUJBQWlCa0c7UUFDakJqQyxXQUFXO1lBQ1RuRSxvQkFBb0I7WUFDcEJFLGlCQUFpQjtRQUNuQixHQUFHO0lBQ0w7SUFFQSxnQkFBZ0I7SUFDaEI1RSxnREFBU0E7MEJBQUM7WUFDUixpREFBaUQ7WUFDakQrRCxjQUFjb0csSUFBSTtrQ0FBQztvQkFDakIsb0RBQW9EO29CQUNwRHRCOzBDQUFXOzRCQUNULElBQUlqRixPQUFPb0csTUFBTSxHQUFHLEdBQUc7Z0NBQ3JCLE1BQU1lLFNBQVNuSCxNQUFNLENBQUNBLE9BQU9vRyxNQUFNLEdBQUcsRUFBRTtnQ0FDeEMsSUFBSWUsUUFBUTtvQ0FDVmhILFlBQVk7d0NBQUVrRyxPQUFPYyxPQUFPYixVQUFVO3dDQUFFYyxPQUFPO29DQUFHO2dDQUNwRDs0QkFDRjt3QkFDRjt5Q0FBRyxNQUFNLHFDQUFxQztnQkFDaEQ7O1lBQ0EsOENBQThDO1lBQzlDLE1BQU1DLFdBQVdDOzJDQUFZO29CQUMzQm5IO2dCQUNGOzBDQUFHO1lBQ0g7a0NBQU8sSUFBTW9ILGNBQWNGOztRQUM3Qjt5QkFBRztRQUFDbEg7S0FBWTtJQUVoQixxREFBcUQ7SUFDckQvRCxnREFBU0E7MEJBQUM7WUFDUixNQUFNb0wsV0FBV0MsTUFBTUMsSUFBSSxDQUN6QixJQUFJbEQsSUFDRnhFLE9BQU8ySCxPQUFPOzJDQUFDbEQsQ0FBQUEsS0FDYixDQUFDQSxHQUFHbUQsS0FBSyxJQUFJLEVBQUUsRUFBRW5JLE1BQU07bURBQUN0QixDQUFBQSxNQUFPLENBQUNBLElBQUlvQixLQUFLLENBQUM7OztZQUloRGlJLFNBQVNLLE9BQU87a0NBQUMsT0FBTTFKO29CQUNyQixJQUFJLENBQUN3QyxZQUFZLENBQUN4QyxJQUFJLEVBQUU7d0JBQ3RCLE1BQU1ILFVBQVUsTUFBTXZCLHlFQUFnQkEsQ0FBQzBCO3dCQUN2Q3lDOzhDQUFnQjhGLENBQUFBLE9BQVM7b0NBQUUsR0FBR0EsSUFBSTtvQ0FBRSxDQUFDdkksSUFBSSxFQUFFSDtnQ0FBUTs7b0JBQ3JEO2dCQUNGOztRQUNBLHVEQUF1RDtRQUN6RDt5QkFBRztRQUFDZ0M7S0FBTztJQUVYLDhCQUE4QjtJQUM5QixNQUFNOEgsa0JBQWtCLENBQUNDO1FBQ3ZCLCtFQUErRTtRQUMvRSxNQUFNQyxjQUFjUCxNQUFNQyxJQUFJLENBQzVCLElBQUlsRCxJQUNGO1lBQ0UsNkRBQTZEO2VBQzFELENBQUN1RCxNQUFNdEgsT0FBTyxDQUFDbEIsS0FBSyxDQUFDLDhDQUFnQyxFQUFFLEVBQUVILEdBQUcsQ0FBQyxDQUFDNkksSUFBY0EsRUFBRXpDLEtBQUssQ0FBQyxHQUFHTCxXQUFXO1lBQ3JHLDhCQUE4QjtlQUMzQixDQUFDNEMsTUFBTXRILE9BQU8sQ0FBQ2xCLEtBQUssQ0FBQyxnREFBa0MsRUFBRSxFQUFFSCxHQUFHLENBQUMsQ0FBQzZJLElBQWNBLEVBQUVDLE9BQU8sQ0FBQyxNQUFNLElBQUkxQyxLQUFLLENBQUMsR0FBR0wsV0FBVztZQUN6SCxnREFBZ0Q7ZUFDN0MsQ0FBQzRDLE1BQU10SCxPQUFPLENBQUNsQixLQUFLLENBQUMsaURBQWtDLEVBQUUsRUFBRUgsR0FBRyxDQUFDLENBQUM2SSxJQUFjQSxFQUFFQyxPQUFPLENBQUMsTUFBTSxJQUFJL0MsV0FBVztTQUNqSDtRQUdMLDJFQUEyRTtRQUMzRSxNQUFNZ0QsVUFBVSxDQUFDSixNQUFNSyxJQUFJLElBQUksRUFBRSxFQUM5QjNJLE1BQU0sQ0FBQyxDQUFDNEksSUFBV0EsQ0FBQyxDQUFDLEVBQUUsSUFBSSwwQ0FBNEJDLElBQUksQ0FBQ0QsQ0FBQyxDQUFDLEVBQUUsR0FDaEVqSixHQUFHLENBQUMsQ0FBQ2lKLElBQVdBLENBQUMsQ0FBQyxFQUFFLENBQUNsRCxXQUFXO1FBQ25DLE9BQU9zQyxNQUFNQyxJQUFJLENBQUMsSUFBSWxELElBQUk7ZUFBSXdEO2VBQWdCRztTQUFRO0lBQ3hEO0lBRUEscUNBQXFDO0lBQ3JDLE1BQU1JLG1CQUFtQmpNLDZDQUFNQSxDQUE2QixDQUFDO0lBQzdELE1BQU1rTSxnQkFBZ0JoTSw4Q0FBT0E7dUNBQTZCO1lBQ3hELElBQUksQ0FBQ3dELE9BQU9vRyxNQUFNLEVBQUUsT0FBT21DLGlCQUFpQnpELE9BQU87WUFDbkQsTUFBTTFGLE1BQWtDLENBQUM7WUFDekNZLE9BQU82SCxPQUFPOytDQUFDLENBQUNwRDtvQkFBY3JGLEdBQUcsQ0FBQ3FGLEdBQUdnRSxFQUFFLENBQUMsR0FBR1gsZ0JBQWdCckQ7Z0JBQUs7O1lBQ2hFOEQsaUJBQWlCekQsT0FBTyxHQUFHMUY7WUFDM0IsT0FBT0E7UUFDVDtzQ0FBRztRQUFDWTtLQUFPO0lBRVgsMEJBQTBCO0lBQzFCLE1BQU0wSSxnQkFBZ0JuTSxrREFBV0E7MkNBQUMsT0FBT29NO1lBQ3ZDekcsV0FBV3lHO1lBQ1h2RyxrQkFBa0IsRUFBRTtZQUNwQlIsVUFBVTtZQUNWRSxpQkFBaUIsRUFBRTtZQUNuQixnQkFBZ0I7WUFDaEIsTUFBTXJDLFNBQVM7Z0JBQUVtSixPQUFPO29CQUFDO2lCQUFFO2dCQUFFLE1BQU07b0JBQUNELElBQUl4RCxXQUFXO2lCQUFHO2dCQUFFaUMsT0FBTztZQUFHO1lBQ2xFLE1BQU15QixRQUFRLE1BQU1ySixpQkFBaUJDO1lBQ3JDMkMsa0JBQWtCeUcsU0FBUyxFQUFFO1FBQy9COzBDQUFHLEVBQUU7SUFFTCw2QkFBNkI7SUFDN0IsU0FBU0MsZUFBZXJFLEVBQU87UUFDN0IsTUFBTTJELE9BQU9JLGFBQWEsQ0FBQy9ELEdBQUdnRSxFQUFFLENBQUMsSUFBSSxFQUFFO1FBQ3ZDLElBQUksQ0FBQ0wsS0FBS2hDLE1BQU0sRUFBRSxPQUFPO1FBQ3pCLHFCQUNFLDhEQUFDeEg7WUFBSU4sV0FBVTtzQkFDWjhKLEtBQUtoSixHQUFHLENBQUN1SixDQUFBQSxvQkFDUiw4REFBQ0k7b0JBRUN6SyxXQUFVO29CQUNWMEssU0FBU3JELENBQUFBO3dCQUFPQSxFQUFFc0QsZUFBZTt3QkFBSVAsY0FBY0M7b0JBQU07O3dCQUMxRDt3QkFDR0E7O21CQUpHQTs7Ozs7Ozs7OztJQVNmO0lBRUEsdUNBQXVDO0lBQ3ZDLE1BQU1PLGlCQUFpQixDQUFDL0csZUFBZWlFLE1BQU0sR0FBRyxJQUFJakUsaUJBQWlCbkMsTUFBSyxFQUFHUCxNQUFNLENBQUNnRixDQUFBQTtRQUNsRixJQUFJLENBQUNwQyxXQUFXLE9BQU87UUFDdkIsdURBQXVEO1FBQ3ZELE1BQU04RyxXQUFZMUUsR0FBR2hFLE9BQU8sSUFBSWdFLEdBQUdoRSxPQUFPLENBQUMwRSxXQUFXLEdBQUdHLFFBQVEsQ0FBQ2pELFVBQVU4QyxXQUFXO1FBQ3ZGLE1BQU1pRSxXQUFXLENBQUMzRSxHQUFHMkQsSUFBSSxJQUFJLEVBQUUsRUFBRWhKLEdBQUcsQ0FBQyxDQUFDaUo7Z0JBQVdBLGlCQUFBQTttQkFBQUEsRUFBQUEsTUFBQUEsQ0FBQyxDQUFDLEVBQUUsY0FBSkEsMkJBQUFBLGtCQUFBQSxJQUFNbEQsV0FBVyxjQUFqQmtELHNDQUFBQSxxQkFBQUEsU0FBeUI7O1FBQzFFLE9BQU9jLFlBQVlDLFNBQVM5RCxRQUFRLENBQUNqRCxVQUFVOEMsV0FBVztJQUM1RDtJQUVBLGdDQUFnQztJQUNoQyxNQUFNa0UsbUJBQW1CN00sOENBQU9BOzBDQUFDO1lBQy9CLE1BQU04TSxZQUF1QyxDQUFDO1lBQzlDdEosT0FBTzZILE9BQU87a0RBQUNwRCxDQUFBQTtvQkFDYixNQUFNMkQsT0FBT0ksYUFBYSxDQUFDL0QsR0FBR2dFLEVBQUUsQ0FBQyxJQUFJLEVBQUU7b0JBQ3ZDTCxLQUFLUCxPQUFPOzBEQUFDYyxDQUFBQTs0QkFDWFcsU0FBUyxDQUFDWCxJQUFJLEdBQUcsQ0FBQ1csU0FBUyxDQUFDWCxJQUFJLElBQUksS0FBSzt3QkFDM0M7O2dCQUNGOztZQUNBLGdDQUFnQztZQUNoQyxPQUFPWSxPQUFPdEQsT0FBTyxDQUFDcUQsV0FDbkJFLElBQUk7a0RBQUMsQ0FBQ3ZMLEdBQUd3TCxJQUFNQSxDQUFDLENBQUMsRUFBRSxHQUFHeEwsQ0FBQyxDQUFDLEVBQUU7aURBQzFCdUgsS0FBSyxDQUFDLEdBQUc7UUFDZDt5Q0FBRztRQUFDeEY7UUFBUXdJO0tBQWM7SUFFMUIsc0NBQXNDO0lBQ3RDcE0sZ0RBQVNBOzBCQUFDO1lBQ1IsSUFBSXNOLFlBQVk7WUFDaEI7a0NBQUM7b0JBQ0MsTUFBTUMsVUFBVVQsZUFBZTlKLEdBQUc7a0RBQUNxRixDQUFBQSxLQUFNQSxHQUFHZ0UsRUFBRTs7b0JBQzlDLElBQUlrQixRQUFRdkQsTUFBTSxLQUFLLEdBQUc7b0JBQzFCLHlEQUF5RDtvQkFDekQsTUFBTXdELGFBQWEsTUFBTXBLLGlCQUFpQjt3QkFBRW9KLE9BQU87NEJBQUM7eUJBQUU7d0JBQUUsTUFBTWU7d0JBQVN2QyxPQUFPO29CQUFLO29CQUNuRixJQUFJLENBQUNzQyxXQUFXO29CQUNoQix1QkFBdUI7b0JBQ3ZCLE1BQU1HLFNBQXVDLENBQUM7b0JBQzlDLE1BQU1DLFFBQXVDLENBQUM7b0JBQzlDRix1QkFBQUEsaUNBQUFBLFdBQVkvQixPQUFPOzBDQUFDLENBQUNwRDs0QkFDbkIsTUFBTXNGLFFBQVEsQ0FBQ3RGLEdBQUcyRCxJQUFJLENBQUM0QixJQUFJO2tEQUFDLENBQUMzQixJQUFXQSxDQUFDLENBQUMsRUFBRSxLQUFLO29EQUFRLEVBQUUsQ0FBQyxDQUFDLEVBQUU7NEJBQy9ELElBQUkwQixPQUFPO2dDQUNURixNQUFNLENBQUNFLE1BQU0sR0FBRyxDQUFDRixNQUFNLENBQUNFLE1BQU0sSUFBSSxLQUFLO2dDQUN2QyxJQUFJdEYsR0FBRzFFLE1BQU0sS0FBS0EsUUFBUStKLEtBQUssQ0FBQ0MsTUFBTSxHQUFHOzRCQUMzQzt3QkFDRjs7b0JBQ0E5RyxjQUFjNEc7b0JBQ2QxRyxjQUFjMkc7Z0JBQ2hCOztZQUNBO2tDQUFPO29CQUFRSixZQUFZO2dCQUFPOztRQUNwQzt5QkFBRztRQUFDUjtRQUFnQm5KO0tBQU87SUFFM0IscUNBQXFDO0lBQ3JDLE1BQU1rSyxhQUFhMU4sa0RBQVdBO3dDQUFDLE9BQU8ySyxRQUFnQmdEO1lBQ3BELElBQUksQ0FBQ25LLFVBQVUsQ0FBQ29LLE9BQU9DLEtBQUssRUFBRTtZQUM5QiwyQkFBMkI7WUFDM0JuSDtnREFBY3lELENBQUFBLE9BQVM7d0JBQUUsR0FBR0EsSUFBSTt3QkFBRSxDQUFDUSxPQUFPLEVBQUUsQ0FBQ1IsSUFBSSxDQUFDUSxPQUFPLElBQUksS0FBSztvQkFBRTs7WUFDcEUvRDtnREFBY3VELENBQUFBLE9BQVM7d0JBQUUsR0FBR0EsSUFBSTt3QkFBRSxDQUFDUSxPQUFPLEVBQUU7b0JBQUs7O1lBQ2pELG1CQUFtQjtZQUNuQixNQUFNYSxRQUFRO2dCQUNac0MsTUFBTTtnQkFDTnRLO2dCQUNBdUcsWUFBWTFJLEtBQUtDLEtBQUssQ0FBQ0gsS0FBS0QsR0FBRyxLQUFLO2dCQUNwQzJLLE1BQU07b0JBQ0o7d0JBQUM7d0JBQUtsQjtxQkFBTztvQkFDYjt3QkFBQzt3QkFBS2dEO3FCQUFXO2lCQUNsQjtnQkFDRHpKLFNBQVM7Z0JBQ1Q2SixLQUFLO1lBQ1A7WUFDQSxtQkFBbUI7WUFDbkIsSUFBSTtnQkFDRixNQUFNQyxTQUFTLE1BQU1KLE9BQU9DLEtBQUssQ0FBQ0ksU0FBUyxDQUFDekM7WUFDNUMsc0NBQXNDO1lBQ3hDLEVBQUUsT0FBTzBDLEtBQUs7Z0JBQ1osc0NBQXNDO2dCQUN0Q3hIO29EQUFjeUQsQ0FBQUEsT0FBUzs0QkFBRSxHQUFHQSxJQUFJOzRCQUFFLENBQUNRLE9BQU8sRUFBRXRKLEtBQUs4TSxHQUFHLENBQUMsQ0FBQ2hFLElBQUksQ0FBQ1EsT0FBTyxJQUFJLEtBQUssR0FBRzt3QkFBRzs7Z0JBQ2pGL0Q7b0RBQWN1RCxDQUFBQSxPQUFTOzRCQUFFLEdBQUdBLElBQUk7NEJBQUUsQ0FBQ1EsT0FBTyxFQUFFO3dCQUFNOztZQUNwRDtRQUNGO3VDQUFHO1FBQUNuSDtLQUFPO0lBRVgsd0NBQXdDO0lBQ3hDM0QsZ0RBQVNBOzBCQUFDO1lBQ1IsSUFBSXNOLFlBQVk7WUFDaEI7a0NBQUM7b0JBQ0MsTUFBTUMsVUFBVVQsZUFBZTlKLEdBQUc7a0RBQUNxRixDQUFBQSxLQUFNQSxHQUFHZ0UsRUFBRTs7b0JBQzlDLElBQUlrQixRQUFRdkQsTUFBTSxLQUFLLEdBQUc7b0JBQzFCLDJEQUEyRDtvQkFDM0QsTUFBTXVFLGVBQWUsTUFBTW5MLGlCQUFpQjt3QkFBRW9KLE9BQU87NEJBQUM7eUJBQUU7d0JBQUUsTUFBTWU7d0JBQVN2QyxPQUFPO29CQUFLO29CQUNyRixJQUFJLENBQUNzQyxXQUFXO29CQUNoQix5QkFBeUI7b0JBQ3pCLE1BQU1HLFNBQXVDLENBQUM7b0JBQzlDLE1BQU1lLFdBQTBDLENBQUM7b0JBQ2pERCx5QkFBQUEsbUNBQUFBLGFBQWM5QyxPQUFPOzBDQUFDLENBQUNwRDs0QkFDckIsTUFBTXNGLFFBQVEsQ0FBQ3RGLEdBQUcyRCxJQUFJLENBQUM0QixJQUFJO2tEQUFDLENBQUMzQixJQUFXQSxDQUFDLENBQUMsRUFBRSxLQUFLO29EQUFRLEVBQUUsQ0FBQyxDQUFDLEVBQUU7NEJBQy9ELElBQUkwQixPQUFPO2dDQUNURixNQUFNLENBQUNFLE1BQU0sR0FBRyxDQUFDRixNQUFNLENBQUNFLE1BQU0sSUFBSSxLQUFLO2dDQUN2QyxJQUFJdEYsR0FBRzFFLE1BQU0sS0FBS0EsUUFBUTZLLFFBQVEsQ0FBQ2IsTUFBTSxHQUFHOzRCQUM5Qzt3QkFDRjs7b0JBQ0ExRyxnQkFBZ0J3RztvQkFDaEJ0RyxpQkFBaUJxSDtnQkFDbkI7O1lBQ0E7a0NBQU87b0JBQVFsQixZQUFZO2dCQUFPOztRQUNwQzt5QkFBRztRQUFDUjtRQUFnQm5KO0tBQU87SUFFM0IsdUNBQXVDO0lBQ3ZDLE1BQU04SyxlQUFldE8sa0RBQVdBOzBDQUFDLE9BQU8ySyxRQUFnQmdELFlBQW9CWTtZQUMxRSxJQUFJLENBQUMvSyxVQUFVLENBQUNvSyxPQUFPQyxLQUFLLEVBQUU7WUFDOUIsMkJBQTJCO1lBQzNCL0c7a0RBQWdCcUQsQ0FBQUEsT0FBUzt3QkFBRSxHQUFHQSxJQUFJO3dCQUFFLENBQUNRLE9BQU8sRUFBRSxDQUFDUixJQUFJLENBQUNRLE9BQU8sSUFBSSxLQUFLO29CQUFFOztZQUN0RTNEO2tEQUFpQm1ELENBQUFBLE9BQVM7d0JBQUUsR0FBR0EsSUFBSTt3QkFBRSxDQUFDUSxPQUFPLEVBQUU7b0JBQUs7O1lBQ3BELHFCQUFxQjtZQUNyQixNQUFNYSxRQUFRO2dCQUNac0MsTUFBTTtnQkFDTnRLO2dCQUNBdUcsWUFBWTFJLEtBQUtDLEtBQUssQ0FBQ0gsS0FBS0QsR0FBRyxLQUFLO2dCQUNwQzJLLE1BQU07b0JBQ0o7d0JBQUM7d0JBQUtsQjtxQkFBTztvQkFDYjt3QkFBQzt3QkFBS2dEO3FCQUFXO2lCQUNsQjtnQkFDRHpKLFNBQVNxSztnQkFDVFIsS0FBSztZQUNQO1lBQ0EsbUJBQW1CO1lBQ25CLElBQUk7Z0JBQ0YsTUFBTUMsU0FBUyxNQUFNSixPQUFPQyxLQUFLLENBQUNJLFNBQVMsQ0FBQ3pDO1lBQzVDLHNDQUFzQztZQUN4QyxFQUFFLE9BQU8wQyxLQUFLO2dCQUNaLHNDQUFzQztnQkFDdENwSDtzREFBZ0JxRCxDQUFBQSxPQUFTOzRCQUFFLEdBQUdBLElBQUk7NEJBQUUsQ0FBQ1EsT0FBTyxFQUFFdEosS0FBSzhNLEdBQUcsQ0FBQyxDQUFDaEUsSUFBSSxDQUFDUSxPQUFPLElBQUksS0FBSyxHQUFHO3dCQUFHOztnQkFDbkYzRDtzREFBaUJtRCxDQUFBQSxPQUFTOzRCQUFFLEdBQUdBLElBQUk7NEJBQUUsQ0FBQ1EsT0FBTyxFQUFFO3dCQUFNOztZQUN2RDtRQUNGO3lDQUFHO1FBQUNuSDtLQUFPO0lBRVgscUVBQXFFO0lBQ3JFLFNBQVNnTCx1QkFBdUJuRCxLQUFlLEVBQUVqSCxZQUFtRCxFQUFFOEMsZ0JBQXVDO1FBQzNJLElBQUksQ0FBQ21FLFNBQVNBLE1BQU14QixNQUFNLEtBQUssR0FBRyxPQUFPO1FBQ3pDLE1BQU00RSxTQUFTcEQsTUFBTW5JLE1BQU0sQ0FBQ3RCLENBQUFBLE1BQU9BLElBQUlvQixLQUFLLENBQUM7UUFDN0Msc0NBQXNDO1FBQ3RDLE1BQU0wTCxlQUFlO1FBQ3JCLE1BQU1DLGtCQUFrQjtRQUN4QixNQUFNQyxTQUFTdkQsTUFBTW5JLE1BQU0sQ0FBQ3RCLENBQUFBLE1BQU9BLElBQUlvQixLQUFLLENBQUMscUJBQXFCMEwsYUFBYTNDLElBQUksQ0FBQ25LO1FBQ3BGLE1BQU1pTixTQUFTeEQsTUFBTW5JLE1BQU0sQ0FBQ3RCLENBQUFBLE1BQU9BLElBQUlvQixLQUFLLENBQUMsd0JBQXdCMkwsZ0JBQWdCNUMsSUFBSSxDQUFDbks7UUFDMUYsTUFBTWtOLFdBQVcsSUFBSTdHLElBQUk7ZUFBSXdHO2VBQVdHO2VBQVdDO1NBQU87UUFDMUQsTUFBTUUsUUFBUTFELE1BQU1uSSxNQUFNLENBQUN0QixDQUFBQSxNQUFPLENBQUNrTixTQUFTekcsR0FBRyxDQUFDekcsUUFBUSxDQUFDQSxJQUFJb0IsS0FBSyxDQUFDLGtEQUFrRCxDQUFDMEwsYUFBYTNDLElBQUksQ0FBQ25LLFFBQVEsQ0FBQytNLGdCQUFnQjVDLElBQUksQ0FBQ25LO1FBQ3RLLHFCQUNFLDhEQUFDUztZQUFJTixXQUFVOztnQkFDWjBNLE9BQU81RSxNQUFNLEdBQUcsbUJBQ2YsOERBQUN4SDtvQkFBSU4sV0FBVyxjQUF3RyxPQUExRjBNLE9BQU81RSxNQUFNLEtBQUssSUFBSSxnQkFBZ0I0RSxPQUFPNUUsTUFBTSxLQUFLLElBQUksZ0JBQWdCOzhCQUN2RzRFLE9BQU94RixLQUFLLENBQUMsR0FBRyxHQUFHcEcsR0FBRyxDQUFDLENBQUNqQixLQUFLb04sTUFDNUIsK0NBQStDO3NDQUMvQyw4REFBQy9NOzRCQUVDQyxLQUFLTjs0QkFDTE8sS0FBSTs0QkFDSkosV0FBVTs0QkFDVjBLLFNBQVNyRCxDQUFBQTtnQ0FBT0EsRUFBRXNELGVBQWU7Z0NBQUl4RixpQkFBaUJ0Rjs0QkFBTTsyQkFKdkRvTjs7Ozs7Ozs7OztnQkFTWEosQ0FBQUEsT0FBTy9FLE1BQU0sR0FBRyxLQUFLZ0YsT0FBT2hGLE1BQU0sR0FBRyxvQkFDckMsOERBQUN4SDtvQkFBSU4sV0FBVTs4QkFDWjsyQkFBSTZNOzJCQUFXQztxQkFBTyxDQUFDaE0sR0FBRyxDQUFDLENBQUNqQixLQUFLb04sb0JBQ2hDLDhEQUFDM007NEJBQWNOLFdBQVU7OzhDQUN2Qiw4REFBQzFCLHVFQUFXQTtvQ0FBQ3VCLEtBQUtBO29DQUFLRyxXQUFVOzs7Ozs7OENBQ2pDLDhEQUFDa047b0NBQUtsTixXQUFVOzhDQUNiSCxJQUFJb0IsS0FBSyxDQUFDLHFCQUFxQjBMLGFBQWEzQyxJQUFJLENBQUNuSyxPQUFPLFVBQVU7Ozs7Ozs7MkJBSDdEb047Ozs7Ozs7Ozs7Z0JBU2ZELE1BQU1sRixNQUFNLEdBQUcsbUJBQ2QsOERBQUN4SDtvQkFBSU4sV0FBVTs4QkFDWmdOLE1BQU1sTSxHQUFHLENBQUMsQ0FBQ2pCLEtBQUtvTixNQUNmNUssWUFBWSxDQUFDeEMsSUFBSSxHQUNmd0MsWUFBWSxDQUFDeEMsSUFBSSxJQUFJSixrQkFBa0I0QyxZQUFZLENBQUN4QyxJQUFJLGtCQUV4RCw4REFBQ0Y7NEJBRUNDLE1BQU1DOzRCQUNOQyxRQUFPOzRCQUNQQyxLQUFJOzRCQUNKQyxXQUFVO3NDQUVUSDsyQkFOSW9OOzs7Ozs7Ozs7Ozs7Ozs7O0lBY3JCO0lBRUEsU0FBU0UsZ0JBQWdCLEtBQXdFO1lBQXhFLEVBQUVDLFFBQVEsRUFBRUMsSUFBSSxFQUF3RCxHQUF4RTs7UUFDdkIsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUd4UCwrQ0FBUUEsQ0FBQztRQUNqQyxNQUFNeVAsTUFBTXhQLDZDQUFNQSxDQUFpQjtRQUNuQyxrQ0FBa0M7UUFDbENGLGdEQUFTQTs4Q0FBQztnQkFDUixTQUFTc0osWUFBWUMsQ0FBYTtvQkFDaEMsSUFBSW1HLElBQUloSCxPQUFPLElBQUksQ0FBQ2dILElBQUloSCxPQUFPLENBQUNjLFFBQVEsQ0FBQ0QsRUFBRXZILE1BQU0sR0FBV3lOLFFBQVE7Z0JBQ3RFO2dCQUNBLElBQUlELE1BQU0vRixTQUFTQyxnQkFBZ0IsQ0FBQyxhQUFhSjtnQkFDakQ7c0RBQU8sSUFBTUcsU0FBU0UsbUJBQW1CLENBQUMsYUFBYUw7O1lBQ3pEOzZDQUFHO1lBQUNrRztTQUFLO1FBQ1QscUJBQ0UsOERBQUNoTjtZQUFJTixXQUFVO1lBQVd3TixLQUFLQTs7OEJBRTdCLDhEQUFDbE47b0JBQUlvSyxTQUFTLElBQU02QyxRQUFRRSxDQUFBQSxJQUFLLENBQUNBO29CQUFJek4sV0FBVTs4QkFDN0NvTjs7Ozs7O2dCQUVGRSxzQkFDQyw4REFBQ2hOO29CQUFJTixXQUFVOzhCQUNacU47Ozs7Ozs7Ozs7OztJQUtYO1FBeEJTRjtJQTBCVCxTQUFTMUk7O1FBQ1AsTUFBTSxDQUFDaUosWUFBWUMsY0FBYyxHQUFHNVAsK0NBQVFBLENBQWdCO1FBRTVERCxnREFBU0E7c0RBQUM7Z0JBQ1IsTUFBTThQO3lFQUFhO3dCQUNqQixJQUFJOzRCQUNGLHFCQUFxQjs0QkFDckIsTUFBTSxFQUFFeE0sYUFBYSxFQUFFLEdBQUcsTUFBTTdDLGtFQUFnQkE7NEJBQ2hELHVFQUF1RTs0QkFDdkUsTUFBTXNQLFNBQVMsTUFBTXJQLGdFQUFjQSxDQUFDNEMsZUFBZTtnQ0FDakQwSCxPQUFPOzRCQUNUOzRCQUNBLDBCQUEwQjs0QkFDMUIsTUFBTWdGLFlBQVksSUFBSTVILElBQUksQ0FBQzJILFVBQVUsRUFBRSxFQUFFL00sR0FBRztxRkFBQ3FGLENBQUFBLEtBQU1BLEdBQUdnRSxFQUFFOzs0QkFDeER3RCxjQUFjRyxVQUFVQyxJQUFJO3dCQUM5QixFQUFFLE9BQU8xRyxHQUFHOzRCQUNWc0csY0FBYzt3QkFDaEI7b0JBQ0Y7O2dCQUNBQztZQUNGO3FEQUFHLEVBQUU7UUFFTCxPQUFPRjtJQUNUO1FBdkJTako7SUF5QlQsNENBQTRDO0lBQzVDM0csZ0RBQVNBOzBCQUFDO1lBQ1Isb0ZBQW9GO1lBQ3BGeUgsZ0JBQWdCO1FBQ2xCO3lCQUFHLEVBQUU7SUFFTCx3Q0FBd0M7SUFDeEMsTUFBTXlJLGtCQUFrQixDQUFDdk07UUFDdkJvRSxxQkFBcUJwRTtRQUNyQmdFLGNBQWM7UUFDZEUscUJBQXFCLE9BQU8sMkJBQTJCO0lBQ3pEO0lBRUEscUNBQXFDO0lBQ3JDN0gsZ0RBQVNBOzBCQUFDO1lBQ1IsSUFBSSxDQUFDMEgsWUFBWTtnQkFDZkcscUJBQXFCO2dCQUNyQjtZQUNGO1lBQ0EsSUFBSXNJLFlBQTZCO1lBQ2pDLElBQUl6SSxlQUFlLFdBQVc7Z0JBQzVCeUksMEJBQVksOERBQUNyUCx5REFBV0E7Ozs7O1lBQzFCLE9BQU8sSUFBSTRHLGVBQWUsVUFBVTtnQkFDbEN5SSwwQkFBWSw4REFBQ3BQLHlEQUFVQTs7Ozs7WUFDekIsT0FBTyxJQUFJMkcsZUFBZSxRQUFRO2dCQUNoQ3lJLDBCQUFZLDhEQUFDblAsdURBQVFBOzs7OztZQUN2QixPQUFPLElBQUkwRyxlQUFlLGFBQWFJLG1CQUFtQjtnQkFDeERxSSwwQkFBWSw4REFBQ3RQLHlEQUFXQTtvQkFBQ3VQLGNBQWN0STtvQkFBbUJ1SSxPQUFPOzBDQUFFLElBQU0xSSxjQUFjOzs7Ozs7O1lBQ3pGLE9BQU87Z0JBQ0wsOEJBQThCO2dCQUM5QndJLDBCQUFZLDhEQUFDM047b0JBQUlOLFdBQVU7OEJBQWlCOzs7Ozs7WUFDOUM7WUFDQTJGLHFCQUFxQnNJO1FBQ3ZCO3lCQUFHO1FBQUN6STtRQUFZSTtLQUFrQjtJQUVsQyxnQ0FBZ0M7SUFDaEMscUJBQXFCO0lBQ3JCLE1BQU0sQ0FBQ3dJLG1CQUFtQkMscUJBQXFCLEdBQUd0USwrQ0FBUUEsQ0FBZ0I7SUFDMUUsTUFBTSxDQUFDdVEsZ0JBQWdCQyxrQkFBa0IsR0FBR3hRLCtDQUFRQSxDQUFDO0lBQ3JERCxnREFBU0E7MEJBQUM7WUFDUixJQUFJMFEsVUFBVTtZQUNkLGVBQWVDO2dCQUNiRixrQkFBa0I7Z0JBQ2xCLElBQUk7b0JBQ0YsTUFBTSxFQUFFbk4sYUFBYSxFQUFFLEdBQUcsTUFBTTdDLGtFQUFnQkE7b0JBQ2hELElBQUlpUSxTQUFTSCxxQkFBcUJqTixjQUFjMEcsTUFBTTtnQkFDeEQsRUFBRSxVQUFNO29CQUNOLElBQUkwRyxTQUFTSCxxQkFBcUI7Z0JBQ3BDLFNBQVU7b0JBQ1IsSUFBSUcsU0FBU0Qsa0JBQWtCO2dCQUNqQztZQUNGO1lBQ0FFO1lBQ0EsdUNBQXVDO1lBQ3ZDLE1BQU0xRixXQUFXQyxZQUFZeUYsYUFBYTtZQUMxQztrQ0FBTztvQkFBUUQsVUFBVTtvQkFBT3ZGLGNBQWNGO2dCQUFXOztRQUMzRDt5QkFBRyxFQUFFO0lBRUwsZ0NBQWdDO0lBQ2hDLHFCQUNFLDhEQUFDekk7UUFBSU4sV0FBVTs7MEJBRWIsOERBQUMwTztnQkFBTTFPLFdBQVU7MEJBQ2YsNEVBQUNqQixtRUFBT0E7b0JBQUM0UCxPQUFPN0k7b0JBQVdOLFlBQVlBOzs7Ozs7Ozs7OzswQkFJekMsOERBQUNsRjtnQkFBSU4sV0FBVTswQkFDYiw0RUFBQ007b0JBQ0NOLFdBQVcsOEhBQTZLLE9BQS9Dd0YsY0FBY0Usb0JBQW9CLFVBQVUsSUFBRzs7c0NBR3hMLDhEQUFDcEY7NEJBQ0NOLFdBQVcsd0lBQXlMLE9BQWpEd0YsY0FBY0Usb0JBQW9CLEtBQUssV0FBVTs7OENBR3BNLDhEQUFDcEY7b0NBQUlOLFdBQVU7O3NEQUNiLDhEQUFDTTs0Q0FBSU4sV0FBVTs7OERBQ2IsOERBQUNNO29EQUFJTixXQUFVOzhEQUNiLDRFQUFDNE87d0RBQ0NDLE1BQUs7d0RBQ0xDLE9BQU96TDt3REFDUDBMLFVBQVUxSCxDQUFBQSxJQUFLL0QsVUFBVStELEVBQUV2SCxNQUFNLENBQUNnUCxLQUFLO3dEQUN2Q0UsU0FBUyxJQUFNdEwsaUJBQWlCO3dEQUNoQ3VMLGFBQVk7d0RBQ1pqUCxXQUFVO3dEQUNWa1AsY0FBYTs7Ozs7Ozs7Ozs7OERBR2pCLDhEQUFDekU7b0RBQ0N6SyxXQUFXLHlJQUFrTCxPQUF6Q2lFLGFBQWEseUJBQXlCO29EQUMxTHlHLFNBQVMsSUFBTXhHLGNBQWN1SixDQUFBQSxJQUFLLENBQUNBOzhEQUVsQ3hKLGFBQWEsaUJBQWlCOzs7Ozs7Ozs7Ozs7d0NBR2xDQSw0QkFDQyw4REFBQzNEOzRDQUFJTixXQUFVOzs4REFDYiw4REFBQzRPO29EQUNDQyxNQUFLO29EQUNMQyxPQUFPL0s7b0RBQ1BnTCxVQUFVMUgsQ0FBQUEsSUFBS3JELGFBQWFxRCxFQUFFdkgsTUFBTSxDQUFDZ1AsS0FBSztvREFDMUNHLGFBQVk7b0RBQ1pqUCxXQUFVOzs7Ozs7OERBRVosOERBQUN5SztvREFDQ3pLLFdBQVU7b0RBQ1YwSyxTQUFTLElBQU0xRyxhQUFhOzhEQUM3Qjs7Ozs7Ozs7Ozs7O3NEQU9MLDhEQUFDbUw7NENBQU9uUCxXQUFVOzs4REFDaEIsOERBQUNvUDtvREFBR3BQLFdBQVU7OERBQXFCOzs7Ozs7OERBQ25DLDhEQUFDTTs4REFDRSxDQUFDbUIsd0JBQ0EsOERBQUNnSjt3REFDQ0MsU0FBUzlJO3dEQUNUNUIsV0FBVTtrRUFDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7d0NBUU53RSxvQkFBb0IscUJBQ25CLDhEQUFDbEU7NENBQUlOLFdBQVU7O2dEQUF5Qzs4REFDL0IsOERBQUNrTjtvREFBS2xOLFdBQVU7OERBQWF3RSxnQkFBZ0I2SyxjQUFjOzs7Ozs7Ozs7OztpRUFHcEYsOERBQUMvTzs0Q0FBSU4sV0FBVTtzREFBeUM7Ozs7Ozt3Q0FJekRvTyxzQkFBc0IsUUFBUUEsb0JBQW9CLG1CQUNqRCw4REFBQzlOOzRDQUFJTixXQUFVOzs4REFDYiw4REFBQ2tOO29EQUFLbE4sV0FBVTs4REFBZ0I7Ozs7Ozs4REFDaEMsOERBQUNrTjs7d0RBQUs7d0RBQU1rQjt3REFBa0I7d0RBQWVBLHNCQUFzQixJQUFJLEtBQUs7d0RBQUk7Ozs7Ozs7OERBQ2hGLDhEQUFDM0Q7b0RBQ0N6SyxXQUFVO29EQUNWMEssU0FBUzt3REFDUDJELHFCQUFxQjt3REFDckJFLGtCQUFrQjt3REFDbEJoUSxrRUFBZ0JBLEdBQUcwSixJQUFJLENBQUM7Z0VBQUMsRUFBRTdHLGFBQWEsRUFBRTs0REFDeENpTixxQkFBcUJqTixjQUFjMEcsTUFBTTs0REFDekN5RyxrQkFBa0I7d0RBQ3BCLEdBQUdwRyxLQUFLLENBQUMsSUFBTW9HLGtCQUFrQjtvREFDbkM7b0RBQ0FlLFVBQVVoQjs4REFFVEEsaUJBQWlCLGdCQUFnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhDQU8xQyw4REFBQ2lCO29DQUFLdlAsV0FBVTs7d0NBRWIyQix1QkFDQyw4REFBQ3RELHlFQUFZQTs0Q0FDWG1SLFNBQVM3Tjs0Q0FDVE8sWUFBWUE7NENBQ1p1TixTQUFTLElBQU01Tjs0Q0FDZjZOLGVBQWU7Z0RBQ2JqUixvRUFBa0JBO2dEQUNsQm9EOzRDQUNGOzs7Ozs7d0NBS0hILE9BQU9vRyxNQUFNLEtBQUssS0FBSyxDQUFDakYsaUJBQWlCLENBQUNsQix1QkFDekMsOERBQUNyQjs0Q0FBSU4sV0FBVTs7OERBQ2IsOERBQUNxRztvREFBRXJHLFdBQVU7OERBQU87Ozs7OztnREFDbkIsQ0FBQ3lCLHdCQUNBLDhEQUFDZ0o7b0RBQ0NDLFNBQVM5STtvREFDVDVCLFdBQVU7OERBQ1g7Ozs7Ozs7Ozs7Ozt3Q0FRTjRLLGVBQWU5SixHQUFHLENBQUMsQ0FBQ3FGLElBQUl3SjtnREF1Q1J4SixhQWUyQkEsY0FBNEJBLGNBQW9CQSxjQUUvRUEsY0FBNEJBLGNBQW9CQSxjQUk3Q0EsY0FBb0JBLGNBQXlCQTtpRUEzRDNELDhEQUFDN0Y7Z0RBRUNrTixLQUFLM0osZUFBZWlFLE1BQU0sS0FBSyxLQUFLNkgsVUFBVWpPLE9BQU9vRyxNQUFNLEdBQUcsSUFBSXZELGNBQWM7Z0RBQ2hGdkUsV0FBVTs7a0VBRVYsOERBQUNNO3dEQUNDb0ssU0FBUzs0REFDUCxJQUFJbkkscUJBQXFCNEQsR0FBR2dFLEVBQUUsRUFBRTtnRUFDOUJ4QixnQkFBZ0J4QyxHQUFHZ0UsRUFBRTs0REFDdkIsT0FBTztnRUFDTCxJQUFJNUgsa0JBQWtCO29FQUNwQm9HLGdCQUFnQnBHO29FQUNoQm9FLFdBQVcsSUFBTW5FLG9CQUFvQjJELEdBQUdnRSxFQUFFLEdBQUc7Z0VBQy9DLE9BQU87b0VBQ0wzSCxvQkFBb0IyRCxHQUFHZ0UsRUFBRTtnRUFDM0I7NERBQ0Y7d0RBQ0Y7d0RBQ0FuSyxXQUFXLDRLQUEwTyxPQUE5RHVDLHFCQUFxQjRELEdBQUdnRSxFQUFFLEdBQUcsOEJBQThCOzswRUFHbFAsOERBQUM3SjtnRUFBSU4sV0FBVTs7a0ZBQ2IsOERBQUNtTjt3RUFDQ0UsTUFBTTVMLFVBQVUwRSxHQUFHMUUsTUFBTSxLQUFLQSxTQUM1QlEsWUFBWWtFLEdBQUcxRSxNQUFNLGtCQUNuQiw4REFBQ2dKOzRFQUNDekssV0FBVTs0RUFDVjBLLFNBQVMsQ0FBQ3JEO2dGQUFRQSxFQUFFc0QsZUFBZTtnRkFBSTNJLGFBQWFtRSxHQUFHMUUsTUFBTTs0RUFBRztzRkFDakU7Ozs7O21HQUVELDhEQUFDZ0o7NEVBQ0N6SyxXQUFVOzRFQUNWMEssU0FBUyxDQUFDckQ7Z0ZBQVFBLEVBQUVzRCxlQUFlO2dGQUFJNUksV0FBV29FLEdBQUcxRSxNQUFNOzRFQUFHO3NGQUMvRDs7Ozs7cUZBRUQ7a0ZBRUosNEVBQUN2Qjs0RUFDQ0MsS0FBS2dHLEVBQUFBLGNBQUFBLEdBQUdDLE9BQU8sY0FBVkQsa0NBQUFBLFlBQVl5SixPQUFPLEtBQUk7NEVBQzVCeFAsS0FBSTs0RUFDSkosV0FBVTs7Ozs7Ozs7Ozs7a0ZBR2QsOERBQUNNO3dFQUFJTixXQUFVOzswRkFFYiw4REFBQ3lLO2dGQUNDb0UsTUFBSztnRkFDTDdPLFdBQVU7Z0ZBQ1YwSyxTQUFTckQsQ0FBQUE7b0ZBQ1BBLEVBQUVzRCxlQUFlO29GQUNqQnFELGdCQUFnQjdILEdBQUcxRSxNQUFNO2dGQUMzQjtnRkFDQW9PLFVBQVU7Z0ZBQ1ZDLGNBQVksb0JBQXNHLE9BQWxGM0osRUFBQUEsZUFBQUEsR0FBR0MsT0FBTyxjQUFWRCxtQ0FBQUEsYUFBWVksWUFBWSxPQUFJWixlQUFBQSxHQUFHQyxPQUFPLGNBQVZELG1DQUFBQSxhQUFZNEosSUFBSSxPQUFJNUosZUFBQUEsR0FBR0MsT0FBTyxjQUFWRCxtQ0FBQUEsYUFBWWMsUUFBUSxLQUFJZCxHQUFHMUUsTUFBTTswRkFFaEgwRSxFQUFBQSxlQUFBQSxHQUFHQyxPQUFPLGNBQVZELG1DQUFBQSxhQUFZWSxZQUFZLE9BQUlaLGVBQUFBLEdBQUdDLE9BQU8sY0FBVkQsbUNBQUFBLGFBQVk0SixJQUFJLE9BQUk1SixlQUFBQSxHQUFHQyxPQUFPLGNBQVZELG1DQUFBQSxhQUFZYyxRQUFRLEtBQUlkLEdBQUcxRSxNQUFNLENBQUN5RixLQUFLLENBQUMsR0FBRyxLQUFLOzs7Ozs7MEZBRW5HLDhEQUFDNUc7Z0ZBQUlOLFdBQVU7O2tHQUNiLDhEQUFDa047OzRGQUFLOzRGQUNGL0csRUFBQUEsZUFBQUEsR0FBR0MsT0FBTyxjQUFWRCxtQ0FBQUEsYUFBWTRKLElBQUksT0FBSTVKLGVBQUFBLEdBQUdDLE9BQU8sY0FBVkQsbUNBQUFBLGFBQVljLFFBQVEsS0FBS2QsQ0FBQUEsRUFBQUEsZUFBQUEsR0FBR0MsT0FBTyxjQUFWRCxtQ0FBQUEsYUFBWTFFLE1BQU0sSUFBRyxHQUFzQzBFLE9BQW5DQSxHQUFHQyxPQUFPLENBQUMzRSxNQUFNLENBQUN5RixLQUFLLENBQUMsR0FBRyxJQUFHLE9BQWlDLE9BQTVCZixHQUFHQyxPQUFPLENBQUMzRSxNQUFNLENBQUN5RixLQUFLLENBQUMsQ0FBQyxNQUFPZixHQUFHMUUsTUFBTSxDQUFDeUYsS0FBSyxDQUFDLEdBQUcsS0FBSyxRQUFRZixHQUFHMUUsTUFBTSxDQUFDeUYsS0FBSyxDQUFDLENBQUMsRUFBQzs7Ozs7OztrR0FFOUwsOERBQUNnRzt3RkFBS2xOLFdBQVU7a0dBQXlCZixhQUFha0gsR0FBRzZCLFVBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7OztrRkFHdkUsOERBQUMxSDt3RUFBSU4sV0FBVTs7Ozs7O29FQUdkMkMsVUFBVSxDQUFDd0QsR0FBR2dFLEVBQUUsQ0FBQyxHQUFHLG1CQUNuQiw4REFBQzdKO3dFQUFJTixXQUFVOzswRkFDYiw4REFBQ2tOOzBGQUFLOzs7Ozs7NEVBQ0x2SyxVQUFVLENBQUN3RCxHQUFHZ0UsRUFBRSxDQUFDOzs7Ozs7Ozs7Ozs7OzBFQU14Qiw4REFBQzdKO2dFQUFJTixXQUFVOzBFQUNaVSxxQkFBcUJ5RixHQUFHaEUsT0FBTzs7Ozs7OzREQUVqQ3NLLHVCQUF1QnRHLEdBQUdtRCxLQUFLLEVBQUVqSCxjQUFjOEM7NERBQy9DcUYsZUFBZXJFOzBFQUdoQiw4REFBQzdGO2dFQUFJTixXQUFVOztrRkFDYiw4REFBQ007d0VBQUlOLFdBQVcsc0NBQTJHLE9BQXJFdUMscUJBQXFCNEQsR0FBR2dFLEVBQUUsR0FBRyxrQkFBa0I7OzBGQUNuRyw4REFBQytDOzBGQUFLOzs7Ozs7MEZBQ04sOERBQUNBOztvRkFBSztvRkFBS3ZLLFVBQVUsQ0FBQ3dELEdBQUdnRSxFQUFFLENBQUMsR0FBRyxJQUFJLEtBQXVCLE9BQWxCeEgsVUFBVSxDQUFDd0QsR0FBR2dFLEVBQUUsQ0FBQyxFQUFDLE9BQUs7Ozs7Ozs7Ozs7Ozs7a0ZBRWpFLDhEQUFDTTt3RUFDQ3pLLFdBQVcsMERBQTZHLE9BQW5ENEUsVUFBVSxDQUFDdUIsR0FBR2dFLEVBQUUsQ0FBQyxHQUFHLDRCQUE0Qjt3RUFDckhPLFNBQVNyRCxDQUFBQTs0RUFBT0EsRUFBRXNELGVBQWU7NEVBQUksSUFBSSxDQUFDL0YsVUFBVSxDQUFDdUIsR0FBR2dFLEVBQUUsQ0FBQyxFQUFFd0IsV0FBV3hGLEdBQUdnRSxFQUFFLEVBQUVoRSxHQUFHMUUsTUFBTTt3RUFBRzt3RUFDM0Y2TixVQUFVLENBQUMsQ0FBQzFLLFVBQVUsQ0FBQ3VCLEdBQUdnRSxFQUFFLENBQUM7d0VBQzdCMkYsY0FBWWxMLFVBQVUsQ0FBQ3VCLEdBQUdnRSxFQUFFLENBQUMsR0FBRyxVQUFVO3dFQUMxQzBFLE1BQUs7OzBGQUVMLDhEQUFDM0I7MEZBQUs7Ozs7OzswRkFDTiw4REFBQ0E7O29GQUFLO29GQUFLeEksVUFBVSxDQUFDeUIsR0FBR2dFLEVBQUUsQ0FBQyxHQUFHLEtBQXVCLE9BQWxCekYsVUFBVSxDQUFDeUIsR0FBR2dFLEVBQUUsQ0FBQyxFQUFDLE9BQUs7Ozs7Ozs7Ozs7Ozs7a0ZBRTdELDhEQUFDTTt3RUFDQ3pLLFdBQVcsMkRBQWtILE9BQXZEZ0YsYUFBYSxDQUFDbUIsR0FBR2dFLEVBQUUsQ0FBQyxHQUFHLDZCQUE2Qjt3RUFDMUhPLFNBQVNyRCxDQUFBQTs0RUFBT0EsRUFBRXNELGVBQWU7NEVBQUksSUFBSSxDQUFDM0YsYUFBYSxDQUFDbUIsR0FBR2dFLEVBQUUsQ0FBQyxFQUFFb0MsYUFBYXBHLEdBQUdnRSxFQUFFLEVBQUVoRSxHQUFHMUUsTUFBTSxFQUFFMEUsR0FBR2hFLE9BQU87d0VBQUc7d0VBQzVHbU4sVUFBVSxDQUFDLENBQUN0SyxhQUFhLENBQUNtQixHQUFHZ0UsRUFBRSxDQUFDO3dFQUNoQzJGLGNBQVk5SyxhQUFhLENBQUNtQixHQUFHZ0UsRUFBRSxDQUFDLEdBQUcsYUFBYTt3RUFDaEQwRSxNQUFLOzswRkFFTCw4REFBQzNCOzBGQUFLOzs7Ozs7MEZBQ04sOERBQUNBOztvRkFBSztvRkFBT3BJLFlBQVksQ0FBQ3FCLEdBQUdnRSxFQUFFLENBQUMsR0FBRyxLQUF5QixPQUFwQnJGLFlBQVksQ0FBQ3FCLEdBQUdnRSxFQUFFLENBQUMsRUFBQyxPQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29EQU10RTVILHFCQUFxQjRELEdBQUdnRSxFQUFFLGtCQUN6Qiw4REFBQy9MLDZEQUFPQTt3REFDTndLLFFBQVF6QyxHQUFHZ0UsRUFBRTt3REFDYjFJLFFBQVFBO3dEQUNSME0sU0FBUyxJQUFNeEYsZ0JBQWdCeEMsR0FBR2dFLEVBQUU7d0RBQ3BDNkYsYUFBYXZOLGtCQUFrQjBELEdBQUdnRSxFQUFFOzs7Ozs7OytDQXBIbkNoRSxHQUFHZ0UsRUFBRTs7Ozs7O3dDQTBIYnRILCtCQUNDLDhEQUFDdkM7NENBQUlOLFdBQVU7OzhEQUNiLDhEQUFDTTtvREFBSU4sV0FBVTs7Ozs7OzhEQUNmLDhEQUFDcUc7b0RBQUVyRyxXQUFVOzhEQUE2Qjs7Ozs7Ozs7Ozs7O3dDQUs3QyxDQUFDK0MsV0FBV3JCLE9BQU9vRyxNQUFNLEdBQUcsbUJBQzNCLDhEQUFDeEg7NENBQUlOLFdBQVU7c0RBQWlDOzs7Ozs7d0NBTWpEaUQsYUFBYSxLQUFLLENBQUNKLGlCQUFpQkUseUJBQ25DLDhEQUFDekM7NENBQUlOLFdBQVU7OzhEQUNiLDhEQUFDcUc7b0RBQUVyRyxXQUFVOzhEQUFxQjs7Ozs7OzhEQUNsQyw4REFBQ3lLO29EQUNDQyxTQUFTO3dEQUNQLE1BQU03QyxjQUFjbkcsTUFBTSxDQUFDQSxPQUFPb0csTUFBTSxHQUFHLEVBQUU7d0RBQzdDLElBQUlELGFBQWE7NERBQ2YvRSxpQkFBaUI7NERBQ2pCakIsWUFBWTtnRUFBRWtHLE9BQU9GLFlBQVlHLFVBQVU7NERBQUMsR0FDekNDLElBQUksQ0FBQ0MsQ0FBQUE7Z0VBQ0psRixXQUFXa0Y7Z0VBQ1hwRixpQkFBaUI7Z0VBQ2pCSSxjQUFjOzREQUNoQixHQUNDaUYsS0FBSyxDQUFDO2dFQUNMckYsaUJBQWlCO2dFQUNqQkksY0FBY2tGLENBQUFBLE9BQVFBLE9BQU87NERBQy9CO3dEQUNKO29EQUNGO29EQUNBcEksV0FBVTs4REFDWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQVNSd0YsY0FBY0UsbUNBQ2IsOERBQUN1Szs0QkFBUWpRLFdBQVU7c0NBQ2hCMEY7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU9ULDhEQUFDZ0o7Z0JBQU0xTyxXQUFVOzBCQUNmLDRFQUFDaEIsd0VBQVlBO29CQUFDK0wsa0JBQWtCQTtvQkFBa0JYLGVBQWVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQUl6RTtHQTMxQndCNUk7O1FBQ3lGM0QscURBQVFBOzs7S0FEakcyRCIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL3NyYy9hcHAvcGFnZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IHVzZU5vc3RyIH0gZnJvbSBcIkAvaG9va3MvdXNlTm9zdHJcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGZldGNoTGlua1ByZXZpZXcgfSBmcm9tIFwiQC9saWIvdXRpbHMvbGluay1wcmV2aWV3XCI7XG5pbXBvcnQgeyBMaW5rUHJldmlldyB9IGZyb20gXCJAL3R5cGVzL2xpbmstcHJldmlld1wiO1xuaW1wb3J0IHsgQ2hhdEJveCB9IGZyb20gXCJAL2NvbXBvbmVudHMvY2hhdC9DaGF0Qm94XCI7XG5pbXBvcnQgeyBQb3N0IH0gZnJvbSBcIkAvY29tcG9uZW50cy9mZWVkL1Bvc3RcIjtcbmltcG9ydCB7IENyZWF0ZVBvc3QgfSBmcm9tIFwiQC9jb21wb25lbnRzL2ZlZWQvQ3JlYXRlUG9zdFwiO1xuaW1wb3J0IHsgTG9hZGluZ1NwaW5uZXIgfSBmcm9tIFwiQC9jb21wb25lbnRzL3NoYXJlZC9Mb2FkaW5nU3Bpbm5lclwiO1xuaW1wb3J0IHsgRXJyb3JNZXNzYWdlIH0gZnJvbSBcIkAvY29tcG9uZW50cy9zaGFyZWQvRXJyb3JNZXNzYWdlXCI7XG5pbXBvcnQgeyBQcm9maWxlUGFuZSB9IGZyb20gXCJAL2NvbXBvbmVudHMvUHJvZmlsZVBhbmVcIjtcbmltcG9ydCB7IEZpbmFuY2lhbFRpY2tlciB9IGZyb20gXCJAL2NvbXBvbmVudHMvc2hhcmVkL0JpdGNvaW5UaWNrZXJcIjtcbmltcG9ydCB7IE1lZGlhUGxheWVyIH0gZnJvbSBcIkAvY29tcG9uZW50cy9zaGFyZWQvTWVkaWFQbGF5ZXJcIjtcbmltcG9ydCB7IGdldEhlYWx0aHlSZWxheXMsIGZldGNoTm9zdHJGZWVkLCBjbGVhckJhZFJlbGF5Q2FjaGUgfSBmcm9tIFwiQC9saWIvbm9zdHIvcmVsYXlcIjtcbmltcG9ydCB7IFNpbXBsZVBvb2wgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbmltcG9ydCBTdGF0c0Rpc3BsYXkgZnJvbSBcIkAvY29tcG9uZW50cy9TdGF0c0Rpc3BsYXlcIjtcbmltcG9ydCBQcm9maWxlUGFnZSBmcm9tIFwiQC9hcHAvcHJvZmlsZS9wYWdlXCI7XG5pbXBvcnQgRXhwbG9yZVBhZ2UgZnJvbSBcIkAvYXBwL2V4cGxvcmUvcGFnZVwiO1xuaW1wb3J0IFdhbGxldFBhZ2UgZnJvbSBcIkAvYXBwL3dhbGxldC9wYWdlXCI7XG5pbXBvcnQgQ2hhdFBhZ2UgZnJvbSBcIkAvYXBwL2NoYXQvcGFnZVwiO1xuaW1wb3J0IFNpZGViYXIgZnJvbSBcIkAvY29tcG9uZW50cy9sYXlvdXQvU2lkZWJhclwiO1xuaW1wb3J0IFJpZ2h0U2lkZWJhciBmcm9tIFwiQC9jb21wb25lbnRzL2xheW91dC9SaWdodFNpZGViYXJcIjtcblxuZnVuY3Rpb24gcmVsYXRpdmVUaW1lKHRpbWVzdGFtcDogbnVtYmVyKSB7XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGNvbnN0IGRpZmYgPSBNYXRoLmZsb29yKChub3cgLSAodGltZXN0YW1wICogMTAwMCB8fCB0aW1lc3RhbXApKSAvIDEwMDApO1xuICBpZiAoZGlmZiA8IDYwKSByZXR1cm4gYCR7ZGlmZn1zIGFnb2A7XG4gIGlmIChkaWZmIDwgMzYwMCkgcmV0dXJuIGAke01hdGguZmxvb3IoZGlmZiAvIDYwKX1tIGFnb2A7XG4gIGlmIChkaWZmIDwgODY0MDApIHJldHVybiBgJHtNYXRoLmZsb29yKGRpZmYgLyAzNjAwKX1oIGFnb2A7XG4gIHJldHVybiBuZXcgRGF0ZSh0aW1lc3RhbXAgKiAxMDAwIHx8IHRpbWVzdGFtcCkudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckxpbmtQcmV2aWV3KHByZXZpZXc6IExpbmtQcmV2aWV3KSB7XG4gIHJldHVybiAoXG4gICAgLy8gUmVwbGFjZSBpbmxpbmUgc3R5bGUgd2l0aCBUYWlsd2luZCBmb3IgYW5jaG9yXG4gICAgPGFcbiAgICAgIGhyZWY9e3ByZXZpZXcudXJsfVxuICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIlxuICAgICAgY2xhc3NOYW1lPVwiYmxvY2sgcm91bmRlZC14bCBib3JkZXIgYm9yZGVyLWdyYXktODAwIGJnLWdyYXktOTUwIGhvdmVyOmJnLWdyYXktOTAwIHRyYW5zaXRpb24gc2hhZG93IGZsZXggZ2FwLTQgcC00IG10LTIgbWF4LXcteGwgbm8tdW5kZXJsaW5lXCJcbiAgICA+XG4gICAgICB7cHJldmlldy5pbWFnZSAmJiAoXG4gICAgICAgIDxpbWdcbiAgICAgICAgICBzcmM9e3ByZXZpZXcuaW1hZ2V9XG4gICAgICAgICAgYWx0PXtwcmV2aWV3LnRpdGxlIHx8IHByZXZpZXcudXJsfVxuICAgICAgICAgIGNsYXNzTmFtZT1cInctMjQgaC0yNCBvYmplY3QtY292ZXIgcm91bmRlZC1sZyBib3JkZXIgYm9yZGVyLWdyYXktODAwIGJnLWJsYWNrIGZsZXgtc2hyaW5rLTBcIlxuICAgICAgICAvPlxuICAgICAgKX1cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBtaW4tdy0wXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1iYXNlIGZvbnQtc2VtaWJvbGQgdGV4dC13aGl0ZSB0cnVuY2F0ZVwiPntwcmV2aWV3LnRpdGxlIHx8IHByZXZpZXcudXJsfTwvZGl2PlxuICAgICAgICB7cHJldmlldy5zaXRlTmFtZSAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS00MDAgbWItMSB0cnVuY2F0ZSBmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMVwiPlxuICAgICAgICAgICAge3ByZXZpZXcuZmF2aWNvbiAmJiA8aW1nIHNyYz17cHJldmlldy5mYXZpY29ufSBhbHQ9XCJmYXZpY29uXCIgY2xhc3NOYW1lPVwiaW5saW5lIHctNCBoLTQgbXItMSBhbGlnbi1taWRkbGUgcm91bmRlZFwiIC8+fSB7cHJldmlldy5zaXRlTmFtZX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgICAge3ByZXZpZXcuZGVzY3JpcHRpb24gJiYgKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LWdyYXktMzAwIHRydW5jYXRlXCI+e3ByZXZpZXcuZGVzY3JpcHRpb259PC9kaXY+XG4gICAgICAgICl9XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWJsdWUtNDAwIHRydW5jYXRlIG10LTFcIj57cHJldmlldy51cmx9PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2E+XG4gICk7XG59XG5cbi8vIFV0aWxpdHkgdG8gZm9ybWF0IE5PU1RSIGFkZHJlc3NlcyBpbiB0ZXh0XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Tm9zdHJBZGRyZXNzZXModGV4dDogc3RyaW5nKSB7XG4gIC8vIFJlZ2V4IGZvciBoZXggcHVia2V5ICg2NCBoZXggY2hhcnMpIGFuZCBucHViMS4uLiBiZWNoMzIgTk9TVFIgYWRkcmVzc2VzXG4gIGNvbnN0IG5vc3RyUmVnZXggPSAvKG5wdWIxWzAtOWEtel17NTl9fFthLWYwLTldezY0fSkvZ2k7XG4gIHJldHVybiB0ZXh0LnNwbGl0KG5vc3RyUmVnZXgpLm1hcCgocGFydCwgaSkgPT4ge1xuICAgIGlmIChwYXJ0Lm1hdGNoKG5vc3RyUmVnZXgpKSB7XG4gICAgICByZXR1cm4gcGFydDsgLy8gTm8gc3BlY2lhbCBmb3JtYXR0aW5nIG9yIGxpbmtpbmdcbiAgICB9XG4gICAgcmV0dXJuIHBhcnQ7XG4gIH0pO1xufVxuXG4vLyBIZWxwZXIgZm9yIGFkdmFuY2VkIHJlbGF5IHF1ZXJpZXMgKGxpa2UgbGlrZXMsIHJlcG9zdHMsIGhhc2h0YWcgc2VhcmNoKVxuYXN5bmMgZnVuY3Rpb24gcXVlcnlSZWxheUV2ZW50cyhmaWx0ZXI6IGFueSkge1xuICBjb25zdCB7IGhlYWx0aHlSZWxheXMgfSA9IGF3YWl0IGdldEhlYWx0aHlSZWxheXMoKTtcbiAgY29uc3QgcG9vbCA9IG5ldyBTaW1wbGVQb29sKCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IHBvb2wucXVlcnlTeW5jKGhlYWx0aHlSZWxheXMsIGZpbHRlcik7XG4gIH0gZmluYWxseSB7XG4gICAgcG9vbC5jbG9zZShoZWFsdGh5UmVsYXlzKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lKCkge1xuICBjb25zdCB7IHB1YmtleSwgZXZlbnRzLCBlcnJvciwgbG9naW4sIGZldGNoRXZlbnRzLCBwb3N0LCBmb2xsb3dVc2VyLCB1bmZvbGxvd1VzZXIsIGlzRm9sbG93aW5nLCByZWxheVN0YXRzIH0gPSB1c2VOb3N0cigpO1xuICBjb25zdCBbY29udGVudCwgc2V0Q29udGVudF0gPSB1c2VTdGF0ZShcIlwiKTtcbiAgY29uc3QgW2xpbmtQcmV2aWV3cywgc2V0TGlua1ByZXZpZXdzXSA9IHVzZVN0YXRlPHsgW3VybDogc3RyaW5nXTogTGlua1ByZXZpZXcgfCBudWxsIH0+KHt9KTtcbiAgY29uc3QgW2FjdGl2ZUNoYXRQb3N0SWQsIHNldEFjdGl2ZUNoYXRQb3N0SWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtjbG9zaW5nQ2hhdElkLCBzZXRDbG9zaW5nQ2hhdElkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbY2hhdENvdW50cywgc2V0Q2hhdENvdW50c10gPSB1c2VTdGF0ZTx7IFtwb3N0SWQ6IHN0cmluZ106IG51bWJlciB9Pih7fSk7XG4gIGNvbnN0IFtpc0xvYWRpbmdNb3JlLCBzZXRJc0xvYWRpbmdNb3JlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2hhc01vcmUsIHNldEhhc01vcmVdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtyZXRyeUNvdW50LCBzZXRSZXRyeUNvdW50XSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbcHJvZmlsZVBhbmVPcGVuLCBzZXRQcm9maWxlUGFuZU9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2VhcmNoLCBzZXRTZWFyY2hdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtzZWFyY2hSZXN1bHRzLCBzZXRTZWFyY2hSZXN1bHRzXSA9IHVzZVN0YXRlPGFueVtdPihbXSk7XG4gIGNvbnN0IFtzZWFyY2hGb2N1c2VkLCBzZXRTZWFyY2hGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2hhc2h0YWcsIHNldEhhc2h0YWddID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcbiAgY29uc3QgW2hhc2h0YWdSZXN1bHRzLCBzZXRIYXNodGFnUmVzdWx0c10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pO1xuICBjb25zdCBbZmlsdGVyVGFnLCBzZXRGaWx0ZXJUYWddID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtzaG93RmlsdGVyLCBzZXRTaG93RmlsdGVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dGdWxsUHJvZmlsZSwgc2V0U2hvd0Z1bGxQcm9maWxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3Qgc2VhcmNoVGltZW91dCA9IHVzZVJlZjxOb2RlSlMuVGltZW91dCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBvYnNlcnZlclJlZiA9IHVzZVJlZjxJbnRlcnNlY3Rpb25PYnNlcnZlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBsYXN0UG9zdFJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBnbG9iYWxQb3N0Q291bnQgPSB1c2VHbG9iYWxOb3N0clBvc3RDb3VudCgpO1xuICBjb25zdCBbbGlrZUNvdW50cywgc2V0TGlrZUNvdW50c10gPSB1c2VTdGF0ZTx7IFtwb3N0SWQ6IHN0cmluZ106IG51bWJlciB9Pih7fSk7XG4gIGNvbnN0IFtsaWtlZFBvc3RzLCBzZXRMaWtlZFBvc3RzXSA9IHVzZVN0YXRlPHsgW3Bvc3RJZDogc3RyaW5nXTogYm9vbGVhbiB9Pih7fSk7XG4gIGNvbnN0IFtyZXBvc3RDb3VudHMsIHNldFJlcG9zdENvdW50c10gPSB1c2VTdGF0ZTx7IFtwb3N0SWQ6IHN0cmluZ106IG51bWJlciB9Pih7fSk7XG4gIGNvbnN0IFtyZXBvc3RlZFBvc3RzLCBzZXRSZXBvc3RlZFBvc3RzXSA9IHVzZVN0YXRlPHsgW3Bvc3RJZDogc3RyaW5nXTogYm9vbGVhbiB9Pih7fSk7XG4gIGNvbnN0IFtsaWdodGJveE1lZGlhLCBzZXRMaWdodGJveE1lZGlhXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbc3RhdHMsIHNldFN0YXRzXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7XG4gIGNvbnN0IFtsb2FkaW5nU3RhdHMsIHNldExvYWRpbmdTdGF0c10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2FjdGl2ZVBhbmUsIHNldEFjdGl2ZVBhbmVdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtzaWRlUGFuZUNvbXBvbmVudCwgc2V0U2lkZVBhbmVDb21wb25lbnRdID0gdXNlU3RhdGU8UmVhY3QuUmVhY3ROb2RlPihudWxsKTtcbiAgY29uc3QgW3Byb2ZpbGVQYW5lUHVia2V5LCBzZXRQcm9maWxlUGFuZVB1YmtleV0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICAvLyBIYW5kbGUgc2lkZWJhciBuYXZpZ2F0aW9uXG4gIGNvbnN0IGhhbmRsZU5hdiA9IHVzZUNhbGxiYWNrKChrZXk6IHN0cmluZykgPT4ge1xuICAgIGlmIChhY3RpdmVQYW5lID09PSBrZXkpIHtcbiAgICAgIHNldEFjdGl2ZVBhbmUobnVsbCk7XG4gICAgICBzZXRTaWRlUGFuZUNvbXBvbmVudChudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0QWN0aXZlUGFuZShrZXkpO1xuICAgIHNldFNpZGVQYW5lQ29tcG9uZW50KG51bGwpOyAvLyBSZXNldCBzaWRlIHBhbmUgY29udGVudFxuICB9LCBbYWN0aXZlUGFuZV0pO1xuXG4gIC8vIFNlYXJjaCBsb2dpYzogZmlsdGVyIGFsbCBrbm93biBwcm9maWxlcyBieSBkaXNwbGF5TmFtZSwgdXNlcm5hbWUsIG9yIHB1YmtleVxuICBjb25zdCBhbGxQcm9maWxlcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgcmV0dXJuIGV2ZW50c1xuICAgICAgLm1hcChldiA9PiBldi5wcm9maWxlIHx8IHsgcHVia2V5OiBldi5wdWJrZXkgfSlcbiAgICAgIC5maWx0ZXIocCA9PiB7XG4gICAgICAgIGlmICghcC5wdWJrZXkgfHwgc2Vlbi5oYXMocC5wdWJrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHNlZW4uYWRkKHAucHVia2V5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgfSwgW2V2ZW50c10pO1xuXG4gIC8vIERlYm91bmNlZCBzZWFyY2hcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2VhcmNoVGltZW91dC5jdXJyZW50KSBjbGVhclRpbWVvdXQoc2VhcmNoVGltZW91dC5jdXJyZW50KTtcbiAgICBpZiAoIXNlYXJjaC50cmltKCkpIHtcbiAgICAgIHNldFNlYXJjaFJlc3VsdHMoW10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZWFyY2hUaW1lb3V0LmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IHEgPSBzZWFyY2gudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBjb25zdCByZXN1bHRzID0gYWxsUHJvZmlsZXMuZmlsdGVyKHAgPT5cbiAgICAgICAgKHAuZGlzcGxheV9uYW1lICYmIHAuZGlzcGxheV9uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocSkpIHx8XG4gICAgICAgIChwLnVzZXJuYW1lICYmIHAudXNlcm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxKSkgfHxcbiAgICAgICAgKHAucHVia2V5ICYmIHAucHVia2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocSkpXG4gICAgICApLnNsaWNlKDAsIDEwKTsgLy8gVG9wIDEwXG4gICAgICBzZXRTZWFyY2hSZXN1bHRzKHJlc3VsdHMpO1xuICAgIH0sIDE1MCk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbc2VhcmNoLCBhbGxQcm9maWxlc10pO1xuXG4gIC8vIENsb3NlIGRyb3Bkb3duIG9uIG91dHNpZGUgY2xpY2tcbiAgY29uc3Qgc2VhcmNoUmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBmdW5jdGlvbiBoYW5kbGVDbGljayhlOiBNb3VzZUV2ZW50KSB7XG4gICAgICBpZiAoc2VhcmNoUmVmLmN1cnJlbnQgJiYgIXNlYXJjaFJlZi5jdXJyZW50LmNvbnRhaW5zKGUudGFyZ2V0IGFzIE5vZGUpKSB7XG4gICAgICAgIHNldFNlYXJjaEZvY3VzZWQoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VhcmNoRm9jdXNlZCkgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBoYW5kbGVDbGljayk7XG4gICAgcmV0dXJuICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgaGFuZGxlQ2xpY2spO1xuICB9LCBbc2VhcmNoRm9jdXNlZF0pO1xuXG4gIC8vIEhhbmRsZSBpbmZpbml0ZSBzY3JvbGxpbmdcbiAgY29uc3QgaGFuZGxlT2JzZXJ2ZXIgPSB1c2VDYWxsYmFjaygoZW50cmllczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeVtdKSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZW50cmllc1swXTtcbiAgICBpZiAodGFyZ2V0LmlzSW50ZXJzZWN0aW5nICYmICFpc0xvYWRpbmdNb3JlICYmIGhhc01vcmUpIHtcbiAgICAgIGNvbnN0IG9sZGVzdEV2ZW50ID0gZXZlbnRzW2V2ZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChvbGRlc3RFdmVudCkge1xuICAgICAgICBzZXRJc0xvYWRpbmdNb3JlKHRydWUpO1xuICAgICAgICBmZXRjaEV2ZW50cyh7IHVudGlsOiBvbGRlc3RFdmVudC5jcmVhdGVkX2F0IH0pXG4gICAgICAgICAgLnRoZW4oaGFzTmV3RXZlbnRzID0+IHtcbiAgICAgICAgICAgIHNldEhhc01vcmUoaGFzTmV3RXZlbnRzKTtcbiAgICAgICAgICAgIHNldElzTG9hZGluZ01vcmUoZmFsc2UpO1xuICAgICAgICAgICAgc2V0UmV0cnlDb3VudCgwKTsgLy8gUmVzZXQgcmV0cnkgY291bnQgb24gc3VjY2Vzc2Z1bCBmZXRjaFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIHNldElzTG9hZGluZ01vcmUoZmFsc2UpO1xuICAgICAgICAgICAgc2V0UmV0cnlDb3VudChwcmV2ID0+IHByZXYgKyAxKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtldmVudHMsIGZldGNoRXZlbnRzLCBpc0xvYWRpbmdNb3JlLCBoYXNNb3JlXSk7XG5cbiAgLy8gU2V0dXAgaW50ZXJzZWN0aW9uIG9ic2VydmVyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGxhc3RQb3N0UmVmLmN1cnJlbnQgJiYgIW9ic2VydmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIG9ic2VydmVyUmVmLmN1cnJlbnQgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZXIsIHtcbiAgICAgICAgcm9vdDogbnVsbCxcbiAgICAgICAgcm9vdE1hcmdpbjogXCIxMDBweFwiLFxuICAgICAgICB0aHJlc2hvbGQ6IDAuMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RQb3N0UmVmLmN1cnJlbnQpIHtcbiAgICAgIG9ic2VydmVyUmVmLmN1cnJlbnQ/Lm9ic2VydmUobGFzdFBvc3RSZWYuY3VycmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG9ic2VydmVyUmVmLmN1cnJlbnQ/LmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbaGFuZGxlT2JzZXJ2ZXJdKTtcblxuICAvLyBIYW5kbGUgY2hhdCBjbG9zaW5nIHdpdGggYW5pbWF0aW9uXG4gIGNvbnN0IGhhbmRsZUNoYXRDbG9zZSA9IChwb3N0SWQ6IHN0cmluZykgPT4ge1xuICAgIHNldENsb3NpbmdDaGF0SWQocG9zdElkKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldEFjdGl2ZUNoYXRQb3N0SWQobnVsbCk7XG4gICAgICBzZXRDbG9zaW5nQ2hhdElkKG51bGwpO1xuICAgIH0sIDMwMCk7XG4gIH07XG5cbiAgLy8gSW5pdGlhbCBmZXRjaFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIDEuIEZldGNoIGEgc21hbGwgYmF0Y2ggZm9yIGZhc3QgaW5pdGlhbCByZW5kZXJcbiAgICBmZXRjaEV2ZW50cygpLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gMi4gSW4gdGhlIGJhY2tncm91bmQsIGZldGNoIG1vcmUgcG9zdHMgYW5kIGFwcGVuZFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChldmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IG9sZGVzdCA9IGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKG9sZGVzdCkge1xuICAgICAgICAgICAgZmV0Y2hFdmVudHMoeyB1bnRpbDogb2xkZXN0LmNyZWF0ZWRfYXQsIGxpbWl0OiA0MCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7IC8vIHNsaWdodCBkZWxheSB0byBhbGxvdyBmaXJzdCByZW5kZXJcbiAgICB9KTtcbiAgICAvLyBMaXZlIHBvbGxpbmcgZXZlcnkgMzAgc2Vjb25kcyBmb3IgbmV3IHBvc3RzXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBmZXRjaEV2ZW50cygpO1xuICAgIH0sIDMwMDAwKTtcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0sIFtmZXRjaEV2ZW50c10pO1xuXG4gIC8vIEZldGNoIGxpbmsgcHJldmlld3MgZm9yIGFsbCB1bmlxdWUgbGlua3MgaW4gZXZlbnRzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgYWxsTGlua3MgPSBBcnJheS5mcm9tKFxuICAgICAgbmV3IFNldChcbiAgICAgICAgZXZlbnRzLmZsYXRNYXAoZXYgPT5cbiAgICAgICAgICAoZXYubWVkaWEgfHwgW10pLmZpbHRlcih1cmwgPT4gIXVybC5tYXRjaCgvXFwuKGpwZWd8anBnfGdpZnxwbmd8bXA0fHdlYm0pJC9pKSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgICk7XG4gICAgYWxsTGlua3MuZm9yRWFjaChhc3luYyB1cmwgPT4ge1xuICAgICAgaWYgKCFsaW5rUHJldmlld3NbdXJsXSkge1xuICAgICAgICBjb25zdCBwcmV2aWV3ID0gYXdhaXQgZmV0Y2hMaW5rUHJldmlldyh1cmwpO1xuICAgICAgICBzZXRMaW5rUHJldmlld3MocHJldiA9PiAoeyAuLi5wcmV2LCBbdXJsXTogcHJldmlldyB9KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbZXZlbnRzXSk7XG5cbiAgLy8gRW5oYW5jZWQgaGFzaHRhZyBleHRyYWN0aW9uXG4gIGNvbnN0IGV4dHJhY3RIYXNodGFncyA9IChldmVudDogYW55KSA9PiB7XG4gICAgLy8gMS4gRnJvbSBjb250ZW50OiAjaGFzaHRhZywgI2hhc2hfdGFnLCAjaGFzaDEyMywgVW5pY29kZSwgYW5kIHF1b3RlZCBoYXNodGFnc1xuICAgIGNvbnN0IGNvbnRlbnRUYWdzID0gQXJyYXkuZnJvbShcbiAgICAgIG5ldyBTZXQoXG4gICAgICAgIFtcbiAgICAgICAgICAvLyBTdGFuZGFyZCBoYXNodGFncyAobGV0dGVycywgbnVtYmVycywgdW5kZXJzY29yZXMsIFVuaWNvZGUpXG4gICAgICAgICAgLi4uKGV2ZW50LmNvbnRlbnQubWF0Y2goLyMoW1xccHtMfVxccHtOfV8tXXsyLDUwfSkvZ3UpIHx8IFtdKS5tYXAoKGg6IHN0cmluZykgPT4gaC5zbGljZSgxKS50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgICAvLyBRdW90ZWQgaGFzaHRhZ3M6IFwiI2hhc2h0YWdcIlxuICAgICAgICAgIC4uLihldmVudC5jb250ZW50Lm1hdGNoKC9cIiMoW1xccHtMfVxccHtOfV8tXXsyLDUwfSlcIi9ndSkgfHwgW10pLm1hcCgoaDogc3RyaW5nKSA9PiBoLnJlcGxhY2UoL1wiL2csICcnKS5zbGljZSgxKS50b0xvd2VyQ2FzZSgpKSxcbiAgICAgICAgICAvLyBIYXNodGFncyBpbiBVUkxzIChlLmcuLCBodHRwczovLy4uLi8jaGFzaHRhZylcbiAgICAgICAgICAuLi4oZXZlbnQuY29udGVudC5tYXRjaCgvXFwvIyhbXFxwe0x9XFxwe059Xy1dezIsNTB9KS9ndSkgfHwgW10pLm1hcCgoaDogc3RyaW5nKSA9PiBoLnJlcGxhY2UoJy8jJywgJycpLnRvTG93ZXJDYXNlKCkpLFxuICAgICAgICBdXG4gICAgICApXG4gICAgKTtcbiAgICAvLyAyLiBGcm9tIHRhZ3MgYXJyYXk6IGFsbCB0YWcgdHlwZXMgd2l0aCBhIHZhbHVlIHRoYXQgbG9va3MgbGlrZSBhIGhhc2h0YWdcbiAgICBjb25zdCB0YWdUYWdzID0gKGV2ZW50LnRhZ3MgfHwgW10pXG4gICAgICAuZmlsdGVyKCh0OiBhbnkpID0+IHRbMV0gJiYgL14oW1xccHtMfVxccHtOfV8tXXsyLDUwfSkkL3UudGVzdCh0WzFdKSlcbiAgICAgIC5tYXAoKHQ6IGFueSkgPT4gdFsxXS50b0xvd2VyQ2FzZSgpKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KFsuLi5jb250ZW50VGFncywgLi4udGFnVGFnc10pKTtcbiAgfTtcblxuICAvLyBNZW1vaXplZCBtYXAgb2YgcG9zdElkIC0+IGhhc2h0YWdzXG4gIGNvbnN0IGV2ZW50SGFzaHRhZ3NSZWYgPSB1c2VSZWY8eyBbaWQ6IHN0cmluZ106IHN0cmluZ1tdIH0+KHt9KTtcbiAgY29uc3QgZXZlbnRIYXNodGFncyA9IHVzZU1lbW88eyBbaWQ6IHN0cmluZ106IHN0cmluZ1tdIH0+KCgpID0+IHtcbiAgICBpZiAoIWV2ZW50cy5sZW5ndGgpIHJldHVybiBldmVudEhhc2h0YWdzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgbWFwOiB7IFtpZDogc3RyaW5nXTogc3RyaW5nW10gfSA9IHt9O1xuICAgIGV2ZW50cy5mb3JFYWNoKChldjogYW55KSA9PiB7IG1hcFtldi5pZF0gPSBleHRyYWN0SGFzaHRhZ3MoZXYpOyB9KTtcbiAgICBldmVudEhhc2h0YWdzUmVmLmN1cnJlbnQgPSBtYXA7XG4gICAgcmV0dXJuIG1hcDtcbiAgfSwgW2V2ZW50c10pO1xuXG4gIC8vIEhhc2h0YWcgc2VhcmNoIChOSVAtMTIpXG4gIGNvbnN0IHNlYXJjaEhhc2h0YWcgPSB1c2VDYWxsYmFjayhhc3luYyAodGFnOiBzdHJpbmcpID0+IHtcbiAgICBzZXRIYXNodGFnKHRhZyk7XG4gICAgc2V0SGFzaHRhZ1Jlc3VsdHMoW10pO1xuICAgIHNldFNlYXJjaChcIlwiKTtcbiAgICBzZXRTZWFyY2hSZXN1bHRzKFtdKTtcbiAgICAvLyBOSVAtMTIgZmlsdGVyXG4gICAgY29uc3QgZmlsdGVyID0geyBraW5kczogWzFdLCBcIiN0XCI6IFt0YWcudG9Mb3dlckNhc2UoKV0sIGxpbWl0OiA1MCB9O1xuICAgIGNvbnN0IHBvc3RzID0gYXdhaXQgcXVlcnlSZWxheUV2ZW50cyhmaWx0ZXIpO1xuICAgIHNldEhhc2h0YWdSZXN1bHRzKHBvc3RzIHx8IFtdKTtcbiAgfSwgW10pO1xuXG4gIC8vIFJlbmRlciBoYXNodGFncyBmb3IgYSBwb3N0XG4gIGZ1bmN0aW9uIHJlbmRlckhhc2h0YWdzKGV2OiBhbnkpIHtcbiAgICBjb25zdCB0YWdzID0gZXZlbnRIYXNodGFnc1tldi5pZF0gfHwgW107XG4gICAgaWYgKCF0YWdzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LXdyYXAgZ2FwLTIgbXQtMlwiPlxuICAgICAgICB7dGFncy5tYXAodGFnID0+IChcbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBrZXk9e3RhZ31cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInRleHQtYmx1ZS00MDAgaG92ZXI6dW5kZXJsaW5lIGJnLWJsdWUtOTAwLzIwIHJvdW5kZWQgcHgtMiBweS0wLjUgdGV4dC14cyBmb250LW1vbm9cIlxuICAgICAgICAgICAgb25DbGljaz17ZSA9PiB7IGUuc3RvcFByb3BhZ2F0aW9uKCk7IHNlYXJjaEhhc2h0YWcodGFnKTsgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICAje3RhZ31cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKSl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgLy8gRW5oYW5jZWQgZmlsdGVyOiBmaWx0ZXIgcG9zdHMgYnkgdGFnXG4gIGNvbnN0IGZpbHRlcmVkRXZlbnRzID0gKGhhc2h0YWdSZXN1bHRzLmxlbmd0aCA+IDAgPyBoYXNodGFnUmVzdWx0cyA6IGV2ZW50cykuZmlsdGVyKGV2ID0+IHtcbiAgICBpZiAoIWZpbHRlclRhZykgcmV0dXJuIHRydWU7XG4gICAgLy8gQ2hlY2sgaWYgZXZlbnQgY29udGVudCBvciB0YWdzIGluY2x1ZGUgdGhlIGZpbHRlclRhZ1xuICAgIGNvbnN0IHRhZ01hdGNoID0gKGV2LmNvbnRlbnQgJiYgZXYuY29udGVudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZpbHRlclRhZy50b0xvd2VyQ2FzZSgpKSk7XG4gICAgY29uc3QgdGFnQXJyYXkgPSAoZXYudGFncyB8fCBbXSkubWFwKCh0OiBhbnkpID0+IHRbMV0/LnRvTG93ZXJDYXNlPy4oKSB8fCBcIlwiKTtcbiAgICByZXR1cm4gdGFnTWF0Y2ggfHwgdGFnQXJyYXkuaW5jbHVkZXMoZmlsdGVyVGFnLnRvTG93ZXJDYXNlKCkpO1xuICB9KTtcblxuICAvLyBUcmVuZGluZyBoYXNodGFncyBjYWxjdWxhdGlvblxuICBjb25zdCB0cmVuZGluZ0hhc2h0YWdzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgdGFnQ291bnRzOiB7IFt0YWc6IHN0cmluZ106IG51bWJlciB9ID0ge307XG4gICAgZXZlbnRzLmZvckVhY2goZXYgPT4ge1xuICAgICAgY29uc3QgdGFncyA9IGV2ZW50SGFzaHRhZ3NbZXYuaWRdIHx8IFtdO1xuICAgICAgdGFncy5mb3JFYWNoKHRhZyA9PiB7XG4gICAgICAgIHRhZ0NvdW50c1t0YWddID0gKHRhZ0NvdW50c1t0YWddIHx8IDApICsgMTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFNvcnQgYnkgZnJlcXVlbmN5LCBkZXNjZW5kaW5nXG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRhZ0NvdW50cylcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSlcbiAgICAgIC5zbGljZSgwLCAxMCk7XG4gIH0sIFtldmVudHMsIGV2ZW50SGFzaHRhZ3NdKTtcblxuICAvLyBGZXRjaCBsaWtlIGNvdW50cyBmb3IgdmlzaWJsZSBwb3N0c1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBpc01vdW50ZWQgPSB0cnVlO1xuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBwb3N0SWRzID0gZmlsdGVyZWRFdmVudHMubWFwKGV2ID0+IGV2LmlkKTtcbiAgICAgIGlmIChwb3N0SWRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgLy8gUXVlcnkgZm9yIGtpbmQgNyAobGlrZSkgZXZlbnRzIHJlZmVyZW5jaW5nIHRoZXNlIHBvc3RzXG4gICAgICBjb25zdCBsaWtlRXZlbnRzID0gYXdhaXQgcXVlcnlSZWxheUV2ZW50cyh7IGtpbmRzOiBbN10sICcjZSc6IHBvc3RJZHMsIGxpbWl0OiAxMDAwIH0pO1xuICAgICAgaWYgKCFpc01vdW50ZWQpIHJldHVybjtcbiAgICAgIC8vIENvdW50IGxpa2VzIHBlciBwb3N0XG4gICAgICBjb25zdCBjb3VudHM6IHsgW3Bvc3RJZDogc3RyaW5nXTogbnVtYmVyIH0gPSB7fTtcbiAgICAgIGNvbnN0IGxpa2VkOiB7IFtwb3N0SWQ6IHN0cmluZ106IGJvb2xlYW4gfSA9IHt9O1xuICAgICAgbGlrZUV2ZW50cz8uZm9yRWFjaCgoZXY6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCByZWZJZCA9IChldi50YWdzLmZpbmQoKHQ6IGFueSkgPT4gdFswXSA9PT0gJ2UnKSB8fCBbXSlbMV07XG4gICAgICAgIGlmIChyZWZJZCkge1xuICAgICAgICAgIGNvdW50c1tyZWZJZF0gPSAoY291bnRzW3JlZklkXSB8fCAwKSArIDE7XG4gICAgICAgICAgaWYgKGV2LnB1YmtleSA9PT0gcHVia2V5KSBsaWtlZFtyZWZJZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNldExpa2VDb3VudHMoY291bnRzKTtcbiAgICAgIHNldExpa2VkUG9zdHMobGlrZWQpO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuICgpID0+IHsgaXNNb3VudGVkID0gZmFsc2U7IH07XG4gIH0sIFtmaWx0ZXJlZEV2ZW50cywgcHVia2V5XSk7XG5cbiAgLy8gTGlrZSBhIHBvc3QgKHB1Ymxpc2gga2luZCA3IGV2ZW50KVxuICBjb25zdCBoYW5kbGVMaWtlID0gdXNlQ2FsbGJhY2soYXN5bmMgKHBvc3RJZDogc3RyaW5nLCBwb3N0UHVia2V5OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXB1YmtleSB8fCAhd2luZG93Lm5vc3RyKSByZXR1cm47XG4gICAgLy8gT3B0aW1pc3RpY2FsbHkgdXBkYXRlIFVJXG4gICAgc2V0TGlrZUNvdW50cyhwcmV2ID0+ICh7IC4uLnByZXYsIFtwb3N0SWRdOiAocHJldltwb3N0SWRdIHx8IDApICsgMSB9KSk7XG4gICAgc2V0TGlrZWRQb3N0cyhwcmV2ID0+ICh7IC4uLnByZXYsIFtwb3N0SWRdOiB0cnVlIH0pKTtcbiAgICAvLyBCdWlsZCBsaWtlIGV2ZW50XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICBraW5kOiA3LFxuICAgICAgcHVia2V5LFxuICAgICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICB0YWdzOiBbXG4gICAgICAgIFtcImVcIiwgcG9zdElkXSxcbiAgICAgICAgW1wicFwiLCBwb3N0UHVia2V5XSxcbiAgICAgIF0sXG4gICAgICBjb250ZW50OiBcIitcIixcbiAgICAgIHNpZzogXCJcIiwgLy8gV2lsbCBiZSBmaWxsZWQgYnkgZXh0ZW5zaW9uXG4gICAgfTtcbiAgICAvLyBTaWduIGFuZCBwdWJsaXNoXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNpZ25lZCA9IGF3YWl0IHdpbmRvdy5ub3N0ci5zaWduRXZlbnQoZXZlbnQpO1xuICAgICAgLy8gVE9ETzogUHVibGlzaCBzaWduZWQgZXZlbnQgdG8gcmVsYXlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFJvbGxiYWNrIG9wdGltaXN0aWMgdXBkYXRlIG9uIGVycm9yXG4gICAgICBzZXRMaWtlQ291bnRzKHByZXYgPT4gKHsgLi4ucHJldiwgW3Bvc3RJZF06IE1hdGgubWF4KChwcmV2W3Bvc3RJZF0gfHwgMSkgLSAxLCAwKSB9KSk7XG4gICAgICBzZXRMaWtlZFBvc3RzKHByZXYgPT4gKHsgLi4ucHJldiwgW3Bvc3RJZF06IGZhbHNlIH0pKTtcbiAgICB9XG4gIH0sIFtwdWJrZXldKTtcblxuICAvLyBGZXRjaCByZXBvc3QgY291bnRzIGZvciB2aXNpYmxlIHBvc3RzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IGlzTW91bnRlZCA9IHRydWU7XG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHBvc3RJZHMgPSBmaWx0ZXJlZEV2ZW50cy5tYXAoZXYgPT4gZXYuaWQpO1xuICAgICAgaWYgKHBvc3RJZHMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAvLyBRdWVyeSBmb3Iga2luZCA2IChyZXBvc3QpIGV2ZW50cyByZWZlcmVuY2luZyB0aGVzZSBwb3N0c1xuICAgICAgY29uc3QgcmVwb3N0RXZlbnRzID0gYXdhaXQgcXVlcnlSZWxheUV2ZW50cyh7IGtpbmRzOiBbNl0sICcjZSc6IHBvc3RJZHMsIGxpbWl0OiAxMDAwIH0pO1xuICAgICAgaWYgKCFpc01vdW50ZWQpIHJldHVybjtcbiAgICAgIC8vIENvdW50IHJlcG9zdHMgcGVyIHBvc3RcbiAgICAgIGNvbnN0IGNvdW50czogeyBbcG9zdElkOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xuICAgICAgY29uc3QgcmVwb3N0ZWQ6IHsgW3Bvc3RJZDogc3RyaW5nXTogYm9vbGVhbiB9ID0ge307XG4gICAgICByZXBvc3RFdmVudHM/LmZvckVhY2goKGV2OiBhbnkpID0+IHtcbiAgICAgICAgY29uc3QgcmVmSWQgPSAoZXYudGFncy5maW5kKCh0OiBhbnkpID0+IHRbMF0gPT09ICdlJykgfHwgW10pWzFdO1xuICAgICAgICBpZiAocmVmSWQpIHtcbiAgICAgICAgICBjb3VudHNbcmVmSWRdID0gKGNvdW50c1tyZWZJZF0gfHwgMCkgKyAxO1xuICAgICAgICAgIGlmIChldi5wdWJrZXkgPT09IHB1YmtleSkgcmVwb3N0ZWRbcmVmSWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZXRSZXBvc3RDb3VudHMoY291bnRzKTtcbiAgICAgIHNldFJlcG9zdGVkUG9zdHMocmVwb3N0ZWQpO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuICgpID0+IHsgaXNNb3VudGVkID0gZmFsc2U7IH07XG4gIH0sIFtmaWx0ZXJlZEV2ZW50cywgcHVia2V5XSk7XG5cbiAgLy8gUmVwb3N0IGEgcG9zdCAocHVibGlzaCBraW5kIDYgZXZlbnQpXG4gIGNvbnN0IGhhbmRsZVJlcG9zdCA9IHVzZUNhbGxiYWNrKGFzeW5jIChwb3N0SWQ6IHN0cmluZywgcG9zdFB1YmtleTogc3RyaW5nLCBwb3N0Q29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFwdWJrZXkgfHwgIXdpbmRvdy5ub3N0cikgcmV0dXJuO1xuICAgIC8vIE9wdGltaXN0aWNhbGx5IHVwZGF0ZSBVSVxuICAgIHNldFJlcG9zdENvdW50cyhwcmV2ID0+ICh7IC4uLnByZXYsIFtwb3N0SWRdOiAocHJldltwb3N0SWRdIHx8IDApICsgMSB9KSk7XG4gICAgc2V0UmVwb3N0ZWRQb3N0cyhwcmV2ID0+ICh7IC4uLnByZXYsIFtwb3N0SWRdOiB0cnVlIH0pKTtcbiAgICAvLyBCdWlsZCByZXBvc3QgZXZlbnRcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIGtpbmQ6IDYsXG4gICAgICBwdWJrZXksXG4gICAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgIHRhZ3M6IFtcbiAgICAgICAgW1wiZVwiLCBwb3N0SWRdLFxuICAgICAgICBbXCJwXCIsIHBvc3RQdWJrZXldLFxuICAgICAgXSxcbiAgICAgIGNvbnRlbnQ6IHBvc3RDb250ZW50LFxuICAgICAgc2lnOiBcIlwiLCAvLyBXaWxsIGJlIGZpbGxlZCBieSBleHRlbnNpb25cbiAgICB9O1xuICAgIC8vIFNpZ24gYW5kIHB1Ymxpc2hcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2lnbmVkID0gYXdhaXQgd2luZG93Lm5vc3RyLnNpZ25FdmVudChldmVudCk7XG4gICAgICAvLyBUT0RPOiBQdWJsaXNoIHNpZ25lZCBldmVudCB0byByZWxheVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gUm9sbGJhY2sgb3B0aW1pc3RpYyB1cGRhdGUgb24gZXJyb3JcbiAgICAgIHNldFJlcG9zdENvdW50cyhwcmV2ID0+ICh7IC4uLnByZXYsIFtwb3N0SWRdOiBNYXRoLm1heCgocHJldltwb3N0SWRdIHx8IDEpIC0gMSwgMCkgfSkpO1xuICAgICAgc2V0UmVwb3N0ZWRQb3N0cyhwcmV2ID0+ICh7IC4uLnByZXYsIFtwb3N0SWRdOiBmYWxzZSB9KSk7XG4gICAgfVxuICB9LCBbcHVia2V5XSk7XG5cbiAgLy8gVXBkYXRlIHJlbmRlck1lZGlhV2l0aFByZXZpZXcgdG8gYWNjZXB0IHNldExpZ2h0Ym94TWVkaWEgYXMgYSBwcm9wXG4gIGZ1bmN0aW9uIHJlbmRlck1lZGlhV2l0aFByZXZpZXcobWVkaWE6IHN0cmluZ1tdLCBsaW5rUHJldmlld3M6IHsgW3VybDogc3RyaW5nXTogTGlua1ByZXZpZXcgfCBudWxsIH0sIHNldExpZ2h0Ym94TWVkaWE6ICh1cmw6IHN0cmluZykgPT4gdm9pZCkge1xuICAgIGlmICghbWVkaWEgfHwgbWVkaWEubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBpbWFnZXMgPSBtZWRpYS5maWx0ZXIodXJsID0+IHVybC5tYXRjaCgvXFwuKGpwZWd8anBnfGdpZnxwbmcpJC9pKSk7XG4gICAgLy8gRGV0ZWN0IFlvdVR1YmUgYW5kIFNvdW5kQ2xvdWQgbGlua3NcbiAgICBjb25zdCB5b3VUdWJlUmVnZXggPSAvKD86eW91dHViZVxcLmNvbVxcL3dhdGNoXFw/dj18eW91dHVcXC5iZVxcLylbXFx3LV0rL2k7XG4gICAgY29uc3Qgc291bmRDbG91ZFJlZ2V4ID0gL3NvdW5kY2xvdWRcXC5jb21cXC8vaTtcbiAgICBjb25zdCB2aWRlb3MgPSBtZWRpYS5maWx0ZXIodXJsID0+IHVybC5tYXRjaCgvXFwuKG1wNHx3ZWJtKSQvaSkgfHwgeW91VHViZVJlZ2V4LnRlc3QodXJsKSk7XG4gICAgY29uc3QgYXVkaW9zID0gbWVkaWEuZmlsdGVyKHVybCA9PiB1cmwubWF0Y2goL1xcLihtcDN8d2F2fG9nZykkL2kpIHx8IHNvdW5kQ2xvdWRSZWdleC50ZXN0KHVybCkpO1xuICAgIGNvbnN0IG1lZGlhU2V0ID0gbmV3IFNldChbLi4uaW1hZ2VzLCAuLi52aWRlb3MsIC4uLmF1ZGlvc10pO1xuICAgIGNvbnN0IGxpbmtzID0gbWVkaWEuZmlsdGVyKHVybCA9PiAhbWVkaWFTZXQuaGFzKHVybCkgJiYgIXVybC5tYXRjaCgvXFwuKGpwZWd8anBnfGdpZnxwbmd8bXA0fHdlYm18bXAzfHdhdnxvZ2cpJC9pKSAmJiAheW91VHViZVJlZ2V4LnRlc3QodXJsKSAmJiAhc291bmRDbG91ZFJlZ2V4LnRlc3QodXJsKSk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtMiBtdC0yXCI+XG4gICAgICAgIHtpbWFnZXMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2BncmlkIGdhcC0yICR7aW1hZ2VzLmxlbmd0aCA9PT0gMSA/IFwiZ3JpZC1jb2xzLTFcIiA6IGltYWdlcy5sZW5ndGggPT09IDIgPyBcImdyaWQtY29scy0yXCIgOiBcImdyaWQtY29scy0yXCJ9YH0+XG4gICAgICAgICAgICB7aW1hZ2VzLnNsaWNlKDAsIDQpLm1hcCgodXJsLCBpZHgpID0+IChcbiAgICAgICAgICAgICAgLy8gUmVwbGFjZSBpbmxpbmUgc3R5bGUgd2l0aCBUYWlsd2luZCBmb3IgaW1hZ2VcbiAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgIGtleT17aWR4fVxuICAgICAgICAgICAgICAgIHNyYz17dXJsfVxuICAgICAgICAgICAgICAgIGFsdD1cIm1lZGlhXCJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyb3VuZGVkLXhsIG9iamVjdC1jb3ZlciBib3JkZXIgYm9yZGVyLWdyYXktODAwIGJnLWJsYWNrIHctZnVsbCBoLTYwIGN1cnNvci1wb2ludGVyIGFzcGVjdC1zcXVhcmUgb2JqZWN0LWNvdmVyXCJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtlID0+IHsgZS5zdG9wUHJvcGFnYXRpb24oKTsgc2V0TGlnaHRib3hNZWRpYSh1cmwpOyB9fVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICAgIHsodmlkZW9zLmxlbmd0aCA+IDAgfHwgYXVkaW9zLmxlbmd0aCA+IDApICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTJcIj5cbiAgICAgICAgICAgIHtbLi4udmlkZW9zLCAuLi5hdWRpb3NdLm1hcCgodXJsLCBpZHgpID0+IChcbiAgICAgICAgICAgICAgPGRpdiBrZXk9e2lkeH0gY2xhc3NOYW1lPVwicmVsYXRpdmVcIj5cbiAgICAgICAgICAgICAgICA8TWVkaWFQbGF5ZXIgdXJsPXt1cmx9IGNsYXNzTmFtZT1cInJvdW5kZWQteGwgYm9yZGVyIGJvcmRlci1ncmF5LTgwMCBiZy1ibGFjayB3LWZ1bGwgc2hhZG93LWxnXCIgLz5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtMiBsZWZ0LTIgYmctYmxhY2svNjAgdGV4dC13aGl0ZSB0ZXh0LXhzIHB4LTIgcHktMSByb3VuZGVkXCI+XG4gICAgICAgICAgICAgICAgICB7dXJsLm1hdGNoKC9cXC4obXA0fHdlYm0pJC9pKSB8fCB5b3VUdWJlUmVnZXgudGVzdCh1cmwpID8gXCJWaWRlb1wiIDogXCJBdWRpb1wifVxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgICAge2xpbmtzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtMlwiPlxuICAgICAgICAgICAge2xpbmtzLm1hcCgodXJsLCBpZHgpID0+XG4gICAgICAgICAgICAgIGxpbmtQcmV2aWV3c1t1cmxdID8gKFxuICAgICAgICAgICAgICAgIGxpbmtQcmV2aWV3c1t1cmxdICYmIHJlbmRlckxpbmtQcmV2aWV3KGxpbmtQcmV2aWV3c1t1cmxdISlcbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAga2V5PXtpZHh9XG4gICAgICAgICAgICAgICAgICBocmVmPXt1cmx9XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LWJsdWUtNDAwIHVuZGVybGluZSBicmVhay1hbGwgaG92ZXI6dGV4dC1ibHVlLTMwMFwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge3VybH1cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gUHJvZmlsZURyb3Bkb3duKHsgY2hpbGRyZW4sIG1lbnUgfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlLCBtZW51OiBSZWFjdC5SZWFjdE5vZGUgfSkge1xuICAgIGNvbnN0IFtvcGVuLCBzZXRPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuICAgIC8vIENsb3NlIGRyb3Bkb3duIG9uIG91dHNpZGUgY2xpY2tcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgZnVuY3Rpb24gaGFuZGxlQ2xpY2soZTogTW91c2VFdmVudCkge1xuICAgICAgICBpZiAocmVmLmN1cnJlbnQgJiYgIXJlZi5jdXJyZW50LmNvbnRhaW5zKGUudGFyZ2V0IGFzIE5vZGUpKSBzZXRPcGVuKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcGVuKSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGhhbmRsZUNsaWNrKTtcbiAgICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGhhbmRsZUNsaWNrKTtcbiAgICB9LCBbb3Blbl0pO1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlbGF0aXZlXCIgcmVmPXtyZWZ9PlxuICAgICAgICB7LyogUmVwbGFjZSBpbmxpbmUgc3R5bGUgd2l0aCBUYWlsd2luZCBmb3IgUHJvZmlsZURyb3Bkb3duIGNsaWNrYWJsZSBkaXYgKi99XG4gICAgICAgIDxkaXYgb25DbGljaz17KCkgPT4gc2V0T3Blbih2ID0+ICF2KX0gY2xhc3NOYW1lPVwiY3Vyc29yLXBvaW50ZXJcIj5cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7b3BlbiAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSBsZWZ0LTAgbXQtMiB6LTIwIGJnLWdyYXktOTAwIGJvcmRlciBib3JkZXItZ3JheS04MDAgcm91bmRlZC14bCBzaGFkb3ctbGcgbWluLXctWzEyMHB4XSBwLTIgZmxleCBmbGV4LWNvbFwiPlxuICAgICAgICAgICAge21lbnV9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlR2xvYmFsTm9zdHJQb3N0Q291bnQoKSB7XG4gICAgY29uc3QgW3RvdGFsQ291bnQsIHNldFRvdGFsQ291bnRdID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgZmV0Y2hDb3VudCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBHZXQgaGVhbHRoeSByZWxheXNcbiAgICAgICAgICBjb25zdCB7IGhlYWx0aHlSZWxheXMgfSA9IGF3YWl0IGdldEhlYWx0aHlSZWxheXMoKTtcbiAgICAgICAgICAvLyBGZXRjaCBhIGxhcmdlIG51bWJlciBvZiBldmVudHMgYW5kIGRlZHVwbGljYXRlIGJ5IGlkIGZvciBhbiBlc3RpbWF0ZVxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoTm9zdHJGZWVkKGhlYWx0aHlSZWxheXMsIHtcbiAgICAgICAgICAgIGxpbWl0OiAxMDAwLCAvLyBGZXRjaCB1cCB0byAxMDAwIGV2ZW50cyBmb3IgZXN0aW1hdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIERlZHVwbGljYXRlIGJ5IGV2ZW50IGlkXG4gICAgICAgICAgY29uc3QgdW5pcXVlSWRzID0gbmV3IFNldCgocmVzdWx0IHx8IFtdKS5tYXAoZXYgPT4gZXYuaWQpKTtcbiAgICAgICAgICBzZXRUb3RhbENvdW50KHVuaXF1ZUlkcy5zaXplKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHNldFRvdGFsQ291bnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmZXRjaENvdW50KCk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHRvdGFsQ291bnQ7XG4gIH1cblxuICAvLyBGZXRjaCBOT1NUUiBCYW5kIHN0YXRzIG9uIGNvbXBvbmVudCBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFJlbW92ZSBmZXRjaE5vc3RyQmFuZFN0YXRzIHVzYWdlIG9yIHJlcGxhY2Ugd2l0aCBjb3JyZWN0IGltcGxlbWVudGF0aW9uIGlmIG5lZWRlZFxuICAgIHNldExvYWRpbmdTdGF0cyhmYWxzZSk7XG4gIH0sIFtdKTtcblxuICAvLyBPcGVuIHByb2ZpbGUgcGFuZSB3aXRoIGEgZ2l2ZW4gcHVia2V5XG4gIGNvbnN0IG9wZW5Qcm9maWxlUGFuZSA9IChwdWJrZXk6IHN0cmluZykgPT4ge1xuICAgIHNldFByb2ZpbGVQYW5lUHVia2V5KHB1YmtleSk7XG4gICAgc2V0QWN0aXZlUGFuZShcInByb2ZpbGVcIik7XG4gICAgc2V0U2lkZVBhbmVDb21wb25lbnQobnVsbCk7IC8vIFdpbGwgYmUgc2V0IGluIHVzZUVmZmVjdFxuICB9O1xuXG4gIC8vIER5bmFtaWMgaW1wb3J0IGxvZ2ljIGZvciBzaWRlIHBhbmVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWFjdGl2ZVBhbmUpIHtcbiAgICAgIHNldFNpZGVQYW5lQ29tcG9uZW50KG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY29tcG9uZW50OiBSZWFjdC5SZWFjdE5vZGUgPSBudWxsO1xuICAgIGlmIChhY3RpdmVQYW5lID09PSBcImV4cGxvcmVcIikge1xuICAgICAgY29tcG9uZW50ID0gPEV4cGxvcmVQYWdlIC8+O1xuICAgIH0gZWxzZSBpZiAoYWN0aXZlUGFuZSA9PT0gXCJ3YWxsZXRcIikge1xuICAgICAgY29tcG9uZW50ID0gPFdhbGxldFBhZ2UgLz47XG4gICAgfSBlbHNlIGlmIChhY3RpdmVQYW5lID09PSBcImNoYXRcIikge1xuICAgICAgY29tcG9uZW50ID0gPENoYXRQYWdlIC8+O1xuICAgIH0gZWxzZSBpZiAoYWN0aXZlUGFuZSA9PT0gXCJwcm9maWxlXCIgJiYgcHJvZmlsZVBhbmVQdWJrZXkpIHtcbiAgICAgIGNvbXBvbmVudCA9IDxQcm9maWxlUGFnZSB1c2VyT3ZlcnJpZGU9e3Byb2ZpbGVQYW5lUHVia2V5fSBvbkNsb3NlPXsoKSA9PiBzZXRBY3RpdmVQYW5lKG51bGwpfSAvPjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUGxhY2Vob2xkZXIgZm9yIG90aGVyIHBhbmVzXG4gICAgICBjb21wb25lbnQgPSA8ZGl2IGNsYXNzTmFtZT1cInAtOCB0ZXh0LXdoaXRlXCI+Q29taW5nIHNvb24uLi48L2Rpdj47XG4gICAgfVxuICAgIHNldFNpZGVQYW5lQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gIH0sIFthY3RpdmVQYW5lLCBwcm9maWxlUGFuZVB1YmtleV0pO1xuXG4gIC8vIC0tLSBMYXlvdXQgUmVmYWN0b3IgU3RhcnQgLS0tXG4gIC8vIFJlbGF5IGhlYWx0aCBzdGF0ZVxuICBjb25zdCBbaGVhbHRoeVJlbGF5Q291bnQsIHNldEhlYWx0aHlSZWxheUNvdW50XSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbY2hlY2tpbmdSZWxheXMsIHNldENoZWNraW5nUmVsYXlzXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgbW91bnRlZCA9IHRydWU7XG4gICAgYXN5bmMgZnVuY3Rpb24gY2hlY2tSZWxheXMoKSB7XG4gICAgICBzZXRDaGVja2luZ1JlbGF5cyh0cnVlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgaGVhbHRoeVJlbGF5cyB9ID0gYXdhaXQgZ2V0SGVhbHRoeVJlbGF5cygpO1xuICAgICAgICBpZiAobW91bnRlZCkgc2V0SGVhbHRoeVJlbGF5Q291bnQoaGVhbHRoeVJlbGF5cy5sZW5ndGgpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIGlmIChtb3VudGVkKSBzZXRIZWFsdGh5UmVsYXlDb3VudChudWxsKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChtb3VudGVkKSBzZXRDaGVja2luZ1JlbGF5cyhmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNoZWNrUmVsYXlzKCk7XG4gICAgLy8gT3B0aW9uYWxseSwgcmUtY2hlY2sgZXZlcnkgMiBtaW51dGVzXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjaGVja1JlbGF5cywgMTIwMDAwKTtcbiAgICByZXR1cm4gKCkgPT4geyBtb3VudGVkID0gZmFsc2U7IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpOyB9O1xuICB9LCBbXSk7XG5cbiAgLy8gLS0tIExheW91dCBSZWZhY3RvciBTdGFydCAtLS1cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIm1pbi1oLXNjcmVlbiB3LWZ1bGwgYmctYmxhY2sgZmxleCBmbGV4LXJvd1wiPlxuICAgICAgey8qIExlZnQgU2lkZWJhciAoZml4ZWQpICovfVxuICAgICAgPGFzaWRlIGNsYXNzTmFtZT1cImhpZGRlbiBtZDpmbGV4IGZsZXgtY29sIHctWzgwcHhdIHhsOnctWzI0MHB4XSBoLXNjcmVlbiBzdGlja3kgdG9wLTAgbGVmdC0wIHotMzAgYm9yZGVyLXIgYm9yZGVyLWdyYXktODAwIGJnLWdyYXktOTUwXCI+XG4gICAgICAgIDxTaWRlYmFyIG9uTmF2PXtoYW5kbGVOYXZ9IGFjdGl2ZVBhbmU9e2FjdGl2ZVBhbmV9IC8+XG4gICAgICA8L2FzaWRlPlxuXG4gICAgICB7LyogQ2VudGVyZWQgY29udGVudCBncm91cDogRmVlZCArIFNpZGUgUGFuZSAqL31cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC0xIGZsZXgganVzdGlmeS1jZW50ZXJcIj5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT17YGZsZXggZmxleC1yb3cgdy1mdWxsIG1heC13LVtjYWxjKDEwMHZ3LTQwMHB4KV0geGw6bWF4LXctW2NhbGMoMTAwdnctNDAwcHgpXSAyeGw6bWF4LXctWzE4MDBweF0gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwICR7YWN0aXZlUGFuZSAmJiBzaWRlUGFuZUNvbXBvbmVudCA/IFwiZ2FwLThcIiA6IFwiXCJ9IGp1c3RpZnktY2VudGVyYH1cbiAgICAgICAgPlxuICAgICAgICAgIHsvKiBNYWluIEZlZWQgKGNlbnRlcmVkLCBidXQgc2hpZnRzIGxlZnQgaWYgc2lkZSBwYW5lIGlzIG9wZW4pICovfVxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT17YHctZnVsbCBtYXgtdy0yeGwgcHgtMiBzbTpweC02IHB5LTggYmctZ3JheS05NTAgYm9yZGVyIGJvcmRlci1ncmF5LTgwMCBzaGFkb3cteGwgcm91bmRlZC14bCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgZmxleC1zaHJpbmstMCAke2FjdGl2ZVBhbmUgJiYgc2lkZVBhbmVDb21wb25lbnQgPyBcIlwiIDogXCJteC1hdXRvXCJ9IG92ZXJmbG93LXktYXV0byBoLVtjYWxjKDEwMHZoLTMycHgpXWB9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgey8qIFNlYXJjaCBhbmQgRmlsdGVyICovfVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi02XCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzbTpmbGV4LXJvdyBnYXAtNFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC0xXCI+XG4gICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17c2VhcmNofVxuICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17ZSA9PiBzZXRTZWFyY2goZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICAgICAgICBvbkZvY3VzPXsoKSA9PiBzZXRTZWFyY2hGb2N1c2VkKHRydWUpfVxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlNlYXJjaCB1c2VycyBieSBuYW1lLCB1c2VybmFtZSwgb3IgbnB1Yi4uLlwiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBweC00IHB5LTIgcm91bmRlZC1mdWxsIGJnLWdyYXktOTAwIGJvcmRlciBib3JkZXItZ3JheS03MDAgdGV4dC13aGl0ZSBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctYmx1ZS01MDAvMzAgZm9jdXM6Ym9yZGVyLWJsdWUtNTAwLzMwIHBsYWNlaG9sZGVyLWdyYXktNTAwXCJcbiAgICAgICAgICAgICAgICAgICAgYXV0b0NvbXBsZXRlPVwib2ZmXCJcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgbWwtMCBzbTptbC0yIHB4LTQgcHktMiByb3VuZGVkLWZ1bGwgYm9yZGVyIGJvcmRlci1ibHVlLTUwMCB0ZXh0LWJsdWUtNDAwIGJnLWJsdWUtOTAwLzIwIGhvdmVyOmJnLWJsdWUtOTAwLzQwIHRyYW5zaXRpb24gZm9udC1zZW1pYm9sZCAke3Nob3dGaWx0ZXIgPyAncmluZy0yIHJpbmctYmx1ZS00MDAnIDogJyd9YH1cbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFNob3dGaWx0ZXIodiA9PiAhdil9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAge3Nob3dGaWx0ZXIgPyAnSGlkZSBGaWx0ZXJzJyA6ICdGaWx0ZXIgYnkgVGFnJ31cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIHtzaG93RmlsdGVyICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTYgZmxleCBnYXAtMiBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtmaWx0ZXJUYWd9XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHNldEZpbHRlclRhZyhlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiRW50ZXIgdGFnIChlLmcuIGJpdGNvaW4sIG5vc3RyLCBhaSlcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgcm91bmRlZC1mdWxsIGJnLWdyYXktOTAwIGJvcmRlciBib3JkZXItZ3JheS03MDAgdGV4dC13aGl0ZSBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctYmx1ZS01MDAvMzAgZm9jdXM6Ym9yZGVyLWJsdWUtNTAwLzMwIHBsYWNlaG9sZGVyLWdyYXktNTAwIHctZnVsbFwiXG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgcm91bmRlZC1mdWxsIGJnLWJsdWUtNTAwIHRleHQtd2hpdGUgaG92ZXI6YmctYmx1ZS02MDAgdHJhbnNpdGlvbiBmb250LXNlbWlib2xkXCJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0RmlsdGVyVGFnKFwiXCIpfVxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICBDbGVhclxuICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgICAgey8qIEhlYWRlciAqL31cbiAgICAgICAgICAgICAgPGhlYWRlciBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gbWItNlwiPlxuICAgICAgICAgICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBmb250LWJvbGRcIj5SQVcuUk9DS1M8L2gxPlxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICB7IXB1YmtleSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtsb2dpbn1cbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTIgcm91bmRlZC1mdWxsIGJnLWJsdWUtNTAwIHRleHQtd2hpdGUgZm9udC1tZWRpdW0gaG92ZXI6YmctYmx1ZS02MDAgc2hhZG93LWxnIHNoYWRvdy1ibHVlLTUwMC8yMCB0cmFuc2l0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgIExvZ2luIHdpdGggTk9TVFJcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2hlYWRlcj5cblxuICAgICAgICAgICAgICB7LyogR2xvYmFsIFBvc3QgQ291bnQgKi99XG4gICAgICAgICAgICAgIHtnbG9iYWxQb3N0Q291bnQgIT09IG51bGwgPyAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS00MDAgbWItMiB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAg8J+MjiBHbG9iYWwgTm9zdHIgUG9zdHM6IDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtYm9sZFwiPntnbG9iYWxQb3N0Q291bnQudG9Mb2NhbGVTdHJpbmcoKX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS00MDAgbWItMiB0ZXh0LWNlbnRlclwiPkxvYWRpbmcgZ2xvYmFsIHBvc3QgY291bnQuLi48L2Rpdj5cbiAgICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgICB7LyogUmVsYXkgSGVhbHRoIFdhcm5pbmcgKi99XG4gICAgICAgICAgICAgIHtoZWFsdGh5UmVsYXlDb3VudCAhPT0gbnVsbCAmJiBoZWFsdGh5UmVsYXlDb3VudCA8IDMgJiYgKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWItNCBwLTMgcm91bmRlZC14bCBiZy15ZWxsb3ctOTAwLzgwIGJvcmRlciBib3JkZXIteWVsbG93LTYwMCB0ZXh0LXllbGxvdy0yMDAgdGV4dC1jZW50ZXIgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgZ2FwLTJcIj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGRcIj7imqDvuI8gTG93IHJlbGF5IGNvbm5lY3Rpdml0eTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuPk9ubHkge2hlYWx0aHlSZWxheUNvdW50fSBoZWFsdGh5IHJlbGF5e2hlYWx0aHlSZWxheUNvdW50ID09PSAxID8gJycgOiAncyd9IGRldGVjdGVkLiBTb21lIHBvc3RzIG1heSBiZSBtaXNzaW5nIG9yIGRlbGF5ZWQuPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJtdC0xIHB4LTMgcHktMSByb3VuZGVkIGJnLXllbGxvdy03MDAgdGV4dC13aGl0ZSBob3ZlcjpiZy15ZWxsb3ctODAwIHRleHQteHMgZm9udC1zZW1pYm9sZFwiXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRIZWFsdGh5UmVsYXlDb3VudChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRDaGVja2luZ1JlbGF5cyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICBnZXRIZWFsdGh5UmVsYXlzKCkudGhlbigoeyBoZWFsdGh5UmVsYXlzIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEhlYWx0aHlSZWxheUNvdW50KGhlYWx0aHlSZWxheXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldENoZWNraW5nUmVsYXlzKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoKSA9PiBzZXRDaGVja2luZ1JlbGF5cyhmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17Y2hlY2tpbmdSZWxheXN9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHtjaGVja2luZ1JlbGF5cyA/ICdDaGVja2luZy4uLicgOiAnUmV0cnkgUmVsYXlzJ31cbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIHsvKiBQb3N0IEZlZWQgKi99XG4gICAgICAgICAgICA8bWFpbiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC02XCI+XG4gICAgICAgICAgICAgIHsvKiBFcnJvciBTdGF0ZSAqL31cbiAgICAgICAgICAgICAge2Vycm9yICYmIChcbiAgICAgICAgICAgICAgICA8RXJyb3JNZXNzYWdlXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlPXtlcnJvcn1cbiAgICAgICAgICAgICAgICAgIHJlbGF5U3RhdHM9e3JlbGF5U3RhdHN9XG4gICAgICAgICAgICAgICAgICBvblJldHJ5PXsoKSA9PiBmZXRjaEV2ZW50cygpfVxuICAgICAgICAgICAgICAgICAgb25DbGVhclJlbGF5cz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckJhZFJlbGF5Q2FjaGUoKTtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hFdmVudHMoKTtcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgICB7LyogRW1wdHkgU3RhdGUgKi99XG4gICAgICAgICAgICAgIHtldmVudHMubGVuZ3RoID09PSAwICYmICFpc0xvYWRpbmdNb3JlICYmICFlcnJvciAmJiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlciB0ZXh0LWdyYXktNTAwIHB5LTEyXCI+XG4gICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtYi00XCI+Tm8gcG9zdHMgeWV0LiBCZSB0aGUgZmlyc3QgdG8gcG9zdCE8L3A+XG4gICAgICAgICAgICAgICAgICB7IXB1YmtleSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtsb2dpbn1cbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC02IHB5LTIgYmctYmx1ZS01MDAvMjAgaG92ZXI6YmctYmx1ZS01MDAvMzAgcm91bmRlZC1mdWxsIHRleHQtYmx1ZS00MDAgdHJhbnNpdGlvblwiXG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICBDb25uZWN0IHdpdGggTk9TVFIgdG8gUG9zdFxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgICAgey8qIFBvc3RzICovfVxuICAgICAgICAgICAgICB7ZmlsdGVyZWRFdmVudHMubWFwKChldiwgaW5kZXgpID0+IChcbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICBrZXk9e2V2LmlkfVxuICAgICAgICAgICAgICAgICAgcmVmPXtoYXNodGFnUmVzdWx0cy5sZW5ndGggPT09IDAgJiYgaW5kZXggPT09IGV2ZW50cy5sZW5ndGggLSAxID8gbGFzdFBvc3RSZWYgOiBudWxsfVxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicmVsYXRpdmVcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVDaGF0UG9zdElkID09PSBldi5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ2hhdENsb3NlKGV2LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUNoYXRQb3N0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ2hhdENsb3NlKGFjdGl2ZUNoYXRQb3N0SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldEFjdGl2ZUNoYXRQb3N0SWQoZXYuaWQpLCAzMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QWN0aXZlQ2hhdFBvc3RJZChldi5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BiZy1ncmF5LTkwMC80MCBiYWNrZHJvcC1ibHVyLXNtIGJvcmRlciBib3JkZXItd2hpdGUvMTAgcm91bmRlZC14bCBwLTUgc2hhZG93LWxnIGZsZXggZmxleC1jb2wgZ2FwLTIgY3Vyc29yLXBvaW50ZXIgdHJhbnNpdGlvbiBob3ZlcjpiZy1ncmF5LTkwMC82MCBob3Zlcjpib3JkZXItd2hpdGUvMjAgJHthY3RpdmVDaGF0UG9zdElkID09PSBldi5pZCA/ICdyb3VuZGVkLWItbm9uZSBib3JkZXItYi0wJyA6ICcnfWB9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHsvKiBQb3N0IGhlYWRlciAqL31cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtNCBtYi0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAgPFByb2ZpbGVEcm9wZG93blxuICAgICAgICAgICAgICAgICAgICAgICAgbWVudT17cHVia2V5ICYmIGV2LnB1YmtleSAhPT0gcHVia2V5ID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZvbGxvd2luZyhldi5wdWJrZXkpID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRleHQteHMgcHgtMyBweS0xIHJvdW5kZWQgYmctZ3JheS04MDAgYm9yZGVyIGJvcmRlci1ncmF5LTYwMCB0ZXh0LWdyYXktMzAwIGhvdmVyOmJnLWdyYXktNzAwIHctZnVsbCB0ZXh0LWxlZnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KGUpID0+IHsgZS5zdG9wUHJvcGFnYXRpb24oKTsgdW5mb2xsb3dVc2VyKGV2LnB1YmtleSk7IH19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPlVuZm9sbG93PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC14cyBweC0zIHB5LTEgcm91bmRlZCBiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIGhvdmVyOmJnLWJsdWUtNjAwIHctZnVsbCB0ZXh0LWxlZnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KGUpID0+IHsgZS5zdG9wUHJvcGFnYXRpb24oKTsgZm9sbG93VXNlcihldi5wdWJrZXkpOyB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID5Gb2xsb3c8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM9e2V2LnByb2ZpbGU/LnBpY3R1cmUgfHwgXCIvZmlsZS5zdmdcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0PVwiYXZhdGFyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy0xMiBoLTEyIHJvdW5kZWQtZnVsbCBib3JkZXIgYm9yZGVyLWdyYXktODAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgPC9Qcm9maWxlRHJvcGRvd24+XG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtaW4tdy0wIGZsZXggZmxleC1jb2xcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvKiBSZW1vdmUgaW5saW5lIHN0eWxlIGZyb20gYnV0dG9uIGluIHBvc3QgaGVhZGVyLCB1c2UgVGFpbHdpbmQgZm9yIHJlc2V0ICovfVxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZCB0ZXh0LXdoaXRlIHRydW5jYXRlIGhvdmVyOnVuZGVybGluZSB0ZXh0LWxlZnQgb3V0bGluZS1ub25lIGJnLXRyYW5zcGFyZW50IGJvcmRlci0wIHAtMCBtLTAgY3Vyc29yLXBvaW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5Qcm9maWxlUGFuZShldi5wdWJrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJJbmRleD17MH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17YE9wZW4gcHJvZmlsZSBmb3IgJHtldi5wcm9maWxlPy5kaXNwbGF5X25hbWUgfHwgZXYucHJvZmlsZT8ubmFtZSB8fCBldi5wcm9maWxlPy51c2VybmFtZSB8fCBldi5wdWJrZXl9YH1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAge2V2LnByb2ZpbGU/LmRpc3BsYXlfbmFtZSB8fCBldi5wcm9maWxlPy5uYW1lIHx8IGV2LnByb2ZpbGU/LnVzZXJuYW1lIHx8IGV2LnB1YmtleS5zbGljZSgwLCA4KSArIFwiLi4uXCIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1ncmF5LTQwMCBmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAe2V2LnByb2ZpbGU/Lm5hbWUgfHwgZXYucHJvZmlsZT8udXNlcm5hbWUgfHwgKGV2LnByb2ZpbGU/LnB1YmtleSA/IGAke2V2LnByb2ZpbGUucHVia2V5LnNsaWNlKDAsIDYpfS4uLiR7ZXYucHJvZmlsZS5wdWJrZXkuc2xpY2UoLTQpfWAgOiBldi5wdWJrZXkuc2xpY2UoMCwgNikgKyAnLi4uJyArIGV2LnB1YmtleS5zbGljZSgtNCkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1ncmF5LTUwMFwiPntyZWxhdGl2ZVRpbWUoZXYuY3JlYXRlZF9hdCl9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4LTFcIiAvPlxuXG4gICAgICAgICAgICAgICAgICAgICAgey8qIENoYXQgY291bnQgYmFkZ2UgKi99XG4gICAgICAgICAgICAgICAgICAgICAge2NoYXRDb3VudHNbZXYuaWRdID4gMCAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInB4LTIgcHktMSByb3VuZGVkLWZ1bGwgYmctYmx1ZS01MDAvMTAgdGV4dC1ibHVlLTQwMCB0ZXh0LXNtIGZsZXggaXRlbXMtY2VudGVyIGdhcC0xXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPvCfkqw8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtjaGF0Q291bnRzW2V2LmlkXX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgIHsvKiBQb3N0IGNvbnRlbnQgKi99XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1sZyB0ZXh0LXdoaXRlIHdoaXRlc3BhY2UtcHJlLWxpbmUgYnJlYWstd29yZHMgbWItMVwiPlxuICAgICAgICAgICAgICAgICAgICAgIHtmb3JtYXROb3N0ckFkZHJlc3Nlcyhldi5jb250ZW50KX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIHtyZW5kZXJNZWRpYVdpdGhQcmV2aWV3KGV2Lm1lZGlhLCBsaW5rUHJldmlld3MsIHNldExpZ2h0Ym94TWVkaWEpfVxuICAgICAgICAgICAgICAgICAgICB7cmVuZGVySGFzaHRhZ3MoZXYpfVxuXG4gICAgICAgICAgICAgICAgICAgIHsvKiBQb3N0IGFjdGlvbnMgKi99XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBnYXAtNiBtdC0yIHRleHQtc20gdGV4dC1ncmF5LTQwMCBib3JkZXItdCBib3JkZXItZ3JheS04MDAgcHQtM1wiPlxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgdHJhbnNpdGlvbiAke2FjdGl2ZUNoYXRQb3N0SWQgPT09IGV2LmlkID8gJ3RleHQtYmx1ZS00MDAnIDogJ2hvdmVyOnRleHQtYmx1ZS00MDAnfWB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+8J+SrDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPkNoYXR7Y2hhdENvdW50c1tldi5pZF0gPiAwID8gYCAoJHtjaGF0Q291bnRzW2V2LmlkXX0pYCA6ICcnfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMiBob3Zlcjp0ZXh0LXBpbmstNDAwIHRyYW5zaXRpb24gJHtsaWtlZFBvc3RzW2V2LmlkXSA/ICd0ZXh0LXBpbmstNDAwIGZvbnQtYm9sZCcgOiAnJ31gfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17ZSA9PiB7IGUuc3RvcFByb3BhZ2F0aW9uKCk7IGlmICghbGlrZWRQb3N0c1tldi5pZF0pIGhhbmRsZUxpa2UoZXYuaWQsIGV2LnB1YmtleSk7IH19XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17ISFsaWtlZFBvc3RzW2V2LmlkXX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e2xpa2VkUG9zdHNbZXYuaWRdID8gJ0xpa2VkJyA6ICdMaWtlJ31cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPuKdpO+4jzwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPkxpa2V7bGlrZUNvdW50c1tldi5pZF0gPyBgICgke2xpa2VDb3VudHNbZXYuaWRdfSlgIDogJyd9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YGZsZXggaXRlbXMtY2VudGVyIGdhcC0yIGhvdmVyOnRleHQtZ3JlZW4tNDAwIHRyYW5zaXRpb24gJHtyZXBvc3RlZFBvc3RzW2V2LmlkXSA/ICd0ZXh0LWdyZWVuLTQwMCBmb250LWJvbGQnIDogJyd9YH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2UgPT4geyBlLnN0b3BQcm9wYWdhdGlvbigpOyBpZiAoIXJlcG9zdGVkUG9zdHNbZXYuaWRdKSBoYW5kbGVSZXBvc3QoZXYuaWQsIGV2LnB1YmtleSwgZXYuY29udGVudCk7IH19XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17ISFyZXBvc3RlZFBvc3RzW2V2LmlkXX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9e3JlcG9zdGVkUG9zdHNbZXYuaWRdID8gJ1JlcG9zdGVkJyA6ICdSZXBvc3QnfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+8J+UgTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPlJlcG9zdHtyZXBvc3RDb3VudHNbZXYuaWRdID8gYCAoJHtyZXBvc3RDb3VudHNbZXYuaWRdfSlgIDogJyd9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICB7LyogQ2hhdCBib3ggYmVsb3cgcG9zdCAqL31cbiAgICAgICAgICAgICAgICAgIHthY3RpdmVDaGF0UG9zdElkID09PSBldi5pZCAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDxDaGF0Qm94XG4gICAgICAgICAgICAgICAgICAgICAgcG9zdElkPXtldi5pZH1cbiAgICAgICAgICAgICAgICAgICAgICBwdWJrZXk9e3B1YmtleX1cbiAgICAgICAgICAgICAgICAgICAgICBvbkNsb3NlPXsoKSA9PiBoYW5kbGVDaGF0Q2xvc2UoZXYuaWQpfVxuICAgICAgICAgICAgICAgICAgICAgIGlzQW5pbWF0aW5nPXtjbG9zaW5nQ2hhdElkID09PSBldi5pZH1cbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICB7LyogTG9hZGluZyBTdGF0ZSAqL31cbiAgICAgICAgICAgICAge2lzTG9hZGluZ01vcmUgJiYgKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgcHktNFwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbmxpbmUtYmxvY2sgYW5pbWF0ZS1zcGluIHJvdW5kZWQtZnVsbCBoLTggdy04IGJvcmRlci10LTIgYm9yZGVyLWItMiBib3JkZXItYmx1ZS01MDBcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cIm10LTIgdGV4dC1ncmF5LTQwMCB0ZXh0LXNtXCI+TG9hZGluZyBtb3JlIHBvc3RzLi4uPC9wPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuXG4gICAgICAgICAgICAgIHsvKiBFbmQgb2YgRmVlZCAqL31cbiAgICAgICAgICAgICAgeyFoYXNNb3JlICYmIGV2ZW50cy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyIHB5LTggdGV4dC1ncmF5LTUwMFwiPlxuICAgICAgICAgICAgICAgICAgWW91J3ZlIHJlYWNoZWQgdGhlIGVuZCFcbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgICB7LyogUmV0cnkgU3RhdGUgKi99XG4gICAgICAgICAgICAgIHtyZXRyeUNvdW50ID4gMCAmJiAhaXNMb2FkaW5nTW9yZSAmJiBoYXNNb3JlICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyIHB5LTRcIj5cbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtZ3JheS00MDAgbWItMlwiPkZhaWxlZCB0byBsb2FkIG1vcmUgcG9zdHM8L3A+XG4gICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRlc3RFdmVudCA9IGV2ZW50c1tldmVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZGVzdEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmdNb3JlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hFdmVudHMoeyB1bnRpbDogb2xkZXN0RXZlbnQuY3JlYXRlZF9hdCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihoYXNOZXdFdmVudHMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEhhc01vcmUoaGFzTmV3RXZlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmdNb3JlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRSZXRyeUNvdW50KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldElzTG9hZGluZ01vcmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFJldHJ5Q291bnQocHJldiA9PiBwcmV2ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtNCBweS0yIGJnLWJsdWUtNTAwLzIwIGhvdmVyOmJnLWJsdWUtNTAwLzMwIHJvdW5kZWQtZnVsbCB0ZXh0LXNtIHRyYW5zaXRpb25cIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICBUcnkgQWdhaW5cbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9tYWluPlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgey8qIER5bmFtaWMgU2lkZSBQYW5lIChFeHBsb3JlLCBXYWxsZXQsIENoYXQsIFByb2ZpbGUsIGV0Yy4pICovfVxuICAgICAgICAgIHthY3RpdmVQYW5lICYmIHNpZGVQYW5lQ29tcG9uZW50ICYmIChcbiAgICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cImhpZGRlbiBsZzpibG9jayB3LWZ1bGwgbWF4LXctMnhsIHB4LTIgc206cHgtNiBweS04IGJnLWdyYXktOTUwIGJvcmRlciBib3JkZXItZ3JheS04MDAgc2hhZG93LXhsIHJvdW5kZWQteGwgb3ZlcmZsb3cteS1hdXRvIHJlbGF0aXZlIGFuaW1hdGUtc2xpZGUtaW4tbGVmdCBmbGV4LXNocmluay0wIGgtW2NhbGMoMTAwdmgtMzJweCldXCI+XG4gICAgICAgICAgICAgIHtzaWRlUGFuZUNvbXBvbmVudH1cbiAgICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7LyogUmlnaHQgU2lkZWJhciAoZml4ZWQpICovfVxuICAgICAgPGFzaWRlIGNsYXNzTmFtZT1cImhpZGRlbiB4bDpmbGV4IGZsZXgtY29sIHctWzMyMHB4XSBoLXNjcmVlbiBzdGlja3kgdG9wLTAgcmlnaHQtMCB6LTMwIGJvcmRlci1sIGJvcmRlci1ncmF5LTgwMCBiZy1ncmF5LTk1MFwiPlxuICAgICAgICA8UmlnaHRTaWRlYmFyIHRyZW5kaW5nSGFzaHRhZ3M9e3RyZW5kaW5nSGFzaHRhZ3N9IHNlYXJjaEhhc2h0YWc9e3NlYXJjaEhhc2h0YWd9IC8+XG4gICAgICA8L2FzaWRlPlxuICAgIDwvZGl2PlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZU5vc3RyIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInVzZU1lbW8iLCJmZXRjaExpbmtQcmV2aWV3IiwiQ2hhdEJveCIsIkVycm9yTWVzc2FnZSIsIk1lZGlhUGxheWVyIiwiZ2V0SGVhbHRoeVJlbGF5cyIsImZldGNoTm9zdHJGZWVkIiwiY2xlYXJCYWRSZWxheUNhY2hlIiwiU2ltcGxlUG9vbCIsIlByb2ZpbGVQYWdlIiwiRXhwbG9yZVBhZ2UiLCJXYWxsZXRQYWdlIiwiQ2hhdFBhZ2UiLCJTaWRlYmFyIiwiUmlnaHRTaWRlYmFyIiwicmVsYXRpdmVUaW1lIiwidGltZXN0YW1wIiwibm93IiwiRGF0ZSIsImRpZmYiLCJNYXRoIiwiZmxvb3IiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJyZW5kZXJMaW5rUHJldmlldyIsInByZXZpZXciLCJhIiwiaHJlZiIsInVybCIsInRhcmdldCIsInJlbCIsImNsYXNzTmFtZSIsImltYWdlIiwiaW1nIiwic3JjIiwiYWx0IiwidGl0bGUiLCJkaXYiLCJzaXRlTmFtZSIsImZhdmljb24iLCJkZXNjcmlwdGlvbiIsImZvcm1hdE5vc3RyQWRkcmVzc2VzIiwidGV4dCIsIm5vc3RyUmVnZXgiLCJzcGxpdCIsIm1hcCIsInBhcnQiLCJpIiwibWF0Y2giLCJxdWVyeVJlbGF5RXZlbnRzIiwiZmlsdGVyIiwiaGVhbHRoeVJlbGF5cyIsInBvb2wiLCJxdWVyeVN5bmMiLCJjbG9zZSIsIkhvbWUiLCJwdWJrZXkiLCJldmVudHMiLCJlcnJvciIsImxvZ2luIiwiZmV0Y2hFdmVudHMiLCJwb3N0IiwiZm9sbG93VXNlciIsInVuZm9sbG93VXNlciIsImlzRm9sbG93aW5nIiwicmVsYXlTdGF0cyIsImNvbnRlbnQiLCJzZXRDb250ZW50IiwibGlua1ByZXZpZXdzIiwic2V0TGlua1ByZXZpZXdzIiwiYWN0aXZlQ2hhdFBvc3RJZCIsInNldEFjdGl2ZUNoYXRQb3N0SWQiLCJjbG9zaW5nQ2hhdElkIiwic2V0Q2xvc2luZ0NoYXRJZCIsImNoYXRDb3VudHMiLCJzZXRDaGF0Q291bnRzIiwiaXNMb2FkaW5nTW9yZSIsInNldElzTG9hZGluZ01vcmUiLCJoYXNNb3JlIiwic2V0SGFzTW9yZSIsInJldHJ5Q291bnQiLCJzZXRSZXRyeUNvdW50IiwicHJvZmlsZVBhbmVPcGVuIiwic2V0UHJvZmlsZVBhbmVPcGVuIiwic2VhcmNoIiwic2V0U2VhcmNoIiwic2VhcmNoUmVzdWx0cyIsInNldFNlYXJjaFJlc3VsdHMiLCJzZWFyY2hGb2N1c2VkIiwic2V0U2VhcmNoRm9jdXNlZCIsImhhc2h0YWciLCJzZXRIYXNodGFnIiwiaGFzaHRhZ1Jlc3VsdHMiLCJzZXRIYXNodGFnUmVzdWx0cyIsImZpbHRlclRhZyIsInNldEZpbHRlclRhZyIsInNob3dGaWx0ZXIiLCJzZXRTaG93RmlsdGVyIiwic2hvd0Z1bGxQcm9maWxlIiwic2V0U2hvd0Z1bGxQcm9maWxlIiwic2VhcmNoVGltZW91dCIsIm9ic2VydmVyUmVmIiwibGFzdFBvc3RSZWYiLCJnbG9iYWxQb3N0Q291bnQiLCJ1c2VHbG9iYWxOb3N0clBvc3RDb3VudCIsImxpa2VDb3VudHMiLCJzZXRMaWtlQ291bnRzIiwibGlrZWRQb3N0cyIsInNldExpa2VkUG9zdHMiLCJyZXBvc3RDb3VudHMiLCJzZXRSZXBvc3RDb3VudHMiLCJyZXBvc3RlZFBvc3RzIiwic2V0UmVwb3N0ZWRQb3N0cyIsImxpZ2h0Ym94TWVkaWEiLCJzZXRMaWdodGJveE1lZGlhIiwic3RhdHMiLCJzZXRTdGF0cyIsImxvYWRpbmdTdGF0cyIsInNldExvYWRpbmdTdGF0cyIsImFjdGl2ZVBhbmUiLCJzZXRBY3RpdmVQYW5lIiwic2lkZVBhbmVDb21wb25lbnQiLCJzZXRTaWRlUGFuZUNvbXBvbmVudCIsInByb2ZpbGVQYW5lUHVia2V5Iiwic2V0UHJvZmlsZVBhbmVQdWJrZXkiLCJoYW5kbGVOYXYiLCJrZXkiLCJhbGxQcm9maWxlcyIsInNlZW4iLCJTZXQiLCJldiIsInByb2ZpbGUiLCJwIiwiaGFzIiwiYWRkIiwiY3VycmVudCIsImNsZWFyVGltZW91dCIsInRyaW0iLCJzZXRUaW1lb3V0IiwicSIsInRvTG93ZXJDYXNlIiwicmVzdWx0cyIsImRpc3BsYXlfbmFtZSIsImluY2x1ZGVzIiwidXNlcm5hbWUiLCJzbGljZSIsInNlYXJjaFJlZiIsImhhbmRsZUNsaWNrIiwiZSIsImNvbnRhaW5zIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZU9ic2VydmVyIiwiZW50cmllcyIsImlzSW50ZXJzZWN0aW5nIiwib2xkZXN0RXZlbnQiLCJsZW5ndGgiLCJ1bnRpbCIsImNyZWF0ZWRfYXQiLCJ0aGVuIiwiaGFzTmV3RXZlbnRzIiwiY2F0Y2giLCJwcmV2IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJyb290Iiwicm9vdE1hcmdpbiIsInRocmVzaG9sZCIsIm9ic2VydmUiLCJkaXNjb25uZWN0IiwiaGFuZGxlQ2hhdENsb3NlIiwicG9zdElkIiwib2xkZXN0IiwibGltaXQiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImFsbExpbmtzIiwiQXJyYXkiLCJmcm9tIiwiZmxhdE1hcCIsIm1lZGlhIiwiZm9yRWFjaCIsImV4dHJhY3RIYXNodGFncyIsImV2ZW50IiwiY29udGVudFRhZ3MiLCJoIiwicmVwbGFjZSIsInRhZ1RhZ3MiLCJ0YWdzIiwidCIsInRlc3QiLCJldmVudEhhc2h0YWdzUmVmIiwiZXZlbnRIYXNodGFncyIsImlkIiwic2VhcmNoSGFzaHRhZyIsInRhZyIsImtpbmRzIiwicG9zdHMiLCJyZW5kZXJIYXNodGFncyIsImJ1dHRvbiIsIm9uQ2xpY2siLCJzdG9wUHJvcGFnYXRpb24iLCJmaWx0ZXJlZEV2ZW50cyIsInRhZ01hdGNoIiwidGFnQXJyYXkiLCJ0cmVuZGluZ0hhc2h0YWdzIiwidGFnQ291bnRzIiwiT2JqZWN0Iiwic29ydCIsImIiLCJpc01vdW50ZWQiLCJwb3N0SWRzIiwibGlrZUV2ZW50cyIsImNvdW50cyIsImxpa2VkIiwicmVmSWQiLCJmaW5kIiwiaGFuZGxlTGlrZSIsInBvc3RQdWJrZXkiLCJ3aW5kb3ciLCJub3N0ciIsImtpbmQiLCJzaWciLCJzaWduZWQiLCJzaWduRXZlbnQiLCJlcnIiLCJtYXgiLCJyZXBvc3RFdmVudHMiLCJyZXBvc3RlZCIsImhhbmRsZVJlcG9zdCIsInBvc3RDb250ZW50IiwicmVuZGVyTWVkaWFXaXRoUHJldmlldyIsImltYWdlcyIsInlvdVR1YmVSZWdleCIsInNvdW5kQ2xvdWRSZWdleCIsInZpZGVvcyIsImF1ZGlvcyIsIm1lZGlhU2V0IiwibGlua3MiLCJpZHgiLCJzcGFuIiwiUHJvZmlsZURyb3Bkb3duIiwiY2hpbGRyZW4iLCJtZW51Iiwib3BlbiIsInNldE9wZW4iLCJyZWYiLCJ2IiwidG90YWxDb3VudCIsInNldFRvdGFsQ291bnQiLCJmZXRjaENvdW50IiwicmVzdWx0IiwidW5pcXVlSWRzIiwic2l6ZSIsIm9wZW5Qcm9maWxlUGFuZSIsImNvbXBvbmVudCIsInVzZXJPdmVycmlkZSIsIm9uQ2xvc2UiLCJoZWFsdGh5UmVsYXlDb3VudCIsInNldEhlYWx0aHlSZWxheUNvdW50IiwiY2hlY2tpbmdSZWxheXMiLCJzZXRDaGVja2luZ1JlbGF5cyIsIm1vdW50ZWQiLCJjaGVja1JlbGF5cyIsImFzaWRlIiwib25OYXYiLCJpbnB1dCIsInR5cGUiLCJ2YWx1ZSIsIm9uQ2hhbmdlIiwib25Gb2N1cyIsInBsYWNlaG9sZGVyIiwiYXV0b0NvbXBsZXRlIiwiaGVhZGVyIiwiaDEiLCJ0b0xvY2FsZVN0cmluZyIsImRpc2FibGVkIiwibWFpbiIsIm1lc3NhZ2UiLCJvblJldHJ5Iiwib25DbGVhclJlbGF5cyIsImluZGV4IiwicGljdHVyZSIsInRhYkluZGV4IiwiYXJpYS1sYWJlbCIsIm5hbWUiLCJpc0FuaW1hdGluZyIsInNlY3Rpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/profile/page.tsx":
/*!**********************************!*\
  !*** ./src/app/profile/page.tsx ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ProfilePage),\n/* harmony export */   dynamic: () => (/* binding */ dynamic)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _hooks_useNostr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/hooks/useNostr */ \"(app-pages-browser)/./src/hooks/useNostr.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _lib_nostr_relay__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/nostr/relay */ \"(app-pages-browser)/./src/lib/nostr/relay.ts\");\n/* harmony import */ var _components_feed_Post__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/components/feed/Post */ \"(app-pages-browser)/./src/components/feed/Post.tsx\");\n/* harmony import */ var _components_ui_tabs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/ui/tabs */ \"(app-pages-browser)/./src/components/ui/tabs.tsx\");\n/* __next_internal_client_entry_do_not_use__ dynamic,default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst dynamic = \"force-static\";\nfunction ProfilePage(param) {\n    let { userOverride, onClose } = param;\n    var _userProfile_username_slice, _userProfile_username, _userProfile_pubkey_slice, _userProfile_pubkey, _userProfile_pubkey1, _userProfile_pubkey2, _editUsername_slice, _userProfile_pubkey_slice1, _userProfile_pubkey3;\n    _s();\n    const { events: rawEvents, profile, pubkey, updateProfile, isFollowing, followUser, unfollowUser } = (0,_hooks_useNostr__WEBPACK_IMPORTED_MODULE_1__.useNostr)();\n    const searchParams = (0,next_navigation__WEBPACK_IMPORTED_MODULE_3__.useSearchParams)();\n    const user = userOverride || searchParams.get(\"user\") || pubkey;\n    const [userProfile, setUserProfile] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [editing, setEditing] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [editDisplayName, setEditDisplayName] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [editBio, setEditBio] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [editUsername, setEditUsername] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [editPicture, setEditPicture] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [editBanner, setEditBanner] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [editWebsite, setEditWebsite] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [editNip05, setEditNip05] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const [userPosts, setUserPosts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [likesCount, setLikesCount] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(0);\n    const [retweetsCount, setRetweetsCount] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(0);\n    const [lightboxMedia, setLightboxMedia] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [profileLoaded, setProfileLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const [activeTab, setActiveTab] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)('posts');\n    const [likedPosts, setLikedPosts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [retweetedPosts, setRetweetedPosts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [followingUsers, setFollowingUsers] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [followingCount, setFollowingCount] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(0);\n    const [followingFilter, setFollowingFilter] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(\"\");\n    const lastUserRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    // Ensure events are NostrEvent[]\n    const events = rawEvents;\n    // Fetch posts for the profile being viewed\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"ProfilePage.useEffect\": ()=>{\n            if (!user) return;\n            // Prevent re-fetching if already loaded for this user\n            if (userProfile && userProfile.pubkey === user && userPosts.length > 0) return;\n            setLoading(true);\n            ({\n                \"ProfilePage.useEffect\": async ()=>{\n                    try {\n                        if (user === pubkey) {\n                            setUserProfile(profile);\n                            setEditDisplayName((profile === null || profile === void 0 ? void 0 : profile.display_name) || \"\");\n                            setEditBio((profile === null || profile === void 0 ? void 0 : profile.about) || \"\");\n                            setEditUsername((profile === null || profile === void 0 ? void 0 : profile.username) || \"\");\n                            setEditPicture((profile === null || profile === void 0 ? void 0 : profile.picture) || \"\");\n                            setEditBanner((profile === null || profile === void 0 ? void 0 : profile.banner) || \"\");\n                            setEditWebsite((profile === null || profile === void 0 ? void 0 : profile.website) || \"\");\n                            setEditNip05((profile === null || profile === void 0 ? void 0 : profile.nip05) || \"\");\n                            setUserPosts(events.filter({\n                                \"ProfilePage.useEffect\": (ev)=>ev.pubkey === user && ev.kind === 1\n                            }[\"ProfilePage.useEffect\"]));\n                        } else {\n                            // Get healthy relays\n                            const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_4__.getHealthyRelays)();\n                            // Fetch profile from relays\n                            const meta = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_4__.fetchNostrProfile)(healthyRelays, user);\n                            setUserProfile({\n                                display_name: (meta === null || meta === void 0 ? void 0 : meta.display_name) || (meta === null || meta === void 0 ? void 0 : meta.name) || user,\n                                bio: meta === null || meta === void 0 ? void 0 : meta.about,\n                                picture: meta === null || meta === void 0 ? void 0 : meta.picture,\n                                username: (meta === null || meta === void 0 ? void 0 : meta.name) || user,\n                                pubkey: user\n                            });\n                            // Try fetching posts with 'authors' filter first\n                            let posts = [];\n                            try {\n                                posts = await fetchNostrFeedWithFilter(healthyRelays, {\n                                    kinds: [\n                                        1\n                                    ],\n                                    authors: [\n                                        user\n                                    ],\n                                    limit: 100\n                                }) || [];\n                            } catch (e) {\n                                // Fallback: try with 'pubkey' (legacy/compat)\n                                posts = await fetchNostrFeedWithFilter(healthyRelays, {\n                                    kinds: [\n                                        1\n                                    ],\n                                    pubkey: user,\n                                    limit: 100\n                                }) || [];\n                            }\n                            // If still no posts, fallback to local events\n                            if (!posts.length) {\n                                posts = events.filter({\n                                    \"ProfilePage.useEffect\": (ev)=>ev.pubkey === user && ev.kind === 1\n                                }[\"ProfilePage.useEffect\"]);\n                            }\n                            setUserPosts(posts.map({\n                                \"ProfilePage.useEffect\": (ev)=>({\n                                        ...ev,\n                                        media: [],\n                                        profile: {\n                                            display_name: (meta === null || meta === void 0 ? void 0 : meta.display_name) || (meta === null || meta === void 0 ? void 0 : meta.name) || user,\n                                            username: (meta === null || meta === void 0 ? void 0 : meta.name) || user,\n                                            picture: meta === null || meta === void 0 ? void 0 : meta.picture,\n                                            bio: meta === null || meta === void 0 ? void 0 : meta.about,\n                                            pubkey: user\n                                        }\n                                    })\n                            }[\"ProfilePage.useEffect\"]));\n                        }\n                        setProfileLoaded(true);\n                    } catch (error) {\n                        console.error(\"Error fetching user posts or profile:\", error);\n                    } finally{\n                        setLoading(false);\n                    }\n                }\n            })[\"ProfilePage.useEffect\"]();\n        }\n    }[\"ProfilePage.useEffect\"], [\n        user,\n        pubkey,\n        profile,\n        events\n    ]);\n    // Helper to allow passing custom filter to fetchNostrFeed\n    function fetchNostrFeedWithFilter(relayUrls, filter) {\n        // This is a workaround to allow custom filters for likes/retweets\n        const pool = new (__webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/../node_modules/nostr-tools/lib/cjs/index.js\").SimplePool)();\n        return pool.querySync(relayUrls, filter).then((events)=>{\n            pool.close(relayUrls);\n            return events;\n        });\n    }\n    // Fetch likes and retweets for the user's posts\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"ProfilePage.useEffect\": ()=>{\n            if (!userPosts.length) return;\n            ({\n                \"ProfilePage.useEffect\": async ()=>{\n                    // Get all post ids\n                    const postIds = userPosts.map({\n                        \"ProfilePage.useEffect.postIds\": (ev)=>ev.id\n                    }[\"ProfilePage.useEffect.postIds\"]);\n                    // Get healthy relays\n                    const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_4__.getHealthyRelays)();\n                    // Fetch likes (kind 7) referencing these posts\n                    const likeEvents = await fetchNostrFeedWithFilter(healthyRelays, {\n                        kinds: [\n                            7\n                        ],\n                        '#e': postIds,\n                        limit: 1000\n                    }) || [];\n                    setLikesCount(likeEvents.length);\n                    // Fetch retweets (kind 6) referencing these posts\n                    const retweetEvents = await fetchNostrFeedWithFilter(healthyRelays, {\n                        kinds: [\n                            6\n                        ],\n                        '#e': postIds,\n                        limit: 1000\n                    }) || [];\n                    setRetweetsCount(retweetEvents.length);\n                }\n            })[\"ProfilePage.useEffect\"]();\n        }\n    }[\"ProfilePage.useEffect\"], [\n        userPosts\n    ]);\n    // Fetch liked posts\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"ProfilePage.useEffect\": ()=>{\n            if (activeTab !== 'liked' || !user) return;\n            ({\n                \"ProfilePage.useEffect\": async ()=>{\n                    setLoading(true);\n                    try {\n                        const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_4__.getHealthyRelays)();\n                        // Fetch like events (kind 7) by this user\n                        const likeEvents = await fetchNostrFeedWithFilter(healthyRelays, {\n                            kinds: [\n                                7\n                            ],\n                            authors: [\n                                user\n                            ],\n                            limit: 100\n                        }) || [];\n                        // For each like event, get the referenced post id\n                        const postIds = likeEvents.map({\n                            \"ProfilePage.useEffect.postIds\": (ev)=>{\n                                const tag = ev.tags.find({\n                                    \"ProfilePage.useEffect.postIds.tag\": (t)=>t[0] === 'e'\n                                }[\"ProfilePage.useEffect.postIds.tag\"]);\n                                return tag ? tag[1] : null;\n                            }\n                        }[\"ProfilePage.useEffect.postIds\"]).filter(Boolean);\n                        // Fetch the actual posts\n                        let posts = [];\n                        if (postIds.length) {\n                            posts = await fetchNostrFeedWithFilter(healthyRelays, {\n                                kinds: [\n                                    1\n                                ],\n                                ids: postIds,\n                                limit: 100\n                            }) || [];\n                        }\n                        setLikedPosts(posts);\n                    } catch (e) {\n                        setLikedPosts([]);\n                    } finally{\n                        setLoading(false);\n                    }\n                }\n            })[\"ProfilePage.useEffect\"]();\n        }\n    }[\"ProfilePage.useEffect\"], [\n        activeTab,\n        user\n    ]);\n    // Fetch retweeted posts\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"ProfilePage.useEffect\": ()=>{\n            if (activeTab !== 'retweeted' || !user) return;\n            ({\n                \"ProfilePage.useEffect\": async ()=>{\n                    setLoading(true);\n                    try {\n                        const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_4__.getHealthyRelays)();\n                        // Fetch retweet events (kind 6) by this user\n                        const retweetEvents = await fetchNostrFeedWithFilter(healthyRelays, {\n                            kinds: [\n                                6\n                            ],\n                            authors: [\n                                user\n                            ],\n                            limit: 100\n                        }) || [];\n                        // For each retweet event, get the referenced post id\n                        const postIds = retweetEvents.map({\n                            \"ProfilePage.useEffect.postIds\": (ev)=>{\n                                const tag = ev.tags.find({\n                                    \"ProfilePage.useEffect.postIds.tag\": (t)=>t[0] === 'e'\n                                }[\"ProfilePage.useEffect.postIds.tag\"]);\n                                return tag ? tag[1] : null;\n                            }\n                        }[\"ProfilePage.useEffect.postIds\"]).filter(Boolean);\n                        // Fetch the actual posts\n                        let posts = [];\n                        if (postIds.length) {\n                            posts = await fetchNostrFeedWithFilter(healthyRelays, {\n                                kinds: [\n                                    1\n                                ],\n                                ids: postIds,\n                                limit: 100\n                            }) || [];\n                        }\n                        setRetweetedPosts(posts);\n                    } catch (e) {\n                        setRetweetedPosts([]);\n                    } finally{\n                        setLoading(false);\n                    }\n                }\n            })[\"ProfilePage.useEffect\"]();\n        }\n    }[\"ProfilePage.useEffect\"], [\n        activeTab,\n        user\n    ]);\n    // Fetch following count (and optionally, following users for the tab)\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"ProfilePage.useEffect\": ()=>{\n            if (!user) return;\n            ({\n                \"ProfilePage.useEffect\": async ()=>{\n                    try {\n                        var _contactEvents_;\n                        const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_4__.getHealthyRelays)();\n                        // Fetch contact list (kind 3) for this user\n                        const contactEvents = await fetchNostrFeedWithFilter(healthyRelays, {\n                            kinds: [\n                                3\n                            ],\n                            authors: [\n                                user\n                            ],\n                            limit: 1\n                        }) || [];\n                        const tags = ((_contactEvents_ = contactEvents[0]) === null || _contactEvents_ === void 0 ? void 0 : _contactEvents_.tags) || [];\n                        const pubkeys = tags.filter({\n                            \"ProfilePage.useEffect.pubkeys\": (t)=>t[0] === 'p'\n                        }[\"ProfilePage.useEffect.pubkeys\"]).map({\n                            \"ProfilePage.useEffect.pubkeys\": (t)=>t[1]\n                        }[\"ProfilePage.useEffect.pubkeys\"]);\n                        setFollowingCount(pubkeys.length);\n                        // If the following tab is open, fetch profiles\n                        if (activeTab === 'following') {\n                            let profiles = [];\n                            if (pubkeys.length) {\n                                profiles = await Promise.all(pubkeys.slice(0, 50).map({\n                                    \"ProfilePage.useEffect\": async (pk)=>{\n                                        const meta = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_4__.fetchNostrProfile)(healthyRelays, pk);\n                                        return {\n                                            pubkey: pk,\n                                            displayName: (meta === null || meta === void 0 ? void 0 : meta.display_name) || (meta === null || meta === void 0 ? void 0 : meta.name) || pk,\n                                            picture: meta === null || meta === void 0 ? void 0 : meta.picture,\n                                            username: (meta === null || meta === void 0 ? void 0 : meta.name) || pk\n                                        };\n                                    }\n                                }[\"ProfilePage.useEffect\"]));\n                            }\n                            setFollowingUsers(profiles);\n                        }\n                    } catch (e) {\n                        setFollowingCount(0);\n                        if (activeTab === 'following') setFollowingUsers([]);\n                    }\n                }\n            })[\"ProfilePage.useEffect\"]();\n        }\n    }[\"ProfilePage.useEffect\"], [\n        user,\n        activeTab === 'following'\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"ProfilePage.useEffect\": ()=>{\n            if (userProfile) {\n                setEditDisplayName(userProfile.display_name);\n                var _userProfile_bio, _ref;\n                setEditBio((_ref = (_userProfile_bio = userProfile.bio) !== null && _userProfile_bio !== void 0 ? _userProfile_bio : userProfile.about) !== null && _ref !== void 0 ? _ref : \"\");\n                setEditUsername(userProfile.username || \"\");\n                setEditPicture(userProfile.picture || \"\");\n                setEditBanner(userProfile.banner || \"\");\n                setEditWebsite(userProfile.website || \"\");\n                setEditNip05(userProfile.nip05 || \"\");\n            }\n        }\n    }[\"ProfilePage.useEffect\"], [\n        userProfile\n    ]);\n    // --- Main feed feature parity state ---\n    const [activeChatPostId, setActiveChatPostId] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [closingChatId, setClosingChatId] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [chatCounts, setChatCounts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({});\n    // Handle chat closing with animation (matches main feed)\n    const handleChatClose = (postId)=>{\n        setClosingChatId(postId);\n        setTimeout(()=>{\n            setActiveChatPostId(null);\n            setClosingChatId(null);\n        }, 300);\n    };\n    // Add skeleton loaders for profile and posts\n    if (loading) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"max-w-2xl mx-auto p-6 text-white\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center gap-4 mb-6 animate-pulse\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"w-20 h-20 bg-gray-700 rounded-full\"\n                        }, void 0, false, {\n                            fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                            lineNumber: 304,\n                            columnNumber: 21\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex flex-col gap-2\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-32 h-6 bg-gray-700 rounded\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                    lineNumber: 306,\n                                    columnNumber: 25\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-24 h-4 bg-gray-700 rounded\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                    lineNumber: 307,\n                                    columnNumber: 25\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                            lineNumber: 305,\n                            columnNumber: 21\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                    lineNumber: 303,\n                    columnNumber: 17\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex flex-col gap-4\",\n                    children: [\n                        ...Array(3)\n                    ].map((_, idx)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"bg-gray-800 border border-gray-700 rounded-xl p-4 animate-pulse\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-full h-6 bg-gray-700 rounded mb-2\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                    lineNumber: 313,\n                                    columnNumber: 29\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-full h-4 bg-gray-700 rounded\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                    lineNumber: 314,\n                                    columnNumber: 29\n                                }, this)\n                            ]\n                        }, idx, true, {\n                            fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                            lineNumber: 312,\n                            columnNumber: 25\n                        }, this))\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                    lineNumber: 310,\n                    columnNumber: 17\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n            lineNumber: 302,\n            columnNumber: 13\n        }, this);\n    }\n    if (!user) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"p-8 text-center\",\n            children: \"No user selected.\"\n        }, void 0, false, {\n            fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n            lineNumber: 323,\n            columnNumber: 16\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"max-w-2xl mx-auto p-6 text-white relative\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mb-2 text-xs text-gray-400\",\n                children: [\n                    \"user: \",\n                    user,\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {}, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 329,\n                        columnNumber: 69\n                    }, this),\n                    \"pubkey: \",\n                    pubkey\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                lineNumber: 329,\n                columnNumber: 13\n            }, this),\n            onClose && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                className: \"absolute top-4 right-4 text-gray-400 hover:text-white text-2xl font-bold z-10\",\n                onClick: onClose,\n                \"aria-label\": \"Close profile pane\",\n                children: \"\\xd7\"\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                lineNumber: 331,\n                columnNumber: 17\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"relative mb-8 rounded-xl shadow-xl bg-gradient-to-br from-[#23243a] to-[#181926] border border-gray-800 overflow-hidden\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"h-40 bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 340,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex items-end gap-6 px-8 pb-6 relative -mt-14\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"w-28 h-28 rounded-full border-4 border-white shadow-lg bg-gray-900 flex items-center justify-center overflow-hidden\",\n                                children: (userProfile === null || userProfile === void 0 ? void 0 : userProfile.picture) ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                    src: userProfile.picture,\n                                    alt: \"Profile\",\n                                    className: \"w-full h-full rounded-full object-cover\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                    lineNumber: 345,\n                                    columnNumber: 29\n                                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-full h-full flex items-center justify-center text-3xl font-bold text-gray-300\",\n                                    children: (userProfile === null || userProfile === void 0 ? void 0 : (_userProfile_username = userProfile.username) === null || _userProfile_username === void 0 ? void 0 : (_userProfile_username_slice = _userProfile_username.slice(0, 2)) === null || _userProfile_username_slice === void 0 ? void 0 : _userProfile_username_slice.toUpperCase()) || (userProfile === null || userProfile === void 0 ? void 0 : (_userProfile_pubkey = userProfile.pubkey) === null || _userProfile_pubkey === void 0 ? void 0 : (_userProfile_pubkey_slice = _userProfile_pubkey.slice(2, 4)) === null || _userProfile_pubkey_slice === void 0 ? void 0 : _userProfile_pubkey_slice.toUpperCase())\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                    lineNumber: 347,\n                                    columnNumber: 29\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 343,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex-1 flex flex-col gap-1\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        className: \"text-3xl font-bold leading-tight\",\n                                        children: (userProfile === null || userProfile === void 0 ? void 0 : userProfile.display_name) || (userProfile === null || userProfile === void 0 ? void 0 : userProfile.username) || (userProfile === null || userProfile === void 0 ? void 0 : (_userProfile_pubkey1 = userProfile.pubkey) === null || _userProfile_pubkey1 === void 0 ? void 0 : _userProfile_pubkey1.slice(0, 8)) + \"...\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 353,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex items-center gap-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"text-gray-400 text-lg font-mono\",\n                                                children: [\n                                                    \"@\",\n                                                    (userProfile === null || userProfile === void 0 ? void 0 : userProfile.username) || (userProfile === null || userProfile === void 0 ? void 0 : (_userProfile_pubkey2 = userProfile.pubkey) === null || _userProfile_pubkey2 === void 0 ? void 0 : _userProfile_pubkey2.slice(0, 8)) + \"...\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                                lineNumber: 355,\n                                                columnNumber: 29\n                                            }, this),\n                                            user !== pubkey && (userProfile === null || userProfile === void 0 ? void 0 : userProfile.pubkey) && (isFollowing && isFollowing(userProfile.pubkey) ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"ml-2 px-4 py-1 rounded bg-gray-700 text-white hover:bg-gray-600 text-xs font-semibold\",\n                                                onClick: ()=>unfollowUser(userProfile.pubkey),\n                                                children: \"Unfollow\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                                lineNumber: 359,\n                                                columnNumber: 37\n                                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"ml-2 px-4 py-1 rounded bg-blue-500 text-white hover:bg-blue-600 text-xs font-semibold\",\n                                                onClick: ()=>followUser(userProfile.pubkey),\n                                                children: \"Follow\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                                lineNumber: 364,\n                                                columnNumber: 37\n                                            }, this))\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 354,\n                                        columnNumber: 25\n                                    }, this),\n                                    user === pubkey && !editing && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"mt-3 w-fit px-5 py-2 rounded-lg bg-blue-500 text-white hover:bg-blue-600 transition font-semibold shadow-md\",\n                                        onClick: ()=>setEditing(true),\n                                        children: \"Edit Profile\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 372,\n                                        columnNumber: 29\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 352,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 342,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex gap-8 px-8 py-4 border-t border-gray-800 bg-black/30 text-center text-base font-medium\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                type: \"button\",\n                                className: \"focus:outline-none transition px-2 py-1 rounded-md \".concat(activeTab === 'posts' ? 'bg-blue-600/20 text-blue-400 font-bold' : 'hover:bg-gray-800 text-white'),\n                                onClick: ()=>setActiveTab('posts'),\n                                \"aria-current\": activeTab === 'posts',\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"font-bold\",\n                                        children: userPosts.length\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 387,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"ml-1\",\n                                        children: \"Posts\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 388,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 381,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                type: \"button\",\n                                className: \"focus:outline-none transition px-2 py-1 rounded-md \".concat(activeTab === 'liked' ? 'bg-blue-600/20 text-blue-400 font-bold' : 'hover:bg-gray-800 text-white'),\n                                onClick: ()=>setActiveTab('liked'),\n                                \"aria-current\": activeTab === 'liked',\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"font-bold\",\n                                        children: likesCount\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 396,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"ml-1\",\n                                        children: \"Liked\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 397,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 390,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                type: \"button\",\n                                className: \"focus:outline-none transition px-2 py-1 rounded-md \".concat(activeTab === 'retweeted' ? 'bg-blue-600/20 text-blue-400 font-bold' : 'hover:bg-gray-800 text-white'),\n                                onClick: ()=>setActiveTab('retweeted'),\n                                \"aria-current\": activeTab === 'retweeted',\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"font-bold\",\n                                        children: retweetsCount\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 405,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"ml-1\",\n                                        children: \"Retweeted\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 406,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 399,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                type: \"button\",\n                                className: \"focus:outline-none transition px-2 py-1 rounded-md \".concat(activeTab === 'following' ? 'bg-blue-600/20 text-blue-400 font-bold' : 'hover:bg-gray-800 text-white'),\n                                onClick: ()=>setActiveTab('following'),\n                                \"aria-current\": activeTab === 'following',\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"font-bold\",\n                                        children: followingCount\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 414,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"ml-1\",\n                                        children: \"Following\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 415,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 408,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 380,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                lineNumber: 338,\n                columnNumber: 13\n            }, this),\n            editing && user === pubkey && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                className: \"mb-6 bg-gray-900 border border-gray-800 rounded-xl p-4 flex flex-col gap-3\",\n                onSubmit: async (e)=>{\n                    e.preventDefault();\n                    await updateProfile({\n                        display_name: editDisplayName,\n                        username: editUsername,\n                        about: editBio,\n                        picture: editPicture,\n                        banner: editBanner,\n                        website: editWebsite,\n                        nip05: editNip05\n                    });\n                    setEditing(false);\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        className: \"font-semibold\",\n                        children: \"Avatar\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 437,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex items-center gap-4 mb-2\",\n                        children: [\n                            editPicture ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                src: editPicture,\n                                alt: \"Avatar preview\",\n                                className: \"w-16 h-16 rounded-full object-cover border border-gray-700\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 440,\n                                columnNumber: 29\n                            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"w-16 h-16 rounded-full bg-gray-700 flex items-center justify-center text-2xl text-gray-300 border border-gray-700\",\n                                children: (editUsername === null || editUsername === void 0 ? void 0 : (_editUsername_slice = editUsername.slice(0, 2)) === null || _editUsername_slice === void 0 ? void 0 : _editUsername_slice.toUpperCase()) || (userProfile === null || userProfile === void 0 ? void 0 : (_userProfile_pubkey3 = userProfile.pubkey) === null || _userProfile_pubkey3 === void 0 ? void 0 : (_userProfile_pubkey_slice1 = _userProfile_pubkey3.slice(2, 4)) === null || _userProfile_pubkey_slice1 === void 0 ? void 0 : _userProfile_pubkey_slice1.toUpperCase())\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 446,\n                                columnNumber: 29\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"file\",\n                                accept: \"image/*\",\n                                className: \"block text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100\",\n                                \"aria-label\": \"Upload avatar\",\n                                onChange: async (e)=>{\n                                    var _e_target_files;\n                                    const file = (_e_target_files = e.target.files) === null || _e_target_files === void 0 ? void 0 : _e_target_files[0];\n                                    if (file) {\n                                        const reader = new FileReader();\n                                        reader.onloadend = ()=>{\n                                            setEditPicture(reader.result);\n                                        };\n                                        reader.readAsDataURL(file);\n                                    }\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 450,\n                                columnNumber: 25\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 438,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        className: \"font-semibold\",\n                        children: \"Display Name\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 467,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        className: \"px-3 py-2 rounded bg-gray-800 text-white border border-gray-700\",\n                        value: editDisplayName,\n                        onChange: (e)=>setEditDisplayName(e.target.value),\n                        placeholder: \"Display Name\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 468,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        className: \"font-semibold\",\n                        children: \"Bio\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 474,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n                        className: \"px-3 py-2 rounded bg-gray-800 text-white border border-gray-700 resize-none\",\n                        value: editBio,\n                        onChange: (e)=>setEditBio(e.target.value),\n                        placeholder: \"Tell us about yourself\",\n                        rows: 3\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 475,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        className: \"font-semibold\",\n                        children: \"Username\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 482,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        className: \"px-3 py-2 rounded bg-gray-800 text-white border border-gray-700\",\n                        value: editUsername,\n                        onChange: (e)=>setEditUsername(e.target.value),\n                        placeholder: \"Username\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 483,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        className: \"font-semibold\",\n                        children: \"Picture URL\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 489,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        className: \"px-3 py-2 rounded bg-gray-800 text-white border border-gray-700\",\n                        value: editPicture,\n                        onChange: (e)=>setEditPicture(e.target.value),\n                        placeholder: \"http://example.com/your-avatar.jpg\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 490,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        className: \"font-semibold\",\n                        children: \"Banner URL\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 496,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        className: \"px-3 py-2 rounded bg-gray-800 text-white border border-gray-700\",\n                        value: editBanner,\n                        onChange: (e)=>setEditBanner(e.target.value),\n                        placeholder: \"http://example.com/your-banner.jpg\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 497,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        className: \"font-semibold\",\n                        children: \"Website\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 503,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        className: \"px-3 py-2 rounded bg-gray-800 text-white border border-gray-700\",\n                        value: editWebsite,\n                        onChange: (e)=>setEditWebsite(e.target.value),\n                        placeholder: \"http://example.com\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 504,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                        className: \"font-semibold\",\n                        children: \"NIP05 (email)\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 510,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        className: \"px-3 py-2 rounded bg-gray-800 text-white border border-gray-700\",\n                        value: editNip05,\n                        onChange: (e)=>setEditNip05(e.target.value),\n                        placeholder: \"yourname@domain.com\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 511,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"submit\",\n                        className: \"mt-4 px-4 py-2 rounded bg-green-500 text-white hover:bg-green-600 transition-transform transform hover:scale-105 shadow-lg\",\n                        children: \"Save Changes\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 517,\n                        columnNumber: 21\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                lineNumber: 421,\n                columnNumber: 17\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mb-6\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_tabs__WEBPACK_IMPORTED_MODULE_6__.Tabs, {\n                    defaultValue: activeTab,\n                    onValueChange: (val)=>setActiveTab(val),\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_tabs__WEBPACK_IMPORTED_MODULE_6__.TabsList, {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_tabs__WEBPACK_IMPORTED_MODULE_6__.TabsTrigger, {\n                                value: \"posts\",\n                                children: [\n                                    \"Posts (\",\n                                    userPosts.length,\n                                    \")\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 532,\n                                columnNumber: 25\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_tabs__WEBPACK_IMPORTED_MODULE_6__.TabsTrigger, {\n                                value: \"liked\",\n                                children: [\n                                    \"Liked (\",\n                                    likesCount,\n                                    \")\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 533,\n                                columnNumber: 25\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_tabs__WEBPACK_IMPORTED_MODULE_6__.TabsTrigger, {\n                                value: \"retweeted\",\n                                children: [\n                                    \"Retweeted (\",\n                                    retweetsCount,\n                                    \")\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 534,\n                                columnNumber: 25\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_ui_tabs__WEBPACK_IMPORTED_MODULE_6__.TabsTrigger, {\n                                value: \"following\",\n                                children: [\n                                    \"Following (\",\n                                    followingCount,\n                                    \")\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 535,\n                                columnNumber: 25\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 531,\n                        columnNumber: 21\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                    lineNumber: 527,\n                    columnNumber: 17\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                lineNumber: 526,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    activeTab === 'posts' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: userPosts.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"p-4 text-center text-gray-400\",\n                            children: \"No posts found for this user.\"\n                        }, void 0, false, {\n                            fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                            lineNumber: 544,\n                            columnNumber: 29\n                        }, this) : userPosts.map((ev)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_feed_Post__WEBPACK_IMPORTED_MODULE_5__.Post, {\n                                event: ev,\n                                onChatOpen: ()=>{},\n                                onChatClose: ()=>{},\n                                isChatActive: false,\n                                isAnimating: false,\n                                chatCount: chatCounts[ev.id] || 0\n                            }, ev.id, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 549,\n                                columnNumber: 33\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 542,\n                        columnNumber: 21\n                    }, this),\n                    activeTab === 'liked' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: likedPosts.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"p-4 text-center text-gray-400\",\n                            children: \"No liked posts found.\"\n                        }, void 0, false, {\n                            fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                            lineNumber: 565,\n                            columnNumber: 29\n                        }, this) : likedPosts.map((ev)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_feed_Post__WEBPACK_IMPORTED_MODULE_5__.Post, {\n                                event: ev,\n                                onChatOpen: ()=>{},\n                                onChatClose: ()=>{},\n                                isChatActive: false,\n                                isAnimating: false,\n                                chatCount: chatCounts[ev.id] || 0\n                            }, ev.id, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 568,\n                                columnNumber: 33\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 563,\n                        columnNumber: 21\n                    }, this),\n                    activeTab === 'retweeted' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: retweetedPosts.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"p-4 text-center text-gray-400\",\n                            children: \"No retweeted posts found.\"\n                        }, void 0, false, {\n                            fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                            lineNumber: 584,\n                            columnNumber: 29\n                        }, this) : retweetedPosts.map((ev)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_feed_Post__WEBPACK_IMPORTED_MODULE_5__.Post, {\n                                event: ev,\n                                onChatOpen: ()=>{},\n                                onChatClose: ()=>{},\n                                isChatActive: false,\n                                isAnimating: false,\n                                chatCount: chatCounts[ev.id] || 0\n                            }, ev.id, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 587,\n                                columnNumber: 33\n                            }, this))\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 582,\n                        columnNumber: 21\n                    }, this),\n                    activeTab === 'following' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: followingUsers.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"p-4 text-center text-gray-400\",\n                            children: \"Not following anyone yet.\"\n                        }, void 0, false, {\n                            fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                            lineNumber: 603,\n                            columnNumber: 29\n                        }, this) : followingUsers.map((user)=>{\n                            var _window_NostrTools_nip19, _window_NostrTools;\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex items-center gap-4 p-3 border-b border-gray-800 hover:bg-gray-900/60 transition group\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                        src: user.picture || '/file.svg',\n                                        alt: \"avatar\",\n                                        className: \"w-12 h-12 rounded-full object-cover border border-gray-700 bg-black\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 607,\n                                        columnNumber: 37\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex-1 min-w-0\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center gap-2\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"font-semibold text-white truncate text-base\",\n                                                        children: user.displayName || user.username || user.pubkey.slice(0, 8) + '...'\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                                        lineNumber: 610,\n                                                        columnNumber: 45\n                                                    }, this),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-xs text-gray-400\",\n                                                        children: [\n                                                            \"@\",\n                                                            user.username || user.pubkey.slice(0, 8) + '...'\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                                        lineNumber: 611,\n                                                        columnNumber: 45\n                                                    }, this)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                                lineNumber: 609,\n                                                columnNumber: 41\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"text-xs text-gray-500 font-mono break-all\",\n                                                children: user.pubkey ? \"npub1\".concat(((_window_NostrTools = window.NostrTools) === null || _window_NostrTools === void 0 ? void 0 : (_window_NostrTools_nip19 = _window_NostrTools.nip19) === null || _window_NostrTools_nip19 === void 0 ? void 0 : _window_NostrTools_nip19.npubEncode) ? window.NostrTools.nip19.npubEncode(user.pubkey).slice(5, 15) + '...' + window.NostrTools.nip19.npubEncode(user.pubkey).slice(-6) : user.pubkey.slice(0, 12) + '...' + user.pubkey.slice(-6)) : ''\n                                            }, void 0, false, {\n                                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                                lineNumber: 613,\n                                                columnNumber: 41\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 608,\n                                        columnNumber: 37\n                                    }, this),\n                                    pubkey !== user.pubkey && (isFollowing && isFollowing(user.pubkey) ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"px-4 py-1 rounded bg-gray-700 text-white hover:bg-gray-600 text-xs font-semibold\",\n                                        onClick: ()=>unfollowUser(user.pubkey),\n                                        children: \"Unfollow\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 621,\n                                        columnNumber: 45\n                                    }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: \"px-4 py-1 rounded bg-blue-500 text-white hover:bg-blue-600 text-xs font-semibold\",\n                                        onClick: ()=>followUser(user.pubkey),\n                                        children: \"Follow\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                        lineNumber: 626,\n                                        columnNumber: 45\n                                    }, this))\n                                ]\n                            }, user.pubkey, true, {\n                                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                                lineNumber: 606,\n                                columnNumber: 33\n                            }, this);\n                        })\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                        lineNumber: 601,\n                        columnNumber: 21\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n                lineNumber: 540,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/app/profile/page.tsx\",\n        lineNumber: 327,\n        columnNumber: 9\n    }, this);\n}\n_s(ProfilePage, \"7lKsEWgdygi3PtEPXMHrsgFnQXE=\", false, function() {\n    return [\n        _hooks_useNostr__WEBPACK_IMPORTED_MODULE_1__.useNostr,\n        next_navigation__WEBPACK_IMPORTED_MODULE_3__.useSearchParams\n    ];\n});\n_c = ProfilePage;\nvar _c;\n$RefreshReg$(_c, \"ProfilePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvcHJvZmlsZS9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFFNEM7QUFRcUI7QUFDZjtBQUNzQztBQUMxQztBQUdxQjtBQUc1RCxNQUFNVyxVQUFVLGVBQWU7QUFPdkIsU0FBU0MsWUFBWSxLQUEyQztRQUEzQyxFQUFFQyxZQUFZLEVBQUVDLE9BQU8sRUFBb0IsR0FBM0M7UUFpVUhDLDZCQUFBQSx1QkFBcURBLDJCQUFBQSxxQkFLMENBLHNCQUV2QkEsc0JBNEZ4RUMscUJBQTJDRCw0QkFBQUE7O0lBbmF4RSxNQUFNLEVBQUVFLFFBQVFDLFNBQVMsRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLGFBQWEsRUFBRUMsV0FBVyxFQUFFQyxVQUFVLEVBQUVDLFlBQVksRUFBRSxHQUFHeEIseURBQVFBO0lBQzdHLE1BQU15QixlQUFlckIsZ0VBQWVBO0lBQ3BDLE1BQU1zQixPQUFPYixnQkFBZ0JZLGFBQWFFLEdBQUcsQ0FBQyxXQUFXUDtJQUN6RCxNQUFNLENBQUNMLGFBQWFhLGVBQWUsR0FBRzFCLCtDQUFRQSxDQUFNO0lBQ3BELE1BQU0sQ0FBQzJCLFNBQVNDLFdBQVcsR0FBRzVCLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQzZCLFNBQVNDLFdBQVcsR0FBRzlCLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQytCLGlCQUFpQkMsbUJBQW1CLEdBQUdoQywrQ0FBUUEsQ0FBQztJQUN2RCxNQUFNLENBQUNpQyxTQUFTQyxXQUFXLEdBQUdsQywrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNjLGNBQWNxQixnQkFBZ0IsR0FBR25DLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ29DLGFBQWFDLGVBQWUsR0FBR3JDLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ3NDLFlBQVlDLGNBQWMsR0FBR3ZDLCtDQUFRQSxDQUFDO0lBQzdDLE1BQU0sQ0FBQ3dDLGFBQWFDLGVBQWUsR0FBR3pD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LE1BQU0sR0FDUixRQUEyTyxPQUFuT3lKLEVBQUFBLHFCQUFBQSxPQUFPQyxVQUFVLGNBQWpCRCwwQ0FBQUEsMkJBQUFBLG1CQUFtQkUsS0FBSyxjQUF4QkYsK0NBQUFBLHlCQUEwQkcsVUFBVSxJQUFHSCxPQUFPQyxVQUFVLENBQUNDLEtBQUssQ0FBQ0MsVUFBVSxDQUFDdEosS0FBS04sTUFBTSxFQUFFZ0csS0FBSyxDQUFDLEdBQUcsTUFBTSxRQUFReUQsT0FBT0MsVUFBVSxDQUFDQyxLQUFLLENBQUNDLFVBQVUsQ0FBQ3RKLEtBQUtOLE1BQU0sRUFBRWdHLEtBQUssQ0FBQyxDQUFDLEtBQUsxRixLQUFLTixNQUFNLENBQUNnRyxLQUFLLENBQUMsR0FBRyxNQUFNLFFBQVExRixLQUFLTixNQUFNLENBQUNnRyxLQUFLLENBQUMsQ0FBQyxNQUN0Tzs7Ozs7Ozs7Ozs7O29DQUdiaEcsV0FBV00sS0FBS04sTUFBTSxJQUNuQkUsQ0FBQUEsZUFBZUEsWUFBWUksS0FBS04sTUFBTSxrQkFDbEMsOERBQUNrSDt3Q0FDR0wsV0FBVTt3Q0FDVk0sU0FBUyxJQUFNL0csYUFBYUUsS0FBS04sTUFBTTtrREFDMUM7Ozs7OzZEQUVELDhEQUFDa0g7d0NBQ0dMLFdBQVU7d0NBQ1ZNLFNBQVMsSUFBTWhILFdBQVdHLEtBQUtOLE1BQU07a0RBQ3hDOzs7Ozs0Q0FDTDs7K0JBeEJFTSxLQUFLTixNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtDckQ7R0FybUJ3QlI7O1FBQ2lGWixxREFBUUE7UUFDeEZJLDREQUFlQTs7O0tBRmhCUSIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL3NyYy9hcHAvcHJvZmlsZS9wYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCBMaW5rIGZyb20gXCJuZXh0L2xpbmtcIjtcbmltcG9ydCB7IHVzZU5vc3RyIH0gZnJvbSBcIkAvaG9va3MvdXNlTm9zdHJcIjtcblxuLy8gRXh0ZW5kIHRoZSBXaW5kb3cgaW50ZXJmYWNlIHRvIGluY2x1ZGUgTm9zdHJUb29sc1xuZGVjbGFyZSBnbG9iYWwge1xuICAgIGludGVyZmFjZSBXaW5kb3cge1xuICAgICAgICBOb3N0clRvb2xzPzogYW55O1xuICAgIH1cbn1cbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcbmltcG9ydCB7IGZldGNoTm9zdHJQcm9maWxlLCBnZXRIZWFsdGh5UmVsYXlzLCBmZXRjaE5vc3RyRmVlZCB9IGZyb20gXCJAL2xpYi9ub3N0ci9yZWxheVwiO1xuaW1wb3J0IHsgUG9zdCB9IGZyb20gXCJAL2NvbXBvbmVudHMvZmVlZC9Qb3N0XCI7XG5pbXBvcnQgeyBOb3N0ckV2ZW50IH0gZnJvbSBcIkAvdHlwZXMvbm9zdHJcIjtcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcbmltcG9ydCB7IFRhYnMsIFRhYnNMaXN0LCBUYWJzVHJpZ2dlciB9IGZyb20gXCJAL2NvbXBvbmVudHMvdWkvdGFic1wiO1xuaW1wb3J0IHsgQ2hhdEJveCB9IGZyb20gXCJAL2NvbXBvbmVudHMvY2hhdC9DaGF0Qm94XCI7XG5cbmV4cG9ydCBjb25zdCBkeW5hbWljID0gXCJmb3JjZS1zdGF0aWNcIjtcblxuaW50ZXJmYWNlIFByb2ZpbGVQYWdlUHJvcHMge1xuICAgIHVzZXJPdmVycmlkZT86IHN0cmluZztcbiAgICBvbkNsb3NlPzogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUHJvZmlsZVBhZ2UoeyB1c2VyT3ZlcnJpZGUsIG9uQ2xvc2UgfTogUHJvZmlsZVBhZ2VQcm9wcykge1xuICAgIGNvbnN0IHsgZXZlbnRzOiByYXdFdmVudHMsIHByb2ZpbGUsIHB1YmtleSwgdXBkYXRlUHJvZmlsZSwgaXNGb2xsb3dpbmcsIGZvbGxvd1VzZXIsIHVuZm9sbG93VXNlciB9ID0gdXNlTm9zdHIoKTtcbiAgICBjb25zdCBzZWFyY2hQYXJhbXMgPSB1c2VTZWFyY2hQYXJhbXMoKTtcbiAgICBjb25zdCB1c2VyID0gdXNlck92ZXJyaWRlIHx8IHNlYXJjaFBhcmFtcy5nZXQoXCJ1c2VyXCIpIHx8IHB1YmtleTtcbiAgICBjb25zdCBbdXNlclByb2ZpbGUsIHNldFVzZXJQcm9maWxlXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7XG4gICAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtlZGl0aW5nLCBzZXRFZGl0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbZWRpdERpc3BsYXlOYW1lLCBzZXRFZGl0RGlzcGxheU5hbWVdID0gdXNlU3RhdGUoXCJcIik7XG4gICAgY29uc3QgW2VkaXRCaW8sIHNldEVkaXRCaW9dID0gdXNlU3RhdGUoXCJcIik7XG4gICAgY29uc3QgW2VkaXRVc2VybmFtZSwgc2V0RWRpdFVzZXJuYW1lXSA9IHVzZVN0YXRlKFwiXCIpO1xuICAgIGNvbnN0IFtlZGl0UGljdHVyZSwgc2V0RWRpdFBpY3R1cmVdID0gdXNlU3RhdGUoXCJcIik7XG4gICAgY29uc3QgW2VkaXRCYW5uZXIsIHNldEVkaXRCYW5uZXJdID0gdXNlU3RhdGUoXCJcIik7XG4gICAgY29uc3QgW2VkaXRXZWJzaXRlLCBzZXRFZGl0V2Vic2l0ZV0gPSB1c2VTdGF0ZShcIlwiKTtcbiAgICBjb25zdCBbZWRpdE5pcDA1LCBzZXRFZGl0TmlwMDVdID0gdXNlU3RhdGUoXCJcIik7XG4gICAgY29uc3QgW3VzZXJQb3N0cywgc2V0VXNlclBvc3RzXSA9IHVzZVN0YXRlPE5vc3RyRXZlbnRbXT4oW10pO1xuICAgIGNvbnN0IFtsaWtlc0NvdW50LCBzZXRMaWtlc0NvdW50XSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IFtyZXR3ZWV0c0NvdW50LCBzZXRSZXR3ZWV0c0NvdW50XSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IFtsaWdodGJveE1lZGlhLCBzZXRMaWdodGJveE1lZGlhXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IFtwcm9maWxlTG9hZGVkLCBzZXRQcm9maWxlTG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbYWN0aXZlVGFiLCBzZXRBY3RpdmVUYWJdID0gdXNlU3RhdGU8J3Bvc3RzJyB8ICdsaWtlZCcgfCAncmV0d2VldGVkJyB8ICdmb2xsb3dpbmcnPigncG9zdHMnKTtcbiAgICBjb25zdCBbbGlrZWRQb3N0cywgc2V0TGlrZWRQb3N0c10gPSB1c2VTdGF0ZTxOb3N0ckV2ZW50W10+KFtdKTtcbiAgICBjb25zdCBbcmV0d2VldGVkUG9zdHMsIHNldFJldHdlZXRlZFBvc3RzXSA9IHVzZVN0YXRlPE5vc3RyRXZlbnRbXT4oW10pO1xuICAgIGNvbnN0IFtmb2xsb3dpbmdVc2Vycywgc2V0Rm9sbG93aW5nVXNlcnNdID0gdXNlU3RhdGU8YW55W10+KFtdKTtcbiAgICBjb25zdCBbZm9sbG93aW5nQ291bnQsIHNldEZvbGxvd2luZ0NvdW50XSA9IHVzZVN0YXRlPG51bWJlcj4oMCk7XG4gICAgY29uc3QgW2ZvbGxvd2luZ0ZpbHRlciwgc2V0Rm9sbG93aW5nRmlsdGVyXSA9IHVzZVN0YXRlKFwiXCIpO1xuICAgIGNvbnN0IGxhc3RVc2VyUmVmID0gdXNlUmVmPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gICAgLy8gRW5zdXJlIGV2ZW50cyBhcmUgTm9zdHJFdmVudFtdXG4gICAgY29uc3QgZXZlbnRzID0gcmF3RXZlbnRzIGFzIE5vc3RyRXZlbnRbXTtcblxuICAgIC8vIEZldGNoIHBvc3RzIGZvciB0aGUgcHJvZmlsZSBiZWluZyB2aWV3ZWRcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICAgICAgLy8gUHJldmVudCByZS1mZXRjaGluZyBpZiBhbHJlYWR5IGxvYWRlZCBmb3IgdGhpcyB1c2VyXG4gICAgICAgIGlmICh1c2VyUHJvZmlsZSAmJiB1c2VyUHJvZmlsZS5wdWJrZXkgPT09IHVzZXIgJiYgdXNlclBvc3RzLmxlbmd0aCA+IDApIHJldHVybjtcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZXIgPT09IHB1YmtleSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRVc2VyUHJvZmlsZShwcm9maWxlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWRpdERpc3BsYXlOYW1lKHByb2ZpbGU/LmRpc3BsYXlfbmFtZSB8fCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWRpdEJpbyhwcm9maWxlPy5hYm91dCB8fCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWRpdFVzZXJuYW1lKHByb2ZpbGU/LnVzZXJuYW1lIHx8IFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZXRFZGl0UGljdHVyZShwcm9maWxlPy5waWN0dXJlIHx8IFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZXRFZGl0QmFubmVyKHByb2ZpbGU/LmJhbm5lciB8fCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWRpdFdlYnNpdGUocHJvZmlsZT8ud2Vic2l0ZSB8fCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWRpdE5pcDA1KHByb2ZpbGU/Lm5pcDA1IHx8IFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZXRVc2VyUG9zdHMoZXZlbnRzLmZpbHRlcihldiA9PiBldi5wdWJrZXkgPT09IHVzZXIgJiYgZXYua2luZCA9PT0gMSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBoZWFsdGh5IHJlbGF5c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGhlYWx0aHlSZWxheXMgfSA9IGF3YWl0IGdldEhlYWx0aHlSZWxheXMoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmV0Y2ggcHJvZmlsZSBmcm9tIHJlbGF5c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gYXdhaXQgZmV0Y2hOb3N0clByb2ZpbGUoaGVhbHRoeVJlbGF5cywgdXNlcik7XG4gICAgICAgICAgICAgICAgICAgIHNldFVzZXJQcm9maWxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogbWV0YT8uZGlzcGxheV9uYW1lIHx8IG1ldGE/Lm5hbWUgfHwgdXNlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbzogbWV0YT8uYWJvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWN0dXJlOiBtZXRhPy5waWN0dXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IG1ldGE/Lm5hbWUgfHwgdXNlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YmtleTogdXNlcixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSBmZXRjaGluZyBwb3N0cyB3aXRoICdhdXRob3JzJyBmaWx0ZXIgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvc3RzOiBOb3N0ckV2ZW50W10gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RzID0gYXdhaXQgZmV0Y2hOb3N0ckZlZWRXaXRoRmlsdGVyKGhlYWx0aHlSZWxheXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kczogWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhvcnM6IFt1c2VyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdDogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IHRyeSB3aXRoICdwdWJrZXknIChsZWdhY3kvY29tcGF0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zdHMgPSBhd2FpdCBmZXRjaE5vc3RyRmVlZFdpdGhGaWx0ZXIoaGVhbHRoeVJlbGF5cywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmRzOiBbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVia2V5OiB1c2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0OiAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzdGlsbCBubyBwb3N0cywgZmFsbGJhY2sgdG8gbG9jYWwgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmICghcG9zdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0cyA9IGV2ZW50cy5maWx0ZXIoZXYgPT4gZXYucHVia2V5ID09PSB1c2VyICYmIGV2LmtpbmQgPT09IDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFVzZXJQb3N0cyhwb3N0cy5tYXAoKGV2OiBhbnkpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5ldixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IG1ldGE/LmRpc3BsYXlfbmFtZSB8fCBtZXRhPy5uYW1lIHx8IHVzZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IG1ldGE/Lm5hbWUgfHwgdXNlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWN0dXJlOiBtZXRhPy5waWN0dXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbzogbWV0YT8uYWJvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVia2V5OiB1c2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRQcm9maWxlTG9hZGVkKHRydWUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgdXNlciBwb3N0cyBvciBwcm9maWxlOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH0sIFt1c2VyLCBwdWJrZXksIHByb2ZpbGUsIGV2ZW50c10pO1xuXG4gICAgLy8gSGVscGVyIHRvIGFsbG93IHBhc3NpbmcgY3VzdG9tIGZpbHRlciB0byBmZXRjaE5vc3RyRmVlZFxuICAgIGZ1bmN0aW9uIGZldGNoTm9zdHJGZWVkV2l0aEZpbHRlcihyZWxheVVybHM6IHN0cmluZ1tdLCBmaWx0ZXI6IGFueSk6IFByb21pc2U8Tm9zdHJFdmVudFtdPiB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIHRvIGFsbG93IGN1c3RvbSBmaWx0ZXJzIGZvciBsaWtlcy9yZXR3ZWV0c1xuICAgICAgICBjb25zdCBwb29sID0gbmV3IChyZXF1aXJlKCdub3N0ci10b29scycpLlNpbXBsZVBvb2wpKCk7XG4gICAgICAgIHJldHVybiBwb29sLnF1ZXJ5U3luYyhyZWxheVVybHMsIGZpbHRlcikudGhlbigoZXZlbnRzOiBhbnkpID0+IHtcbiAgICAgICAgICAgIHBvb2wuY2xvc2UocmVsYXlVcmxzKTtcbiAgICAgICAgICAgIHJldHVybiBldmVudHM7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEZldGNoIGxpa2VzIGFuZCByZXR3ZWV0cyBmb3IgdGhlIHVzZXIncyBwb3N0c1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghdXNlclBvc3RzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgLy8gR2V0IGFsbCBwb3N0IGlkc1xuICAgICAgICAgICAgY29uc3QgcG9zdElkcyA9IHVzZXJQb3N0cy5tYXAoZXYgPT4gZXYuaWQpO1xuICAgICAgICAgICAgLy8gR2V0IGhlYWx0aHkgcmVsYXlzXG4gICAgICAgICAgICBjb25zdCB7IGhlYWx0aHlSZWxheXMgfSA9IGF3YWl0IGdldEhlYWx0aHlSZWxheXMoKTtcbiAgICAgICAgICAgIC8vIEZldGNoIGxpa2VzIChraW5kIDcpIHJlZmVyZW5jaW5nIHRoZXNlIHBvc3RzXG4gICAgICAgICAgICBjb25zdCBsaWtlRXZlbnRzID0gYXdhaXQgZmV0Y2hOb3N0ckZlZWRXaXRoRmlsdGVyKGhlYWx0aHlSZWxheXMsIHtcbiAgICAgICAgICAgICAgICBraW5kczogWzddLFxuICAgICAgICAgICAgICAgICcjZSc6IHBvc3RJZHMsXG4gICAgICAgICAgICAgICAgbGltaXQ6IDEwMDAsXG4gICAgICAgICAgICB9KSB8fCBbXTtcbiAgICAgICAgICAgIHNldExpa2VzQ291bnQobGlrZUV2ZW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgLy8gRmV0Y2ggcmV0d2VldHMgKGtpbmQgNikgcmVmZXJlbmNpbmcgdGhlc2UgcG9zdHNcbiAgICAgICAgICAgIGNvbnN0IHJldHdlZXRFdmVudHMgPSBhd2FpdCBmZXRjaE5vc3RyRmVlZFdpdGhGaWx0ZXIoaGVhbHRoeVJlbGF5cywge1xuICAgICAgICAgICAgICAgIGtpbmRzOiBbNl0sXG4gICAgICAgICAgICAgICAgJyNlJzogcG9zdElkcyxcbiAgICAgICAgICAgICAgICBsaW1pdDogMTAwMCxcbiAgICAgICAgICAgIH0pIHx8IFtdO1xuICAgICAgICAgICAgc2V0UmV0d2VldHNDb3VudChyZXR3ZWV0RXZlbnRzLmxlbmd0aCk7XG4gICAgICAgIH0pKCk7XG4gICAgfSwgW3VzZXJQb3N0c10pO1xuXG4gICAgLy8gRmV0Y2ggbGlrZWQgcG9zdHNcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoYWN0aXZlVGFiICE9PSAnbGlrZWQnIHx8ICF1c2VyKSByZXR1cm47XG4gICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGhlYWx0aHlSZWxheXMgfSA9IGF3YWl0IGdldEhlYWx0aHlSZWxheXMoKTtcbiAgICAgICAgICAgICAgICAvLyBGZXRjaCBsaWtlIGV2ZW50cyAoa2luZCA3KSBieSB0aGlzIHVzZXJcbiAgICAgICAgICAgICAgICBjb25zdCBsaWtlRXZlbnRzID0gYXdhaXQgZmV0Y2hOb3N0ckZlZWRXaXRoRmlsdGVyKGhlYWx0aHlSZWxheXMsIHtcbiAgICAgICAgICAgICAgICAgICAga2luZHM6IFs3XSxcbiAgICAgICAgICAgICAgICAgICAgYXV0aG9yczogW3VzZXJdLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogMTAwLFxuICAgICAgICAgICAgICAgIH0pIHx8IFtdO1xuICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIGxpa2UgZXZlbnQsIGdldCB0aGUgcmVmZXJlbmNlZCBwb3N0IGlkXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zdElkcyA9IGxpa2VFdmVudHMubWFwKGV2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFnID0gZXYudGFncy5maW5kKCh0OiBhbnkpID0+IHRbMF0gPT09ICdlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YWcgPyB0YWdbMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgICAgICAgICAvLyBGZXRjaCB0aGUgYWN0dWFsIHBvc3RzXG4gICAgICAgICAgICAgICAgbGV0IHBvc3RzOiBOb3N0ckV2ZW50W10gPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAocG9zdElkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zdHMgPSBhd2FpdCBmZXRjaE5vc3RyRmVlZFdpdGhGaWx0ZXIoaGVhbHRoeVJlbGF5cywge1xuICAgICAgICAgICAgICAgICAgICAgICAga2luZHM6IFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkczogcG9zdElkcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0OiAxMDAsXG4gICAgICAgICAgICAgICAgICAgIH0pIHx8IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRMaWtlZFBvc3RzKHBvc3RzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzZXRMaWtlZFBvc3RzKFtdKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfSwgW2FjdGl2ZVRhYiwgdXNlcl0pO1xuXG4gICAgLy8gRmV0Y2ggcmV0d2VldGVkIHBvc3RzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZVRhYiAhPT0gJ3JldHdlZXRlZCcgfHwgIXVzZXIpIHJldHVybjtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGVhbHRoeVJlbGF5cyB9ID0gYXdhaXQgZ2V0SGVhbHRoeVJlbGF5cygpO1xuICAgICAgICAgICAgICAgIC8vIEZldGNoIHJldHdlZXQgZXZlbnRzIChraW5kIDYpIGJ5IHRoaXMgdXNlclxuICAgICAgICAgICAgICAgIGNvbnN0IHJldHdlZXRFdmVudHMgPSBhd2FpdCBmZXRjaE5vc3RyRmVlZFdpdGhGaWx0ZXIoaGVhbHRoeVJlbGF5cywge1xuICAgICAgICAgICAgICAgICAgICBraW5kczogWzZdLFxuICAgICAgICAgICAgICAgICAgICBhdXRob3JzOiBbdXNlcl0sXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiAxMDAsXG4gICAgICAgICAgICAgICAgfSkgfHwgW107XG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggcmV0d2VldCBldmVudCwgZ2V0IHRoZSByZWZlcmVuY2VkIHBvc3QgaWRcbiAgICAgICAgICAgICAgICBjb25zdCBwb3N0SWRzID0gcmV0d2VldEV2ZW50cy5tYXAoZXYgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWcgPSBldi50YWdzLmZpbmQoKHQ6IGFueSkgPT4gdFswXSA9PT0gJ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhZyA/IHRhZ1sxXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICAgICAgICAgIC8vIEZldGNoIHRoZSBhY3R1YWwgcG9zdHNcbiAgICAgICAgICAgICAgICBsZXQgcG9zdHM6IE5vc3RyRXZlbnRbXSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChwb3N0SWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwb3N0cyA9IGF3YWl0IGZldGNoTm9zdHJGZWVkV2l0aEZpbHRlcihoZWFsdGh5UmVsYXlzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kczogWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWRzOiBwb3N0SWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQ6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgfSkgfHwgW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFJldHdlZXRlZFBvc3RzKHBvc3RzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzZXRSZXR3ZWV0ZWRQb3N0cyhbXSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH0sIFthY3RpdmVUYWIsIHVzZXJdKTtcblxuICAgIC8vIEZldGNoIGZvbGxvd2luZyBjb3VudCAoYW5kIG9wdGlvbmFsbHksIGZvbGxvd2luZyB1c2VycyBmb3IgdGhlIHRhYilcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBoZWFsdGh5UmVsYXlzIH0gPSBhd2FpdCBnZXRIZWFsdGh5UmVsYXlzKCk7XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggY29udGFjdCBsaXN0IChraW5kIDMpIGZvciB0aGlzIHVzZXJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWN0RXZlbnRzID0gYXdhaXQgZmV0Y2hOb3N0ckZlZWRXaXRoRmlsdGVyKGhlYWx0aHlSZWxheXMsIHtcbiAgICAgICAgICAgICAgICAgICAga2luZHM6IFszXSxcbiAgICAgICAgICAgICAgICAgICAgYXV0aG9yczogW3VzZXJdLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgICAgICAgICB9KSB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWdzID0gY29udGFjdEV2ZW50c1swXT8udGFncyB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJrZXlzID0gdGFncy5maWx0ZXIoKHQ6IGFueSkgPT4gdFswXSA9PT0gJ3AnKS5tYXAoKHQ6IGFueSkgPT4gdFsxXSk7XG4gICAgICAgICAgICAgICAgc2V0Rm9sbG93aW5nQ291bnQocHVia2V5cy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmb2xsb3dpbmcgdGFiIGlzIG9wZW4sIGZldGNoIHByb2ZpbGVzXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVRhYiA9PT0gJ2ZvbGxvd2luZycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByb2ZpbGVzOiBhbnlbXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHVia2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGVzID0gYXdhaXQgUHJvbWlzZS5hbGwocHVia2V5cy5zbGljZSgwLCA1MCkubWFwKGFzeW5jIChwazogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGF3YWl0IGZldGNoTm9zdHJQcm9maWxlKGhlYWx0aHlSZWxheXMsIHBrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJrZXk6IHBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogbWV0YT8uZGlzcGxheV9uYW1lIHx8IG1ldGE/Lm5hbWUgfHwgcGssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY3R1cmU6IG1ldGE/LnBpY3R1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBtZXRhPy5uYW1lIHx8IHBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0Rm9sbG93aW5nVXNlcnMocHJvZmlsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBzZXRGb2xsb3dpbmdDb3VudCgwKTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVGFiID09PSAnZm9sbG93aW5nJykgc2V0Rm9sbG93aW5nVXNlcnMoW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH0sIFt1c2VyLCBhY3RpdmVUYWIgPT09ICdmb2xsb3dpbmcnXSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodXNlclByb2ZpbGUpIHtcbiAgICAgICAgICAgIHNldEVkaXREaXNwbGF5TmFtZSh1c2VyUHJvZmlsZS5kaXNwbGF5X25hbWUpO1xuICAgICAgICAgICAgc2V0RWRpdEJpbyh1c2VyUHJvZmlsZS5iaW8gPz8gdXNlclByb2ZpbGUuYWJvdXQgPz8gXCJcIik7XG4gICAgICAgICAgICBzZXRFZGl0VXNlcm5hbWUodXNlclByb2ZpbGUudXNlcm5hbWUgfHwgXCJcIik7XG4gICAgICAgICAgICBzZXRFZGl0UGljdHVyZSh1c2VyUHJvZmlsZS5waWN0dXJlIHx8IFwiXCIpO1xuICAgICAgICAgICAgc2V0RWRpdEJhbm5lcih1c2VyUHJvZmlsZS5iYW5uZXIgfHwgXCJcIik7XG4gICAgICAgICAgICBzZXRFZGl0V2Vic2l0ZSh1c2VyUHJvZmlsZS53ZWJzaXRlIHx8IFwiXCIpO1xuICAgICAgICAgICAgc2V0RWRpdE5pcDA1KHVzZXJQcm9maWxlLm5pcDA1IHx8IFwiXCIpO1xuICAgICAgICB9XG4gICAgfSwgW3VzZXJQcm9maWxlXSk7XG5cbiAgICAvLyAtLS0gTWFpbiBmZWVkIGZlYXR1cmUgcGFyaXR5IHN0YXRlIC0tLVxuICAgIGNvbnN0IFthY3RpdmVDaGF0UG9zdElkLCBzZXRBY3RpdmVDaGF0UG9zdElkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IFtjbG9zaW5nQ2hhdElkLCBzZXRDbG9zaW5nQ2hhdElkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IFtjaGF0Q291bnRzLCBzZXRDaGF0Q291bnRzXSA9IHVzZVN0YXRlPHsgW3Bvc3RJZDogc3RyaW5nXTogbnVtYmVyIH0+KHt9KTtcblxuICAgIC8vIEhhbmRsZSBjaGF0IGNsb3Npbmcgd2l0aCBhbmltYXRpb24gKG1hdGNoZXMgbWFpbiBmZWVkKVxuICAgIGNvbnN0IGhhbmRsZUNoYXRDbG9zZSA9IChwb3N0SWQ6IHN0cmluZykgPT4ge1xuICAgICAgICBzZXRDbG9zaW5nQ2hhdElkKHBvc3RJZCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc2V0QWN0aXZlQ2hhdFBvc3RJZChudWxsKTtcbiAgICAgICAgICAgIHNldENsb3NpbmdDaGF0SWQobnVsbCk7XG4gICAgICAgIH0sIDMwMCk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBza2VsZXRvbiBsb2FkZXJzIGZvciBwcm9maWxlIGFuZCBwb3N0c1xuICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1heC13LTJ4bCBteC1hdXRvIHAtNiB0ZXh0LXdoaXRlXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtNCBtYi02IGFuaW1hdGUtcHVsc2VcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTIwIGgtMjAgYmctZ3JheS03MDAgcm91bmRlZC1mdWxsXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTMyIGgtNiBiZy1ncmF5LTcwMCByb3VuZGVkXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctMjQgaC00IGJnLWdyYXktNzAwIHJvdW5kZWRcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC00XCI+XG4gICAgICAgICAgICAgICAgICAgIHtbLi4uQXJyYXkoMyldLm1hcCgoXywgaWR4KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGtleT17aWR4fSBjbGFzc05hbWU9XCJiZy1ncmF5LTgwMCBib3JkZXIgYm9yZGVyLWdyYXktNzAwIHJvdW5kZWQteGwgcC00IGFuaW1hdGUtcHVsc2VcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBoLTYgYmctZ3JheS03MDAgcm91bmRlZCBtYi0yXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC00IGJnLWdyYXktNzAwIHJvdW5kZWRcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmICghdXNlcikge1xuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJwLTggdGV4dC1jZW50ZXJcIj5ObyB1c2VyIHNlbGVjdGVkLjwvZGl2PjtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1heC13LTJ4bCBteC1hdXRvIHAtNiB0ZXh0LXdoaXRlIHJlbGF0aXZlXCI+XG4gICAgICAgICAgICB7LyogREVCVUc6IFNob3cgdXNlciBhbmQgcHVia2V5IHZhbHVlcyAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWItMiB0ZXh0LXhzIHRleHQtZ3JheS00MDBcIj51c2VyOiB7dXNlcn08YnIvPnB1YmtleToge3B1YmtleX08L2Rpdj5cbiAgICAgICAgICAgIHtvbkNsb3NlICYmIChcbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC00IHJpZ2h0LTQgdGV4dC1ncmF5LTQwMCBob3Zlcjp0ZXh0LXdoaXRlIHRleHQtMnhsIGZvbnQtYm9sZCB6LTEwXCJcbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25DbG9zZX1cbiAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIkNsb3NlIHByb2ZpbGUgcGFuZVwiXG4gICAgICAgICAgICAgICAgPsOXPC9idXR0b24+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAgey8qIFByb2ZpbGUgQ2FyZCAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmUgbWItOCByb3VuZGVkLXhsIHNoYWRvdy14bCBiZy1ncmFkaWVudC10by1iciBmcm9tLVsjMjMyNDNhXSB0by1bIzE4MTkyNl0gYm9yZGVyIGJvcmRlci1ncmF5LTgwMCBvdmVyZmxvdy1oaWRkZW5cIj5cbiAgICAgICAgICAgICAgICB7LyogQmFubmVyICovfVxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaC00MCBiZy1ncmFkaWVudC10by1yIGZyb20taW5kaWdvLTUwMCB2aWEtcHVycGxlLTUwMCB0by1waW5rLTUwMFwiIC8+XG4gICAgICAgICAgICAgICAgey8qIEF2YXRhciBhbmQgSW5mbyAqL31cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtZW5kIGdhcC02IHB4LTggcGItNiByZWxhdGl2ZSAtbXQtMTRcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTI4IGgtMjggcm91bmRlZC1mdWxsIGJvcmRlci00IGJvcmRlci13aGl0ZSBzaGFkb3ctbGcgYmctZ3JheS05MDAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgb3ZlcmZsb3ctaGlkZGVuXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7dXNlclByb2ZpbGU/LnBpY3R1cmUgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9e3VzZXJQcm9maWxlLnBpY3R1cmV9IGFsdD1cIlByb2ZpbGVcIiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIHJvdW5kZWQtZnVsbCBvYmplY3QtY292ZXJcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgdGV4dC0zeGwgZm9udC1ib2xkIHRleHQtZ3JheS0zMDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3VzZXJQcm9maWxlPy51c2VybmFtZT8uc2xpY2UoMCwgMik/LnRvVXBwZXJDYXNlKCkgfHwgdXNlclByb2ZpbGU/LnB1YmtleT8uc2xpY2UoMiwgNCk/LnRvVXBwZXJDYXNlKCl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4LTEgZmxleCBmbGV4LWNvbCBnYXAtMVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtM3hsIGZvbnQtYm9sZCBsZWFkaW5nLXRpZ2h0XCI+e3VzZXJQcm9maWxlPy5kaXNwbGF5X25hbWUgfHwgdXNlclByb2ZpbGU/LnVzZXJuYW1lIHx8IHVzZXJQcm9maWxlPy5wdWJrZXk/LnNsaWNlKDAsIDgpICsgXCIuLi5cIn08L2gyPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtZ3JheS00MDAgdGV4dC1sZyBmb250LW1vbm9cIj5Ae3VzZXJQcm9maWxlPy51c2VybmFtZSB8fCB1c2VyUHJvZmlsZT8ucHVia2V5Py5zbGljZSgwLCA4KSArIFwiLi4uXCJ9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsvKiBGb2xsb3cvVW5mb2xsb3cgYnV0dG9uIGZvciBvdGhlciB1c2VycyAqL31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dXNlciAhPT0gcHVia2V5ICYmIHVzZXJQcm9maWxlPy5wdWJrZXkgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZvbGxvd2luZyAmJiBpc0ZvbGxvd2luZyh1c2VyUHJvZmlsZS5wdWJrZXkpID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1sLTIgcHgtNCBweS0xIHJvdW5kZWQgYmctZ3JheS03MDAgdGV4dC13aGl0ZSBob3ZlcjpiZy1ncmF5LTYwMCB0ZXh0LXhzIGZvbnQtc2VtaWJvbGRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHVuZm9sbG93VXNlcih1c2VyUHJvZmlsZS5wdWJrZXkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlVuZm9sbG93PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibWwtMiBweC00IHB5LTEgcm91bmRlZCBiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIGhvdmVyOmJnLWJsdWUtNjAwIHRleHQteHMgZm9udC1zZW1pYm9sZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gZm9sbG93VXNlcih1c2VyUHJvZmlsZS5wdWJrZXkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPkZvbGxvdzwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAge3VzZXIgPT09IHB1YmtleSAmJiAhZWRpdGluZyAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJtdC0zIHctZml0IHB4LTUgcHktMiByb3VuZGVkLWxnIGJnLWJsdWUtNTAwIHRleHQtd2hpdGUgaG92ZXI6YmctYmx1ZS02MDAgdHJhbnNpdGlvbiBmb250LXNlbWlib2xkIHNoYWRvdy1tZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEVkaXRpbmcodHJ1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPkVkaXQgUHJvZmlsZTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgey8qIFN0YXRzIFJvdyAqL31cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZ2FwLTggcHgtOCBweS00IGJvcmRlci10IGJvcmRlci1ncmF5LTgwMCBiZy1ibGFjay8zMCB0ZXh0LWNlbnRlciB0ZXh0LWJhc2UgZm9udC1tZWRpdW1cIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2Bmb2N1czpvdXRsaW5lLW5vbmUgdHJhbnNpdGlvbiBweC0yIHB5LTEgcm91bmRlZC1tZCAke2FjdGl2ZVRhYiA9PT0gJ3Bvc3RzJyA/ICdiZy1ibHVlLTYwMC8yMCB0ZXh0LWJsdWUtNDAwIGZvbnQtYm9sZCcgOiAnaG92ZXI6YmctZ3JheS04MDAgdGV4dC13aGl0ZSd9YH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEFjdGl2ZVRhYigncG9zdHMnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtY3VycmVudD17YWN0aXZlVGFiID09PSAncG9zdHMnfVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmb250LWJvbGRcIj57dXNlclBvc3RzLmxlbmd0aH08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJtbC0xXCI+UG9zdHM8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YGZvY3VzOm91dGxpbmUtbm9uZSB0cmFuc2l0aW9uIHB4LTIgcHktMSByb3VuZGVkLW1kICR7YWN0aXZlVGFiID09PSAnbGlrZWQnID8gJ2JnLWJsdWUtNjAwLzIwIHRleHQtYmx1ZS00MDAgZm9udC1ib2xkJyA6ICdob3ZlcjpiZy1ncmF5LTgwMCB0ZXh0LXdoaXRlJ31gfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0QWN0aXZlVGFiKCdsaWtlZCcpfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJpYS1jdXJyZW50PXthY3RpdmVUYWIgPT09ICdsaWtlZCd9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtYm9sZFwiPntsaWtlc0NvdW50fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIm1sLTFcIj5MaWtlZDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgZm9jdXM6b3V0bGluZS1ub25lIHRyYW5zaXRpb24gcHgtMiBweS0xIHJvdW5kZWQtbWQgJHthY3RpdmVUYWIgPT09ICdyZXR3ZWV0ZWQnID8gJ2JnLWJsdWUtNjAwLzIwIHRleHQtYmx1ZS00MDAgZm9udC1ib2xkJyA6ICdob3ZlcjpiZy1ncmF5LTgwMCB0ZXh0LXdoaXRlJ31gfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0QWN0aXZlVGFiKCdyZXR3ZWV0ZWQnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtY3VycmVudD17YWN0aXZlVGFiID09PSAncmV0d2VldGVkJ31cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZm9udC1ib2xkXCI+e3JldHdlZXRzQ291bnR9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibWwtMVwiPlJldHdlZXRlZDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgZm9jdXM6b3V0bGluZS1ub25lIHRyYW5zaXRpb24gcHgtMiBweS0xIHJvdW5kZWQtbWQgJHthY3RpdmVUYWIgPT09ICdmb2xsb3dpbmcnID8gJ2JnLWJsdWUtNjAwLzIwIHRleHQtYmx1ZS00MDAgZm9udC1ib2xkJyA6ICdob3ZlcjpiZy1ncmF5LTgwMCB0ZXh0LXdoaXRlJ31gfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0QWN0aXZlVGFiKCdmb2xsb3dpbmcnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtY3VycmVudD17YWN0aXZlVGFiID09PSAnZm9sbG93aW5nJ31cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZm9udC1ib2xkXCI+e2ZvbGxvd2luZ0NvdW50fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIm1sLTFcIj5Gb2xsb3dpbmc8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7LyogRWRpdCBQcm9maWxlIEZvcm0gKi99XG4gICAgICAgICAgICB7ZWRpdGluZyAmJiB1c2VyID09PSBwdWJrZXkgJiYgKFxuICAgICAgICAgICAgICAgIDxmb3JtXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1iLTYgYmctZ3JheS05MDAgYm9yZGVyIGJvcmRlci1ncmF5LTgwMCByb3VuZGVkLXhsIHAtNCBmbGV4IGZsZXgtY29sIGdhcC0zXCJcbiAgICAgICAgICAgICAgICAgICAgb25TdWJtaXQ9e2FzeW5jIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlUHJvZmlsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheV9uYW1lOiBlZGl0RGlzcGxheU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IGVkaXRVc2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm91dDogZWRpdEJpbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWN0dXJlOiBlZGl0UGljdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYW5uZXI6IGVkaXRCYW5uZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Vic2l0ZTogZWRpdFdlYnNpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmlwMDU6IGVkaXROaXAwNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWRpdGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZFwiPkF2YXRhcjwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTQgbWItMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAge2VkaXRQaWN0dXJlID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjPXtlZGl0UGljdHVyZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0PVwiQXZhdGFyIHByZXZpZXdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTE2IGgtMTYgcm91bmRlZC1mdWxsIG9iamVjdC1jb3ZlciBib3JkZXIgYm9yZGVyLWdyYXktNzAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctMTYgaC0xNiByb3VuZGVkLWZ1bGwgYmctZ3JheS03MDAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgdGV4dC0yeGwgdGV4dC1ncmF5LTMwMCBib3JkZXIgYm9yZGVyLWdyYXktNzAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtlZGl0VXNlcm5hbWU/LnNsaWNlKDAsMik/LnRvVXBwZXJDYXNlKCkgfHwgdXNlclByb2ZpbGU/LnB1YmtleT8uc2xpY2UoMiw0KT8udG9VcHBlckNhc2UoKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0PVwiaW1hZ2UvKlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmxvY2sgdGV4dC1zbSB0ZXh0LWdyYXktNDAwIGZpbGU6bXItNCBmaWxlOnB5LTIgZmlsZTpweC00IGZpbGU6cm91bmRlZC1mdWxsIGZpbGU6Ym9yZGVyLTAgZmlsZTp0ZXh0LXNtIGZpbGU6Zm9udC1zZW1pYm9sZCBmaWxlOmJnLWJsdWUtNTAgZmlsZTp0ZXh0LWJsdWUtNzAwIGhvdmVyOmZpbGU6YmctYmx1ZS0xMDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJVcGxvYWQgYXZhdGFyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17YXN5bmMgZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBlLnRhcmdldC5maWxlcz8uWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWRpdFBpY3R1cmUocmVhZGVyLnJlc3VsdCBhcyBzdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZFwiPkRpc3BsYXkgTmFtZTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtMyBweS0yIHJvdW5kZWQgYmctZ3JheS04MDAgdGV4dC13aGl0ZSBib3JkZXIgYm9yZGVyLWdyYXktNzAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtlZGl0RGlzcGxheU5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17ZSA9PiBzZXRFZGl0RGlzcGxheU5hbWUoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJEaXNwbGF5IE5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZFwiPkJpbzwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtMyBweS0yIHJvdW5kZWQgYmctZ3JheS04MDAgdGV4dC13aGl0ZSBib3JkZXIgYm9yZGVyLWdyYXktNzAwIHJlc2l6ZS1ub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtlZGl0QmlvfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4gc2V0RWRpdEJpbyhlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlRlbGwgdXMgYWJvdXQgeW91cnNlbGZcIlxuICAgICAgICAgICAgICAgICAgICAgICAgcm93cz17M31cbiAgICAgICAgICAgICAgICAgICAgPjwvdGV4dGFyZWE+XG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkXCI+VXNlcm5hbWU8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTMgcHktMiByb3VuZGVkIGJnLWdyYXktODAwIHRleHQtd2hpdGUgYm9yZGVyIGJvcmRlci1ncmF5LTcwMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17ZWRpdFVzZXJuYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4gc2V0RWRpdFVzZXJuYW1lKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiVXNlcm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZFwiPlBpY3R1cmUgVVJMPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0zIHB5LTIgcm91bmRlZCBiZy1ncmF5LTgwMCB0ZXh0LXdoaXRlIGJvcmRlciBib3JkZXItZ3JheS03MDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2VkaXRQaWN0dXJlfVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4gc2V0RWRpdFBpY3R1cmUoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJodHRwOi8vZXhhbXBsZS5jb20veW91ci1hdmF0YXIuanBnXCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGRcIj5CYW5uZXIgVVJMPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0zIHB5LTIgcm91bmRlZCBiZy1ncmF5LTgwMCB0ZXh0LXdoaXRlIGJvcmRlciBib3JkZXItZ3JheS03MDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2VkaXRCYW5uZXJ9XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17ZSA9PiBzZXRFZGl0QmFubmVyKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiaHR0cDovL2V4YW1wbGUuY29tL3lvdXItYmFubmVyLmpwZ1wiXG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkXCI+V2Vic2l0ZTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtMyBweS0yIHJvdW5kZWQgYmctZ3JheS04MDAgdGV4dC13aGl0ZSBib3JkZXIgYm9yZGVyLWdyYXktNzAwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXtlZGl0V2Vic2l0ZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHNldEVkaXRXZWJzaXRlKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiaHR0cDovL2V4YW1wbGUuY29tXCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGRcIj5OSVAwNSAoZW1haWwpPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0zIHB5LTIgcm91bmRlZCBiZy1ncmF5LTgwMCB0ZXh0LXdoaXRlIGJvcmRlciBib3JkZXItZ3JheS03MDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e2VkaXROaXAwNX1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtlID0+IHNldEVkaXROaXAwNShlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cInlvdXJuYW1lQGRvbWFpbi5jb21cIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwic3VibWl0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm10LTQgcHgtNCBweS0yIHJvdW5kZWQgYmctZ3JlZW4tNTAwIHRleHQtd2hpdGUgaG92ZXI6YmctZ3JlZW4tNjAwIHRyYW5zaXRpb24tdHJhbnNmb3JtIHRyYW5zZm9ybSBob3ZlcjpzY2FsZS0xMDUgc2hhZG93LWxnXCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgU2F2ZSBDaGFuZ2VzXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICB7LyogUHJvZmlsZSB0YWJzIChQb3N0cywgTGlrZWQsIFJldHdlZXRlZCwgRm9sbG93aW5nKSAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWItNlwiPlxuICAgICAgICAgICAgICAgIDxUYWJzXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT17YWN0aXZlVGFifVxuICAgICAgICAgICAgICAgICAgICBvblZhbHVlQ2hhbmdlPXsodmFsKSA9PiBzZXRBY3RpdmVUYWIodmFsIGFzIHR5cGVvZiBhY3RpdmVUYWIpfVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPFRhYnNMaXN0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPFRhYnNUcmlnZ2VyIHZhbHVlPVwicG9zdHNcIj5Qb3N0cyAoe3VzZXJQb3N0cy5sZW5ndGh9KTwvVGFic1RyaWdnZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFic1RyaWdnZXIgdmFsdWU9XCJsaWtlZFwiPkxpa2VkICh7bGlrZXNDb3VudH0pPC9UYWJzVHJpZ2dlcj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxUYWJzVHJpZ2dlciB2YWx1ZT1cInJldHdlZXRlZFwiPlJldHdlZXRlZCAoe3JldHdlZXRzQ291bnR9KTwvVGFic1RyaWdnZXI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8VGFic1RyaWdnZXIgdmFsdWU9XCJmb2xsb3dpbmdcIj5Gb2xsb3dpbmcgKHtmb2xsb3dpbmdDb3VudH0pPC9UYWJzVHJpZ2dlcj5cbiAgICAgICAgICAgICAgICAgICAgPC9UYWJzTGlzdD5cbiAgICAgICAgICAgICAgICA8L1RhYnM+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHsvKiBBY3RpdmUgdGFiIGNvbnRlbnQgKi99XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIHthY3RpdmVUYWIgPT09ICdwb3N0cycgJiYgKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAge3VzZXJQb3N0cy5sZW5ndGggPT09IDAgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTQgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTQwMFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBObyBwb3N0cyBmb3VuZCBmb3IgdGhpcyB1c2VyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyUG9zdHMubWFwKGV2ID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFBvc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17ZXYuaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudD17ZXZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYXRPcGVuPXsoKSA9PiB7fX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhdENsb3NlPXsoKSA9PiB7fX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hhdEFjdGl2ZT17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FuaW1hdGluZz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGF0Q291bnQ9e2NoYXRDb3VudHNbZXYuaWRdIHx8IDB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAge2FjdGl2ZVRhYiA9PT0gJ2xpa2VkJyAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICB7bGlrZWRQb3N0cy5sZW5ndGggPT09IDAgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTQgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTQwMFwiPk5vIGxpa2VkIHBvc3RzIGZvdW5kLjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWtlZFBvc3RzLm1hcChldiA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxQb3N0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2V2LmlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ9e2V2fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGF0T3Blbj17KCkgPT4ge319XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYXRDbG9zZT17KCkgPT4ge319XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NoYXRBY3RpdmU9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBbmltYXRpbmc9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhdENvdW50PXtjaGF0Q291bnRzW2V2LmlkXSB8fCAwfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIHthY3RpdmVUYWIgPT09ICdyZXR3ZWV0ZWQnICYmIChcbiAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtyZXR3ZWV0ZWRQb3N0cy5sZW5ndGggPT09IDAgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTQgdGV4dC1jZW50ZXIgdGV4dC1ncmF5LTQwMFwiPk5vIHJldHdlZXRlZCBwb3N0cyBmb3VuZC48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0d2VldGVkUG9zdHMubWFwKGV2ID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPFBvc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17ZXYuaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudD17ZXZ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYXRPcGVuPXsoKSA9PiB7fX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhdENsb3NlPXsoKSA9PiB7fX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ2hhdEFjdGl2ZT17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0FuaW1hdGluZz17ZmFsc2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGF0Q291bnQ9e2NoYXRDb3VudHNbZXYuaWRdIHx8IDB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAge2FjdGl2ZVRhYiA9PT0gJ2ZvbGxvd2luZycgJiYgKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAge2ZvbGxvd2luZ1VzZXJzLmxlbmd0aCA9PT0gMCA/IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNCB0ZXh0LWNlbnRlciB0ZXh0LWdyYXktNDAwXCI+Tm90IGZvbGxvd2luZyBhbnlvbmUgeWV0LjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2xsb3dpbmdVc2Vycy5tYXAodXNlciA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYga2V5PXt1c2VyLnB1YmtleX0gY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTQgcC0zIGJvcmRlci1iIGJvcmRlci1ncmF5LTgwMCBob3ZlcjpiZy1ncmF5LTkwMC82MCB0cmFuc2l0aW9uIGdyb3VwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz17dXNlci5waWN0dXJlIHx8ICcvZmlsZS5zdmcnfSBhbHQ9XCJhdmF0YXJcIiBjbGFzc05hbWU9XCJ3LTEyIGgtMTIgcm91bmRlZC1mdWxsIG9iamVjdC1jb3ZlciBib3JkZXIgYm9yZGVyLWdyYXktNzAwIGJnLWJsYWNrXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleC0xIG1pbi13LTBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGQgdGV4dC13aGl0ZSB0cnVuY2F0ZSB0ZXh0LWJhc2VcIj57dXNlci5kaXNwbGF5TmFtZSB8fCB1c2VyLnVzZXJuYW1lIHx8IHVzZXIucHVia2V5LnNsaWNlKDAsIDgpICsgJy4uLid9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS00MDBcIj5Ae3VzZXIudXNlcm5hbWUgfHwgdXNlci5wdWJrZXkuc2xpY2UoMCwgOCkgKyAnLi4uJ308L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS01MDAgZm9udC1tb25vIGJyZWFrLWFsbFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7dXNlci5wdWJrZXkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYG5wdWIxJHt3aW5kb3cuTm9zdHJUb29scz8ubmlwMTk/Lm5wdWJFbmNvZGUgPyB3aW5kb3cuTm9zdHJUb29scy5uaXAxOS5ucHViRW5jb2RlKHVzZXIucHVia2V5KS5zbGljZSg1LCAxNSkgKyAnLi4uJyArIHdpbmRvdy5Ob3N0clRvb2xzLm5pcDE5Lm5wdWJFbmNvZGUodXNlci5wdWJrZXkpLnNsaWNlKC02KSA6IHVzZXIucHVia2V5LnNsaWNlKDAsIDEyKSArICcuLi4nICsgdXNlci5wdWJrZXkuc2xpY2UoLTYpfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJyd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtwdWJrZXkgIT09IHVzZXIucHVia2V5ICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZvbGxvd2luZyAmJiBpc0ZvbGxvd2luZyh1c2VyLnB1YmtleSkgPyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMSByb3VuZGVkIGJnLWdyYXktNzAwIHRleHQtd2hpdGUgaG92ZXI6YmctZ3JheS02MDAgdGV4dC14cyBmb250LXNlbWlib2xkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHVuZm9sbG93VXNlcih1c2VyLnB1YmtleSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5VbmZvbGxvdzwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMSByb3VuZGVkIGJnLWJsdWUtNTAwIHRleHQtd2hpdGUgaG92ZXI6YmctYmx1ZS02MDAgdGV4dC14cyBmb250LXNlbWlib2xkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGZvbGxvd1VzZXIodXNlci5wdWJrZXkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+Rm9sbG93PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VOb3N0ciIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidXNlUmVmIiwidXNlU2VhcmNoUGFyYW1zIiwiZmV0Y2hOb3N0clByb2ZpbGUiLCJnZXRIZWFsdGh5UmVsYXlzIiwiUG9zdCIsIlRhYnMiLCJUYWJzTGlzdCIsIlRhYnNUcmlnZ2VyIiwiZHluYW1pYyIsIlByb2ZpbGVQYWdlIiwidXNlck92ZXJyaWRlIiwib25DbG9zZSIsInVzZXJQcm9maWxlIiwiZWRpdFVzZXJuYW1lIiwiZXZlbnRzIiwicmF3RXZlbnRzIiwicHJvZmlsZSIsInB1YmtleSIsInVwZGF0ZVByb2ZpbGUiLCJpc0ZvbGxvd2luZyIsImZvbGxvd1VzZXIiLCJ1bmZvbGxvd1VzZXIiLCJzZWFyY2hQYXJhbXMiLCJ1c2VyIiwiZ2V0Iiwic2V0VXNlclByb2ZpbGUiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVkaXRpbmciLCJzZXRFZGl0aW5nIiwiZWRpdERpc3BsYXlOYW1lIiwic2V0RWRpdERpc3BsYXlOYW1lIiwiZWRpdEJpbyIsInNldEVkaXRCaW8iLCJzZXRFZGl0VXNlcm5hbWUiLCJlZGl0UGljdHVyZSIsInNldEVkaXRQaWN0dXJlIiwiZWRpdEJhbm5lciIsInNldEVkaXRCYW5uZXIiLCJlZGl0V2Vic2l0ZSIsInNldEVkaXRXZWJzaXRlIiwiZWRpdE5pcDA1Iiwic2V0RWRpdE5pcDA1IiwidXNlclBvc3RzIiwic2V0VXNlclBvc3RzIiwibGlrZXNDb3VudCIsInNldExpa2VzQ291bnQiLCJyZXR3ZWV0c0NvdW50Iiwic2V0UmV0d2VldHNDb3VudCIsImxpZ2h0Ym94TWVkaWEiLCJzZXRMaWdodGJveE1lZGlhIiwicHJvZmlsZUxvYWRlZCIsInNldFByb2ZpbGVMb2FkZWQiLCJhY3RpdmVUYWIiLCJzZXRBY3RpdmVUYWIiLCJsaWtlZFBvc3RzIiwic2V0TGlrZWRQb3N0cyIsInJldHdlZXRlZFBvc3RzIiwic2V0UmV0d2VldGVkUG9zdHMiLCJmb2xsb3dpbmdVc2VycyIsInNldEZvbGxvd2luZ1VzZXJzIiwiZm9sbG93aW5nQ291bnQiLCJzZXRGb2xsb3dpbmdDb3VudCIsImZvbGxvd2luZ0ZpbHRlciIsInNldEZvbGxvd2luZ0ZpbHRlciIsImxhc3RVc2VyUmVmIiwibGVuZ3RoIiwiZGlzcGxheV9uYW1lIiwiYWJvdXQiLCJ1c2VybmFtZSIsInBpY3R1cmUiLCJiYW5uZXIiLCJ3ZWJzaXRlIiwibmlwMDUiLCJmaWx0ZXIiLCJldiIsImtpbmQiLCJoZWFsdGh5UmVsYXlzIiwibWV0YSIsIm5hbWUiLCJiaW8iLCJwb3N0cyIsImZldGNoTm9zdHJGZWVkV2l0aEZpbHRlciIsImtpbmRzIiwiYXV0aG9ycyIsImxpbWl0IiwibWFwIiwibWVkaWEiLCJlcnJvciIsImNvbnNvbGUiLCJyZWxheVVybHMiLCJwb29sIiwicmVxdWlyZSIsIlNpbXBsZVBvb2wiLCJxdWVyeVN5bmMiLCJ0aGVuIiwiY2xvc2UiLCJwb3N0SWRzIiwiaWQiLCJsaWtlRXZlbnRzIiwicmV0d2VldEV2ZW50cyIsInRhZyIsInRhZ3MiLCJmaW5kIiwidCIsIkJvb2xlYW4iLCJpZHMiLCJlIiwiY29udGFjdEV2ZW50cyIsInB1YmtleXMiLCJwcm9maWxlcyIsIlByb21pc2UiLCJhbGwiLCJzbGljZSIsInBrIiwiZGlzcGxheU5hbWUiLCJhY3RpdmVDaGF0UG9zdElkIiwic2V0QWN0aXZlQ2hhdFBvc3RJZCIsImNsb3NpbmdDaGF0SWQiLCJzZXRDbG9zaW5nQ2hhdElkIiwiY2hhdENvdW50cyIsInNldENoYXRDb3VudHMiLCJoYW5kbGVDaGF0Q2xvc2UiLCJwb3N0SWQiLCJzZXRUaW1lb3V0IiwiZGl2IiwiY2xhc3NOYW1lIiwiQXJyYXkiLCJfIiwiaWR4IiwiYnIiLCJidXR0b24iLCJvbkNsaWNrIiwiYXJpYS1sYWJlbCIsImltZyIsInNyYyIsImFsdCIsInRvVXBwZXJDYXNlIiwiaDIiLCJzcGFuIiwidHlwZSIsImFyaWEtY3VycmVudCIsImZvcm0iLCJvblN1Ym1pdCIsInByZXZlbnREZWZhdWx0IiwibGFiZWwiLCJpbnB1dCIsImFjY2VwdCIsIm9uQ2hhbmdlIiwiZmlsZSIsInRhcmdldCIsImZpbGVzIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZGVuZCIsInJlc3VsdCIsInJlYWRBc0RhdGFVUkwiLCJ2YWx1ZSIsInBsYWNlaG9sZGVyIiwidGV4dGFyZWEiLCJyb3dzIiwiZGVmYXVsdFZhbHVlIiwib25WYWx1ZUNoYW5nZSIsInZhbCIsImV2ZW50Iiwib25DaGF0T3BlbiIsIm9uQ2hhdENsb3NlIiwiaXNDaGF0QWN0aXZlIiwiaXNBbmltYXRpbmciLCJjaGF0Q291bnQiLCJ3aW5kb3ciLCJOb3N0clRvb2xzIiwibmlwMTkiLCJucHViRW5jb2RlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/profile/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/wallet/page.tsx":
/*!*********************************!*\
  !*** ./src/app/wallet/page.tsx ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WalletPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction WalletPage() {\n    _s();\n    const [connected, setConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [walletAddress, setWalletAddress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [balance, setBalance] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [tokens, setTokens] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [activeTab, setActiveTab] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"portfolio\");\n    const [connectError, setConnectError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    // Explicit connect handler\n    const handleConnect = async ()=>{\n        setConnectError(\"\");\n        if ( true && window.alephium) {\n            try {\n                const accounts = await window.alephium.request({\n                    method: \"wallet_getAccounts\"\n                });\n                if (accounts && accounts.length > 0) {\n                    setWalletAddress(accounts[0]);\n                    setConnected(true);\n                } else {\n                    setConnectError(\"No accounts found in Alephium wallet.\");\n                }\n            } catch (err) {\n                setConnectError(\"Failed to connect to Alephium wallet.\");\n                setConnected(false);\n            }\n        } else {\n            setConnectError(\"Alephium Wallet extension not detected. \");\n        }\n    };\n    // Dummy fetch for balance/tokens (replace with real API if needed)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WalletPage.useEffect\": ()=>{\n            if (walletAddress) {\n                setBalance(0); // Replace with real fetch\n                setTokens([]); // Replace with real fetch\n            }\n        }\n    }[\"WalletPage.useEffect\"], [\n        walletAddress\n    ]);\n    // Tab click handler\n    const handleTabClick = (tab)=>{\n        if (tab === \"games\") {\n            router.push(\"/games\");\n            return;\n        }\n        setActiveTab(tab);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"min-h-screen bg-black text-white px-6 py-8\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex justify-between items-center mb-8\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                        className: \"text-2xl font-bold\",\n                        children: \"Blockchain Wallet\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                        lineNumber: 63,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex gap-2\",\n                        children: connected ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: \"px-4 py-2 bg-blue-500 rounded text-white\",\n                            onClick: ()=>{\n                                setConnected(false);\n                                setWalletAddress(\"\");\n                            },\n                            type: \"button\",\n                            children: \"Disconnect\"\n                        }, void 0, false, {\n                            fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                            lineNumber: 66,\n                            columnNumber: 13\n                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: \"px-4 py-2 bg-blue-500 rounded text-white\",\n                            onClick: handleConnect,\n                            type: \"button\",\n                            children: \"Connect Alephium Wallet\"\n                        }, void 0, false, {\n                            fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                            lineNumber: 74,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                        lineNumber: 64,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                lineNumber: 62,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex gap-2 mb-6\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"px-4 py-2 rounded \".concat(activeTab === 'portfolio' ? 'bg-blue-600 text-white' : 'bg-gray-800 text-gray-300'),\n                        onClick: ()=>handleTabClick('portfolio'),\n                        type: \"button\",\n                        children: \"My Portfolio\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                        lineNumber: 87,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"px-4 py-2 rounded \".concat(activeTab === 'dapps' ? 'bg-blue-600 text-white' : 'bg-gray-800 text-gray-300'),\n                        onClick: ()=>handleTabClick('dapps'),\n                        type: \"button\",\n                        children: \"My dApps\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                        lineNumber: 88,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"px-4 py-2 rounded \".concat(activeTab === 'alephium' ? 'bg-blue-600 text-white' : 'bg-gray-800 text-gray-300'),\n                        onClick: ()=>handleTabClick('alephium'),\n                        type: \"button\",\n                        children: \"My Alephium\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                        lineNumber: 89,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"px-4 py-2 rounded \".concat(activeTab === 'games' ? 'bg-blue-600 text-white' : 'bg-gray-800 text-gray-300'),\n                        onClick: ()=>handleTabClick('games'),\n                        type: \"button\",\n                        children: \"Games\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                        lineNumber: 90,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                lineNumber: 86,\n                columnNumber: 7\n            }, this),\n            activeTab === 'games' ? null : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mb-8\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"bg-gray-900 border border-gray-800 rounded-xl p-5 flex flex-col gap-2 shadow-lg\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"text-xs text-gray-400 mb-1\",\n                                    children: \"Current Wallet Address\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                    lineNumber: 99,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"font-mono text-lg text-blue-300 break-all flex items-center gap-2\",\n                                    children: walletAddress ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                title: walletAddress,\n                                                className: \"truncate max-w-[220px] inline-block align-middle\",\n                                                children: [\n                                                    walletAddress.slice(0, 8),\n                                                    \"...\",\n                                                    walletAddress.slice(-6)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                                lineNumber: 103,\n                                                columnNumber: 21\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"ml-2 px-2 py-1 rounded bg-gray-800 text-gray-300 hover:bg-gray-700 text-xs border border-gray-700\",\n                                                onClick: ()=>{\n                                                    navigator.clipboard.writeText(walletAddress);\n                                                },\n                                                title: \"Copy address\",\n                                                children: \"Copy\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                                lineNumber: 104,\n                                                columnNumber: 21\n                                            }, this)\n                                        ]\n                                    }, void 0, true) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"text-gray-500\",\n                                        children: \"No wallet selected\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                        lineNumber: 111,\n                                        columnNumber: 19\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                    lineNumber: 100,\n                                    columnNumber: 15\n                                }, this),\n                                connectError && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"text-red-400 text-xs mt-2\",\n                                    children: [\n                                        connectError,\n                                        \" \",\n                                        !window.alephium && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                            href: \"https://chrome.google.com/webstore/detail/alephium-wallet/\",\n                                            target: \"_blank\",\n                                            rel: \"noopener noreferrer\",\n                                            className: \"underline\",\n                                            children: \"Install Extension\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                            lineNumber: 115,\n                                            columnNumber: 96\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                    lineNumber: 115,\n                                    columnNumber: 17\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                            lineNumber: 98,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                        lineNumber: 97,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"grid grid-cols-1 md:grid-cols-3 gap-6\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"md:col-span-2 bg-gray-900 rounded-xl p-6 mb-6 md:mb-0\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"font-semibold text-lg mb-2\",\n                                        children: \"Portfolio Overview\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                        lineNumber: 124,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"text-3xl font-bold text-blue-400 mb-1\",\n                                        children: [\n                                            balance.toFixed(2),\n                                            \" ALPH\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                        lineNumber: 125,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"text-gray-400 text-sm mb-4\",\n                                        children: [\n                                            \"Tokens: \",\n                                            tokens.length\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                        lineNumber: 126,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"h-32 flex items-center justify-center\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"text-gray-600\",\n                                            children: \"(Chart coming soon)\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                            lineNumber: 128,\n                                            columnNumber: 17\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                        lineNumber: 127,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                lineNumber: 123,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"bg-gray-900 rounded-xl p-6\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"font-semibold text-lg mb-2\",\n                                        children: \"Tracked Wallets\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                        lineNumber: 133,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"text-gray-400 text-sm mb-2\",\n                                        children: \"(Add wallet management here if needed)\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                        lineNumber: 134,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mt-2 text-gray-500\",\n                                        children: walletAddress ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            children: walletAddress\n                                        }, void 0, false, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                            lineNumber: 137,\n                                            columnNumber: 19\n                                        }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            children: \"No wallets tracked\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                            lineNumber: 139,\n                                            columnNumber: 19\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                        lineNumber: 135,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                lineNumber: 132,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                        lineNumber: 121,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-gray-900 border border-gray-800 rounded-xl p-5 shadow-lg mt-8\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"font-semibold text-lg text-white mb-2\",\n                                children: \"Token Balances\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                lineNumber: 147,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-gray-400 text-sm\",\n                                children: \"Your token holdings\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                lineNumber: 148,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mt-2 text-gray-500\",\n                                children: tokens.length === 0 ? 'No tokens found in tracked wallets' : \"\".concat(tokens.length, \" tokens\")\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                                lineNumber: 149,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n                        lineNumber: 146,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/app/wallet/page.tsx\",\n        lineNumber: 60,\n        columnNumber: 5\n    }, this);\n}\n_s(WalletPage, \"UYUdEqUr8DktEHeovxnlFardvls=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = WalletPage;\nvar _c;\n$RefreshReg$(_c, \"WalletPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvd2FsbGV0L3BhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDNEM7QUFDQTtBQVM3QixTQUFTRzs7SUFDdEIsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUdMLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ00sZUFBZUMsaUJBQWlCLEdBQUdQLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ1EsU0FBU0MsV0FBVyxHQUFHVCwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNVLFFBQVFDLFVBQVUsR0FBR1gsK0NBQVFBLENBQUMsRUFBRTtJQUN2QyxNQUFNLENBQUNZLFdBQVdDLGFBQWEsR0FBR2IsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDYyxjQUFjQyxnQkFBZ0IsR0FBR2YsK0NBQVFBLENBQUM7SUFDakQsTUFBTWdCLFNBQVNkLDBEQUFTQTtJQUV4QiwyQkFBMkI7SUFDM0IsTUFBTWUsZ0JBQWdCO1FBQ3BCRixnQkFBZ0I7UUFDaEIsSUFBSSxLQUE2QixJQUFJLE9BQWdCSSxRQUFRLEVBQUU7WUFDN0QsSUFBSTtnQkFDRixNQUFNQyxXQUFXLE1BQU0sT0FBZ0JELFFBQVEsQ0FBQ0UsT0FBTyxDQUFDO29CQUFFQyxRQUFRO2dCQUFxQjtnQkFDdkYsSUFBSUYsWUFBWUEsU0FBU0csTUFBTSxHQUFHLEdBQUc7b0JBQ25DaEIsaUJBQWlCYSxRQUFRLENBQUMsRUFBRTtvQkFDNUJmLGFBQWE7Z0JBQ2YsT0FBTztvQkFDTFUsZ0JBQWdCO2dCQUNsQjtZQUNGLEVBQUUsT0FBT1MsS0FBSztnQkFDWlQsZ0JBQWdCO2dCQUNoQlYsYUFBYTtZQUNmO1FBQ0YsT0FBTztZQUNMVSxnQkFBZ0I7UUFDbEI7SUFDRjtJQUVBLG1FQUFtRTtJQUNuRWQsZ0RBQVNBO2dDQUFDO1lBQ1IsSUFBSUssZUFBZTtnQkFDakJHLFdBQVcsSUFBSSwwQkFBMEI7Z0JBQ3pDRSxVQUFVLEVBQUUsR0FBRywwQkFBMEI7WUFD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QUlDLFdBQVU7a0RBQTZCOzs7Ozs7a0RBQzVDLDhEQUFDRDt3Q0FBSUMsV0FBVTtrREFBNkI7Ozs7OztrREFDNUMsOERBQUNEO3dDQUFJQyxXQUFVO2tEQUNadkIsOEJBQ0MsOERBQUNzQjtzREFBS3RCOzs7OztpRUFFTiw4REFBQ3NCO3NEQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FPYiw4REFBQ0E7d0JBQUlDLFdBQVU7OzBDQUNiLDhEQUFDRDtnQ0FBSUMsV0FBVTswQ0FBd0M7Ozs7OzswQ0FDdkQsOERBQUNEO2dDQUFJQyxXQUFVOzBDQUF3Qjs7Ozs7OzBDQUN2Qyw4REFBQ0Q7Z0NBQUlDLFdBQVU7MENBQ1puQixPQUFPYSxNQUFNLEtBQUssSUFBSSx1Q0FBdUMsR0FBaUIsT0FBZGIsT0FBT2EsTUFBTSxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU83RjtHQWpKd0JwQjs7UUFPUEQsc0RBQVNBOzs7S0FQRkMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9zcmMvYXBwL3dhbGxldC9wYWdlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcblxuLy8gRXh0ZW5kIHRoZSBXaW5kb3cgaW50ZXJmYWNlIHRvIGluY2x1ZGUgYWxlcGhpdW1cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgYWxlcGhpdW0/OiBhbnk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gV2FsbGV0UGFnZSgpIHtcbiAgY29uc3QgW2Nvbm5lY3RlZCwgc2V0Q29ubmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3dhbGxldEFkZHJlc3MsIHNldFdhbGxldEFkZHJlc3NdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IFtiYWxhbmNlLCBzZXRCYWxhbmNlXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbdG9rZW5zLCBzZXRUb2tlbnNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbYWN0aXZlVGFiLCBzZXRBY3RpdmVUYWJdID0gdXNlU3RhdGUoXCJwb3J0Zm9saW9cIik7XG4gIGNvbnN0IFtjb25uZWN0RXJyb3IsIHNldENvbm5lY3RFcnJvcl0gPSB1c2VTdGF0ZShcIlwiKTtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG5cbiAgLy8gRXhwbGljaXQgY29ubmVjdCBoYW5kbGVyXG4gIGNvbnN0IGhhbmRsZUNvbm5lY3QgPSBhc3luYyAoKSA9PiB7XG4gICAgc2V0Q29ubmVjdEVycm9yKFwiXCIpO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICh3aW5kb3cgYXMgYW55KS5hbGVwaGl1bSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCAod2luZG93IGFzIGFueSkuYWxlcGhpdW0ucmVxdWVzdCh7IG1ldGhvZDogXCJ3YWxsZXRfZ2V0QWNjb3VudHNcIiB9KTtcbiAgICAgICAgaWYgKGFjY291bnRzICYmIGFjY291bnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzZXRXYWxsZXRBZGRyZXNzKGFjY291bnRzWzBdKTtcbiAgICAgICAgICBzZXRDb25uZWN0ZWQodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0Q29ubmVjdEVycm9yKFwiTm8gYWNjb3VudHMgZm91bmQgaW4gQWxlcGhpdW0gd2FsbGV0LlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNldENvbm5lY3RFcnJvcihcIkZhaWxlZCB0byBjb25uZWN0IHRvIEFsZXBoaXVtIHdhbGxldC5cIik7XG4gICAgICAgIHNldENvbm5lY3RlZChmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldENvbm5lY3RFcnJvcihcIkFsZXBoaXVtIFdhbGxldCBleHRlbnNpb24gbm90IGRldGVjdGVkLiBcIik7XG4gICAgfVxuICB9O1xuXG4gIC8vIER1bW15IGZldGNoIGZvciBiYWxhbmNlL3Rva2VucyAocmVwbGFjZSB3aXRoIHJlYWwgQVBJIGlmIG5lZWRlZClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAod2FsbGV0QWRkcmVzcykge1xuICAgICAgc2V0QmFsYW5jZSgwKTsgLy8gUmVwbGFjZSB3aXRoIHJlYWwgZmV0Y2hcbiAgICAgIHNldFRva2VucyhbXSk7IC8vIFJlcGxhY2Ugd2l0aCByZWFsIGZldGNoXG4gICAgfVxuICB9LCBbd2FsbGV0QWRkcmVzc10pO1xuXG4gIC8vIFRhYiBjbGljayBoYW5kbGVyXG4gIGNvbnN0IGhhbmRsZVRhYkNsaWNrID0gKHRhYjogc3RyaW5nKSA9PiB7XG4gICAgaWYgKHRhYiA9PT0gXCJnYW1lc1wiKSB7XG4gICAgICByb3V0ZXIucHVzaChcIi9nYW1lc1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0QWN0aXZlVGFiKHRhYik7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIm1pbi1oLXNjcmVlbiBiZy1ibGFjayB0ZXh0LXdoaXRlIHB4LTYgcHktOFwiPlxuICAgICAgey8qIEhlYWRlciAqL31cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIG1iLThcIj5cbiAgICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQtMnhsIGZvbnQtYm9sZFwiPkJsb2NrY2hhaW4gV2FsbGV0PC9oMT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGdhcC0yXCI+XG4gICAgICAgICAge2Nvbm5lY3RlZCA/IChcbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtNCBweS0yIGJnLWJsdWUtNTAwIHJvdW5kZWQgdGV4dC13aGl0ZVwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHsgc2V0Q29ubmVjdGVkKGZhbHNlKTsgc2V0V2FsbGV0QWRkcmVzcyhcIlwiKTsgfX1cbiAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIERpc2Nvbm5lY3RcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1ibHVlLTUwMCByb3VuZGVkIHRleHQtd2hpdGVcIlxuICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVDb25uZWN0fVxuICAgICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgQ29ubmVjdCBBbGVwaGl1bSBXYWxsZXRcbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIHsvKiBUYWJzICovfVxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGdhcC0yIG1iLTZcIj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2BweC00IHB5LTIgcm91bmRlZCAke2FjdGl2ZVRhYiA9PT0gJ3BvcnRmb2xpbycgPyAnYmctYmx1ZS02MDAgdGV4dC13aGl0ZScgOiAnYmctZ3JheS04MDAgdGV4dC1ncmF5LTMwMCd9YH0gb25DbGljaz17KCkgPT4gaGFuZGxlVGFiQ2xpY2soJ3BvcnRmb2xpbycpfSB0eXBlPVwiYnV0dG9uXCI+TXkgUG9ydGZvbGlvPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gY2xhc3NOYW1lPXtgcHgtNCBweS0yIHJvdW5kZWQgJHthY3RpdmVUYWIgPT09ICdkYXBwcycgPyAnYmctYmx1ZS02MDAgdGV4dC13aGl0ZScgOiAnYmctZ3JheS04MDAgdGV4dC1ncmF5LTMwMCd9YH0gb25DbGljaz17KCkgPT4gaGFuZGxlVGFiQ2xpY2soJ2RhcHBzJyl9IHR5cGU9XCJidXR0b25cIj5NeSBkQXBwczwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT17YHB4LTQgcHktMiByb3VuZGVkICR7YWN0aXZlVGFiID09PSAnYWxlcGhpdW0nID8gJ2JnLWJsdWUtNjAwIHRleHQtd2hpdGUnIDogJ2JnLWdyYXktODAwIHRleHQtZ3JheS0zMDAnfWB9IG9uQ2xpY2s9eygpID0+IGhhbmRsZVRhYkNsaWNrKCdhbGVwaGl1bScpfSB0eXBlPVwiYnV0dG9uXCI+TXkgQWxlcGhpdW08L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2BweC00IHB5LTIgcm91bmRlZCAke2FjdGl2ZVRhYiA9PT0gJ2dhbWVzJyA/ICdiZy1ibHVlLTYwMCB0ZXh0LXdoaXRlJyA6ICdiZy1ncmF5LTgwMCB0ZXh0LWdyYXktMzAwJ31gfSBvbkNsaWNrPXsoKSA9PiBoYW5kbGVUYWJDbGljaygnZ2FtZXMnKX0gdHlwZT1cImJ1dHRvblwiPkdhbWVzPC9idXR0b24+XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIE1haW4gQ29udGVudCBHcmlkICovfVxuICAgICAge2FjdGl2ZVRhYiA9PT0gJ2dhbWVzJyA/IG51bGwgOiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgey8qIFdhbGxldCBBZGRyZXNzIENhcmQgKi99XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi04XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLWdyYXktOTAwIGJvcmRlciBib3JkZXItZ3JheS04MDAgcm91bmRlZC14bCBwLTUgZmxleCBmbGV4LWNvbCBnYXAtMiBzaGFkb3ctbGdcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS00MDAgbWItMVwiPkN1cnJlbnQgV2FsbGV0IEFkZHJlc3M8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb250LW1vbm8gdGV4dC1sZyB0ZXh0LWJsdWUtMzAwIGJyZWFrLWFsbCBmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMlwiPlxuICAgICAgICAgICAgICAgIHt3YWxsZXRBZGRyZXNzID8gKFxuICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gdGl0bGU9e3dhbGxldEFkZHJlc3N9IGNsYXNzTmFtZT1cInRydW5jYXRlIG1heC13LVsyMjBweF0gaW5saW5lLWJsb2NrIGFsaWduLW1pZGRsZVwiPnt3YWxsZXRBZGRyZXNzLnNsaWNlKDAsIDgpfS4uLnt3YWxsZXRBZGRyZXNzLnNsaWNlKC02KX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJtbC0yIHB4LTIgcHktMSByb3VuZGVkIGJnLWdyYXktODAwIHRleHQtZ3JheS0zMDAgaG92ZXI6YmctZ3JheS03MDAgdGV4dC14cyBib3JkZXIgYm9yZGVyLWdyYXktNzAwXCJcbiAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQod2FsbGV0QWRkcmVzcyl9fVxuICAgICAgICAgICAgICAgICAgICAgIHRpdGxlPVwiQ29weSBhZGRyZXNzXCJcbiAgICAgICAgICAgICAgICAgICAgPkNvcHk8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNTAwXCI+Tm8gd2FsbGV0IHNlbGVjdGVkPC9zcGFuPlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICB7Y29ubmVjdEVycm9yICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtcmVkLTQwMCB0ZXh0LXhzIG10LTJcIj57Y29ubmVjdEVycm9yfSB7IXdpbmRvdy5hbGVwaGl1bSAmJiA8YSBocmVmPVwiaHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvYWxlcGhpdW0td2FsbGV0L1wiIHRhcmdldD1cIl9ibGFua1wiIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIiBjbGFzc05hbWU9XCJ1bmRlcmxpbmVcIj5JbnN0YWxsIEV4dGVuc2lvbjwvYT59PC9kaXY+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIHsvKiBNYWluIENvbnRlbnQgR3JpZCAqL31cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTEgbWQ6Z3JpZC1jb2xzLTMgZ2FwLTZcIj5cbiAgICAgICAgICAgIHsvKiBQb3J0Zm9saW8gT3ZlcnZpZXcgKi99XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1kOmNvbC1zcGFuLTIgYmctZ3JheS05MDAgcm91bmRlZC14bCBwLTYgbWItNiBtZDptYi0wXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZCB0ZXh0LWxnIG1iLTJcIj5Qb3J0Zm9saW8gT3ZlcnZpZXc8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LTN4bCBmb250LWJvbGQgdGV4dC1ibHVlLTQwMCBtYi0xXCI+e2JhbGFuY2UudG9GaXhlZCgyKX0gQUxQSDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtZ3JheS00MDAgdGV4dC1zbSBtYi00XCI+VG9rZW5zOiB7dG9rZW5zLmxlbmd0aH08L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoLTMyIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1ncmF5LTYwMFwiPihDaGFydCBjb21pbmcgc29vbik8L3NwYW4+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7LyogU2lkZWJhciAqL31cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctZ3JheS05MDAgcm91bmRlZC14bCBwLTZcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkIHRleHQtbGcgbWItMlwiPlRyYWNrZWQgV2FsbGV0czwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtZ3JheS00MDAgdGV4dC1zbSBtYi0yXCI+KEFkZCB3YWxsZXQgbWFuYWdlbWVudCBoZXJlIGlmIG5lZWRlZCk8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC0yIHRleHQtZ3JheS01MDBcIj5cbiAgICAgICAgICAgICAgICB7d2FsbGV0QWRkcmVzcyA/IChcbiAgICAgICAgICAgICAgICAgIDxkaXY+e3dhbGxldEFkZHJlc3N9PC9kaXY+XG4gICAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAgIDxkaXY+Tm8gd2FsbGV0cyB0cmFja2VkPC9kaXY+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIHsvKiBUb2tlbiBCYWxhbmNlcyAqL31cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLWdyYXktOTAwIGJvcmRlciBib3JkZXItZ3JheS04MDAgcm91bmRlZC14bCBwLTUgc2hhZG93LWxnIG10LThcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZm9udC1zZW1pYm9sZCB0ZXh0LWxnIHRleHQtd2hpdGUgbWItMlwiPlRva2VuIEJhbGFuY2VzPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtZ3JheS00MDAgdGV4dC1zbVwiPllvdXIgdG9rZW4gaG9sZGluZ3M8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtMiB0ZXh0LWdyYXktNTAwXCI+XG4gICAgICAgICAgICAgIHt0b2tlbnMubGVuZ3RoID09PSAwID8gJ05vIHRva2VucyBmb3VuZCBpbiB0cmFja2VkIHdhbGxldHMnIDogYCR7dG9rZW5zLmxlbmd0aH0gdG9rZW5zYH1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSb3V0ZXIiLCJXYWxsZXRQYWdlIiwiY29ubmVjdGVkIiwic2V0Q29ubmVjdGVkIiwid2FsbGV0QWRkcmVzcyIsInNldFdhbGxldEFkZHJlc3MiLCJiYWxhbmNlIiwic2V0QmFsYW5jZSIsInRva2VucyIsInNldFRva2VucyIsImFjdGl2ZVRhYiIsInNldEFjdGl2ZVRhYiIsImNvbm5lY3RFcnJvciIsInNldENvbm5lY3RFcnJvciIsInJvdXRlciIsImhhbmRsZUNvbm5lY3QiLCJ3aW5kb3ciLCJhbGVwaGl1bSIsImFjY291bnRzIiwicmVxdWVzdCIsIm1ldGhvZCIsImxlbmd0aCIsImVyciIsImhhbmRsZVRhYkNsaWNrIiwidGFiIiwicHVzaCIsImRpdiIsImNsYXNzTmFtZSIsImgxIiwiYnV0dG9uIiwib25DbGljayIsInR5cGUiLCJzcGFuIiwidGl0bGUiLCJzbGljZSIsIm5hdmlnYXRvciIsImNsaXBib2FyZCIsIndyaXRlVGV4dCIsImEiLCJocmVmIiwidGFyZ2V0IiwicmVsIiwidG9GaXhlZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/wallet/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/StatsDisplay.tsx":
/*!*****************************************!*\
  !*** ./src/components/StatsDisplay.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nconst StatsDisplay = ()=>{\n    _s();\n    const [stats, setStats] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [trending, setTrending] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"StatsDisplay.useEffect\": ()=>{\n            async function loadStats() {\n                setLoading(true);\n                setError(null);\n                try {\n                    // Fetch global stats\n                    const statsRes = await fetch(\"https://api.nostr.band/v0/stats\");\n                    if (!statsRes.ok) {\n                        throw new Error(\"Failed to fetch stats: \".concat(statsRes.status, \" \").concat(statsRes.statusText));\n                    }\n                    const statsData = await statsRes.json();\n                    if (statsData && typeof statsData.events === 'number') {\n                        setStats(statsData);\n                    } else {\n                        setError('Stats data format incorrect');\n                    }\n                } catch (e) {\n                    console.error(\"Error loading stats:\", e);\n                    setError(e.message || 'Failed to load stats');\n                }\n                setLoading(false);\n            }\n            async function loadTrending() {\n                try {\n                    const trendingRes = await fetch(\"https://api.nostr.band/v0/trending/notes\");\n                    if (!trendingRes.ok) {\n                        throw new Error(\"Failed to fetch trending notes: \".concat(trendingRes.status, \" \").concat(trendingRes.statusText));\n                    }\n                    const trendingData = await trendingRes.json();\n                    if (trendingData && Array.isArray(trendingData.notes)) {\n                        setTrending(trendingData.notes.slice(0, 5)); // Top 5 trending\n                    }\n                } catch (e) {\n                    // ignore trending error for now, or handle it more gracefully\n                    console.warn(\"Failed to load trending notes:\", e.message || e);\n                }\n            }\n            loadStats();\n            loadTrending();\n        }\n    }[\"StatsDisplay.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"bg-gray-900 rounded-xl shadow-md p-4 mb-4 border border-gray-800 text-white\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"text-lg font-bold mb-3 text-pink-400\",\n                children: \"Global Nostr Stats\"\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                lineNumber: 62,\n                columnNumber: 13\n            }, undefined),\n            loading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"animate-pulse text-gray-400\",\n                children: \"Loading stats...\"\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                lineNumber: 64,\n                columnNumber: 17\n            }, undefined) : error ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-red-500 text-sm\",\n                children: error\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                lineNumber: 66,\n                columnNumber: 17\n            }, undefined) : stats ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                className: \"space-y-1 mb-4 text-sm\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        className: \"flex justify-between\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"text-gray-400\",\n                                children: \"Total Events\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                lineNumber: 69,\n                                columnNumber: 58\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"font-semibold text-gray-200\",\n                                children: stats.events.toLocaleString()\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                lineNumber: 69,\n                                columnNumber: 109\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                        lineNumber: 69,\n                        columnNumber: 21\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        className: \"flex justify-between\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"text-gray-400\",\n                                children: \"Total Relays\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                lineNumber: 70,\n                                columnNumber: 58\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"font-semibold text-gray-200\",\n                                children: stats.relays.toLocaleString()\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                lineNumber: 70,\n                                columnNumber: 109\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                        lineNumber: 70,\n                        columnNumber: 21\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        className: \"flex justify-between\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"text-gray-400\",\n                                children: \"Total Profiles\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                lineNumber: 71,\n                                columnNumber: 58\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"font-semibold text-gray-200\",\n                                children: stats.profiles.toLocaleString()\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                lineNumber: 71,\n                                columnNumber: 111\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                        lineNumber: 71,\n                        columnNumber: 21\n                    }, undefined),\n                    typeof stats.notes_24h === 'number' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        className: \"flex justify-between\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"text-gray-400\",\n                                children: \"Notes (24h)\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                lineNumber: 72,\n                                columnNumber: 98\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"font-semibold text-gray-200\",\n                                children: stats.notes_24h.toLocaleString()\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                lineNumber: 72,\n                                columnNumber: 148\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                        lineNumber: 72,\n                        columnNumber: 61\n                    }, undefined),\n                    typeof stats.profiles_24h === 'number' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        className: \"flex justify-between\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"text-gray-400\",\n                                children: \"Profiles (24h)\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                lineNumber: 73,\n                                columnNumber: 101\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"font-semibold text-gray-200\",\n                                children: stats.profiles_24h.toLocaleString()\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                lineNumber: 73,\n                                columnNumber: 154\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                        lineNumber: 73,\n                        columnNumber: 64\n                    }, undefined),\n                    typeof stats.relays_24h === 'number' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        className: \"flex justify-between\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"text-gray-400\",\n                                children: \"Relays (24h)\"\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                lineNumber: 74,\n                                columnNumber: 99\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"font-semibold text-gray-200\",\n                                children: stats.relays_24h.toLocaleString()\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                lineNumber: 74,\n                                columnNumber: 150\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                        lineNumber: 74,\n                        columnNumber: 62\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                lineNumber: 68,\n                columnNumber: 17\n            }, undefined) : !loading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-gray-400 text-sm\",\n                children: \"Stats unavailable.\"\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                lineNumber: 77,\n                columnNumber: 29\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                className: \"text-md font-semibold mb-2 mt-4 text-pink-400\",\n                children: \"Trending Notes\"\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                lineNumber: 79,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                className: \"divide-y divide-gray-800\",\n                children: [\n                    trending.length === 0 && !loading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                        className: \"text-gray-400 py-2 text-sm\",\n                        children: \"No trending notes available.\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                        lineNumber: 81,\n                        columnNumber: 55\n                    }, undefined),\n                    trending.map((note)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            className: \"py-2 text-sm\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"font-medium text-gray-300\",\n                                    children: [\n                                        note.id.slice(0, 8),\n                                        \"...\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                    lineNumber: 84,\n                                    columnNumber: 25\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"ml-2 text-gray-500\",\n                                    children: [\n                                        \"by \",\n                                        note.pubkey.slice(0, 8),\n                                        \"...\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                    lineNumber: 85,\n                                    columnNumber: 25\n                                }, undefined),\n                                note.event && note.event.content && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"text-xs text-gray-400 mt-1 truncate\",\n                                    children: [\n                                        note.event.content.slice(0, 80),\n                                        note.event.content.length > 80 ? '...' : ''\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                                    lineNumber: 87,\n                                    columnNumber: 29\n                                }, undefined)\n                            ]\n                        }, note.id, true, {\n                            fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                            lineNumber: 83,\n                            columnNumber: 21\n                        }, undefined))\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n                lineNumber: 80,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/components/StatsDisplay.tsx\",\n        lineNumber: 61,\n        columnNumber: 9\n    }, undefined);\n};\n_s(StatsDisplay, \"l2aVlCbq/qtnfvgW55+zmBYLOss=\");\n_c = StatsDisplay;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StatsDisplay);\nvar _c;\n$RefreshReg$(_c, \"StatsDisplay\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1N0YXRzRGlzcGxheS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW1EO0FBWW5ELE1BQU1HLGVBQXlCOztJQUMzQixNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR0gsK0NBQVFBLENBQWU7SUFDakQsTUFBTSxDQUFDSSxTQUFTQyxXQUFXLEdBQUdMLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQ00sT0FBT0MsU0FBUyxHQUFHUCwrQ0FBUUEsQ0FBZ0I7SUFDbEQsTUFBTSxDQUFDUSxVQUFVQyxZQUFZLEdBQUdULCtDQUFRQSxDQUFRLEVBQUU7SUFFbERELGdEQUFTQTtrQ0FBQztZQUNOLGVBQWVXO2dCQUNYTCxXQUFXO2dCQUNYRSxTQUFTO2dCQUNULElBQUk7b0JBQ0EscUJBQXFCO29CQUNyQixNQUFNSSxXQUFXLE1BQU1DLE1BQU07b0JBQzdCLElBQUksQ0FBQ0QsU0FBU0UsRUFBRSxFQUFFO3dCQUNkLE1BQU0sSUFBSUMsTUFBTSwwQkFBNkNILE9BQW5CQSxTQUFTSSxNQUFNLEVBQUMsS0FBdUIsT0FBcEJKLFNBQVNLLFVBQVU7b0JBQ3BGO29CQUNBLE1BQU1DLFlBQVksTUFBTU4sU0FBU08sSUFBSTtvQkFDckMsSUFBSUQsYUFBYSxPQUFPQSxVQUFVRSxNQUFNLEtBQUssVUFBVTt3QkFDbkRoQixTQUFTYztvQkFDYixPQUFPO3dCQUNIVixTQUFTO29CQUNiO2dCQUNKLEVBQUUsT0FBT2EsR0FBUTtvQkFDYkMsUUFBUWYsS0FBSyxDQUFDLHdCQUF3QmM7b0JBQ3RDYixTQUFTYSxFQUFFRSxPQUFPLElBQUk7Z0JBQzFCO2dCQUNBakIsV0FBVztZQUNmO1lBQ0EsZUFBZWtCO2dCQUNYLElBQUk7b0JBQ0EsTUFBTUMsY0FBYyxNQUFNWixNQUFNO29CQUNoQyxJQUFJLENBQUNZLFlBQVlYLEVBQUUsRUFBRTt3QkFDakIsTUFBTSxJQUFJQyxNQUFNLG1DQUF5RFUsT0FBdEJBLFlBQVlULE1B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QixLQUFLLENBQUMsR0FBRzt3Q0FBRzs7Ozs7OztnQ0FDaEVpQixLQUFLRyxLQUFLLElBQUlILEtBQUtHLEtBQUssQ0FBQ0MsT0FBTyxrQkFDN0IsOERBQUNuQjtvQ0FBSUMsV0FBVTs7d0NBQXVDYyxLQUFLRyxLQUFLLENBQUNDLE9BQU8sQ0FBQ3JCLEtBQUssQ0FBQyxHQUFHO3dDQUFLaUIsS0FBS0csS0FBSyxDQUFDQyxPQUFPLENBQUNOLE1BQU0sR0FBRyxLQUFLLFFBQVE7Ozs7Ozs7OzJCQUovSEUsS0FBS0MsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXcEM7R0FqRk05QztLQUFBQTtBQW1GTixpRUFBZUEsWUFBWUEsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL3NyYy9jb21wb25lbnRzL1N0YXRzRGlzcGxheS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuaW50ZXJmYWNlIFN0YXRzIHtcbiAgICBldmVudHM6IG51bWJlcjtcbiAgICByZWxheXM6IG51bWJlcjtcbiAgICBwcm9maWxlczogbnVtYmVyO1xuICAgIG5vdGVzXzI0aD86IG51bWJlcjtcbiAgICBwcm9maWxlc18yNGg/OiBudW1iZXI7XG4gICAgcmVsYXlzXzI0aD86IG51bWJlcjtcbiAgICAvLyBBZGQgbW9yZSBmaWVsZHMgaWYgbmVlZGVkIGZyb20gdGhlIEFQSSByZXNwb25zZVxufVxuXG5jb25zdCBTdGF0c0Rpc3BsYXk6IFJlYWN0LkZDID0gKCkgPT4ge1xuICAgIGNvbnN0IFtzdGF0cywgc2V0U3RhdHNdID0gdXNlU3RhdGU8U3RhdHMgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IFt0cmVuZGluZywgc2V0VHJlbmRpbmddID0gdXNlU3RhdGU8YW55W10+KFtdKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRTdGF0cygpIHtcbiAgICAgICAgICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gRmV0Y2ggZ2xvYmFsIHN0YXRzXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHNSZXMgPSBhd2FpdCBmZXRjaChcImh0dHBzOi8vYXBpLm5vc3RyLmJhbmQvdjAvc3RhdHNcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0c1Jlcy5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBzdGF0czogJHtzdGF0c1Jlcy5zdGF0dXN9ICR7c3RhdHNSZXMuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHNEYXRhID0gYXdhaXQgc3RhdHNSZXMuanNvbigpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0c0RhdGEgJiYgdHlwZW9mIHN0YXRzRGF0YS5ldmVudHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXRzKHN0YXRzRGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoJ1N0YXRzIGRhdGEgZm9ybWF0IGluY29ycmVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIHN0YXRzOlwiLCBlKTtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihlLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBsb2FkIHN0YXRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBsb2FkVHJlbmRpbmcoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyZW5kaW5nUmVzID0gYXdhaXQgZmV0Y2goXCJodHRwczovL2FwaS5ub3N0ci5iYW5kL3YwL3RyZW5kaW5nL25vdGVzXCIpO1xuICAgICAgICAgICAgICAgIGlmICghdHJlbmRpbmdSZXMub2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggdHJlbmRpbmcgbm90ZXM6ICR7dHJlbmRpbmdSZXMuc3RhdHVzfSAke3RyZW5kaW5nUmVzLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRyZW5kaW5nRGF0YSA9IGF3YWl0IHRyZW5kaW5nUmVzLmpzb24oKTtcbiAgICAgICAgICAgICAgICBpZiAodHJlbmRpbmdEYXRhICYmIEFycmF5LmlzQXJyYXkodHJlbmRpbmdEYXRhLm5vdGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUcmVuZGluZyh0cmVuZGluZ0RhdGEubm90ZXMuc2xpY2UoMCwgNSkpOyAvLyBUb3AgNSB0cmVuZGluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSB0cmVuZGluZyBlcnJvciBmb3Igbm93LCBvciBoYW5kbGUgaXQgbW9yZSBncmFjZWZ1bGx5XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGxvYWQgdHJlbmRpbmcgbm90ZXM6XCIsIGUubWVzc2FnZSB8fCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2FkU3RhdHMoKTtcbiAgICAgICAgbG9hZFRyZW5kaW5nKCk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJiZy1ncmF5LTkwMCByb3VuZGVkLXhsIHNoYWRvdy1tZCBwLTQgbWItNCBib3JkZXIgYm9yZGVyLWdyYXktODAwIHRleHQtd2hpdGVcIj5cbiAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0zIHRleHQtcGluay00MDBcIj5HbG9iYWwgTm9zdHIgU3RhdHM8L2gyPlxuICAgICAgICAgICAge2xvYWRpbmcgPyAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhbmltYXRlLXB1bHNlIHRleHQtZ3JheS00MDBcIj5Mb2FkaW5nIHN0YXRzLi4uPC9kaXY+XG4gICAgICAgICAgICApIDogZXJyb3IgPyAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXJlZC01MDAgdGV4dC1zbVwiPntlcnJvcn08L2Rpdj5cbiAgICAgICAgICAgICkgOiBzdGF0cyA/IChcbiAgICAgICAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwic3BhY2UteS0xIG1iLTQgdGV4dC1zbVwiPlxuICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW5cIj48c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNDAwXCI+VG90YWwgRXZlbnRzPC9zcGFuPjxzcGFuIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGQgdGV4dC1ncmF5LTIwMFwiPntzdGF0cy5ldmVudHMudG9Mb2NhbGVTdHJpbmcoKX08L3NwYW4+PC9saT5cbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1iZXR3ZWVuXCI+PHNwYW4gY2xhc3NOYW1lPVwidGV4dC1ncmF5LTQwMFwiPlRvdGFsIFJlbGF5czwvc3Bhbj48c3BhbiBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkIHRleHQtZ3JheS0yMDBcIj57c3RhdHMucmVsYXlzLnRvTG9jYWxlU3RyaW5nKCl9PC9zcGFuPjwvbGk+XG4gICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlblwiPjxzcGFuIGNsYXNzTmFtZT1cInRleHQtZ3JheS00MDBcIj5Ub3RhbCBQcm9maWxlczwvc3Bhbj48c3BhbiBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkIHRleHQtZ3JheS0yMDBcIj57c3RhdHMucHJvZmlsZXMudG9Mb2NhbGVTdHJpbmcoKX08L3NwYW4+PC9saT5cbiAgICAgICAgICAgICAgICAgICAge3R5cGVvZiBzdGF0cy5ub3Rlc18yNGggPT09ICdudW1iZXInICYmIDxsaSBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlblwiPjxzcGFuIGNsYXNzTmFtZT1cInRleHQtZ3JheS00MDBcIj5Ob3RlcyAoMjRoKTwvc3Bhbj48c3BhbiBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkIHRleHQtZ3JheS0yMDBcIj57c3RhdHMubm90ZXNfMjRoLnRvTG9jYWxlU3RyaW5nKCl9PC9zcGFuPjwvbGk+fVxuICAgICAgICAgICAgICAgICAgICB7dHlwZW9mIHN0YXRzLnByb2ZpbGVzXzI0aCA9PT0gJ251bWJlcicgJiYgPGxpIGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1iZXR3ZWVuXCI+PHNwYW4gY2xhc3NOYW1lPVwidGV4dC1ncmF5LTQwMFwiPlByb2ZpbGVzICgyNGgpPC9zcGFuPjxzcGFuIGNsYXNzTmFtZT1cImZvbnQtc2VtaWJvbGQgdGV4dC1ncmF5LTIwMFwiPntzdGF0cy5wcm9maWxlc18yNGgudG9Mb2NhbGVTdHJpbmcoKX08L3NwYW4+PC9saT59XG4gICAgICAgICAgICAgICAgICAgIHt0eXBlb2Ygc3RhdHMucmVsYXlzXzI0aCA9PT0gJ251bWJlcicgJiYgPGxpIGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1iZXR3ZWVuXCI+PHNwYW4gY2xhc3NOYW1lPVwidGV4dC1ncmF5LTQwMFwiPlJlbGF5cyAoMjRoKTwvc3Bhbj48c3BhbiBjbGFzc05hbWU9XCJmb250LXNlbWlib2xkIHRleHQtZ3JheS0yMDBcIj57c3RhdHMucmVsYXlzXzI0aC50b0xvY2FsZVN0cmluZygpfTwvc3Bhbj48L2xpPn1cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICAhbG9hZGluZyAmJiA8ZGl2IGNsYXNzTmFtZT1cInRleHQtZ3JheS00MDAgdGV4dC1zbVwiPlN0YXRzIHVuYXZhaWxhYmxlLjwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LW1kIGZvbnQtc2VtaWJvbGQgbWItMiBtdC00IHRleHQtcGluay00MDBcIj5UcmVuZGluZyBOb3RlczwvaDM+XG4gICAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwiZGl2aWRlLXkgZGl2aWRlLWdyYXktODAwXCI+XG4gICAgICAgICAgICAgICAge3RyZW5kaW5nLmxlbmd0aCA9PT0gMCAmJiAhbG9hZGluZyAmJiA8bGkgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTQwMCBweS0yIHRleHQtc21cIj5ObyB0cmVuZGluZyBub3RlcyBhdmFpbGFibGUuPC9saT59XG4gICAgICAgICAgICAgICAge3RyZW5kaW5nLm1hcCgobm90ZSkgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8bGkga2V5PXtub3RlLmlkfSBjbGFzc05hbWU9XCJweS0yIHRleHQtc21cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZvbnQtbWVkaXVtIHRleHQtZ3JheS0zMDBcIj57bm90ZS5pZC5zbGljZSgwLCA4KX0uLi48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJtbC0yIHRleHQtZ3JheS01MDBcIj5ieSB7bm90ZS5wdWJrZXkuc2xpY2UoMCwgOCl9Li4uPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAge25vdGUuZXZlbnQgJiYgbm90ZS5ldmVudC5jb250ZW50ICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1ncmF5LTQwMCBtdC0xIHRydW5jYXRlXCI+e25vdGUuZXZlbnQuY29udGVudC5zbGljZSgwLCA4MCl9e25vdGUuZXZlbnQuY29udGVudC5sZW5ndGggPiA4MCA/ICcuLi4nIDogJyd9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFN0YXRzRGlzcGxheTsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIlN0YXRzRGlzcGxheSIsInN0YXRzIiwic2V0U3RhdHMiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJ0cmVuZGluZyIsInNldFRyZW5kaW5nIiwibG9hZFN0YXRzIiwic3RhdHNSZXMiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNUZXh0Iiwic3RhdHNEYXRhIiwianNvbiIsImV2ZW50cyIsImUiLCJjb25zb2xlIiwibWVzc2FnZSIsImxvYWRUcmVuZGluZyIsInRyZW5kaW5nUmVzIiwidHJlbmRpbmdEYXRhIiwiQXJyYXkiLCJpc0FycmF5Iiwibm90ZXMiLCJzbGljZSIsIndhcm4iLCJkaXYiLCJjbGFzc05hbWUiLCJoMiIsInVsIiwibGkiLCJzcGFuIiwidG9Mb2NhbGVTdHJpbmciLCJyZWxheXMiLCJwcm9maWxlcyIsIm5vdGVzXzI0aCIsInByb2ZpbGVzXzI0aCIsInJlbGF5c18yNGgiLCJoMyIsImxlbmd0aCIsIm1hcCIsIm5vdGUiLCJpZCIsInB1YmtleSIsImV2ZW50IiwiY29udGVudCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/StatsDisplay.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/chat/ChatBox.tsx":
/*!*****************************************!*\
  !*** ./src/components/chat/ChatBox.tsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatBox: () => (/* binding */ ChatBox)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_nostr_relay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/nostr/relay */ \"(app-pages-browser)/./src/lib/nostr/relay.ts\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/../node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var _ChatHeader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ChatHeader */ \"(app-pages-browser)/./src/components/chat/ChatHeader.tsx\");\n/* harmony import */ var _ChatMessage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ChatMessage */ \"(app-pages-browser)/./src/components/chat/ChatMessage.tsx\");\n/* harmony import */ var _ChatInput__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ChatInput */ \"(app-pages-browser)/./src/components/chat/ChatInput.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nfunction ChatBox(param) {\n    let { postId, pubkey, onClose, isAnimating = false } = param;\n    _s();\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [sending, setSending] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [relays, setRelays] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const poolRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const chatRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Subscribe to chat events for this post\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ChatBox.useEffect\": ()=>{\n            let unsub;\n            let pool = null;\n            const setupPool = {\n                \"ChatBox.useEffect.setupPool\": async ()=>{\n                    const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_2__.getHealthyRelays)();\n                    setRelays(healthyRelays);\n                    pool = new nostr_tools__WEBPACK_IMPORTED_MODULE_6__.SimplePool();\n                    poolRef.current = pool;\n                    unsub = pool.subscribeMany(healthyRelays, [\n                        {\n                            kinds: [\n                                1\n                            ],\n                            \"#e\": [\n                                postId\n                            ],\n                            limit: 50\n                        }\n                    ], {\n                        onevent: {\n                            \"ChatBox.useEffect.setupPool\": (ev)=>{\n                                setMessages({\n                                    \"ChatBox.useEffect.setupPool\": (msgs)=>{\n                                        if (msgs.find({\n                                            \"ChatBox.useEffect.setupPool\": (m)=>m.id === ev.id\n                                        }[\"ChatBox.useEffect.setupPool\"])) return msgs;\n                                        return [\n                                            ...msgs,\n                                            ev\n                                        ].sort({\n                                            \"ChatBox.useEffect.setupPool\": (a, b)=>a.created_at - b.created_at\n                                        }[\"ChatBox.useEffect.setupPool\"]);\n                                    }\n                                }[\"ChatBox.useEffect.setupPool\"]);\n                            }\n                        }[\"ChatBox.useEffect.setupPool\"]\n                    });\n                }\n            }[\"ChatBox.useEffect.setupPool\"];\n            setupPool();\n            return ({\n                \"ChatBox.useEffect\": ()=>{\n                    if (typeof (unsub === null || unsub === void 0 ? void 0 : unsub.close) === 'function') unsub.close();\n                    if (pool && relays.length > 0) pool.close(relays);\n                }\n            })[\"ChatBox.useEffect\"];\n        }\n    }[\"ChatBox.useEffect\"], [\n        postId\n    ]);\n    // Scroll to bottom on new message\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ChatBox.useEffect\": ()=>{\n            if (chatRef.current) chatRef.current.scrollTop = chatRef.current.scrollHeight;\n        }\n    }[\"ChatBox.useEffect\"], [\n        messages\n    ]);\n    // Send a chat message\n    async function sendMessage() {\n        if (!input.trim() || !pubkey || !window.nostr || relays.length === 0) return;\n        setSending(true);\n        const event = {\n            kind: 1,\n            pubkey,\n            created_at: Math.floor(Date.now() / 1000),\n            tags: [\n                [\n                    \"e\",\n                    postId\n                ]\n            ],\n            content: input\n        };\n        let signedEvent;\n        try {\n            signedEvent = await window.nostr.signEvent(event);\n        } catch (e) {\n            alert(\"Failed to sign chat message.\");\n            setSending(false);\n            return;\n        }\n        try {\n            // Ensure we have the pool\n            if (!poolRef.current) {\n                throw new Error(\"Pool not initialized\");\n            }\n            // Publish to all relays\n            const publishPromises = relays.map(async (url)=>{\n                try {\n                    const pub = await poolRef.current.publish([\n                        url\n                    ], signedEvent);\n                    // Wait for confirmation\n                    await Promise.race([\n                        pub,\n                        new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Timeout\")), 5000))\n                    ]);\n                    return true;\n                } catch (err) {\n                    console.warn(\"Failed to publish to \".concat(url, \":\"), err);\n                    return false;\n                }\n            });\n            // Wait for at least one successful publish\n            const results = await Promise.all(publishPromises);\n            if (!results.some((success)=>success)) {\n                throw new Error(\"Failed to publish to any relay\");\n            }\n            setInput(\"\");\n            // Add the message locally for immediate feedback\n            setMessages((prev)=>[\n                    ...prev,\n                    signedEvent\n                ].sort((a, b)=>a.created_at - b.created_at));\n        } catch (error) {\n            console.error(\"Error publishing message:\", error);\n            alert(\"Failed to send message. Please try again.\");\n        } finally{\n            setSending(false);\n        }\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"mt-2 bg-gray-900/40 backdrop-blur-md rounded-b-xl transition-all duration-300 \".concat(isAnimating ? 'opacity-0 transform translate-y-[-10px]' : 'opacity-100 transform translate-y-0'),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ChatHeader__WEBPACK_IMPORTED_MODULE_3__.ChatHeader, {\n                messageCount: messages.length,\n                onClose: onClose\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/chat/ChatBox.tsx\",\n                lineNumber: 127,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: chatRef,\n                className: \"max-h-[480px] overflow-y-auto p-6 space-y-4\",\n                children: messages.length === 0 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-gray-400 text-center py-8\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"text-3xl mb-3\",\n                            children: \"\\uD83D\\uDCAD\"\n                        }, void 0, false, {\n                            fileName: \"/Users/scarnes/workspace/src/components/chat/ChatBox.tsx\",\n                            lineNumber: 132,\n                            columnNumber: 25\n                        }, this),\n                        \"Start the conversation!\"\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/scarnes/workspace/src/components/chat/ChatBox.tsx\",\n                    lineNumber: 131,\n                    columnNumber: 21\n                }, this) : messages.map((msg)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ChatMessage__WEBPACK_IMPORTED_MODULE_4__.ChatMessage, {\n                        message: msg,\n                        isOwnMessage: msg.pubkey === pubkey\n                    }, msg.id, false, {\n                        fileName: \"/Users/scarnes/workspace/src/components/chat/ChatBox.tsx\",\n                        lineNumber: 137,\n                        columnNumber: 25\n                    }, this))\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/chat/ChatBox.tsx\",\n                lineNumber: 129,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ChatInput__WEBPACK_IMPORTED_MODULE_5__.ChatInput, {\n                value: input,\n                onChange: setInput,\n                onSubmit: sendMessage,\n                disabled: sending\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/chat/ChatBox.tsx\",\n                lineNumber: 146,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/components/chat/ChatBox.tsx\",\n        lineNumber: 125,\n        columnNumber: 9\n    }, this);\n}\n_s(ChatBox, \"n/UleARowF1jcvBVgjF4NKP4A0Y=\");\n_c = ChatBox;\nvar _c;\n$RefreshReg$(_c, \"ChatBox\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2NoYXQvQ2hhdEJveC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBb0Q7QUFDQztBQUNaO0FBRUM7QUFDRTtBQUNKO0FBV2pDLFNBQVNRLFFBQVEsS0FBOEQ7UUFBOUQsRUFBRUMsTUFBTSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxLQUFLLEVBQWdCLEdBQTlEOztJQUNwQixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR1osK0NBQVFBLENBQWUsRUFBRTtJQUN6RCxNQUFNLENBQUNhLE9BQU9DLFNBQVMsR0FBR2QsK0NBQVFBLENBQVM7SUFDM0MsTUFBTSxDQUFDZSxTQUFTQyxXQUFXLEdBQUdoQiwrQ0FBUUEsQ0FBVTtJQUNoRCxNQUFNLENBQUNpQixRQUFRQyxVQUFVLEdBQUdsQiwrQ0FBUUEsQ0FBVyxFQUFFO0lBQ2pELE1BQU1tQixVQUFVcEIsNkNBQU1BLENBQW9CO0lBQzFDLE1BQU1xQixVQUFVckIsNkNBQU1BLENBQWlCO0lBRXZDLHlDQUF5QztJQUN6Q0QsZ0RBQVNBOzZCQUFDO1lBQ04sSUFBSXVCO1lBQ0osSUFBSUMsT0FBMEI7WUFFOUIsTUFBTUM7K0NBQVk7b0JBQ2QsTUFBTSxFQUFFQyxhQUFhLEVBQUUsR0FBRyxNQUFNdkIsa0VBQWdCQTtvQkFDaERpQixVQUFVTTtvQkFDVkYsT0FBTyxJQUFJcEIsbURBQVVBO29CQUNyQmlCLFFBQVFNLE9BQU8sR0FBR0g7b0JBRWxCRCxRQUFRQyxLQUFLSSxhQUFhLENBQUNGLGVBQWU7d0JBQUM7NEJBQ3ZDRyxPQUFPO2dDQUFDOzZCQUFFOzRCQUNWLE1BQU07Z0NBQUNwQjs2QkFBTzs0QkFDZHFCLE9BQU87d0JBQ1g7cUJBQUUsRUFBRTt3QkFDQUMsT0FBTzsyREFBRSxDQUFDQztnQ0FDTmxCO21FQUFZLENBQUNtQjt3Q0FDVCxJQUFJQSxLQUFLQyxJQUFJOzJFQUFDLENBQUNDLElBQWtCQSxFQUFFQyxFQUFF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QkFFcEQsOERBQUNxRTtnQkFBSUcsS0FBSzdEO2dCQUFTMkQsV0FBVTswQkFDeEJwRSxTQUFTNkIsTUFBTSxLQUFLLGtCQUNqQiw4REFBQ3NDO29CQUFJQyxXQUFVOztzQ0FDWCw4REFBQ0Q7NEJBQUlDLFdBQVU7c0NBQWdCOzs7Ozs7d0JBQVE7Ozs7OzsyQkFJM0NwRSxTQUFTaUQsR0FBRyxDQUFDc0IsQ0FBQUEsb0JBQ1QsOERBQUM5RSxxREFBV0E7d0JBRVIrRSxTQUFTRDt3QkFDVEUsY0FBY0YsSUFBSTFFLE1BQU0sS0FBS0E7dUJBRnhCMEUsSUFBSWhELEVBQUU7Ozs7Ozs7Ozs7MEJBUTNCLDhEQUFDN0IsaURBQVNBO2dCQUNOZ0YsT0FBT3hFO2dCQUNQeUUsVUFBVXhFO2dCQUNWeUUsVUFBVTVDO2dCQUNWNkMsVUFBVXpFOzs7Ozs7Ozs7Ozs7QUFJMUI7R0F4SWdCVDtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL3NyYy9jb21wb25lbnRzL2NoYXQvQ2hhdEJveC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBnZXRIZWFsdGh5UmVsYXlzIH0gZnJvbSBcIkAvbGliL25vc3RyL3JlbGF5XCI7XG5pbXBvcnQgeyBTaW1wbGVQb29sIH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG5pbXBvcnQgeyBOb3N0ckV2ZW50IH0gZnJvbSBcIkAvdHlwZXMvbm9zdHJcIjtcbmltcG9ydCB7IENoYXRIZWFkZXIgfSBmcm9tIFwiLi9DaGF0SGVhZGVyXCI7XG5pbXBvcnQgeyBDaGF0TWVzc2FnZSB9IGZyb20gXCIuL0NoYXRNZXNzYWdlXCI7XG5pbXBvcnQgeyBDaGF0SW5wdXQgfSBmcm9tIFwiLi9DaGF0SW5wdXRcIjtcblxudHlwZSBTdWJDbG9zZXIgPSB7IGNsb3NlOiAoKSA9PiB2b2lkIH07XG5cbmludGVyZmFjZSBDaGF0Qm94UHJvcHMge1xuICAgIHBvc3RJZDogc3RyaW5nO1xuICAgIHB1YmtleTogc3RyaW5nIHwgbnVsbDtcbiAgICBvbkNsb3NlOiAoKSA9PiB2b2lkO1xuICAgIGlzQW5pbWF0aW5nPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIENoYXRCb3goeyBwb3N0SWQsIHB1YmtleSwgb25DbG9zZSwgaXNBbmltYXRpbmcgPSBmYWxzZSB9OiBDaGF0Qm94UHJvcHMpIHtcbiAgICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlPE5vc3RyRXZlbnRbXT4oW10pO1xuICAgIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcbiAgICBjb25zdCBbc2VuZGluZywgc2V0U2VuZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gICAgY29uc3QgW3JlbGF5cywgc2V0UmVsYXlzXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7XG4gICAgY29uc3QgcG9vbFJlZiA9IHVzZVJlZjxTaW1wbGVQb29sIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgY2hhdFJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG5cbiAgICAvLyBTdWJzY3JpYmUgdG8gY2hhdCBldmVudHMgZm9yIHRoaXMgcG9zdFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGxldCB1bnN1YjogU3ViQ2xvc2VyIHwgdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcG9vbDogU2ltcGxlUG9vbCB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGNvbnN0IHNldHVwUG9vbCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGVhbHRoeVJlbGF5cyB9ID0gYXdhaXQgZ2V0SGVhbHRoeVJlbGF5cygpO1xuICAgICAgICAgICAgc2V0UmVsYXlzKGhlYWx0aHlSZWxheXMpO1xuICAgICAgICAgICAgcG9vbCA9IG5ldyBTaW1wbGVQb29sKCk7XG4gICAgICAgICAgICBwb29sUmVmLmN1cnJlbnQgPSBwb29sO1xuXG4gICAgICAgICAgICB1bnN1YiA9IHBvb2wuc3Vic2NyaWJlTWFueShoZWFsdGh5UmVsYXlzLCBbe1xuICAgICAgICAgICAgICAgIGtpbmRzOiBbMV0sIC8vIFVzZSBraW5kIDEgZm9yIHRleHRfbm90ZVxuICAgICAgICAgICAgICAgIFwiI2VcIjogW3Bvc3RJZF0sIC8vIHRhZyB3aXRoIHBvc3QgaWRcbiAgICAgICAgICAgICAgICBsaW1pdDogNTAsXG4gICAgICAgICAgICB9XSwge1xuICAgICAgICAgICAgICAgIG9uZXZlbnQ6IChldjogTm9zdHJFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRNZXNzYWdlcygobXNnczogTm9zdHJFdmVudFtdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXNncy5maW5kKChtOiBOb3N0ckV2ZW50KSA9PiBtLmlkID09PSBldi5pZCkpIHJldHVybiBtc2dzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5tc2dzLCBldl0uc29ydCgoYSwgYikgPT4gYS5jcmVhdGVkX2F0IC0gYi5jcmVhdGVkX2F0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2V0dXBQb29sKCk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdW5zdWI/LmNsb3NlID09PSAnZnVuY3Rpb24nKSB1bnN1Yi5jbG9zZSgpO1xuICAgICAgICAgICAgaWYgKHBvb2wgJiYgcmVsYXlzLmxlbmd0aCA+IDApIHBvb2wuY2xvc2UocmVsYXlzKTtcbiAgICAgICAgfTtcbiAgICB9LCBbcG9zdElkXSk7XG5cbiAgICAvLyBTY3JvbGwgdG8gYm90dG9tIG9uIG5ldyBtZXNzYWdlXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGNoYXRSZWYuY3VycmVudCkgY2hhdFJlZi5jdXJyZW50LnNjcm9sbFRvcCA9IGNoYXRSZWYuY3VycmVudC5zY3JvbGxIZWlnaHQ7XG4gICAgfSwgW21lc3NhZ2VzXSk7XG5cbiAgICAvLyBTZW5kIGEgY2hhdCBtZXNzYWdlXG4gICAgYXN5bmMgZnVuY3Rpb24gc2VuZE1lc3NhZ2UoKSB7XG4gICAgICAgIGlmICghaW5wdXQudHJpbSgpIHx8ICFwdWJrZXkgfHwgISh3aW5kb3cgYXMgYW55KS5ub3N0ciB8fCByZWxheXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHNldFNlbmRpbmcodHJ1ZSk7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgICAga2luZDogMSwgIC8vIGtpbmQgMSBmb3IgdGV4dF9ub3RlXG4gICAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgICAgIHRhZ3M6IFtbXCJlXCIsIHBvc3RJZF1dLFxuICAgICAgICAgICAgY29udGVudDogaW5wdXQsXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHNpZ25lZEV2ZW50O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2lnbmVkRXZlbnQgPSBhd2FpdCAod2luZG93IGFzIGFueSkubm9zdHIuc2lnbkV2ZW50KGV2ZW50KTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBhbGVydChcIkZhaWxlZCB0byBzaWduIGNoYXQgbWVzc2FnZS5cIik7XG4gICAgICAgICAgICBzZXRTZW5kaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHBvb2xcbiAgICAgICAgICAgIGlmICghcG9vbFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9vbCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggdG8gYWxsIHJlbGF5c1xuICAgICAgICAgICAgY29uc3QgcHVibGlzaFByb21pc2VzID0gcmVsYXlzLm1hcChhc3luYyB1cmwgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHB1YiA9IGF3YWl0IHBvb2xSZWYuY3VycmVudCEucHVibGlzaChbdXJsXSwgc2lnbmVkRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciBjb25maXJtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1YixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVvdXRcIikpLCA1MDAwKSlcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBwdWJsaXNoIHRvICR7dXJsfTpgLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIGF0IGxlYXN0IG9uZSBzdWNjZXNzZnVsIHB1Ymxpc2hcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwdWJsaXNoUHJvbWlzZXMpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHRzLnNvbWUoc3VjY2VzcyA9PiBzdWNjZXNzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwdWJsaXNoIHRvIGFueSByZWxheVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0SW5wdXQoXCJcIik7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG1lc3NhZ2UgbG9jYWxseSBmb3IgaW1tZWRpYXRlIGZlZWRiYWNrXG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCBzaWduZWRFdmVudF0uc29ydCgoYSwgYikgPT4gYS5jcmVhdGVkX2F0IC0gYi5jcmVhdGVkX2F0KSk7XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwdWJsaXNoaW5nIG1lc3NhZ2U6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIGFsZXJ0KFwiRmFpbGVkIHRvIHNlbmQgbWVzc2FnZS4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRTZW5kaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgbXQtMiBiZy1ncmF5LTkwMC80MCBiYWNrZHJvcC1ibHVyLW1kIHJvdW5kZWQtYi14bCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgJHtpc0FuaW1hdGluZyA/ICdvcGFjaXR5LTAgdHJhbnNmb3JtIHRyYW5zbGF0ZS15LVstMTBweF0nIDogJ29wYWNpdHktMTAwIHRyYW5zZm9ybSB0cmFuc2xhdGUteS0wJ1xuICAgICAgICAgICAgfWB9PlxuICAgICAgICAgICAgPENoYXRIZWFkZXIgbWVzc2FnZUNvdW50PXttZXNzYWdlcy5sZW5ndGh9IG9uQ2xvc2U9e29uQ2xvc2V9IC8+XG5cbiAgICAgICAgICAgIDxkaXYgcmVmPXtjaGF0UmVmfSBjbGFzc05hbWU9XCJtYXgtaC1bNDgwcHhdIG92ZXJmbG93LXktYXV0byBwLTYgc3BhY2UteS00XCI+XG4gICAgICAgICAgICAgICAge21lc3NhZ2VzLmxlbmd0aCA9PT0gMCA/IChcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNDAwIHRleHQtY2VudGVyIHB5LThcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC0zeGwgbWItM1wiPvCfkq08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIFN0YXJ0IHRoZSBjb252ZXJzYXRpb24hXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzLm1hcChtc2cgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPENoYXRNZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXttc2cuaWR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZT17bXNnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT3duTWVzc2FnZT17bXNnLnB1YmtleSA9PT0gcHVia2V5fVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxDaGF0SW5wdXRcbiAgICAgICAgICAgICAgICB2YWx1ZT17aW5wdXR9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e3NldElucHV0fVxuICAgICAgICAgICAgICAgIG9uU3VibWl0PXtzZW5kTWVzc2FnZX1cbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17c2VuZGluZ31cbiAgICAgICAgICAgIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59XG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJnZXRIZWFsdGh5UmVsYXlzIiwiU2ltcGxlUG9vbCIsIkNoYXRIZWFkZXIiLCJDaGF0TWVzc2FnZSIsIkNoYXRJbnB1dCIsIkNoYXRCb3giLCJwb3N0SWQiLCJwdWJrZXkiLCJvbkNsb3NlIiwiaXNBbmltYXRpbmciLCJtZXNzYWdlcyIsInNldE1lc3NhZ2VzIiwiaW5wdXQiLCJzZXRJbnB1dCIsInNlbmRpbmciLCJzZXRTZW5kaW5nIiwicmVsYXlzIiwic2V0UmVsYXlzIiwicG9vbFJlZiIsImNoYXRSZWYiLCJ1bnN1YiIsInBvb2wiLCJzZXR1cFBvb2wiLCJoZWFsdGh5UmVsYXlzIiwiY3VycmVudCIsInN1YnNjcmliZU1hbnkiLCJraW5kcyIsImxpbWl0Iiwib25ldmVudCIsImV2IiwibXNncyIsImZpbmQiLCJtIiwiaWQiLCJzb3J0IiwiYSIsImIiLCJjcmVhdGVkX2F0IiwiY2xvc2UiLCJsZW5ndGgiLCJzY3JvbGxUb3AiLCJzY3JvbGxIZWlnaHQiLCJzZW5kTWVzc2FnZSIsInRyaW0iLCJ3aW5kb3ciLCJub3N0ciIsImV2ZW50Iiwia2luZCIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJub3ciLCJ0YWdzIiwiY29udGVudCIsInNpZ25lZEV2ZW50Iiwic2lnbkV2ZW50IiwiYWxlcnQiLCJFcnJvciIsInB1Ymxpc2hQcm9taXNlcyIsIm1hcCIsInVybCIsInB1YiIsInB1Ymxpc2giLCJQcm9taXNlIiwicmFjZSIsIl8iLCJyZWplY3QiLCJzZXRUaW1lb3V0IiwiZXJyIiwiY29uc29sZSIsIndhcm4iLCJyZXN1bHRzIiwiYWxsIiwic29tZSIsInN1Y2Nlc3MiLCJwcmV2IiwiZXJyb3IiLCJkaXYiLCJjbGFzc05hbWUiLCJtZXNzYWdlQ291bnQiLCJyZWYiLCJtc2ciLCJtZXNzYWdlIiwiaXNPd25NZXNzYWdlIiwidmFsdWUiLCJvbkNoYW5nZSIsIm9uU3VibWl0IiwiZGlzYWJsZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/chat/ChatBox.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/chat/ChatHeader.tsx":
/*!********************************************!*\
  !*** ./src/components/chat/ChatHeader.tsx ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatHeader: () => (/* binding */ ChatHeader)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nfunction ChatHeader(param) {\n    let { messageCount, onClose } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex items-center justify-between px-6 py-3 border-b border-white/10\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-center gap-3\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-blue-400 text-xl\",\n                        children: \"\\uD83D\\uDCAC\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/components/chat/ChatHeader.tsx\",\n                        lineNumber: 10,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"font-medium text-white\",\n                        children: \"Live Chat\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/components/chat/ChatHeader.tsx\",\n                        lineNumber: 11,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"px-2 py-0.5 rounded-full bg-white/5 text-xs text-blue-300\",\n                        children: messageCount\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/components/chat/ChatHeader.tsx\",\n                        lineNumber: 12,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/components/chat/ChatHeader.tsx\",\n                lineNumber: 9,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: onClose,\n                className: \"w-8 h-8 flex items-center justify-center rounded-full text-gray-400 hover:text-white hover:bg-gray-800/50 transition\",\n                children: \"\\xd7\"\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/chat/ChatHeader.tsx\",\n                lineNumber: 16,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/components/chat/ChatHeader.tsx\",\n        lineNumber: 8,\n        columnNumber: 9\n    }, this);\n}\n_c = ChatHeader;\nvar _c;\n$RefreshReg$(_c, \"ChatHeader\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2NoYXQvQ2hhdEhlYWRlci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBS08sU0FBU0EsV0FBVyxLQUEwQztRQUExQyxFQUFFQyxZQUFZLEVBQUVDLE9BQU8sRUFBbUIsR0FBMUM7SUFDdkIscUJBQ0ksOERBQUNDO1FBQUlDLFdBQVU7OzBCQUNYLDhEQUFDRDtnQkFBSUMsV0FBVTs7a0NBQ1gsOERBQUNDO3dCQUFLRCxXQUFVO2tDQUF3Qjs7Ozs7O2tDQUN4Qyw4REFBQ0Q7d0JBQUlDLFdBQVU7a0NBQXlCOzs7Ozs7a0NBQ3hDLDhEQUFDQzt3QkFBS0QsV0FBVTtrQ0FDWEg7Ozs7Ozs7Ozs7OzswQkFHVCw4REFBQ0s7Z0JBQ0dDLFNBQVNMO2dCQUNURSxXQUFVOzBCQUNiOzs7Ozs7Ozs7Ozs7QUFLYjtLQWxCZ0JKIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvc3JjL2NvbXBvbmVudHMvY2hhdC9DaGF0SGVhZGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbnRlcmZhY2UgQ2hhdEhlYWRlclByb3BzIHtcbiAgICBtZXNzYWdlQ291bnQ6IG51bWJlcjtcbiAgICBvbkNsb3NlOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2hhdEhlYWRlcih7IG1lc3NhZ2VDb3VudCwgb25DbG9zZSB9OiBDaGF0SGVhZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBweC02IHB5LTMgYm9yZGVyLWIgYm9yZGVyLXdoaXRlLzEwXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0zXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1ibHVlLTQwMCB0ZXh0LXhsXCI+8J+SrDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvbnQtbWVkaXVtIHRleHQtd2hpdGVcIj5MaXZlIENoYXQ8L2Rpdj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJweC0yIHB5LTAuNSByb3VuZGVkLWZ1bGwgYmctd2hpdGUvNSB0ZXh0LXhzIHRleHQtYmx1ZS0zMDBcIj5cbiAgICAgICAgICAgICAgICAgICAge21lc3NhZ2VDb3VudH1cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtvbkNsb3NlfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctOCBoLTggZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcm91bmRlZC1mdWxsIHRleHQtZ3JheS00MDAgaG92ZXI6dGV4dC13aGl0ZSBob3ZlcjpiZy1ncmF5LTgwMC81MCB0cmFuc2l0aW9uXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICDDl1xuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59XG4iXSwibmFtZXMiOlsiQ2hhdEhlYWRlciIsIm1lc3NhZ2VDb3VudCIsIm9uQ2xvc2UiLCJkaXYiLCJjbGFzc05hbWUiLCJzcGFuIiwiYnV0dG9uIiwib25DbGljayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/chat/ChatHeader.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/chat/ChatInput.tsx":
/*!*******************************************!*\
  !*** ./src/components/chat/ChatInput.tsx ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatInput: () => (/* binding */ ChatInput)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nfunction ChatInput(param) {\n    let { value, onChange, onSubmit, disabled } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n        className: \"p-4 border-t border-white/10 flex gap-2\",\n        onSubmit: (e)=>{\n            e.preventDefault();\n            onSubmit();\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                className: \"flex-1 px-4 py-2 rounded-full bg-white/5 text-white border border-white/10 focus:outline-none focus:ring-2 focus:ring-blue-500/30 focus:border-blue-500/30 placeholder-gray-500\",\n                placeholder: \"Type your message...\",\n                value: value,\n                onChange: (e)=>onChange(e.target.value),\n                disabled: disabled,\n                autoFocus: true\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/chat/ChatInput.tsx\",\n                lineNumber: 11,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                type: \"submit\",\n                className: \"px-6 py-2 rounded-full bg-blue-500/90 text-white font-medium hover:bg-blue-500 focus:ring-2 focus:ring-blue-500/50 focus:outline-none shadow-lg shadow-blue-500/20 disabled:opacity-50 disabled:hover:bg-blue-500/90 backdrop-blur-sm transition\",\n                disabled: disabled || !value.trim(),\n                children: \"Send\"\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/chat/ChatInput.tsx\",\n                lineNumber: 19,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/components/chat/ChatInput.tsx\",\n        lineNumber: 10,\n        columnNumber: 9\n    }, this);\n}\n_c = ChatInput;\nvar _c;\n$RefreshReg$(_c, \"ChatInput\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2NoYXQvQ2hhdElucHV0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFPTyxTQUFTQSxVQUFVLEtBQXVEO1FBQXZELEVBQUVDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsRUFBa0IsR0FBdkQ7SUFDdEIscUJBQ0ksOERBQUNDO1FBQUtDLFdBQVU7UUFBMENILFVBQVVJLENBQUFBO1lBQU9BLEVBQUVDLGNBQWM7WUFBSUw7UUFBWTs7MEJBQ3ZHLDhEQUFDTTtnQkFDR0gsV0FBVTtnQkFDVkksYUFBWTtnQkFDWlQsT0FBT0E7Z0JBQ1BDLFVBQVVLLENBQUFBLElBQUtMLFNBQVNLLEVBQUVJLE1BQU0sQ0FBQ1YsS0FBSztnQkFDdENHLFVBQVVBO2dCQUNWUSxTQUFTOzs7Ozs7MEJBRWIsOERBQUNDO2dCQUNHQyxNQUFLO2dCQUNMUixXQUFVO2dCQUNWRixVQUFVQSxZQUFZLENBQUNILE1BQU1jLElBQUk7MEJBQ3BDOzs7Ozs7Ozs7Ozs7QUFLYjtLQXBCZ0JmIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvc3JjL2NvbXBvbmVudHMvY2hhdC9DaGF0SW5wdXQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImludGVyZmFjZSBDaGF0SW5wdXRQcm9wcyB7XG4gICAgdmFsdWU6IHN0cmluZztcbiAgICBvbkNoYW5nZTogKHZhbHVlOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgb25TdWJtaXQ6ICgpID0+IHZvaWQ7XG4gICAgZGlzYWJsZWQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2hhdElucHV0KHsgdmFsdWUsIG9uQ2hhbmdlLCBvblN1Ym1pdCwgZGlzYWJsZWQgfTogQ2hhdElucHV0UHJvcHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICA8Zm9ybSBjbGFzc05hbWU9XCJwLTQgYm9yZGVyLXQgYm9yZGVyLXdoaXRlLzEwIGZsZXggZ2FwLTJcIiBvblN1Ym1pdD17ZSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgb25TdWJtaXQoKTsgfX0+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmbGV4LTEgcHgtNCBweS0yIHJvdW5kZWQtZnVsbCBiZy13aGl0ZS81IHRleHQtd2hpdGUgYm9yZGVyIGJvcmRlci13aGl0ZS8xMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctYmx1ZS01MDAvMzAgZm9jdXM6Ym9yZGVyLWJsdWUtNTAwLzMwIHBsYWNlaG9sZGVyLWdyYXktNTAwXCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlR5cGUgeW91ciBtZXNzYWdlLi4uXCJcbiAgICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9XG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2UgPT4gb25DaGFuZ2UoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICAgICAgICBhdXRvRm9jdXNcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtNiBweS0yIHJvdW5kZWQtZnVsbCBiZy1ibHVlLTUwMC85MCB0ZXh0LXdoaXRlIGZvbnQtbWVkaXVtIGhvdmVyOmJnLWJsdWUtNTAwIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWJsdWUtNTAwLzUwIGZvY3VzOm91dGxpbmUtbm9uZSBzaGFkb3ctbGcgc2hhZG93LWJsdWUtNTAwLzIwIGRpc2FibGVkOm9wYWNpdHktNTAgZGlzYWJsZWQ6aG92ZXI6YmctYmx1ZS01MDAvOTAgYmFja2Ryb3AtYmx1ci1zbSB0cmFuc2l0aW9uXCJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWQgfHwgIXZhbHVlLnRyaW0oKX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBTZW5kXG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9mb3JtPlxuICAgICk7XG59XG4iXSwibmFtZXMiOlsiQ2hhdElucHV0IiwidmFsdWUiLCJvbkNoYW5nZSIsIm9uU3VibWl0IiwiZGlzYWJsZWQiLCJmb3JtIiwiY2xhc3NOYW1lIiwiZSIsInByZXZlbnREZWZhdWx0IiwiaW5wdXQiLCJwbGFjZWhvbGRlciIsInRhcmdldCIsImF1dG9Gb2N1cyIsImJ1dHRvbiIsInR5cGUiLCJ0cmltIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/chat/ChatInput.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/chat/ChatMessage.tsx":
/*!*********************************************!*\
  !*** ./src/components/chat/ChatMessage.tsx ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatMessage: () => (/* binding */ ChatMessage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nfunction ChatMessage(param) {\n    let { message, isOwnMessage } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"group flex items-start gap-3 \".concat(isOwnMessage ? 'flex-row-reverse' : ''),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-8 h-8 rounded-full bg-white/5 border border-white/10 flex-shrink-0 flex items-center justify-center text-xs text-blue-300\",\n                children: message.pubkey.slice(0, 2)\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/chat/ChatMessage.tsx\",\n                lineNumber: 11,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex-1 relative \".concat(isOwnMessage ? 'text-right' : ''),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"inline-block max-w-[80%] \".concat(isOwnMessage ? 'bg-blue-500/20 text-blue-100 border border-blue-500/20' : 'bg-white/5 text-white border border-white/10', \" rounded-2xl px-4 py-2 text-sm backdrop-blur-sm\"),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"whitespace-pre-line break-words\",\n                            children: message.content\n                        }, void 0, false, {\n                            fileName: \"/Users/scarnes/workspace/src/components/chat/ChatMessage.tsx\",\n                            lineNumber: 20,\n                            columnNumber: 21\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/components/chat/ChatMessage.tsx\",\n                        lineNumber: 15,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mt-1 text-xs text-gray-500\",\n                        children: new Date(message.created_at * 1000).toLocaleTimeString([], {\n                            hour: '2-digit',\n                            minute: '2-digit'\n                        })\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/components/chat/ChatMessage.tsx\",\n                        lineNumber: 22,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/components/chat/ChatMessage.tsx\",\n                lineNumber: 14,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/components/chat/ChatMessage.tsx\",\n        lineNumber: 10,\n        columnNumber: 9\n    }, this);\n}\n_c = ChatMessage;\nvar _c;\n$RefreshReg$(_c, \"ChatMessage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2NoYXQvQ2hhdE1lc3NhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7OztBQU9PLFNBQVNBLFlBQVksS0FBMkM7UUFBM0MsRUFBRUMsT0FBTyxFQUFFQyxZQUFZLEVBQW9CLEdBQTNDO0lBQ3hCLHFCQUNJLDhEQUFDQztRQUFJQyxXQUFXLGdDQUF1RSxPQUF2Q0YsZUFBZSxxQkFBcUI7OzBCQUNoRiw4REFBQ0M7Z0JBQUlDLFdBQVU7MEJBQ1ZILFFBQVFJLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDLEdBQUc7Ozs7OzswQkFFN0IsOERBQUNIO2dCQUFJQyxXQUFXLG1CQUFvRCxPQUFqQ0YsZUFBZSxlQUFlOztrQ0FDN0QsOERBQUNDO3dCQUFJQyxXQUFXLDRCQUdYLE9BSHVDRixlQUNsQywyREFDQSxnREFDTDtrQ0FFRCw0RUFBQ0M7NEJBQUlDLFdBQVU7c0NBQW1DSCxRQUFRTSxPQUFPOzs7Ozs7Ozs7OztrQ0FFckUsOERBQUNKO3dCQUFJQyxXQUFVO2tDQUNWLElBQUlJLEtBQUtQLFFBQVFRLFVBQVUsR0FBRyxNQUFNQyxrQkFBa0IsQ0FBQyxFQUFFLEVBQUU7NEJBQ3hEQyxNQUFNOzRCQUNOQyxRQUFRO3dCQUNaOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLcEI7S0F2QmdCWiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL3NyYy9jb21wb25lbnRzL2NoYXQvQ2hhdE1lc3NhZ2UudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vc3RyRXZlbnQgfSBmcm9tIFwiQC90eXBlcy9ub3N0clwiO1xuXG5pbnRlcmZhY2UgQ2hhdE1lc3NhZ2VQcm9wcyB7XG4gICAgbWVzc2FnZTogTm9zdHJFdmVudDtcbiAgICBpc093bk1lc3NhZ2U6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDaGF0TWVzc2FnZSh7IG1lc3NhZ2UsIGlzT3duTWVzc2FnZSB9OiBDaGF0TWVzc2FnZVByb3BzKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Bncm91cCBmbGV4IGl0ZW1zLXN0YXJ0IGdhcC0zICR7aXNPd25NZXNzYWdlID8gJ2ZsZXgtcm93LXJldmVyc2UnIDogJyd9YH0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctOCBoLTggcm91bmRlZC1mdWxsIGJnLXdoaXRlLzUgYm9yZGVyIGJvcmRlci13aGl0ZS8xMCBmbGV4LXNocmluay0wIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHRleHQteHMgdGV4dC1ibHVlLTMwMFwiPlxuICAgICAgICAgICAgICAgIHttZXNzYWdlLnB1YmtleS5zbGljZSgwLCAyKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2BmbGV4LTEgcmVsYXRpdmUgJHtpc093bk1lc3NhZ2UgPyAndGV4dC1yaWdodCcgOiAnJ31gfT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YGlubGluZS1ibG9jayBtYXgtdy1bODAlXSAke2lzT3duTWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnYmctYmx1ZS01MDAvMjAgdGV4dC1ibHVlLTEwMCBib3JkZXIgYm9yZGVyLWJsdWUtNTAwLzIwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAnYmctd2hpdGUvNSB0ZXh0LXdoaXRlIGJvcmRlciBib3JkZXItd2hpdGUvMTAnXG4gICAgICAgICAgICAgICAgICAgIH0gcm91bmRlZC0yeGwgcHgtNCBweS0yIHRleHQtc20gYmFja2Ryb3AtYmx1ci1zbWB9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIndoaXRlc3BhY2UtcHJlLWxpbmUgYnJlYWstd29yZHNcIj57bWVzc2FnZS5jb250ZW50fTwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtMSB0ZXh0LXhzIHRleHQtZ3JheS01MDBcIj5cbiAgICAgICAgICAgICAgICAgICAge25ldyBEYXRlKG1lc3NhZ2UuY3JlYXRlZF9hdCAqIDEwMDApLnRvTG9jYWxlVGltZVN0cmluZyhbXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG91cjogJzItZGlnaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlOiAnMi1kaWdpdCdcbiAgICAgICAgICAgICAgICAgICAgfSl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn1cbiJdLCJuYW1lcyI6WyJDaGF0TWVzc2FnZSIsIm1lc3NhZ2UiLCJpc093bk1lc3NhZ2UiLCJkaXYiLCJjbGFzc05hbWUiLCJwdWJrZXkiLCJzbGljZSIsImNvbnRlbnQiLCJEYXRlIiwiY3JlYXRlZF9hdCIsInRvTG9jYWxlVGltZVN0cmluZyIsImhvdXIiLCJtaW51dGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/chat/ChatMessage.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/feed/Post.tsx":
/*!**************************************!*\
  !*** ./src/components/feed/Post.tsx ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Post: () => (/* binding */ Post)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _app_page__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/app/page */ \"(app-pages-browser)/./src/app/page.tsx\");\n/* harmony import */ var _components_shared_BitcoinTicker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/shared/BitcoinTicker */ \"(app-pages-browser)/./src/components/shared/BitcoinTicker.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\n// Map of common financial symbols to asset details\nconst assetMap = {\n    // Cryptocurrencies\n    '$BTC': {\n        assetId: 'bitcoin',\n        assetType: 'crypto',\n        symbol: '$BTC'\n    },\n    '$ETH': {\n        assetId: 'ethereum',\n        assetType: 'crypto',\n        symbol: '$ETH'\n    },\n    '$XRP': {\n        assetId: 'ripple',\n        assetType: 'crypto',\n        symbol: '$XRP'\n    },\n    // Stocks\n    '$AAPL': {\n        assetId: 'aapl',\n        assetType: 'stock',\n        symbol: '$AAPL'\n    },\n    '$TSLA': {\n        assetId: 'tsla',\n        assetType: 'stock',\n        symbol: '$TSLA'\n    },\n    '$GOOGL': {\n        assetId: 'googl',\n        assetType: 'stock',\n        symbol: '$GOOGL'\n    },\n    // Forex\n    'USD/EUR': {\n        assetId: 'usd-eur',\n        assetType: 'forex',\n        symbol: 'USD/EUR'\n    },\n    'EUR/USD': {\n        assetId: 'eur-usd',\n        assetType: 'forex',\n        symbol: 'EUR/USD'\n    }\n};\nfunction Post(param) {\n    let { event, onChatOpen, onChatClose, isChatActive, isAnimating, chatCount } = param;\n    var _event_profile, _event_profile1, _event_profile2;\n    _s();\n    const [financialAssets, setFinancialAssets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Function to detect financial assets in content\n    const detectFinancialAssets = (content)=>{\n        const assets = [];\n        // Match $SYMBOL or #SYMBOL or forex pairs\n        const regex = /[$#][A-Z]+|(?:USD|EUR|GBP|JPY)\\/(?:USD|EUR|GBP|JPY)/g;\n        const matches = content.match(regex) || [];\n        matches.forEach((symbol)=>{\n            // Normalize to $SYMBOL for assetMap lookup\n            let lookup = symbol;\n            if (symbol.startsWith('#')) lookup = '$' + symbol.slice(1);\n            if (assetMap[lookup] && !assets.some((asset)=>asset.symbol === lookup)) {\n                assets.push(assetMap[lookup]);\n            }\n        });\n        return assets;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"Post.useEffect\": ()=>{\n            // Detect financial assets in the post content\n            const detectedAssets = detectFinancialAssets(event.content);\n            setFinancialAssets(detectedAssets);\n        }\n    }[\"Post.useEffect\"], [\n        event.content\n    ]);\n    function renderPostContent(content) {\n        const financialSymbolRegex = /\\$(\\w+)/g; // Matches $SYMBOL\n        const matches = content.match(financialSymbolRegex);\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: [\n                matches && matches.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"mb-2\",\n                    children: matches.map((symbol, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_shared_BitcoinTicker__WEBPACK_IMPORTED_MODULE_3__.FinancialTicker, {\n                            assetId: symbol.slice(1).toLowerCase(),\n                            assetType: \"crypto\" // Default to crypto; can be extended to detect other types\n                            ,\n                            symbol: symbol,\n                            className: \"mb-2\"\n                        }, index, false, {\n                            fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                            lineNumber: 73,\n                            columnNumber: 29\n                        }, this))\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                    lineNumber: 71,\n                    columnNumber: 21\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    children: content\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                    lineNumber: 83,\n                    columnNumber: 17\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n            lineNumber: 69,\n            columnNumber: 13\n        }, this);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative bg-transparent backdrop-blur-md rounded-xl border border-white/10 overflow-hidden w-full max-w-xl mx-auto\",\n        children: [\n            financialAssets.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-3 left-3 z-20 flex flex-col gap-2 pointer-events-none\",\n                children: financialAssets.map((asset, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_shared_BitcoinTicker__WEBPACK_IMPORTED_MODULE_3__.FinancialTicker, {\n                        assetId: asset.assetId,\n                        assetType: asset.assetType,\n                        currency: \"usd\",\n                        decimals: asset.assetType === 'forex' ? 4 : 2,\n                        showVolume: false,\n                        showMarketCap: false,\n                        className: \"w-32 sm:w-40 shadow-lg border-2 border-yellow-400/40 bg-black/80 opacity-90 rounded-lg\",\n                        symbol: asset.symbol\n                    }, \"\".concat(asset.assetId, \"-\").concat(index), false, {\n                        fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                        lineNumber: 94,\n                        columnNumber: 25\n                    }, this))\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                lineNumber: 92,\n                columnNumber: 17\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"p-4 sm:p-6\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex items-start gap-3 sm:gap-4\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"w-10 h-10 sm:w-12 sm:h-12 rounded-full bg-white/5 border border-white/10 flex-shrink-0\",\n                                children: ((_event_profile = event.profile) === null || _event_profile === void 0 ? void 0 : _event_profile.picture) ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                    src: event.profile.picture,\n                                    alt: \"\",\n                                    className: \"w-full h-full rounded-full object-cover\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                    lineNumber: 114,\n                                    columnNumber: 29\n                                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"w-full h-full flex items-center justify-center text-blue-300 text-sm\",\n                                    children: event.pubkey.slice(0, 2)\n                                }, void 0, false, {\n                                    fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                    lineNumber: 116,\n                                    columnNumber: 29\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                lineNumber: 112,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex-1 min-w-0\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"flex items-center gap-2 mb-1\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"font-medium truncate\",\n                                                children: ((_event_profile1 = event.profile) === null || _event_profile1 === void 0 ? void 0 : _event_profile1.displayName) || ((_event_profile2 = event.profile) === null || _event_profile2 === void 0 ? void 0 : _event_profile2.username) || \"\".concat(event.pubkey.slice(0, 6), \"...\").concat(event.pubkey.slice(-4))\n                                            }, void 0, false, {\n                                                fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                                lineNumber: 125,\n                                                columnNumber: 29\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                className: \"text-gray-500 text-sm\",\n                                                children: new Date(event.created_at * 1000).toLocaleTimeString()\n                                            }, void 0, false, {\n                                                fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                                lineNumber: 128,\n                                                columnNumber: 29\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                        lineNumber: 124,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"whitespace-pre-line break-words text-gray-100\",\n                                        children: (0,_app_page__WEBPACK_IMPORTED_MODULE_2__.formatNostrAddresses)(event.content)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                        lineNumber: 132,\n                                        columnNumber: 25\n                                    }, this),\n                                    event.media && event.media.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mt-4 grid grid-cols-1 sm:grid-cols-2 gap-2\",\n                                        children: event.media.map((url, i)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                                src: url,\n                                                alt: \"\",\n                                                className: \"rounded-lg w-full h-48 object-cover\"\n                                            }, i, false, {\n                                                fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                                lineNumber: 140,\n                                                columnNumber: 37\n                                            }, this))\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                        lineNumber: 138,\n                                        columnNumber: 29\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                lineNumber: 123,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                        lineNumber: 110,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mt-4 flex items-center gap-4 sm:gap-6 text-sm\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex items-center gap-2 hover:text-blue-400 cursor-pointer transition\",\n                                onClick: ()=>isChatActive ? onChatClose(event.id) : onChatOpen(event.id),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: \"\\uD83D\\uDCAC\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                        lineNumber: 158,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: [\n                                            \"Chat\",\n                                            chatCount > 0 ? \" (\".concat(chatCount, \")\") : ''\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                        lineNumber: 159,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                lineNumber: 154,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex items-center gap-2 hover:text-pink-400 cursor-pointer transition\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: \"❤️\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                        lineNumber: 162,\n                                        columnNumber: 25\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: \"Like\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                        lineNumber: 163,\n                                        columnNumber: 25\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                                lineNumber: 161,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                        lineNumber: 153,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n                lineNumber: 109,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/components/feed/Post.tsx\",\n        lineNumber: 89,\n        columnNumber: 9\n    }, this);\n}\n_s(Post, \"63ce1j44nmeIYnQfYtua1FgBE2c=\");\n_c = Post;\nvar _c;\n$RefreshReg$(_c, \"Post\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2ZlZWQvUG9zdC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBNEM7QUFHTTtBQUNrQjtBQWdCcEUsbURBQW1EO0FBQ25ELE1BQU1JLFdBQTJDO0lBQzdDLG1CQUFtQjtJQUNuQixRQUFRO1FBQUVDLFNBQVM7UUFBV0MsV0FBVztRQUFVQyxRQUFRO0lBQU87SUFDbEUsUUFBUTtRQUFFRixTQUFTO1FBQVlDLFdBQVc7UUFBVUMsUUFBUTtJQUFPO0lBQ25FLFFBQVE7UUFBRUYsU0FBUztRQUFVQyxXQUFXO1FBQVVDLFFBQVE7SUFBTztJQUNqRSxTQUFTO0lBQ1QsU0FBUztRQUFFRixTQUFTO1FBQVFDLFdBQVc7UUFBU0MsUUFBUTtJQUFRO0lBQ2hFLFNBQVM7UUFBRUYsU0FBUztRQUFRQyxXQUFXO1FBQVNDLFFBQVE7SUFBUTtJQUNoRSxVQUFVO1FBQUVGLFNBQVM7UUFBU0MsV0FBVztRQUFTQyxRQUFRO0lBQVM7SUFDbkUsUUFBUTtJQUNSLFdBQVc7UUFBRUYsU0FBUztRQUFXQyxXQUFXO1FBQVNDLFFBQVE7SUFBVTtJQUN2RSxXQUFXO1FBQUVGLFNBQVM7UUFBV0MsV0FBVztRQUFTQyxRQUFRO0lBQVU7QUFDM0U7QUFFTyxTQUFTQyxLQUFLLEtBQW1GO1FBQW5GLEVBQUVDLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxTQUFTLEVBQWEsR0FBbkY7UUE2RUlMLGdCQWFRQSxpQkFBOEJBOztJQXpGM0QsTUFBTSxDQUFDTSxpQkFBaUJDLG1CQUFtQixHQUFHZiwrQ0FBUUEsQ0FBbUIsRUFBRTtJQUUzRSxpREFBaUQ7SUFDakQsTUFBTWdCLHdCQUF3QixDQUFDQztRQUMzQixNQUFNQyxTQUEyQixFQUFFO1FBQ25DLDBDQUEwQztRQUMxQyxNQUFNQyxRQUFRO1FBQ2QsTUFBTUMsVUFBVUgsUUFBUUksS0FBSyxDQUFDRixVQUFVLEVBQUU7UUFF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TUFBTTZDLFVBQVUsR0FBRyxNQUFNQyxrQkFBa0I7Ozs7Ozs7Ozs7OztrREFHN0QsOERBQUN0Qjt3Q0FBSUUsV0FBVTtrREFDVmpDLCtEQUFvQkEsQ0FBQ08sTUFBTVMsT0FBTzs7Ozs7O29DQUl0Q1QsTUFBTStDLEtBQUssSUFBSS9DLE1BQU0rQyxLQUFLLENBQUN0QixNQUFNLEdBQUcsbUJBQ2pDLDhEQUFDRDt3Q0FBSUUsV0FBVTtrREFDVjFCLE1BQU0rQyxLQUFLLENBQUNwQixHQUFHLENBQUMsQ0FBQ3FCLEtBQUtDLGtCQUNuQiw4REFBQ1o7Z0RBRUdDLEtBQUtVO2dEQUNMVCxLQUFJO2dEQUNKYixXQUFVOytDQUhMdUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBWTdCLDhEQUFDekI7d0JBQUlFLFdBQVU7OzBDQUNYLDhEQUFDRjtnQ0FDR0UsV0FBVTtnQ0FDVndCLFNBQVMsSUFBTy9DLGVBQWVELFlBQVlGLE1BQU1tRCxFQUFFLElBQUlsRCxXQUFXRCxNQUFNbUQsRUFBRTs7a0RBRTFFLDhEQUFDVjtrREFBSzs7Ozs7O2tEQUNOLDhEQUFDQTs7NENBQUs7NENBQUtwQyxZQUFZLElBQUksS0FBZSxPQUFWQSxXQUFVLE9BQUs7Ozs7Ozs7Ozs7Ozs7MENBRW5ELDhEQUFDbUI7Z0NBQUlFLFdBQVU7O2tEQUNYLDhEQUFDZTtrREFBSzs7Ozs7O2tEQUNOLDhEQUFDQTtrREFBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTTlCO0dBcklnQjFDO0tBQUFBIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvc3JjL2NvbXBvbmVudHMvZmVlZC9Qb3N0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJztcbmltcG9ydCB7IE5vc3RyRXZlbnQgfSBmcm9tICdAL3R5cGVzL25vc3RyJztcbmltcG9ydCB7IGZvcm1hdE5vc3RyQWRkcmVzc2VzIH0gZnJvbSAnQC9hcHAvcGFnZSc7XG5pbXBvcnQgeyBGaW5hbmNpYWxUaWNrZXIgfSBmcm9tIFwiQC9jb21wb25lbnRzL3NoYXJlZC9CaXRjb2luVGlja2VyXCI7XG5pbnRlcmZhY2UgUG9zdFByb3BzIHtcbiAgICBldmVudDogTm9zdHJFdmVudDtcbiAgICBvbkNoYXRPcGVuOiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgICBvbkNoYXRDbG9zZTogKGlkOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgaXNDaGF0QWN0aXZlOiBib29sZWFuO1xuICAgIGlzQW5pbWF0aW5nOiBib29sZWFuO1xuICAgIGNoYXRDb3VudDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgRmluYW5jaWFsQXNzZXQge1xuICAgIGFzc2V0SWQ6IHN0cmluZztcbiAgICBhc3NldFR5cGU6ICdjcnlwdG8nIHwgJ3N0b2NrJyB8ICdmb3JleCc7XG4gICAgc3ltYm9sOiBzdHJpbmc7XG59XG5cbi8vIE1hcCBvZiBjb21tb24gZmluYW5jaWFsIHN5bWJvbHMgdG8gYXNzZXQgZGV0YWlsc1xuY29uc3QgYXNzZXRNYXA6IFJlY29yZDxzdHJpbmcsIEZpbmFuY2lhbEFzc2V0PiA9IHtcbiAgICAvLyBDcnlwdG9jdXJyZW5jaWVzXG4gICAgJyRCVEMnOiB7IGFzc2V0SWQ6ICdiaXRjb2luJywgYXNzZXRUeXBlOiAnY3J5cHRvJywgc3ltYm9sOiAnJEJUQycgfSxcbiAgICAnJEVUSCc6IHsgYXNzZXRJZDogJ2V0aGVyZXVtJywgYXNzZXRUeXBlOiAnY3J5cHRvJywgc3ltYm9sOiAnJEVUSCcgfSxcbiAgICAnJFhSUCc6IHsgYXNzZXRJZDogJ3JpcHBsZScsIGFzc2V0VHlwZTogJ2NyeXB0bycsIHN5bWJvbDogJyRYUlAnIH0sXG4gICAgLy8gU3RvY2tzXG4gICAgJyRBQVBMJzogeyBhc3NldElkOiAnYWFwbCcsIGFzc2V0VHlwZTogJ3N0b2NrJywgc3ltYm9sOiAnJEFBUEwnIH0sXG4gICAgJyRUU0xBJzogeyBhc3NldElkOiAndHNsYScsIGFzc2V0VHlwZTogJ3N0b2NrJywgc3ltYm9sOiAnJFRTTEEnIH0sXG4gICAgJyRHT09HTCc6IHsgYXNzZXRJZDogJ2dvb2dsJywgYXNzZXRUeXBlOiAnc3RvY2snLCBzeW1ib2w6ICckR09PR0wnIH0sXG4gICAgLy8gRm9yZXhcbiAgICAnVVNEL0VVUic6IHsgYXNzZXRJZDogJ3VzZC1ldXInLCBhc3NldFR5cGU6ICdmb3JleCcsIHN5bWJvbDogJ1VTRC9FVVInIH0sXG4gICAgJ0VVUi9VU0QnOiB7IGFzc2V0SWQ6ICdldXItdXNkJywgYXNzZXRUeXBlOiAnZm9yZXgnLCBzeW1ib2w6ICdFVVIvVVNEJyB9LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIFBvc3QoeyBldmVudCwgb25DaGF0T3Blbiwgb25DaGF0Q2xvc2UsIGlzQ2hhdEFjdGl2ZSwgaXNBbmltYXRpbmcsIGNoYXRDb3VudCB9OiBQb3N0UHJvcHMpIHtcbiAgICBjb25zdCBbZmluYW5jaWFsQXNzZXRzLCBzZXRGaW5hbmNpYWxBc3NldHNdID0gdXNlU3RhdGU8RmluYW5jaWFsQXNzZXRbXT4oW10pO1xuXG4gICAgLy8gRnVuY3Rpb24gdG8gZGV0ZWN0IGZpbmFuY2lhbCBhc3NldHMgaW4gY29udGVudFxuICAgIGNvbnN0IGRldGVjdEZpbmFuY2lhbEFzc2V0cyA9IChjb250ZW50OiBzdHJpbmcpOiBGaW5hbmNpYWxBc3NldFtdID0+IHtcbiAgICAgICAgY29uc3QgYXNzZXRzOiBGaW5hbmNpYWxBc3NldFtdID0gW107XG4gICAgICAgIC8vIE1hdGNoICRTWU1CT0wgb3IgI1NZTUJPTCBvciBmb3JleCBwYWlyc1xuICAgICAgICBjb25zdCByZWdleCA9IC9bJCNdW0EtWl0rfCg/OlVTRHxFVVJ8R0JQfEpQWSlcXC8oPzpVU0R8RVVSfEdCUHxKUFkpL2c7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoKHJlZ2V4KSB8fCBbXTtcblxuICAgICAgICBtYXRjaGVzLmZvckVhY2goKHN5bWJvbCkgPT4ge1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvICRTWU1CT0wgZm9yIGFzc2V0TWFwIGxvb2t1cFxuICAgICAgICAgICAgbGV0IGxvb2t1cCA9IHN5bWJvbDtcbiAgICAgICAgICAgIGlmIChzeW1ib2wuc3RhcnRzV2l0aCgnIycpKSBsb29rdXAgPSAnJCcgKyBzeW1ib2wuc2xpY2UoMSk7XG4gICAgICAgICAgICBpZiAoYXNzZXRNYXBbbG9va3VwXSAmJiAhYXNzZXRzLnNvbWUoKGFzc2V0KSA9PiBhc3NldC5zeW1ib2wgPT09IGxvb2t1cCkpIHtcbiAgICAgICAgICAgICAgICBhc3NldHMucHVzaChhc3NldE1hcFtsb29rdXBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFzc2V0cztcbiAgICB9O1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gRGV0ZWN0IGZpbmFuY2lhbCBhc3NldHMgaW4gdGhlIHBvc3QgY29udGVudFxuICAgICAgICBjb25zdCBkZXRlY3RlZEFzc2V0cyA9IGRldGVjdEZpbmFuY2lhbEFzc2V0cyhldmVudC5jb250ZW50KTtcbiAgICAgICAgc2V0RmluYW5jaWFsQXNzZXRzKGRldGVjdGVkQXNzZXRzKTtcbiAgICB9LCBbZXZlbnQuY29udGVudF0pO1xuXG4gICAgZnVuY3Rpb24gcmVuZGVyUG9zdENvbnRlbnQoY29udGVudDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGZpbmFuY2lhbFN5bWJvbFJlZ2V4ID0gL1xcJChcXHcrKS9nOyAvLyBNYXRjaGVzICRTWU1CT0xcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2goZmluYW5jaWFsU3ltYm9sUmVnZXgpO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIHttYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWItMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAge21hdGNoZXMubWFwKChzeW1ib2wsIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPEZpbmFuY2lhbFRpY2tlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NldElkPXtzeW1ib2wuc2xpY2UoMSkudG9Mb3dlckNhc2UoKX0gLy8gUmVtb3ZlICQgYW5kIGNvbnZlcnQgdG8gbG93ZXJjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2V0VHlwZT1cImNyeXB0b1wiIC8vIERlZmF1bHQgdG8gY3J5cHRvOyBjYW4gYmUgZXh0ZW5kZWQgdG8gZGV0ZWN0IG90aGVyIHR5cGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbD17c3ltYm9sfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJtYi0yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPHA+e2NvbnRlbnR9PC9wPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZWxhdGl2ZSBiZy10cmFuc3BhcmVudCBiYWNrZHJvcC1ibHVyLW1kIHJvdW5kZWQteGwgYm9yZGVyIGJvcmRlci13aGl0ZS8xMCBvdmVyZmxvdy1oaWRkZW4gdy1mdWxsIG1heC13LXhsIG14LWF1dG9cIj5cbiAgICAgICAgICAgIHsvKiBGaW5hbmNpYWwgVGlja2VyKHMpIC0gc2hvdyBjb21wYWN0LCBzdWJ0bGUsIGFuZCB2aXN1YWxseSBkaXN0aW5jdCBhdCB0b3AgbGVmdCBpZiBwcmVzZW50ICovfVxuICAgICAgICAgICAge2ZpbmFuY2lhbEFzc2V0cy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC0zIGxlZnQtMyB6LTIwIGZsZXggZmxleC1jb2wgZ2FwLTIgcG9pbnRlci1ldmVudHMtbm9uZVwiPlxuICAgICAgICAgICAgICAgICAgICB7ZmluYW5jaWFsQXNzZXRzLm1hcCgoYXNzZXQsIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8RmluYW5jaWFsVGlja2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtgJHthc3NldC5hc3NldElkfS0ke2luZGV4fWB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXRJZD17YXNzZXQuYXNzZXRJZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NldFR5cGU9e2Fzc2V0LmFzc2V0VHlwZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeT1cInVzZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM9e2Fzc2V0LmFzc2V0VHlwZSA9PT0gJ2ZvcmV4JyA/IDQgOiAyfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dWb2x1bWU9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dNYXJrZXRDYXA9e2ZhbHNlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctMzIgc206dy00MCBzaGFkb3ctbGcgYm9yZGVyLTIgYm9yZGVyLXllbGxvdy00MDAvNDAgYmctYmxhY2svODAgb3BhY2l0eS05MCByb3VuZGVkLWxnXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2w9e2Fzc2V0LnN5bWJvbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwLTQgc206cC02XCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLXN0YXJ0IGdhcC0zIHNtOmdhcC00XCI+XG4gICAgICAgICAgICAgICAgICAgIHsvKiBQcm9maWxlIFBpY3R1cmUgKi99XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy0xMCBoLTEwIHNtOnctMTIgc206aC0xMiByb3VuZGVkLWZ1bGwgYmctd2hpdGUvNSBib3JkZXIgYm9yZGVyLXdoaXRlLzEwIGZsZXgtc2hyaW5rLTBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtldmVudC5wcm9maWxlPy5waWN0dXJlID8gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtldmVudC5wcm9maWxlLnBpY3R1cmV9IGFsdD1cIlwiIGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgcm91bmRlZC1mdWxsIG9iamVjdC1jb3ZlclwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciB0ZXh0LWJsdWUtMzAwIHRleHQtc21cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2V2ZW50LnB1YmtleS5zbGljZSgwLCAyKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgIHsvKiBDb250ZW50ICovfVxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgtMSBtaW4tdy0wXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0yIG1iLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJmb250LW1lZGl1bSB0cnVuY2F0ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZXZlbnQucHJvZmlsZT8uZGlzcGxheU5hbWUgfHwgZXZlbnQucHJvZmlsZT8udXNlcm5hbWUgfHwgYCR7ZXZlbnQucHVia2V5LnNsaWNlKDAsIDYpfS4uLiR7ZXZlbnQucHVia2V5LnNsaWNlKC00KX1gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNTAwIHRleHQtc21cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25ldyBEYXRlKGV2ZW50LmNyZWF0ZWRfYXQgKiAxMDAwKS50b0xvY2FsZVRpbWVTdHJpbmcoKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2hpdGVzcGFjZS1wcmUtbGluZSBicmVhay13b3JkcyB0ZXh0LWdyYXktMTAwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2Zvcm1hdE5vc3RyQWRkcmVzc2VzKGV2ZW50LmNvbnRlbnQpfVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHsvKiBNZWRpYSAqL31cbiAgICAgICAgICAgICAgICAgICAgICAgIHtldmVudC5tZWRpYSAmJiBldmVudC5tZWRpYS5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgZ3JpZCBncmlkLWNvbHMtMSBzbTpncmlkLWNvbHMtMiBnYXAtMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZXZlbnQubWVkaWEubWFwKCh1cmwsIGkpID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2l9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjPXt1cmx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0PVwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyb3VuZGVkLWxnIHctZnVsbCBoLTQ4IG9iamVjdC1jb3ZlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgey8qIEFjdGlvbnMgKi99XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00IGZsZXggaXRlbXMtY2VudGVyIGdhcC00IHNtOmdhcC02IHRleHQtc21cIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgaG92ZXI6dGV4dC1ibHVlLTQwMCBjdXJzb3ItcG9pbnRlciB0cmFuc2l0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IChpc0NoYXRBY3RpdmUgPyBvbkNoYXRDbG9zZShldmVudC5pZCkgOiBvbkNoYXRPcGVuKGV2ZW50LmlkKSl9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPvCfkqw8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj5DaGF0e2NoYXRDb3VudCA+IDAgPyBgICgke2NoYXRDb3VudH0pYCA6ICcnfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgaG92ZXI6dGV4dC1waW5rLTQwMCBjdXJzb3ItcG9pbnRlciB0cmFuc2l0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj7inaTvuI88L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj5MaWtlPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsImZvcm1hdE5vc3RyQWRkcmVzc2VzIiwiRmluYW5jaWFsVGlja2VyIiwiYXNzZXRNYXAiLCJhc3NldElkIiwiYXNzZXRUeXBlIiwic3ltYm9sIiwiUG9zdCIsImV2ZW50Iiwib25DaGF0T3BlbiIsIm9uQ2hhdENsb3NlIiwiaXNDaGF0QWN0aXZlIiwiaXNBbmltYXRpbmciLCJjaGF0Q291bnQiLCJmaW5hbmNpYWxBc3NldHMiLCJzZXRGaW5hbmNpYWxBc3NldHMiLCJkZXRlY3RGaW5hbmNpYWxBc3NldHMiLCJjb250ZW50IiwiYXNzZXRzIiwicmVnZXgiLCJtYXRjaGVzIiwibWF0Y2giLCJmb3JFYWNoIiwibG9va3VwIiwic3RhcnRzV2l0aCIsInNsaWNlIiwic29tZSIsImFzc2V0IiwicHVzaCIsImRldGVjdGVkQXNzZXRzIiwicmVuZGVyUG9zdENvbnRlbnQiLCJmaW5hbmNpYWxTeW1ib2xSZWdleCIsImRpdiIsImxlbmd0aCIsImNsYXNzTmFtZSIsIm1hcCIsImluZGV4IiwidG9Mb3dlckNhc2UiLCJwIiwiY3VycmVuY3kiLCJkZWNpbWFscyIsInNob3dWb2x1bWUiLCJzaG93TWFya2V0Q2FwIiwicHJvZmlsZSIsInBpY3R1cmUiLCJpbWciLCJzcmMiLCJhbHQiLCJwdWJrZXkiLCJzcGFuIiwiZGlzcGxheU5hbWUiLCJ1c2VybmFtZSIsIkRhdGUiLCJjcmVhdGVkX2F0IiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwibWVkaWEiLCJ1cmwiLCJpIiwib25DbGljayIsImlkIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/feed/Post.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/layout/RightSidebar.tsx":
/*!************************************************!*\
  !*** ./src/components/layout/RightSidebar.tsx ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RightSidebar)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _StatsDisplay__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../StatsDisplay */ \"(app-pages-browser)/./src/components/StatsDisplay.tsx\");\n// filepath: src/components/layout/RightSidebar.tsx\n\n\nfunction RightSidebar(param) {\n    let { trendingHashtags, searchHashtag } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"aside\", {\n        className: \"hidden xl:flex flex-col w-[320px] h-screen sticky top-0 right-0 z-30 border-l border-gray-800 bg-gray-950 px-6 py-8 gap-6\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_StatsDisplay__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/layout/RightSidebar.tsx\",\n                lineNumber: 12,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        className: \"text-lg font-bold mb-2 text-white\",\n                        children: \"Trending Hashtags\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/components/layout/RightSidebar.tsx\",\n                        lineNumber: 14,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex flex-wrap gap-2\",\n                        children: trendingHashtags.map((param)=>{\n                            let [tag, count] = param;\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                className: \"bg-gray-800 text-pink-400 px-3 py-1 rounded-full text-sm font-medium hover:bg-pink-600 transition\",\n                                onClick: ()=>searchHashtag(tag),\n                                children: [\n                                    \"#\",\n                                    tag,\n                                    \" \",\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"ml-1 text-xs text-gray-400\",\n                                        children: count\n                                    }, void 0, false, {\n                                        fileName: \"/Users/scarnes/workspace/src/components/layout/RightSidebar.tsx\",\n                                        lineNumber: 22,\n                                        columnNumber: 36\n                                    }, this)\n                                ]\n                            }, tag, true, {\n                                fileName: \"/Users/scarnes/workspace/src/components/layout/RightSidebar.tsx\",\n                                lineNumber: 17,\n                                columnNumber: 25\n                            }, this);\n                        })\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/components/layout/RightSidebar.tsx\",\n                        lineNumber: 15,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/components/layout/RightSidebar.tsx\",\n                lineNumber: 13,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/components/layout/RightSidebar.tsx\",\n        lineNumber: 11,\n        columnNumber: 9\n    }, this);\n}\n_c = RightSidebar;\nvar _c;\n$RefreshReg$(_c, \"RightSidebar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xheW91dC9SaWdodFNpZGViYXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLG1EQUFtRDs7QUFDUjtBQU81QixTQUFTQyxhQUFhLEtBQXNEO1FBQXRELEVBQUVDLGdCQUFnQixFQUFFQyxhQUFhLEVBQXFCLEdBQXREO0lBQ2pDLHFCQUNJLDhEQUFDQztRQUFNQyxXQUFVOzswQkFDYiw4REFBQ0wscURBQVlBOzs7OzswQkFDYiw4REFBQ007O2tDQUNHLDhEQUFDQzt3QkFBR0YsV0FBVTtrQ0FBb0M7Ozs7OztrQ0FDbEQsOERBQUNDO3dCQUFJRCxXQUFVO2tDQUNWSCxpQkFBaUJNLEdBQUcsQ0FBQztnQ0FBQyxDQUFDQyxLQUFLQyxNQUFNO2lEQUMvQiw4REFBQ0M7Z0NBRUdOLFdBQVU7Z0NBQ1ZPLFNBQVMsSUFBTVQsY0FBY007O29DQUNoQztvQ0FDS0E7b0NBQUk7a0RBQUMsOERBQUNJO3dDQUFLUixXQUFVO2tEQUE4Qks7Ozs7Ozs7K0JBSmhERDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXakM7S0FwQndCUiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL3NyYy9jb21wb25lbnRzL2xheW91dC9SaWdodFNpZGViYXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZpbGVwYXRoOiBzcmMvY29tcG9uZW50cy9sYXlvdXQvUmlnaHRTaWRlYmFyLnRzeFxuaW1wb3J0IFN0YXRzRGlzcGxheSBmcm9tIFwiLi4vU3RhdHNEaXNwbGF5XCI7XG5cbmludGVyZmFjZSBSaWdodFNpZGViYXJQcm9wcyB7XG4gICAgdHJlbmRpbmdIYXNodGFnczogW3N0cmluZywgbnVtYmVyXVtdO1xuICAgIHNlYXJjaEhhc2h0YWc6ICh0YWc6IHN0cmluZykgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUmlnaHRTaWRlYmFyKHsgdHJlbmRpbmdIYXNodGFncywgc2VhcmNoSGFzaHRhZyB9OiBSaWdodFNpZGViYXJQcm9wcykge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxhc2lkZSBjbGFzc05hbWU9XCJoaWRkZW4geGw6ZmxleCBmbGV4LWNvbCB3LVszMjBweF0gaC1zY3JlZW4gc3RpY2t5IHRvcC0wIHJpZ2h0LTAgei0zMCBib3JkZXItbCBib3JkZXItZ3JheS04MDAgYmctZ3JheS05NTAgcHgtNiBweS04IGdhcC02XCI+XG4gICAgICAgICAgICA8U3RhdHNEaXNwbGF5IC8+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yIHRleHQtd2hpdGVcIj5UcmVuZGluZyBIYXNodGFnczwvaDM+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtd3JhcCBnYXAtMlwiPlxuICAgICAgICAgICAgICAgICAgICB7dHJlbmRpbmdIYXNodGFncy5tYXAoKFt0YWcsIGNvdW50XSkgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17dGFnfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJnLWdyYXktODAwIHRleHQtcGluay00MDAgcHgtMyBweS0xIHJvdW5kZWQtZnVsbCB0ZXh0LXNtIGZvbnQtbWVkaXVtIGhvdmVyOmJnLXBpbmstNjAwIHRyYW5zaXRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNlYXJjaEhhc2h0YWcodGFnKX1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAje3RhZ30gPHNwYW4gY2xhc3NOYW1lPVwibWwtMSB0ZXh0LXhzIHRleHQtZ3JheS00MDBcIj57Y291bnR9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvYXNpZGU+XG4gICAgKTtcbn1cbiJdLCJuYW1lcyI6WyJTdGF0c0Rpc3BsYXkiLCJSaWdodFNpZGViYXIiLCJ0cmVuZGluZ0hhc2h0YWdzIiwic2VhcmNoSGFzaHRhZyIsImFzaWRlIiwiY2xhc3NOYW1lIiwiZGl2IiwiaDMiLCJtYXAiLCJ0YWciLCJjb3VudCIsImJ1dHRvbiIsIm9uQ2xpY2siLCJzcGFuIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/layout/RightSidebar.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/layout/Sidebar.tsx":
/*!*******************************************!*\
  !*** ./src/components/layout/Sidebar.tsx ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Sidebar)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _hooks_useNostr__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/hooks/useNostr */ \"(app-pages-browser)/./src/hooks/useNostr.ts\");\n\nvar _s = $RefreshSig$();\n\n\nconst navItems = [\n    {\n        key: \"feed\",\n        label: \"Feed\",\n        href: \"/\"\n    },\n    {\n        key: \"explore\",\n        label: \"Explore\",\n        href: \"/explore\"\n    },\n    {\n        key: \"wallet\",\n        label: \"Wallet\",\n        href: \"/wallet\"\n    },\n    {\n        key: \"community\",\n        label: \"Community\",\n        href: \"/community\"\n    },\n    {\n        key: \"games\",\n        label: \"Games\",\n        href: \"/games\"\n    },\n    {\n        key: \"notifications\",\n        label: \"Notifications\",\n        href: \"/notifications\"\n    },\n    {\n        key: \"chat\",\n        label: \"Chat\",\n        href: \"/chat\"\n    }\n];\nfunction Sidebar(param) {\n    let { onNav, activePane } = param;\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_1__.useRouter)();\n    const { pubkey, profile } = (0,_hooks_useNostr__WEBPACK_IMPORTED_MODULE_2__.useNostr)();\n    // Fallbacks for avatar and username\n    const avatar = (profile === null || profile === void 0 ? void 0 : profile.picture) || \"/file.svg\";\n    // Use display_name for display, username for handle\n    const displayName = (profile === null || profile === void 0 ? void 0 : profile.display_name) || (profile === null || profile === void 0 ? void 0 : profile.username) || ((profile === null || profile === void 0 ? void 0 : profile.pubkey) ? profile.pubkey.slice(0, 8) + \"...\" : \"\");\n    const username = (profile === null || profile === void 0 ? void 0 : profile.username) || ((profile === null || profile === void 0 ? void 0 : profile.pubkey) ? profile.pubkey.slice(0, 8) + \"...\" : \"\");\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"aside\", {\n        className: \"h-screen w-64 bg-gray-950 border-r border-gray-800 flex flex-col justify-between fixed left-0 top-0 z-40\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"p-6 text-2xl font-bold text-white tracking-tight mb-8\",\n                    children: \"raw.rocks\"\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/components/layout/Sidebar.tsx\",\n                    lineNumber: 31,\n                    columnNumber: 17\n                }, this),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n                    className: \"flex flex-col gap-2\",\n                    children: navItems.map((item)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: \"px-6 py-3 flex items-center gap-3 text-lg rounded-lg transition-colors w-full text-left \".concat(activePane === item.key ? \"bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500 text-white\" : \"text-gray-300 hover:bg-gray-800 hover:text-white\"),\n                            onClick: ()=>onNav(item.key),\n                            children: item.label\n                        }, item.key, false, {\n                            fileName: \"/Users/scarnes/workspace/src/components/layout/Sidebar.tsx\",\n                            lineNumber: 36,\n                            columnNumber: 25\n                        }, this))\n                }, void 0, false, {\n                    fileName: \"/Users/scarnes/workspace/src/components/layout/Sidebar.tsx\",\n                    lineNumber: 34,\n                    columnNumber: 17\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/scarnes/workspace/src/components/layout/Sidebar.tsx\",\n            lineNumber: 30,\n            columnNumber: 13\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/scarnes/workspace/src/components/layout/Sidebar.tsx\",\n        lineNumber: 29,\n        columnNumber: 9\n    }, this);\n}\n_s(Sidebar, \"I2oj3vTtghDEoEeQSd7cW+NUQt4=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_1__.useRouter,\n        _hooks_useNostr__WEBPACK_IMPORTED_MODULE_2__.useNostr\n    ];\n});\n_c = Sidebar;\nvar _c;\n$RefreshReg$(_c, \"Sidebar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL2xheW91dC9TaWRlYmFyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDNEM7QUFDQTtBQU81QyxNQUFNRSxXQUFXO0lBQ2I7UUFBRUMsS0FBSztRQUFRQyxPQUFPO1FBQVFDLE1BQU07SUFBSTtJQUN4QztRQUFFRixLQUFLO1FBQVdDLE9BQU87UUFBV0MsTUFBTTtJQUFXO0lBQ3JEO1FBQUVGLEtBQUs7UUFBVUMsT0FBTztRQUFVQyxNQUFNO0lBQVU7SUFDbEQ7UUFBRUYsS0FBSztRQUFhQyxPQUFPO1FBQWFDLE1BQU07SUFBYTtJQUMzRDtRQUFFRixLQUFLO1FBQVNDLE9BQU87UUFBU0MsTUFBTTtJQUFTO0lBQy9DO1FBQUVGLEtBQUs7UUFBaUJDLE9BQU87UUFBaUJDLE1BQU07SUFBaUI7SUFDdkU7UUFBRUYsS0FBSztRQUFRQyxPQUFPO1FBQVFDLE1BQU07SUFBUTtDQUMvQztBQUVjLFNBQVNDLFFBQVEsS0FBbUM7UUFBbkMsRUFBRUMsS0FBSyxFQUFFQyxVQUFVLEVBQWdCLEdBQW5DOztJQUM1QixNQUFNQyxTQUFTVCwwREFBU0E7SUFDeEIsTUFBTSxFQUFFVSxNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHVix5REFBUUE7SUFDcEMsb0NBQW9DO0lBQ3BDLE1BQU1XLFNBQVNELENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0UsT0FBTyxLQUFJO0lBQ25DLG9EQUFvRDtJQUNwRCxNQUFNQyxjQUFjSCxDQUFBQSxvQkFBQUEsOEJBQUFBLFFBQVNJLFlBQVksTUFBSUosb0JBQUFBLDhCQUFBQSxRQUFTSyxRQUFRLEtBQUtMLENBQUFBLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0QsTUFBTSxJQUFHQyxRQUFRRCxNQUFNLENBQUNPLEtBQUssQ0FBQyxHQUFHLEtBQUssUUFBUSxFQUFDO0lBQzNILE1BQU1ELFdBQVdMLENBQUFBLG9CQUFBQSw4QkFBQUEsUUFBU0ssUUFBUSxLQUFLTCxDQUFBQSxDQUFBQSxvQkFBQUEsOEJBQUFBLFFBQVNELE1BQU0sSUFBR0MsUUFBUUQsTUFBTSxDQUFDTyxLQUFLLENBQUMsR0FBRyxLQUFLLFFBQVEsRUFBQztJQUMvRixxQkFDSSw4REFBQ0M7UUFBTUMsV0FBVTtrQkFDYiw0RUFBQ0M7OzhCQUNHLDhEQUFDQTtvQkFBSUQsV0FBVTs4QkFBd0Q7Ozs7Ozs4QkFHdkUsOERBQUNFO29CQUFJRixXQUFVOzhCQUNWakIsU0FBU29CLEdBQUcsQ0FBQ0MsQ0FBQUEscUJBQ1YsOERBQUNDOzRCQUVHTCxXQUFXLDJGQUFtUCxPQUF4SlgsZUFBZWUsS0FBS3BCLEdBQUcsR0FBRywyRUFBMkU7NEJBQzNNc0IsU0FBUyxJQUFNbEIsTUFBTWdCLEtBQUtwQixHQUFHO3NDQUU1Qm9CLEtBQUtuQixLQUFLOzJCQUpObUIsS0FBS3BCLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWF6QztHQTlCd0JHOztRQUNMTixzREFBU0E7UUFDSUMscURBQVFBOzs7S0FGaEJLIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvc3JjL2NvbXBvbmVudHMvbGF5b3V0L1NpZGViYXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBMaW5rIGZyb20gXCJuZXh0L2xpbmtcIjtcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcbmltcG9ydCB7IHVzZU5vc3RyIH0gZnJvbSBcIkAvaG9va3MvdXNlTm9zdHJcIjtcblxuaW50ZXJmYWNlIFNpZGViYXJQcm9wcyB7XG4gICAgb25OYXY6IChrZXk6IHN0cmluZykgPT4gdm9pZDtcbiAgICBhY3RpdmVQYW5lOiBzdHJpbmcgfCBudWxsO1xufVxuXG5jb25zdCBuYXZJdGVtcyA9IFtcbiAgICB7IGtleTogXCJmZWVkXCIsIGxhYmVsOiBcIkZlZWRcIiwgaHJlZjogXCIvXCIgfSxcbiAgICB7IGtleTogXCJleHBsb3JlXCIsIGxhYmVsOiBcIkV4cGxvcmVcIiwgaHJlZjogXCIvZXhwbG9yZVwiIH0sXG4gICAgeyBrZXk6IFwid2FsbGV0XCIsIGxhYmVsOiBcIldhbGxldFwiLCBocmVmOiBcIi93YWxsZXRcIiB9LFxuICAgIHsga2V5OiBcImNvbW11bml0eVwiLCBsYWJlbDogXCJDb21tdW5pdHlcIiwgaHJlZjogXCIvY29tbXVuaXR5XCIgfSxcbiAgICB7IGtleTogXCJnYW1lc1wiLCBsYWJlbDogXCJHYW1lc1wiLCBocmVmOiBcIi9nYW1lc1wiIH0sXG4gICAgeyBrZXk6IFwibm90aWZpY2F0aW9uc1wiLCBsYWJlbDogXCJOb3RpZmljYXRpb25zXCIsIGhyZWY6IFwiL25vdGlmaWNhdGlvbnNcIiB9LFxuICAgIHsga2V5OiBcImNoYXRcIiwgbGFiZWw6IFwiQ2hhdFwiLCBocmVmOiBcIi9jaGF0XCIgfSwgLy8gQWRkZWQgQ2hhdCBwYWdlXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTaWRlYmFyKHsgb25OYXYsIGFjdGl2ZVBhbmUgfTogU2lkZWJhclByb3BzKSB7XG4gICAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG4gICAgY29uc3QgeyBwdWJrZXksIHByb2ZpbGUgfSA9IHVzZU5vc3RyKCk7XG4gICAgLy8gRmFsbGJhY2tzIGZvciBhdmF0YXIgYW5kIHVzZXJuYW1lXG4gICAgY29uc3QgYXZhdGFyID0gcHJvZmlsZT8ucGljdHVyZSB8fCBcIi9maWxlLnN2Z1wiO1xuICAgIC8vIFVzZSBkaXNwbGF5X25hbWUgZm9yIGRpc3BsYXksIHVzZXJuYW1lIGZvciBoYW5kbGVcbiAgICBjb25zdCBkaXNwbGF5TmFtZSA9IHByb2ZpbGU/LmRpc3BsYXlfbmFtZSB8fCBwcm9maWxlPy51c2VybmFtZSB8fCAocHJvZmlsZT8ucHVia2V5ID8gcHJvZmlsZS5wdWJrZXkuc2xpY2UoMCwgOCkgKyBcIi4uLlwiIDogXCJcIik7XG4gICAgY29uc3QgdXNlcm5hbWUgPSBwcm9maWxlPy51c2VybmFtZSB8fCAocHJvZmlsZT8ucHVia2V5ID8gcHJvZmlsZS5wdWJrZXkuc2xpY2UoMCwgOCkgKyBcIi4uLlwiIDogXCJcIik7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGFzaWRlIGNsYXNzTmFtZT1cImgtc2NyZWVuIHctNjQgYmctZ3JheS05NTAgYm9yZGVyLXIgYm9yZGVyLWdyYXktODAwIGZsZXggZmxleC1jb2wganVzdGlmeS1iZXR3ZWVuIGZpeGVkIGxlZnQtMCB0b3AtMCB6LTQwXCI+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicC02IHRleHQtMnhsIGZvbnQtYm9sZCB0ZXh0LXdoaXRlIHRyYWNraW5nLXRpZ2h0IG1iLThcIj5cbiAgICAgICAgICAgICAgICAgICAgcmF3LnJvY2tzXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPG5hdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC0yXCI+XG4gICAgICAgICAgICAgICAgICAgIHtuYXZJdGVtcy5tYXAoaXRlbSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtpdGVtLmtleX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BweC02IHB5LTMgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTMgdGV4dC1sZyByb3VuZGVkLWxnIHRyYW5zaXRpb24tY29sb3JzIHctZnVsbCB0ZXh0LWxlZnQgJHthY3RpdmVQYW5lID09PSBpdGVtLmtleSA/IFwiYmctZ3JhZGllbnQtdG8tciBmcm9tLWluZGlnby01MDAgdmlhLXB1cnBsZS01MDAgdG8tcGluay01MDAgdGV4dC13aGl0ZVwiIDogXCJ0ZXh0LWdyYXktMzAwIGhvdmVyOmJnLWdyYXktODAwIGhvdmVyOnRleHQtd2hpdGVcIn1gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uTmF2KGl0ZW0ua2V5KX1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXRlbS5sYWJlbH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICA8L25hdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgey8qIFVzZXIgcHJvZmlsZSBhdCBib3R0b20gKi99XG4gICAgICAgICAgICB7LyogUmVtb3ZlZCB1c2VyIHByb2ZpbGUgc2VjdGlvbiBmcm9tIHNpZGViYXIgKi99XG4gICAgICAgIDwvYXNpZGU+XG4gICAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VSb3V0ZXIiLCJ1c2VOb3N0ciIsIm5hdkl0ZW1zIiwia2V5IiwibGFiZWwiLCJocmVmIiwiU2lkZWJhciIsIm9uTmF2IiwiYWN0aXZlUGFuZSIsInJvdXRlciIsInB1YmtleSIsInByb2ZpbGUiLCJhdmF0YXIiLCJwaWN0dXJlIiwiZGlzcGxheU5hbWUiLCJkaXNwbGF5X25hbWUiLCJ1c2VybmFtZSIsInNsaWNlIiwiYXNpZGUiLCJjbGFzc05hbWUiLCJkaXYiLCJuYXYiLCJtYXAiLCJpdGVtIiwiYnV0dG9uIiwib25DbGljayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/layout/Sidebar.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/shared/BitcoinTicker.tsx":
/*!*************************************************!*\
  !*** ./src/components/shared/BitcoinTicker.tsx ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FinancialTicker: () => (/* binding */ FinancialTicker)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../node_modules/process/browser.js\");\n\nvar _s = $RefreshSig$();\n\nfunction FinancialTicker(param) {\n    let { assetId, assetType, refreshInterval = 300, currency = 'usd', decimals = 2, showVolume = true, showMarketCap = false, className, symbol } = param;\n    _s();\n    const [tickerData, setTickerData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [lastSuccessfulData, setLastSuccessfulData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [retryCount, setRetryCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const maxRetries = 3;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"FinancialTicker.useEffect\": ()=>{\n            const fetchFinancialData = {\n                \"FinancialTicker.useEffect.fetchFinancialData\": async ()=>{\n                    try {\n                        setLoading(true);\n                        let apiUrl = '';\n                        let apiKey = process.env.NEXT_PUBLIC_ALPHA_VANTAGE_API_KEY || 'YOUR_API_KEY'; // Replace with your API key\n                        // Determine API based on asset type\n                        if (assetType === 'crypto') {\n                            apiUrl = \"https://api.coingecko.com/api/v3/coins/\".concat(assetId, \"?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false\");\n                        } else if (assetType === 'stock') {\n                            // Alpha Vantage API for stock data\n                            apiUrl = \"https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=\".concat(assetId, \"&apikey=\").concat(apiKey);\n                        } else if (assetType === 'forex') {\n                            // ExchangeRate-API for forex data\n                            apiUrl = \"https://api.exchangerate-api.com/v4/latest/\".concat(assetId.split('-')[0]); // e.g., 'usd' from 'usd-eur'\n                        }\n                        const response = await fetch(apiUrl);\n                        if (!response.ok) {\n                            throw new Error(\"Failed to fetch \".concat(assetType, \" data: \").concat(response.statusText));\n                        }\n                        const data = await response.json();\n                        // Normalize data based on asset type\n                        let newData;\n                        if (assetType === 'crypto') {\n                            newData = {\n                                price: data.market_data.current_price[currency.toLowerCase()] || 0,\n                                change24h: data.market_data.price_change_percentage_24h || 0,\n                                volume24h: data.market_data.total_volume[currency.toLowerCase()] || 0,\n                                marketCap: data.market_data.market_cap[currency.toLowerCase()],\n                                high24h: data.market_data.high_24h[currency.toLowerCase()],\n                                low24h: data.market_data.low_24h[currency.toLowerCase()]\n                            };\n                        } else if (assetType === 'stock') {\n                            var _quote_10changepercent;\n                            const quote = data['Global Quote'] || {};\n                            newData = {\n                                price: parseFloat(quote['05. price']) || 0,\n                                change24h: parseFloat((_quote_10changepercent = quote['10. change percent']) === null || _quote_10changepercent === void 0 ? void 0 : _quote_10changepercent.replace('%', '')) || 0,\n                                volume24h: parseFloat(quote['06. volume']) || 0,\n                                marketCap: undefined,\n                                high24h: parseFloat(quote['03. high']) || 0,\n                                low24h: parseFloat(quote['04. low']) || 0\n                            };\n                        } else if (assetType === 'forex') {\n                            const targetCurrency = assetId.split('-')[1]; // e.g., 'eur' from 'usd-eur'\n                            newData = {\n                                price: data.rates[targetCurrency] || 0,\n                                change24h: 0,\n                                volume24h: 0,\n                                marketCap: undefined,\n                                high24h: undefined,\n                                low24h: undefined\n                            };\n                        } else {\n                            throw new Error('Unsupported asset type');\n                        }\n                        setTickerData(newData);\n                        setLastSuccessfulData(newData); // Cache successful data\n                        setError(null);\n                        setLoading(false);\n                        setRetryCount(0); // Reset retry count on success\n                    } catch (err) {\n                        console.error(\"Error fetching \".concat(assetType, \" data for \").concat(assetId, \":\"), err);\n                        if (retryCount < maxRetries) {\n                            setTimeout({\n                                \"FinancialTicker.useEffect.fetchFinancialData\": ()=>{\n                                    setRetryCount(retryCount + 1);\n                                }\n                            }[\"FinancialTicker.useEffect.fetchFinancialData\"], 2000 * (retryCount + 1)); // Exponential backoff\n                        } else {\n                            setError(\"Failed to load \".concat(assetType, \" data for \").concat(symbol || assetId, \". Showing last known data.\"));\n                            setLoading(false);\n                        }\n                    }\n                }\n            }[\"FinancialTicker.useEffect.fetchFinancialData\"];\n            fetchFinancialData();\n            // Set up interval for periodic updates\n            const intervalId = setInterval(fetchFinancialData, refreshInterval * 1000);\n            // Cleanup interval on component unmount\n            return ({\n                \"FinancialTicker.useEffect\": ()=>clearInterval(intervalId)\n            })[\"FinancialTicker.useEffect\"];\n        }\n    }[\"FinancialTicker.useEffect\"], [\n        assetId,\n        assetType,\n        currency,\n        refreshInterval,\n        retryCount,\n        symbol\n    ]);\n    // Loading state (no cached data)\n    if (loading && !lastSuccessfulData) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"flex items-center p-2 bg-transparent backdrop-blur-md rounded-md border border-white/10 shadow-md \".concat(className),\n            role: \"status\",\n            \"aria-live\": \"polite\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"animate-pulse w-24 h-6 bg-white/5 rounded\"\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/shared/BitcoinTicker.tsx\",\n                lineNumber: 138,\n                columnNumber: 17\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/scarnes/workspace/src/components/shared/BitcoinTicker.tsx\",\n            lineNumber: 133,\n            columnNumber: 13\n        }, this);\n    }\n    // Use last successful data if current fetch fails\n    const displayData = tickerData || lastSuccessfulData;\n    // No data available (initial load failed and no cached data)\n    if (!displayData) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"p-2 bg-transparent backdrop-blur-md rounded-md border border-red-800/50 \".concat(className),\n            role: \"alert\",\n            \"aria-live\": \"assertive\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"text-red-400\",\n                children: [\n                    \"No data available for \",\n                    symbol || assetId\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/components/shared/BitcoinTicker.tsx\",\n                lineNumber: 154,\n                columnNumber: 17\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/scarnes/workspace/src/components/shared/BitcoinTicker.tsx\",\n            lineNumber: 149,\n            columnNumber: 13\n        }, this);\n    }\n    const isPositive = displayData.change24h >= 0;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col p-2 bg-transparent backdrop-blur-md rounded-md border border-white/10 shadow-md transition-all hover:scale-105 hover:border-yellow-400/50 group \".concat(className),\n        role: \"region\",\n        \"aria-label\": \"\".concat(symbol || assetId, \" financial ticker\"),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-center gap-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-yellow-400 text-lg font-bold mr-1\",\n                        children: symbol || (assetType === 'crypto' ? '₿' : assetType === 'stock' ? '📈' : '💱')\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/components/shared/BitcoinTicker.tsx\",\n                        lineNumber: 168,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"text-gray-100 font-mono\",\n                        children: [\n                            currency.toUpperCase(),\n                            \" \",\n                            displayData.price.toLocaleString(undefined, {\n                                maximumFractionDigits: decimals\n                            })\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/components/shared/BitcoinTicker.tsx\",\n                        lineNumber: 171,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"text-xs font-medium \".concat(isPositive ? 'text-green-400' : 'text-red-400'),\n                        children: [\n                            isPositive ? '▲' : '▼',\n                            \" \",\n                            Math.abs(displayData.change24h).toFixed(2),\n                            \"%\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/scarnes/workspace/src/components/shared/BitcoinTicker.tsx\",\n                        lineNumber: 174,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/components/shared/BitcoinTicker.tsx\",\n                lineNumber: 167,\n                columnNumber: 13\n            }, this),\n            showVolume && displayData.volume24h > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-xs text-gray-400 mt-1\",\n                children: [\n                    \"Volume (24h): \",\n                    displayData.volume24h.toLocaleString(undefined, {\n                        maximumFractionDigits: 0\n                    })\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/components/shared/BitcoinTicker.tsx\",\n                lineNumber: 179,\n                columnNumber: 17\n            }, this),\n            showMarketCap && displayData.marketCap && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-xs text-gray-400 mt-1\",\n                children: [\n                    \"Market Cap: \",\n                    displayData.marketCap.toLocaleString(undefined, {\n                        maximumFractionDigits: 0\n                    })\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/components/shared/BitcoinTicker.tsx\",\n                lineNumber: 184,\n                columnNumber: 17\n            }, this),\n            displayData.high24h && displayData.low24h && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-xs text-gray-400 mt-1\",\n                children: [\n                    \"24h Range: \",\n                    displayData.low24h.toLocaleString(undefined, {\n                        maximumFractionDigits: decimals\n                    }),\n                    \" -\",\n                    ' ',\n                    displayData.high24h.toLocaleString(undefined, {\n                        maximumFractionDigits: decimals\n                    })\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/components/shared/BitcoinTicker.tsx\",\n                lineNumber: 189,\n                columnNumber: 17\n            }, this),\n            error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"text-xs text-red-400 mt-1\",\n                role: \"alert\",\n                children: error\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/shared/BitcoinTicker.tsx\",\n                lineNumber: 195,\n                columnNumber: 17\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/components/shared/BitcoinTicker.tsx\",\n        lineNumber: 162,\n        columnNumber: 9\n    }, this);\n}\n_s(FinancialTicker, \"j2d93HA9/iR8xc80ZuJKdsbIEZI=\");\n_c = FinancialTicker;\nvar _c;\n$RefreshReg$(_c, \"FinancialTicker\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3NoYXJlZC9CaXRjb2luVGlja2VyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQTRDO0FBdUJyQyxTQUFTRSxnQkFBZ0IsS0FVVDtRQVZTLEVBQzVCQyxPQUFPLEVBQ1BDLFNBQVMsRUFDVEMsa0JBQWtCLEdBQUcsRUFDckJDLFdBQVcsS0FBSyxFQUNoQkMsV0FBVyxDQUFDLEVBQ1pDLGFBQWEsSUFBSSxFQUNqQkMsZ0JBQWdCLEtBQUssRUFDckJDLFNBQVMsRUFDVEMsTUFBTSxFQUNhLEdBVlM7O0lBVzVCLE1BQU0sQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHWiwrQ0FBUUEsQ0FBb0I7SUFDaEUsTUFBTSxDQUFDYSxTQUFTQyxXQUFXLEdBQUdkLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQ2UsT0FBT0MsU0FBUyxHQUFHaEIsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU0sQ0FBQ2lCLG9CQUFvQkMsc0JBQXNCLEdBQUdsQiwrQ0FBUUEsQ0FBb0I7SUFDaEYsTUFBTSxDQUFDbUIsWUFBWUMsY0FBYyxHQUFHcEIsK0NBQVFBLENBQUM7SUFDN0MsTUFBTXFCLGFBQWE7SUFFbkJ0QixnREFBU0E7cUNBQUM7WUFDTixNQUFNdUI7Z0VBQXFCO29CQUN2QixJQUFJO3dCQUNBUixXQUFXO3dCQUNYLElBQUlTLFNBQVM7d0JBQ2IsSUFBSUMsU0FBU0MsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxpQ0FBaUMsSUFBSSxnQkFBZ0IsNEJBQTRCO3dCQUUxRyxvQ0FBb0M7d0JBQ3BDLElBQUl4QixjQUFjLFVBQVU7NEJBQ3hCb0IsU0FBUywwQ0FBa0QsT0FBUnJCLFNBQVE7d0JBQy9ELE9BQU8sSUFBSUMsY0FBYyxTQUFTOzRCQUM5QixtQ0FBbUM7NEJBQ25Db0IsU0FBUyxrRUFBb0ZDLE9BQWxCdEIsU0FBUSxZQUFpQixPQUFQc0I7d0JBQ2pHLE9BQU8sSUFBSXJCLGNBQWMsU0FBUzs0QkFDOUIsa0NBQWtDOzRC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QUc7Ozs7Ozs7Ozs7Ozs7WUFHNUVwRSxjQUFjMkQsWUFBWXZCLFNBQVMsR0FBRyxtQkFDbkMsOERBQUNvQjtnQkFBSXRELFdBQVU7O29CQUE2QjtvQkFDekJ5RCxZQUFZdkIsU0FBUyxDQUFDNEIsY0FBYyxDQUFDakIsV0FBVzt3QkFBRWtCLHVCQUF1QjtvQkFBRTs7Ozs7OztZQUdqR2hFLGlCQUFpQjBELFlBQVlyQixTQUFTLGtCQUNuQyw4REFBQ2tCO2dCQUFJdEQsV0FBVTs7b0JBQTZCO29CQUMzQnlELFlBQVlyQixTQUFTLENBQUMwQixjQUFjLENBQUNqQixXQUFXO3dCQUFFa0IsdUJBQXVCO29CQUFFOzs7Ozs7O1lBRy9GTixZQUFZbkIsT0FBTyxJQUFJbUIsWUFBWWpCLE1BQU0sa0JBQ3RDLDhEQUFDYztnQkFBSXRELFdBQVU7O29CQUE2QjtvQkFDNUJ5RCxZQUFZakIsTUFBTSxDQUFDc0IsY0FBYyxDQUFDakIsV0FBVzt3QkFBRWtCLHVCQUF1QmxFO29CQUFTO29CQUFHO29CQUFHO29CQUNoRzRELFlBQVluQixPQUFPLENBQUN3QixjQUFjLENBQUNqQixXQUFXO3dCQUFFa0IsdUJBQXVCbEU7b0JBQVM7Ozs7Ozs7WUFHeEZTLHVCQUNHLDhEQUFDZ0Q7Z0JBQUl0RCxXQUFVO2dCQUE0QnVELE1BQUs7MEJBQzNDakQ7Ozs7Ozs7Ozs7OztBQUtyQjtHQWpMZ0JkO0tBQUFBIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvc3JjL2NvbXBvbmVudHMvc2hhcmVkL0JpdGNvaW5UaWNrZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmludGVyZmFjZSBGaW5hbmNpYWxUaWNrZXJQcm9wcyB7XG4gICAgYXNzZXRJZDogc3RyaW5nOyAvLyBlLmcuLCAnYml0Y29pbicsICdldGhlcmV1bScsICdhYXBsJywgJ3VzZC1ldXInXG4gICAgYXNzZXRUeXBlOiAnY3J5cHRvJyB8ICdzdG9jaycgfCAnZm9yZXgnOyAvLyBUeXBlIG9mIGZpbmFuY2lhbCBhc3NldFxuICAgIHJlZnJlc2hJbnRlcnZhbD86IG51bWJlcjsgLy8gUmVmcmVzaCBpbnRlcnZhbCBpbiBzZWNvbmRzIChkZWZhdWx0OiAzMDApXG4gICAgY3VycmVuY3k/OiBzdHJpbmc7IC8vIERpc3BsYXkgY3VycmVuY3kgKGUuZy4sICd1c2QnLCAnZXVyJylcbiAgICBkZWNpbWFscz86IG51bWJlcjsgLy8gTnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBwcmljZVxuICAgIHNob3dWb2x1bWU/OiBib29sZWFuOyAvLyBUb2dnbGUgdm9sdW1lIGRpc3BsYXlcbiAgICBzaG93TWFya2V0Q2FwPzogYm9vbGVhbjsgLy8gVG9nZ2xlIG1hcmtldCBjYXAgZGlzcGxheVxuICAgIGNsYXNzTmFtZT86IHN0cmluZzsgLy8gT3B0aW9uYWwgQ1NTIGNsYXNzIGZvciBzdHlsaW5nXG4gICAgc3ltYm9sPzogc3RyaW5nOyAvLyBPcmlnaW5hbCBzeW1ib2wgZnJvbSBwb3N0IChlLmcuLCAnJEJUQycsICckQUFQTCcpXG59XG5cbmludGVyZmFjZSBUaWNrZXJEYXRhIHtcbiAgICBwcmljZTogbnVtYmVyO1xuICAgIGNoYW5nZTI0aDogbnVtYmVyO1xuICAgIHZvbHVtZTI0aDogbnVtYmVyO1xuICAgIG1hcmtldENhcD86IG51bWJlcjtcbiAgICBoaWdoMjRoPzogbnVtYmVyO1xuICAgIGxvdzI0aD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEZpbmFuY2lhbFRpY2tlcih7XG4gICAgYXNzZXRJZCxcbiAgICBhc3NldFR5cGUsXG4gICAgcmVmcmVzaEludGVydmFsID0gMzAwLCAvLyBEZWZhdWx0OiA1IG1pbnV0ZXNcbiAgICBjdXJyZW5jeSA9ICd1c2QnLFxuICAgIGRlY2ltYWxzID0gMixcbiAgICBzaG93Vm9sdW1lID0gdHJ1ZSxcbiAgICBzaG93TWFya2V0Q2FwID0gZmFsc2UsXG4gICAgY2xhc3NOYW1lLFxuICAgIHN5bWJvbCxcbn06IEZpbmFuY2lhbFRpY2tlclByb3BzKSB7XG4gICAgY29uc3QgW3RpY2tlckRhdGEsIHNldFRpY2tlckRhdGFdID0gdXNlU3RhdGU8VGlja2VyRGF0YSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgW2xhc3RTdWNjZXNzZnVsRGF0YSwgc2V0TGFzdFN1Y2Nlc3NmdWxEYXRhXSA9IHVzZVN0YXRlPFRpY2tlckRhdGEgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbcmV0cnlDb3VudCwgc2V0UmV0cnlDb3VudF0gPSB1c2VTdGF0ZSgwKTtcbiAgICBjb25zdCBtYXhSZXRyaWVzID0gMztcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZldGNoRmluYW5jaWFsRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgICAgICAgICAgICBsZXQgYXBpVXJsID0gJyc7XG4gICAgICAgICAgICAgICAgbGV0IGFwaUtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FMUEhBX1ZBTlRBR0VfQVBJX0tFWSB8fCAnWU9VUl9BUElfS0VZJzsgLy8gUmVwbGFjZSB3aXRoIHlvdXIgQVBJIGtleVxuXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIEFQSSBiYXNlZCBvbiBhc3NldCB0eXBlXG4gICAgICAgICAgICAgICAgaWYgKGFzc2V0VHlwZSA9PT0gJ2NyeXB0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsID0gYGh0dHBzOi8vYXBpLmNvaW5nZWNrby5jb20vYXBpL3YzL2NvaW5zLyR7YXNzZXRJZH0/bG9jYWxpemF0aW9uPWZhbHNlJnRpY2tlcnM9ZmFsc2UmbWFya2V0X2RhdGE9dHJ1ZSZjb21tdW5pdHlfZGF0YT1mYWxzZSZkZXZlbG9wZXJfZGF0YT1mYWxzZWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhc3NldFR5cGUgPT09ICdzdG9jaycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxwaGEgVmFudGFnZSBBUEkgZm9yIHN0b2NrIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsID0gYGh0dHBzOi8vd3d3LmFscGhhdmFudGFnZS5jby9xdWVyeT9mdW5jdGlvbj1HTE9CQUxfUVVPVEUmc3ltYm9sPSR7YXNzZXRJZH0mYXBpa2V5PSR7YXBpS2V5fWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhc3NldFR5cGUgPT09ICdmb3JleCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhjaGFuZ2VSYXRlLUFQSSBmb3IgZm9yZXggZGF0YVxuICAgICAgICAgICAgICAgICAgICBhcGlVcmwgPSBgaHR0cHM6Ly9hcGkuZXhjaGFuZ2VyYXRlLWFwaS5jb20vdjQvbGF0ZXN0LyR7YXNzZXRJZC5zcGxpdCgnLScpWzBdfWA7IC8vIGUuZy4sICd1c2QnIGZyb20gJ3VzZC1ldXInXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcGlVcmwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCAke2Fzc2V0VHlwZX0gZGF0YTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBOb3JtYWxpemUgZGF0YSBiYXNlZCBvbiBhc3NldCB0eXBlXG4gICAgICAgICAgICAgICAgbGV0IG5ld0RhdGE6IFRpY2tlckRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKGFzc2V0VHlwZSA9PT0gJ2NyeXB0bycpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBkYXRhLm1hcmtldF9kYXRhLmN1cnJlbnRfcHJpY2VbY3VycmVuY3kudG9Mb3dlckNhc2UoKV0gfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZTI0aDogZGF0YS5tYXJrZXRfZGF0YS5wcmljZV9jaGFuZ2VfcGVyY2VudGFnZV8yNGggfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvbHVtZTI0aDogZGF0YS5tYXJrZXRfZGF0YS50b3RhbF92b2x1bWVbY3VycmVuY3kudG9Mb3dlckNhc2UoKV0gfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtldENhcDogZGF0YS5tYXJrZXRfZGF0YS5tYXJrZXRfY2FwW2N1cnJlbmN5LnRvTG93ZXJDYXNlKCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGlnaDI0aDogZGF0YS5tYXJrZXRfZGF0YS5oaWdoXzI0aFtjdXJyZW5jeS50b0xvd2VyQ2FzZSgpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvdzI0aDogZGF0YS5tYXJrZXRfZGF0YS5sb3dfMjRoW2N1cnJlbmN5LnRvTG93ZXJDYXNlKCldLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXNzZXRUeXBlID09PSAnc3RvY2snKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHF1b3RlID0gZGF0YVsnR2xvYmFsIFF1b3RlJ10gfHwge307XG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmljZTogcGFyc2VGbG9hdChxdW90ZVsnMDUuIHByaWNlJ10pIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UyNGg6IHBhcnNlRmxvYXQocXVvdGVbJzEwLiBjaGFuZ2UgcGVyY2VudCddPy5yZXBsYWNlKCclJywgJycpKSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdm9sdW1lMjRoOiBwYXJzZUZsb2F0KHF1b3RlWycwNi4gdm9sdW1lJ10pIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXRDYXA6IHVuZGVmaW5lZCwgLy8gQWxwaGEgVmFudGFnZSBmcmVlIHRpZXIgZG9lc24ndCBwcm92aWRlIG1hcmtldCBjYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2gyNGg6IHBhcnNlRmxvYXQocXVvdGVbJzAzLiBoaWdoJ10pIHx8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3cyNGg6IHBhcnNlRmxvYXQocXVvdGVbJzA0LiBsb3cnXSkgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFzc2V0VHlwZSA9PT0gJ2ZvcmV4Jykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRDdXJyZW5jeSA9IGFzc2V0SWQuc3BsaXQoJy0nKVsxXTsgLy8gZS5nLiwgJ2V1cicgZnJvbSAndXNkLWV1cidcbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaWNlOiBkYXRhLnJhdGVzW3RhcmdldEN1cnJlbmN5XSB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlMjRoOiAwLCAvLyBFeGNoYW5nZVJhdGUtQVBJIGZyZWUgdGllciBkb2Vzbid0IHByb3ZpZGUgMjRoIGNoYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgdm9sdW1lMjRoOiAwLCAvLyBOb3QgYXZhaWxhYmxlIGluIHRoaXMgQVBJXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJrZXRDYXA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2gyNGg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvdzI0aDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgYXNzZXQgdHlwZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldFRpY2tlckRhdGEobmV3RGF0YSk7XG4gICAgICAgICAgICAgICAgc2V0TGFzdFN1Y2Nlc3NmdWxEYXRhKG5ld0RhdGEpOyAvLyBDYWNoZSBzdWNjZXNzZnVsIGRhdGFcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBzZXRSZXRyeUNvdW50KDApOyAvLyBSZXNldCByZXRyeSBjb3VudCBvbiBzdWNjZXNzXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyAke2Fzc2V0VHlwZX0gZGF0YSBmb3IgJHthc3NldElkfTpgLCBlcnIpO1xuICAgICAgICAgICAgICAgIGlmIChyZXRyeUNvdW50IDwgbWF4UmV0cmllcykge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFJldHJ5Q291bnQocmV0cnlDb3VudCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9LCAyMDAwICogKHJldHJ5Q291bnQgKyAxKSk7IC8vIEV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcihgRmFpbGVkIHRvIGxvYWQgJHthc3NldFR5cGV9IGRhdGEgZm9yICR7c3ltYm9sIHx8IGFzc2V0SWR9LiBTaG93aW5nIGxhc3Qga25vd24gZGF0YS5gKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZldGNoRmluYW5jaWFsRGF0YSgpO1xuXG4gICAgICAgIC8vIFNldCB1cCBpbnRlcnZhbCBmb3IgcGVyaW9kaWMgdXBkYXRlc1xuICAgICAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZmV0Y2hGaW5hbmNpYWxEYXRhLCByZWZyZXNoSW50ZXJ2YWwgKiAxMDAwKTtcblxuICAgICAgICAvLyBDbGVhbnVwIGludGVydmFsIG9uIGNvbXBvbmVudCB1bm1vdW50XG4gICAgICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIH0sIFthc3NldElkLCBhc3NldFR5cGUsIGN1cnJlbmN5LCByZWZyZXNoSW50ZXJ2YWwsIHJldHJ5Q291bnQsIHN5bWJvbF0pO1xuXG4gICAgLy8gTG9hZGluZyBzdGF0ZSAobm8gY2FjaGVkIGRhdGEpXG4gICAgaWYgKGxvYWRpbmcgJiYgIWxhc3RTdWNjZXNzZnVsRGF0YSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YGZsZXggaXRlbXMtY2VudGVyIHAtMiBiZy10cmFuc3BhcmVudCBiYWNrZHJvcC1ibHVyLW1kIHJvdW5kZWQtbWQgYm9yZGVyIGJvcmRlci13aGl0ZS8xMCBzaGFkb3ctbWQgJHtjbGFzc05hbWV9YH1cbiAgICAgICAgICAgICAgICByb2xlPVwic3RhdHVzXCJcbiAgICAgICAgICAgICAgICBhcmlhLWxpdmU9XCJwb2xpdGVcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYW5pbWF0ZS1wdWxzZSB3LTI0IGgtNiBiZy13aGl0ZS81IHJvdW5kZWRcIj48L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIFVzZSBsYXN0IHN1Y2Nlc3NmdWwgZGF0YSBpZiBjdXJyZW50IGZldGNoIGZhaWxzXG4gICAgY29uc3QgZGlzcGxheURhdGEgPSB0aWNrZXJEYXRhIHx8IGxhc3RTdWNjZXNzZnVsRGF0YTtcblxuICAgIC8vIE5vIGRhdGEgYXZhaWxhYmxlIChpbml0aWFsIGxvYWQgZmFpbGVkIGFuZCBubyBjYWNoZWQgZGF0YSlcbiAgICBpZiAoIWRpc3BsYXlEYXRhKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgcC0yIGJnLXRyYW5zcGFyZW50IGJhY2tkcm9wLWJsdXItbWQgcm91bmRlZC1tZCBib3JkZXIgYm9yZGVyLXJlZC04MDAvNTAgJHtjbGFzc05hbWV9YH1cbiAgICAgICAgICAgICAgICByb2xlPVwiYWxlcnRcIlxuICAgICAgICAgICAgICAgIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1yZWQtNDAwXCI+Tm8gZGF0YSBhdmFpbGFibGUgZm9yIHtzeW1ib2wgfHwgYXNzZXRJZH08L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1Bvc2l0aXZlID0gZGlzcGxheURhdGEuY2hhbmdlMjRoID49IDA7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9e2BmbGV4IGZsZXgtY29sIHAtMiBiZy10cmFuc3BhcmVudCBiYWNrZHJvcC1ibHVyLW1kIHJvdW5kZWQtbWQgYm9yZGVyIGJvcmRlci13aGl0ZS8xMCBzaGFkb3ctbWQgdHJhbnNpdGlvbi1hbGwgaG92ZXI6c2NhbGUtMTA1IGhvdmVyOmJvcmRlci15ZWxsb3ctNDAwLzUwIGdyb3VwICR7Y2xhc3NOYW1lfWB9XG4gICAgICAgICAgICByb2xlPVwicmVnaW9uXCJcbiAgICAgICAgICAgIGFyaWEtbGFiZWw9e2Ake3N5bWJvbCB8fCBhc3NldElkfSBmaW5hbmNpYWwgdGlja2VyYH1cbiAgICAgICAgPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMlwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQteWVsbG93LTQwMCB0ZXh0LWxnIGZvbnQtYm9sZCBtci0xXCI+XG4gICAgICAgICAgICAgICAgICAgIHtzeW1ib2wgfHwgKGFzc2V0VHlwZSA9PT0gJ2NyeXB0bycgPyAn4oK/JyA6IGFzc2V0VHlwZSA9PT0gJ3N0b2NrJyA/ICfwn5OIJyA6ICfwn5KxJyl9XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtZ3JheS0xMDAgZm9udC1tb25vXCI+XG4gICAgICAgICAgICAgICAgICAgIHtjdXJyZW5jeS50b1VwcGVyQ2FzZSgpfSB7ZGlzcGxheURhdGEucHJpY2UudG9Mb2NhbGVTdHJpbmcodW5kZWZpbmVkLCB7IG1heGltdW1GcmFjdGlvbkRpZ2l0czogZGVjaW1hbHMgfSl9XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgdGV4dC14cyBmb250LW1lZGl1bSAke2lzUG9zaXRpdmUgPyAndGV4dC1ncmVlbi00MDAnIDogJ3RleHQtcmVkLTQwMCd9YH0+XG4gICAgICAgICAgICAgICAgICAgIHtpc1Bvc2l0aXZlID8gJ+KWsicgOiAn4pa8J30ge01hdGguYWJzKGRpc3BsYXlEYXRhLmNoYW5nZTI0aCkudG9GaXhlZCgyKX0lXG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHtzaG93Vm9sdW1lICYmIGRpc3BsYXlEYXRhLnZvbHVtZTI0aCA+IDAgJiYgKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWdyYXktNDAwIG10LTFcIj5cbiAgICAgICAgICAgICAgICAgICAgVm9sdW1lICgyNGgpOiB7ZGlzcGxheURhdGEudm9sdW1lMjRoLnRvTG9jYWxlU3RyaW5nKHVuZGVmaW5lZCwgeyBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDAgfSl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAge3Nob3dNYXJrZXRDYXAgJiYgZGlzcGxheURhdGEubWFya2V0Q2FwICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1ncmF5LTQwMCBtdC0xXCI+XG4gICAgICAgICAgICAgICAgICAgIE1hcmtldCBDYXA6IHtkaXNwbGF5RGF0YS5tYXJrZXRDYXAudG9Mb2NhbGVTdHJpbmcodW5kZWZpbmVkLCB7IG1heGltdW1GcmFjdGlvbkRpZ2l0czogMCB9KX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICB7ZGlzcGxheURhdGEuaGlnaDI0aCAmJiBkaXNwbGF5RGF0YS5sb3cyNGggJiYgKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LWdyYXktNDAwIG10LTFcIj5cbiAgICAgICAgICAgICAgICAgICAgMjRoIFJhbmdlOiB7ZGlzcGxheURhdGEubG93MjRoLnRvTG9jYWxlU3RyaW5nKHVuZGVmaW5lZCwgeyBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IGRlY2ltYWxzIH0pfSAteycgJ31cbiAgICAgICAgICAgICAgICAgICAge2Rpc3BsYXlEYXRhLmhpZ2gyNGgudG9Mb2NhbGVTdHJpbmcodW5kZWZpbmVkLCB7IG1heGltdW1GcmFjdGlvbkRpZ2l0czogZGVjaW1hbHMgfSl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAge2Vycm9yICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1yZWQtNDAwIG10LTFcIiByb2xlPVwiYWxlcnRcIj5cbiAgICAgICAgICAgICAgICAgICAge2Vycm9yfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn0iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJGaW5hbmNpYWxUaWNrZXIiLCJhc3NldElkIiwiYXNzZXRUeXBlIiwicmVmcmVzaEludGVydmFsIiwiY3VycmVuY3kiLCJkZWNpbWFscyIsInNob3dWb2x1bWUiLCJzaG93TWFya2V0Q2FwIiwiY2xhc3NOYW1lIiwic3ltYm9sIiwidGlja2VyRGF0YSIsInNldFRpY2tlckRhdGEiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJsYXN0U3VjY2Vzc2Z1bERhdGEiLCJzZXRMYXN0U3VjY2Vzc2Z1bERhdGEiLCJyZXRyeUNvdW50Iiwic2V0UmV0cnlDb3VudCIsIm1heFJldHJpZXMiLCJmZXRjaEZpbmFuY2lhbERhdGEiLCJhcGlVcmwiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQUxQSEFfVkFOVEFHRV9BUElfS0VZIiwic3BsaXQiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJFcnJvciIsInN0YXR1c1RleHQiLCJkYXRhIiwianNvbiIsIm5ld0RhdGEiLCJwcmljZSIsIm1hcmtldF9kYXRhIiwiY3VycmVudF9wcmljZSIsInRvTG93ZXJDYXNlIiwiY2hhbmdlMjRoIiwicHJpY2VfY2hhbmdlX3BlcmNlbnRhZ2VfMjRoIiwidm9sdW1lMjRoIiwidG90YWxfdm9sdW1lIiwibWFya2V0Q2FwIiwibWFya2V0X2NhcCIsImhpZ2gyNGgiLCJoaWdoXzI0aCIsImxvdzI0aCIsImxvd18yNGgiLCJxdW90ZSIsInBhcnNlRmxvYXQiLCJyZXBsYWNlIiwidW5kZWZpbmVkIiwidGFyZ2V0Q3VycmVuY3kiLCJyYXRlcyIsImVyciIsImNvbnNvbGUiLCJzZXRUaW1lb3V0IiwiaW50ZXJ2YWxJZCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImRpdiIsInJvbGUiLCJhcmlhLWxpdmUiLCJkaXNwbGF5RGF0YSIsInNwYW4iLCJpc1Bvc2l0aXZlIiwiYXJpYS1sYWJlbCIsInRvVXBwZXJDYXNlIiwidG9Mb2NhbGVTdHJpbmciLCJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCJNYXRoIiwiYWJzIiwidG9GaXhlZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/shared/BitcoinTicker.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/shared/ErrorMessage.tsx":
/*!************************************************!*\
  !*** ./src/components/shared/ErrorMessage.tsx ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorMessage: () => (/* binding */ ErrorMessage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nfunction ErrorMessage(param) {\n    let { message, onRetry, relayStats, onClearRelays } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"bg-red-500/10 border border-red-500/20 rounded-lg p-4 text-red-400 backdrop-blur-lg\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: relayStats ? \"\".concat(relayStats.healthyCount, \"/\").concat(relayStats.totalCount, \" relays connected. \").concat(relayStats.healthyCount === 0 ? message : '') : message\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/shared/ErrorMessage.tsx\",\n                lineNumber: 16,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex gap-2 mt-2\",\n                children: [\n                    onRetry && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: onRetry,\n                        className: \"px-4 py-1 bg-red-500/20 hover:bg-red-500/30 rounded-full text-sm transition\",\n                        children: \"Retry\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/components/shared/ErrorMessage.tsx\",\n                        lineNumber: 24,\n                        columnNumber: 21\n                    }, this),\n                    onClearRelays && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: onClearRelays,\n                        className: \"px-4 py-1 bg-blue-500/20 hover:bg-blue-500/30 rounded-full text-sm transition\",\n                        children: \"Reset Relays\"\n                    }, void 0, false, {\n                        fileName: \"/Users/scarnes/workspace/src/components/shared/ErrorMessage.tsx\",\n                        lineNumber: 32,\n                        columnNumber: 21\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/scarnes/workspace/src/components/shared/ErrorMessage.tsx\",\n                lineNumber: 22,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/components/shared/ErrorMessage.tsx\",\n        lineNumber: 15,\n        columnNumber: 9\n    }, this);\n}\n_c = ErrorMessage;\nvar _c;\n$RefreshReg$(_c, \"ErrorMessage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3NoYXJlZC9FcnJvck1lc3NhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7OztBQVlPLFNBQVNBLGFBQWEsS0FBa0U7UUFBbEUsRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsYUFBYSxFQUFxQixHQUFsRTtJQUN6QixxQkFDSSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ1gsOERBQUNDOzBCQUNJSixhQUNLLEdBQThCQSxPQUEzQkEsV0FBV0ssWUFBWSxFQUFDLEtBQThDTCxPQUEzQ0EsV0FBV00sVUFBVSxFQUFDLHVCQUFrRSxPQUE3Q04sV0FBV0ssWUFBWSxLQUFLLElBQUlQLFVBQVUsTUFDbkhBOzs7Ozs7MEJBR1YsOERBQUNJO2dCQUFJQyxXQUFVOztvQkFDVkoseUJBQ0csOERBQUNRO3dCQUNHQyxTQUFTVDt3QkFDVEksV0FBVTtrQ0FDYjs7Ozs7O29CQUlKRiwrQkFDRyw4REFBQ007d0JBQ0dDLFNBQVNQO3dCQUNURSxXQUFVO2tDQUNiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPckI7S0E3QmdCTiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL3NyYy9jb21wb25lbnRzL3NoYXJlZC9FcnJvck1lc3NhZ2UudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNsZWFyQmFkUmVsYXlDYWNoZSB9IGZyb20gXCJAL2xpYi9ub3N0ci9yZWxheVwiO1xuXG5pbnRlcmZhY2UgRXJyb3JNZXNzYWdlUHJvcHMge1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICBvblJldHJ5PzogKCkgPT4gdm9pZDtcbiAgICByZWxheVN0YXRzPzoge1xuICAgICAgICBoZWFsdGh5Q291bnQ6IG51bWJlcjtcbiAgICAgICAgdG90YWxDb3VudDogbnVtYmVyO1xuICAgIH0gfCBudWxsO1xuICAgIG9uQ2xlYXJSZWxheXM/OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRXJyb3JNZXNzYWdlKHsgbWVzc2FnZSwgb25SZXRyeSwgcmVsYXlTdGF0cywgb25DbGVhclJlbGF5cyB9OiBFcnJvck1lc3NhZ2VQcm9wcykge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctcmVkLTUwMC8xMCBib3JkZXIgYm9yZGVyLXJlZC01MDAvMjAgcm91bmRlZC1sZyBwLTQgdGV4dC1yZWQtNDAwIGJhY2tkcm9wLWJsdXItbGdcIj5cbiAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgIHtyZWxheVN0YXRzXG4gICAgICAgICAgICAgICAgICAgID8gYCR7cmVsYXlTdGF0cy5oZWFsdGh5Q291bnR9LyR7cmVsYXlTdGF0cy50b3RhbENvdW50fSByZWxheXMgY29ubmVjdGVkLiAke3JlbGF5U3RhdHMuaGVhbHRoeUNvdW50ID09PSAwID8gbWVzc2FnZSA6ICcnfWBcbiAgICAgICAgICAgICAgICAgICAgOiBtZXNzYWdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGdhcC0yIG10LTJcIj5cbiAgICAgICAgICAgICAgICB7b25SZXRyeSAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e29uUmV0cnl9XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC00IHB5LTEgYmctcmVkLTUwMC8yMCBob3ZlcjpiZy1yZWQtNTAwLzMwIHJvdW5kZWQtZnVsbCB0ZXh0LXNtIHRyYW5zaXRpb25cIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICBSZXRyeVxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIHtvbkNsZWFyUmVsYXlzICYmIChcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17b25DbGVhclJlbGF5c31cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMSBiZy1ibHVlLTUwMC8yMCBob3ZlcjpiZy1ibHVlLTUwMC8zMCByb3VuZGVkLWZ1bGwgdGV4dC1zbSB0cmFuc2l0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgUmVzZXQgUmVsYXlzXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn1cbiJdLCJuYW1lcyI6WyJFcnJvck1lc3NhZ2UiLCJtZXNzYWdlIiwib25SZXRyeSIsInJlbGF5U3RhdHMiLCJvbkNsZWFyUmVsYXlzIiwiZGl2IiwiY2xhc3NOYW1lIiwicCIsImhlYWx0aHlDb3VudCIsInRvdGFsQ291bnQiLCJidXR0b24iLCJvbkNsaWNrIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/shared/ErrorMessage.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/shared/MediaPlayer.tsx":
/*!***********************************************!*\
  !*** ./src/components/shared/MediaPlayer.tsx ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MediaPlayer: () => (/* binding */ MediaPlayer)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-player */ \"(app-pages-browser)/./node_modules/react-player/lib/index.js\");\n/* harmony import */ var react_player__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_player__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst MediaPlayer = (param)=>{\n    let { url, className = '', onClick } = param;\n    // Platform detection\n    let label = '';\n    if (/youtube\\.com|youtu\\.be/.test(url)) label = 'YouTube';\n    else if (/soundcloud\\.com/.test(url)) label = 'SoundCloud';\n    else if (/vimeo\\.com/.test(url)) label = 'Vimeo';\n    else if (/twitch\\.tv/.test(url)) label = 'Twitch';\n    else if (/facebook\\.com/.test(url)) label = 'Facebook';\n    else if (url.match(/\\.(mp4|webm)$/i)) label = 'Video';\n    else if (url.match(/\\.(mp3|wav|ogg)$/i)) label = 'Audio';\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: className,\n        onClick: onClick,\n        style: {\n            position: 'relative'\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react_player__WEBPACK_IMPORTED_MODULE_2___default()), {\n                url: url,\n                controls: true,\n                width: \"100%\",\n                height: label === 'Audio' ? '50px' : '360px',\n                style: {\n                    borderRadius: '0.75rem',\n                    overflow: 'hidden',\n                    background: '#000'\n                },\n                config: {\n                    file: {\n                        attributes: {\n                            controlsList: 'nodownload',\n                            style: {\n                                maxHeight: '24rem',\n                                width: '100%'\n                            }\n                        }\n                    }\n                }\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/shared/MediaPlayer.tsx\",\n                lineNumber: 22,\n                columnNumber: 13\n            }, undefined),\n            label && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"absolute top-2 left-2 bg-black/70 text-white text-xs px-2 py-1 rounded shadow\",\n                style: {\n                    pointerEvents: 'none',\n                    zIndex: 2\n                },\n                \"aria-label\": label + ' media',\n                children: label\n            }, void 0, false, {\n                fileName: \"/Users/scarnes/workspace/src/components/shared/MediaPlayer.tsx\",\n                lineNumber: 38,\n                columnNumber: 17\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/scarnes/workspace/src/components/shared/MediaPlayer.tsx\",\n        lineNumber: 21,\n        columnNumber: 9\n    }, undefined);\n};\n_c = MediaPlayer;\nvar _c;\n$RefreshReg$(_c, \"MediaPlayer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3NoYXJlZC9NZWRpYVBsYXllci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEwQjtBQUNhO0FBUWhDLE1BQU1FLGNBQTBDO1FBQUMsRUFBRUMsR0FBRyxFQUFFQyxZQUFZLEVBQUUsRUFBRUMsT0FBTyxFQUFFO0lBQ3BGLHFCQUFxQjtJQUNyQixJQUFJQyxRQUFRO0lBQ1osSUFBSSx5QkFBeUJDLElBQUksQ0FBQ0osTUFBTUcsUUFBUTtTQUMzQyxJQUFJLGtCQUFrQkMsSUFBSSxDQUFDSixNQUFNRyxRQUFRO1NBQ3pDLElBQUksYUFBYUMsSUFBSSxDQUFDSixNQUFNRyxRQUFRO1NBQ3BDLElBQUksYUFBYUMsSUFBSSxDQUFDSixNQUFNRyxRQUFRO1NBQ3BDLElBQUksZ0JBQWdCQyxJQUFJLENBQUNKLE1BQU1HLFFBQVE7U0FDdkMsSUFBSUgsSUFBSUssS0FBSyxDQUFDLG1CQUFtQkYsUUFBUTtTQUN6QyxJQUFJSCxJQUFJSyxLQUFLLENBQUMsc0JBQXNCRixRQUFRO0lBQ2pELHFCQUNJLDhEQUFDRztRQUFJTCxXQUFXQTtRQUFXQyxTQUFTQTtRQUFTSyxPQUFPO1lBQUVDLFVBQVU7UUFBVzs7MEJBQ3ZFLDhEQUFDVixxREFBV0E7Z0JBQ1JFLEtBQUtBO2dCQUNMUyxRQUFRO2dCQUNSQyxPQUFNO2dCQUNOQyxRQUFRUixVQUFVLFVBQVUsU0FBUztnQkFDckNJLE9BQU87b0JBQUVLLGNBQWM7b0JBQVdDLFVBQVU7b0JBQVVDLFlBQVk7Z0JBQU87Z0JBQ3pFQyxRQUFRO29CQUNKQyxNQUFNO3dCQUNGQyxZQUFZOzRCQUNSQyxjQUFjOzRCQUNkWCxPQUFPO2dDQUFFWSxXQUFXO2dDQUFTVCxPQUFPOzRCQUFPO3dCQUMvQztvQkFDSjtnQkFDSjs7Ozs7O1lBRUhQLHVCQUNHLDhEQUFDaUI7Z0JBQ0duQixXQUFVO2dCQUNWTSxPQUFPO29CQUFFYyxlQUFlO29CQUFRQyxRQUFRO2dCQUFFO2dCQUMxQ0MsY0FBWXBCLFFBQVE7MEJBRW5CQTs7Ozs7Ozs7Ozs7O0FBS3JCLEVBQUU7S0F0Q1dKIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvc3JjL2NvbXBvbmVudHMvc2hhcmVkL01lZGlhUGxheWVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0UGxheWVyIGZyb20gJ3JlYWN0LXBsYXllcic7XG5cbmludGVyZmFjZSBNZWRpYVBsYXllclByb3BzIHtcbiAgICB1cmw6IHN0cmluZztcbiAgICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gICAgb25DbGljaz86IChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgTWVkaWFQbGF5ZXI6IFJlYWN0LkZDPE1lZGlhUGxheWVyUHJvcHM+ID0gKHsgdXJsLCBjbGFzc05hbWUgPSAnJywgb25DbGljayB9KSA9PiB7XG4gICAgLy8gUGxhdGZvcm0gZGV0ZWN0aW9uXG4gICAgbGV0IGxhYmVsID0gJyc7XG4gICAgaWYgKC95b3V0dWJlXFwuY29tfHlvdXR1XFwuYmUvLnRlc3QodXJsKSkgbGFiZWwgPSAnWW91VHViZSc7XG4gICAgZWxzZSBpZiAoL3NvdW5kY2xvdWRcXC5jb20vLnRlc3QodXJsKSkgbGFiZWwgPSAnU291bmRDbG91ZCc7XG4gICAgZWxzZSBpZiAoL3ZpbWVvXFwuY29tLy50ZXN0KHVybCkpIGxhYmVsID0gJ1ZpbWVvJztcbiAgICBlbHNlIGlmICgvdHdpdGNoXFwudHYvLnRlc3QodXJsKSkgbGFiZWwgPSAnVHdpdGNoJztcbiAgICBlbHNlIGlmICgvZmFjZWJvb2tcXC5jb20vLnRlc3QodXJsKSkgbGFiZWwgPSAnRmFjZWJvb2snO1xuICAgIGVsc2UgaWYgKHVybC5tYXRjaCgvXFwuKG1wNHx3ZWJtKSQvaSkpIGxhYmVsID0gJ1ZpZGVvJztcbiAgICBlbHNlIGlmICh1cmwubWF0Y2goL1xcLihtcDN8d2F2fG9nZykkL2kpKSBsYWJlbCA9ICdBdWRpbyc7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0gb25DbGljaz17b25DbGlja30gc3R5bGU9e3sgcG9zaXRpb246ICdyZWxhdGl2ZScgfX0+XG4gICAgICAgICAgICA8UmVhY3RQbGF5ZXJcbiAgICAgICAgICAgICAgICB1cmw9e3VybH1cbiAgICAgICAgICAgICAgICBjb250cm9sc1xuICAgICAgICAgICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICAgICAgICAgICAgaGVpZ2h0PXtsYWJlbCA9PT0gJ0F1ZGlvJyA/ICc1MHB4JyA6ICczNjBweCd9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgYm9yZGVyUmFkaXVzOiAnMC43NXJlbScsIG92ZXJmbG93OiAnaGlkZGVuJywgYmFja2dyb3VuZDogJyMwMDAnIH19XG4gICAgICAgICAgICAgICAgY29uZmlnPXt7XG4gICAgICAgICAgICAgICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sc0xpc3Q6ICdub2Rvd25sb2FkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogeyBtYXhIZWlnaHQ6ICcyNHJlbScsIHdpZHRoOiAnMTAwJScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7bGFiZWwgJiYgKFxuICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImFic29sdXRlIHRvcC0yIGxlZnQtMiBiZy1ibGFjay83MCB0ZXh0LXdoaXRlIHRleHQteHMgcHgtMiBweS0xIHJvdW5kZWQgc2hhZG93XCJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgcG9pbnRlckV2ZW50czogJ25vbmUnLCB6SW5kZXg6IDIgfX1cbiAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD17bGFiZWwgKyAnIG1lZGlhJ31cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHtsYWJlbH1cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlJlYWN0UGxheWVyIiwiTWVkaWFQbGF5ZXIiLCJ1cmwiLCJjbGFzc05hbWUiLCJvbkNsaWNrIiwibGFiZWwiLCJ0ZXN0IiwibWF0Y2giLCJkaXYiLCJzdHlsZSIsInBvc2l0aW9uIiwiY29udHJvbHMiLCJ3aWR0aCIsImhlaWdodCIsImJvcmRlclJhZGl1cyIsIm92ZXJmbG93IiwiYmFja2dyb3VuZCIsImNvbmZpZyIsImZpbGUiLCJhdHRyaWJ1dGVzIiwiY29udHJvbHNMaXN0IiwibWF4SGVpZ2h0Iiwic3BhbiIsInBvaW50ZXJFdmVudHMiLCJ6SW5kZXgiLCJhcmlhLWxhYmVsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/shared/MediaPlayer.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/ui/tabs.tsx":
/*!************************************!*\
  !*** ./src/components/ui/tabs.tsx ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tabs: () => (/* binding */ Tabs),\n/* harmony export */   TabsContent: () => (/* binding */ TabsContent),\n/* harmony export */   TabsList: () => (/* binding */ TabsList),\n/* harmony export */   TabsTrigger: () => (/* binding */ TabsTrigger)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nfunction Tabs(param) {\n    let { defaultValue, onValueChange, children } = param;\n    _s();\n    const [value, setValue] = react__WEBPACK_IMPORTED_MODULE_1__.useState(defaultValue);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect({\n        \"Tabs.useEffect\": ()=>{\n            if (onValueChange) onValueChange(value);\n        }\n    }[\"Tabs.useEffect\"], [\n        value\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: react__WEBPACK_IMPORTED_MODULE_1__.Children.map(children, (child)=>{\n            if (/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.isValidElement(child)) {\n                return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.cloneElement(child, {\n                    tabsValue: value,\n                    setTabsValue: setValue\n                });\n            }\n            return child;\n        })\n    }, void 0, false, {\n        fileName: \"/Users/scarnes/workspace/src/components/ui/tabs.tsx\",\n        lineNumber: 8,\n        columnNumber: 9\n    }, this);\n}\n_s(Tabs, \"zp4Iw+LU/f7rg16WySk7ISePCcE=\");\n_c = Tabs;\nfunction TabsList(param) {\n    let { children, className } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: className,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/scarnes/workspace/src/components/ui/tabs.tsx\",\n        lineNumber: 20,\n        columnNumber: 12\n    }, this);\n}\n_c1 = TabsList;\nfunction TabsTrigger(param) {\n    let { value, children, className, tabsValue, setTabsValue } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        className: className + (tabsValue === value ? \" bg-gray-200\" : \"\"),\n        onClick: ()=>setTabsValue && setTabsValue(value),\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/scarnes/workspace/src/components/ui/tabs.tsx\",\n        lineNumber: 24,\n        columnNumber: 12\n    }, this);\n}\n_c2 = TabsTrigger;\nfunction TabsContent(param) {\n    let { value, children, tabsValue, className } = param;\n    if (tabsValue !== value) return null;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: className,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/scarnes/workspace/src/components/ui/tabs.tsx\",\n        lineNumber: 29,\n        columnNumber: 12\n    }, this);\n}\n_c3 = TabsContent;\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"Tabs\");\n$RefreshReg$(_c1, \"TabsList\");\n$RefreshReg$(_c2, \"TabsTrigger\");\n$RefreshReg$(_c3, \"TabsContent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL3VpL3RhYnMudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErQjtBQUV4QixTQUFTQyxLQUFLLEtBQXFJO1FBQXJJLEVBQUVDLFlBQVksRUFBRUMsYUFBYSxFQUFFQyxRQUFRLEVBQThGLEdBQXJJOztJQUNqQixNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR04sMkNBQWMsQ0FBQ0U7SUFDekNGLDRDQUFlOzBCQUFDO1lBQVEsSUFBSUcsZUFBZUEsY0FBY0U7UUFBUTt5QkFBRztRQUFDQTtLQUFNO0lBRTNFLHFCQUNJLDhEQUFDSTtrQkFDSVQsMkNBQWMsQ0FBQ1csR0FBRyxDQUFDUCxVQUFVUSxDQUFBQTtZQUMxQixrQkFBSVosaURBQW9CLENBQStEWSxRQUFRO2dCQUMzRixxQkFBT1osK0NBQWtCLENBQUNZLE9BQU87b0JBQUVHLFdBQVdWO29CQUFPVyxjQUFjVjtnQkFBUztZQUNoRjtZQUNBLE9BQU9NO1FBQ1g7Ozs7OztBQUdaO0dBZGdCWDtLQUFBQTtBQWdCVCxTQUFTZ0IsU0FBUyxLQUEwRTtRQUExRSxFQUFFYixRQUFRLEVBQUVjLFNBQVMsRUFBcUQsR0FBMUU7SUFDckIscUJBQU8sOERBQUNUO1FBQUlTLFdBQVdBO2tCQUFZZDs7Ozs7O0FBQ3ZDO01BRmdCYTtBQUlULFNBQVNFLFlBQVksS0FBbUw7UUFBbkwsRUFBRWQsS0FBSyxFQUFFRCxRQUFRLEVBQUVjLFNBQVMsRUFBRUgsU0FBUyxFQUFFQyxZQUFZLEVBQThILEdBQW5MO0lBQ3hCLHFCQUFPLDhEQUFDSTtRQUFPRixXQUFXQSxZQUFhSCxDQUFBQSxjQUFjVixRQUFRLGlCQUFpQixFQUFDO1FBQUlnQixTQUFTLElBQU1MLGdCQUFnQkEsYUFBYVg7a0JBQVNEOzs7Ozs7QUFDNUk7TUFGZ0JlO0FBSVQsU0FBU0csWUFBWSxLQUErSDtRQUEvSCxFQUFFakIsS0FBSyxFQUFFRCxRQUFRLEVBQUVXLFNBQVMsRUFBRUcsU0FBUyxFQUF3RixHQUEvSDtJQUN4QixJQUFJSCxjQUFjVixPQUFPLE9BQU87SUFDaEMscUJBQU8sOERBQUNJO1FBQUlTLFdBQVdBO2tCQUFZZDs7Ozs7O0FBQ3ZDO01BSGdCa0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9zcmMvY29tcG9uZW50cy91aS90YWJzLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIFRhYnMoeyBkZWZhdWx0VmFsdWUsIG9uVmFsdWVDaGFuZ2UsIGNoaWxkcmVuIH06IHsgZGVmYXVsdFZhbHVlOiBzdHJpbmcsIG9uVmFsdWVDaGFuZ2U/OiAodmFsOiBzdHJpbmcpID0+IHZvaWQsIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfSkge1xuICAgIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoZGVmYXVsdFZhbHVlKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4geyBpZiAob25WYWx1ZUNoYW5nZSkgb25WYWx1ZUNoYW5nZSh2YWx1ZSk7IH0sIFt2YWx1ZV0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIHtSZWFjdC5DaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQ8eyB0YWJzVmFsdWU/OiBzdHJpbmc7IHNldFRhYnNWYWx1ZT86ICh2YWw6IHN0cmluZykgPT4gdm9pZCB9PihjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgeyB0YWJzVmFsdWU6IHZhbHVlLCBzZXRUYWJzVmFsdWU6IHNldFZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFRhYnNMaXN0KHsgY2hpbGRyZW4sIGNsYXNzTmFtZSB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUsIGNsYXNzTmFtZT86IHN0cmluZyB9KSB7XG4gICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9PntjaGlsZHJlbn08L2Rpdj47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBUYWJzVHJpZ2dlcih7IHZhbHVlLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCB0YWJzVmFsdWUsIHNldFRhYnNWYWx1ZSB9OiB7IHZhbHVlOiBzdHJpbmcsIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUsIGNsYXNzTmFtZT86IHN0cmluZywgdGFic1ZhbHVlPzogc3RyaW5nLCBzZXRUYWJzVmFsdWU/OiAodmFsOiBzdHJpbmcpID0+IHZvaWQgfSkge1xuICAgIHJldHVybiA8YnV0dG9uIGNsYXNzTmFtZT17Y2xhc3NOYW1lICsgKHRhYnNWYWx1ZSA9PT0gdmFsdWUgPyBcIiBiZy1ncmF5LTIwMFwiIDogXCJcIil9IG9uQ2xpY2s9eygpID0+IHNldFRhYnNWYWx1ZSAmJiBzZXRUYWJzVmFsdWUodmFsdWUpfT57Y2hpbGRyZW59PC9idXR0b24+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gVGFic0NvbnRlbnQoeyB2YWx1ZSwgY2hpbGRyZW4sIHRhYnNWYWx1ZSwgY2xhc3NOYW1lIH06IHsgdmFsdWU6IHN0cmluZywgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSwgdGFic1ZhbHVlPzogc3RyaW5nLCBjbGFzc05hbWU/OiBzdHJpbmcgfSkge1xuICAgIGlmICh0YWJzVmFsdWUgIT09IHZhbHVlKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+e2NoaWxkcmVufTwvZGl2Pjtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlRhYnMiLCJkZWZhdWx0VmFsdWUiLCJvblZhbHVlQ2hhbmdlIiwiY2hpbGRyZW4iLCJ2YWx1ZSIsInNldFZhbHVlIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJkaXYiLCJDaGlsZHJlbiIsIm1hcCIsImNoaWxkIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJ0YWJzVmFsdWUiLCJzZXRUYWJzVmFsdWUiLCJUYWJzTGlzdCIsImNsYXNzTmFtZSIsIlRhYnNUcmlnZ2VyIiwiYnV0dG9uIiwib25DbGljayIsIlRhYnNDb250ZW50Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/ui/tabs.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/useNostr.ts":
/*!*******************************!*\
  !*** ./src/hooks/useNostr.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RELAYS: () => (/* binding */ RELAYS),\n/* harmony export */   useNostr: () => (/* binding */ useNostr)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/nostr/relay */ \"(app-pages-browser)/./src/lib/nostr/relay.ts\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/../node_modules/nostr-tools/lib/esm/index.js\");\n\n\n\nconst RELAYS = [\n    \"wss://relay.damus.io\",\n    \"wss://relay.nostr.band\",\n    \"wss://nostr-pub.wellorder.net\"\n];\nfunction useNostr() {\n    const [pubkey, setPubkey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [events, setEvents] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [profile, setProfile] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null); // Current user's profile\n    const [following, setFollowing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]); // List of pubkeys the user follows\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false); // General loading state\n    const [relayStats, setRelayStats] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const profileCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    const getWindowNostr = ()=>{\n        return window.nostr;\n    };\n    // --- Persist pubkey in localStorage ---\n    // On mount, rehydrate pubkey from localStorage if present\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if (true) {\n                const storedPubkey = window.localStorage.getItem('nostr_pubkey');\n                if (storedPubkey && !pubkey) {\n                    setPubkey(storedPubkey);\n                }\n            }\n        }\n    }[\"useNostr.useEffect\"], []);\n    // When pubkey changes, persist to localStorage\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if ( true && pubkey) {\n                window.localStorage.setItem('nostr_pubkey', pubkey);\n            }\n        }\n    }[\"useNostr.useEffect\"], [\n        pubkey\n    ]);\n    // Auth/login\n    const login = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[login]\": async ()=>{\n            const nostr = getWindowNostr();\n            if (nostr) {\n                setIsLoading(true);\n                setError(null);\n                try {\n                    const pk = await nostr.getPublicKey();\n                    setPubkey(pk);\n                    // Optional: Schnorr signing for custom message (e.g., NIP-42 auth)\n                    const message = \"Login to RAW.ROCKS: \".concat(Date.now());\n                    if (typeof nostr.signMessage === \"function\") {\n                        try {\n                            const signature = await nostr.signMessage(message);\n                            console.log(\"Signed login message:\", signature);\n                        } catch (err) {\n                            console.warn(\"signMessage for login failed:\", err);\n                        }\n                    } else {\n                        console.warn(\"signMessage is not supported by this NOSTR extension.\");\n                    }\n                    // Load profile from relays\n                    const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                    if (healthyRelays.length > 0) {\n                        const userProfileData = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrProfile)(healthyRelays, pk);\n                        if (userProfileData) {\n                            const userProfile = {\n                                ...userProfileData,\n                                pubkey: pk,\n                                username: userProfileData.name || pk\n                            };\n                            setProfile(userProfile);\n                            profileCache.current[pk] = userProfile;\n                        }\n                    } else {\n                        console.warn(\"No healthy relays to fetch initial profile.\");\n                    }\n                } catch (err) {\n                    console.error(\"Login failed:\", err);\n                    setError(err.message || \"Login failed. Please ensure your NOSTR extension is configured.\");\n                    setPubkey(null);\n                } finally{\n                    setIsLoading(false);\n                }\n            } else {\n                setError(\"NOSTR extension not found. Please install a NOSTR browser extension.\");\n            // alert(\"NOSTR extension not found. Please install a NOSTR browser extension.\");\n            }\n        }\n    }[\"useNostr.useCallback[login]\"], []);\n    // Fetch feed with pagination support\n    const fetchEvents = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[fetchEvents]\": async (options)=>{\n            setIsLoading(true);\n            setError(null);\n            try {\n                const { healthyRelays, healthyCount, totalCount } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                setRelayStats({\n                    healthyCount,\n                    totalCount\n                });\n                if (!healthyRelays.length) {\n                    setError(\"No healthy relays available to fetch feed.\");\n                    return false;\n                }\n                const fetchedNostrEvents = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrFeed)(healthyRelays, {\n                    limit: 20,\n                    ...options\n                });\n                const uniquePubkeys = Array.from(new Set(fetchedNostrEvents.map({\n                    \"useNostr.useCallback[fetchEvents].uniquePubkeys\": (ev)=>ev.pubkey\n                }[\"useNostr.useCallback[fetchEvents].uniquePubkeys\"])));\n                const profilesToFetch = uniquePubkeys.filter({\n                    \"useNostr.useCallback[fetchEvents].profilesToFetch\": (pk)=>!profileCache.current[pk]\n                }[\"useNostr.useCallback[fetchEvents].profilesToFetch\"]);\n                if (profilesToFetch.length > 0) {\n                    await Promise.all(profilesToFetch.map({\n                        \"useNostr.useCallback[fetchEvents]\": async (pk)=>{\n                            const meta = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrProfile)(healthyRelays, pk);\n                            if (meta) {\n                                profileCache.current[pk] = {\n                                    ...meta,\n                                    pubkey: pk,\n                                    username: meta.name || pk\n                                };\n                            }\n                        }\n                    }[\"useNostr.useCallback[fetchEvents]\"]));\n                }\n                const processedFeed = fetchedNostrEvents.map({\n                    \"useNostr.useCallback[fetchEvents].processedFeed\": (ev)=>{\n                        let media = [];\n                        const urlRegex = /(https?:\\/\\/(?:[\\w-]+\\.)+[\\w-]+(?:\\/[\\w\\-._~:/?#[\\]@!$&'()*+,;=]*)?\\.(?:jpg|jpeg|png|gif|mp4|webm))/gi;\n                        let match;\n                        while(match = urlRegex.exec(ev.content)){\n                            media.push(match[1]);\n                        }\n                        const userProf = profileCache.current[ev.pubkey] || {\n                            pubkey: ev.pubkey,\n                            username: ev.pubkey\n                        };\n                        const picture = userProf.picture || \"/file.svg\"; // Default avatar\n                        return {\n                            ...ev,\n                            media,\n                            profile: {\n                                ...userProf,\n                                display_name: userProf.display_name || userProf.username || \"\".concat(ev.pubkey.slice(0, 6), \"...\").concat(ev.pubkey.slice(-4)),\n                                picture: userProf.picture || \"/file.svg\",\n                                username: userProf.username || ev.pubkey,\n                                pubkey: ev.pubkey\n                            }\n                        };\n                    }\n                }[\"useNostr.useCallback[fetchEvents].processedFeed\"]);\n                if (options === null || options === void 0 ? void 0 : options.until) {\n                    setEvents({\n                        \"useNostr.useCallback[fetchEvents]\": (prev)=>{\n                            const existingIds = new Set(prev.map({\n                                \"useNostr.useCallback[fetchEvents]\": (e)=>e.id\n                            }[\"useNostr.useCallback[fetchEvents]\"]));\n                            const newEvents = processedFeed.filter({\n                                \"useNostr.useCallback[fetchEvents].newEvents\": (e)=>!existingIds.has(e.id)\n                            }[\"useNostr.useCallback[fetchEvents].newEvents\"]);\n                            return [\n                                ...prev,\n                                ...newEvents\n                            ].sort({\n                                \"useNostr.useCallback[fetchEvents]\": (a, b)=>b.created_at - a.created_at\n                            }[\"useNostr.useCallback[fetchEvents]\"]);\n                        }\n                    }[\"useNostr.useCallback[fetchEvents]\"]);\n                } else {\n                    setEvents(processedFeed.sort({\n                        \"useNostr.useCallback[fetchEvents]\": (a, b)=>b.created_at - a.created_at\n                    }[\"useNostr.useCallback[fetchEvents]\"]));\n                }\n                return processedFeed.length > 0;\n            } catch (err) {\n                console.error(\"Error fetching events:\", err);\n                setError(err.message || \"Failed to fetch posts. Please try again later.\");\n                return false;\n            } finally{\n                setIsLoading(false);\n            }\n        }\n    }[\"useNostr.useCallback[fetchEvents]\"], []);\n    // Helper to publish a signed event\n    const publishEvent = async (signedEvent)=>{\n        try {\n            const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n            if (!healthyRelays.length) {\n                setError(\"No healthy relays available to publish event.\");\n                return false;\n            }\n            const pool = new nostr_tools__WEBPACK_IMPORTED_MODULE_2__.SimplePool();\n            const promises = pool.publish(healthyRelays, signedEvent);\n            // Wait for at least one successful publish or timeout\n            // This is a simplified version; nostr-tools' publish returns promises for each relay\n            await Promise.any(promises.map((p)=>Promise.race([\n                    p,\n                    new Promise((_, rej)=>setTimeout(()=>rej(new Error('timeout')), 5000))\n                ])));\n            pool.close(healthyRelays); // Close connections after publishing\n            return true;\n        } catch (err) {\n            console.error(\"Failed to publish event to relays:\", err);\n            setError(\"Failed to publish event. Some relays might be offline.\");\n            return false;\n        }\n    };\n    // Post event (sign and publish using extension)\n    const post = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[post]\": async (content)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                const unsignedEvent = {\n                    kind: 1,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: [],\n                    content\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    // Optimistic update\n                    const currentProfile = profileCache.current[pubkey] || {\n                        pubkey,\n                        username: pubkey\n                    };\n                    setEvents({\n                        \"useNostr.useCallback[post]\": (prev)=>[\n                                {\n                                    id: signedEvent.id,\n                                    pubkey: signedEvent.pubkey,\n                                    content: signedEvent.content,\n                                    created_at: signedEvent.created_at,\n                                    kind: signedEvent.kind,\n                                    tags: signedEvent.tags,\n                                    media: [],\n                                    profile: {\n                                        display_name: currentProfile.display_name || currentProfile.username || \"\".concat(pubkey.slice(0, 6), \"...\").concat(pubkey.slice(-4)),\n                                        username: currentProfile.username || pubkey,\n                                        picture: currentProfile.picture || \"/file.svg\",\n                                        pubkey: pubkey\n                                    }\n                                },\n                                ...prev\n                            ].sort({\n                                \"useNostr.useCallback[post]\": (a, b)=>b.created_at - a.created_at\n                            }[\"useNostr.useCallback[post]\"])\n                    }[\"useNostr.useCallback[post]\"]);\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to post event:\", err);\n                setError(err.message || \"Failed to post. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[post]\"], [\n        pubkey,\n        profile\n    ]);\n    // Update profile (Kind 0)\n    const updateProfileMetadata = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[updateProfileMetadata]\": async (newProfileData)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                // Ensure only valid profile fields are included\n                const contentPayload = {};\n                if (newProfileData.username !== undefined) contentPayload.name = newProfileData.username; // Always set 'name' from 'username'\n                if (newProfileData.display_name !== undefined) contentPayload.display_name = newProfileData.display_name;\n                if (newProfileData.about !== undefined) contentPayload.about = newProfileData.about;\n                if (newProfileData.picture !== undefined) contentPayload.picture = newProfileData.picture;\n                if (newProfileData.banner !== undefined) contentPayload.banner = newProfileData.banner;\n                if (newProfileData.website !== undefined) contentPayload.website = newProfileData.website;\n                if (newProfileData.lud06 !== undefined) contentPayload.lud06 = newProfileData.lud06;\n                if (newProfileData.lud16 !== undefined) contentPayload.lud16 = newProfileData.lud16;\n                if (newProfileData.nip05 !== undefined) contentPayload.nip05 = newProfileData.nip05;\n                const unsignedEvent = {\n                    kind: 0,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: [],\n                    content: JSON.stringify(contentPayload)\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    const updatedFullProfile = {\n                        ...profile,\n                        ...newProfileData,\n                        pubkey,\n                        username: newProfileData.username\n                    };\n                    setProfile(updatedFullProfile);\n                    profileCache.current[pubkey] = updatedFullProfile; // Update cache\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to update profile:\", err);\n                setError(err.message || \"Failed to update profile. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[updateProfileMetadata]\"], [\n        pubkey,\n        profile\n    ]);\n    // Manage contact list (Kind 3)\n    const updateContactList = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[updateContactList]\": async (newFollowingPubkeys)=>{\n            const nostr = getWindowNostr();\n            if (!pubkey || !nostr) {\n                setError(\"Not logged in or NOSTR extension not found.\");\n                return;\n            }\n            setIsLoading(true);\n            setError(null);\n            try {\n                // NIP-02 recommends preserving existing non-\"p\" tags if any.\n                // For simplicity, this example only manages \"p\" tags.\n                // Fetch existing contact list to preserve other tags if necessary (more complex)\n                const tags = newFollowingPubkeys.map({\n                    \"useNostr.useCallback[updateContactList].tags\": (pk)=>[\n                            \"p\",\n                            pk\n                        ]\n                }[\"useNostr.useCallback[updateContactList].tags\"]);\n                const unsignedEvent = {\n                    kind: 3,\n                    pubkey,\n                    created_at: Math.floor(Date.now() / 1000),\n                    tags: tags,\n                    content: \"\"\n                };\n                const signedEvent = await nostr.signEvent(unsignedEvent);\n                if (await publishEvent(signedEvent)) {\n                    setFollowing(newFollowingPubkeys);\n                    return true;\n                }\n            } catch (err) {\n                console.error(\"Failed to update contact list:\", err);\n                setError(err.message || \"Failed to update contact list. Please try again.\");\n            } finally{\n                setIsLoading(false);\n            }\n            return false;\n        }\n    }[\"useNostr.useCallback[updateContactList]\"], [\n        pubkey\n    ]);\n    const followUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[followUser]\": async (userPubkey)=>{\n            if (following.includes(userPubkey)) return true; // Already following\n            const newFollowingList = [\n                ...following,\n                userPubkey\n            ];\n            return await updateContactList(newFollowingList);\n        }\n    }[\"useNostr.useCallback[followUser]\"], [\n        following,\n        updateContactList\n    ]);\n    const unfollowUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[unfollowUser]\": async (userPubkey)=>{\n            if (!following.includes(userPubkey)) return true; // Not following\n            const newFollowingList = following.filter({\n                \"useNostr.useCallback[unfollowUser].newFollowingList\": (pk)=>pk !== userPubkey\n            }[\"useNostr.useCallback[unfollowUser].newFollowingList\"]);\n            return await updateContactList(newFollowingList);\n        }\n    }[\"useNostr.useCallback[unfollowUser]\"], [\n        following,\n        updateContactList\n    ]);\n    const isFollowing = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useNostr.useCallback[isFollowing]\": (userPubkey)=>{\n            return following.includes(userPubkey);\n        }\n    }[\"useNostr.useCallback[isFollowing]\"], [\n        following\n    ]);\n    // Effect to load initial following list for the logged-in user\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useNostr.useEffect\": ()=>{\n            if (pubkey) {\n                ({\n                    \"useNostr.useEffect\": async ()=>{\n                        try {\n                            const { healthyRelays } = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.getHealthyRelays)();\n                            if (healthyRelays.length === 0) return;\n                            // Use correct filter type for nostr-tools\n                            const filter = {\n                                kinds: [\n                                    3\n                                ],\n                                authors: [\n                                    pubkey\n                                ],\n                                limit: 1\n                            };\n                            // @ts-ignore: Filter type is broader than FeedOptions\n                            const contactListEvents = await (0,_lib_nostr_relay__WEBPACK_IMPORTED_MODULE_1__.fetchNostrFeed)(healthyRelays, filter);\n                            if (contactListEvents.length > 0) {\n                                const latestContactList = contactListEvents.sort({\n                                    \"useNostr.useEffect\": (a, b)=>b.created_at - a.created_at\n                                }[\"useNostr.useEffect\"])[0];\n                                const followedPubkeys = latestContactList.tags.filter({\n                                    \"useNostr.useEffect.followedPubkeys\": (tag)=>tag[0] === 'p' && tag[1]\n                                }[\"useNostr.useEffect.followedPubkeys\"]).map({\n                                    \"useNostr.useEffect.followedPubkeys\": (tag)=>tag[1]\n                                }[\"useNostr.useEffect.followedPubkeys\"]);\n                                setFollowing(followedPubkeys);\n                            }\n                        } catch (err) {\n                            console.error(\"Failed to fetch initial contact list:\", err);\n                        }\n                    }\n                })[\"useNostr.useEffect\"]();\n            } else {\n                setFollowing([]); // Clear following list if not logged in\n            }\n        }\n    }[\"useNostr.useEffect\"], [\n        pubkey\n    ]);\n    return {\n        pubkey,\n        events,\n        profile,\n        following,\n        error,\n        isLoading,\n        relayStats,\n        login,\n        fetchEvents,\n        post,\n        updateProfile: updateProfileMetadata,\n        followUser,\n        unfollowUser,\n        isFollowing,\n        setEvents,\n        setProfile,\n        setFollowing\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VOb3N0ci50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUU7QUFDdUI7QUFTeUI7QUFnQjFHLE1BQU1RLFNBQVM7SUFDbEI7SUFDQTtJQUNBO0NBRUgsQ0FBQztBQTJCSyxTQUFTQztJQUNaLE1BQU0sQ0FBQ0MsUUFBUUMsVUFBVSxHQUFHWCwrQ0FBUUEsQ0FBZ0I7SUFDcEQsTUFBTSxDQUFDWSxRQUFRQyxVQUFVLEdBQUdiLCtDQUFRQSxDQUFlLEVBQUU7SUFDckQsTUFBTSxDQUFDYyxTQUFTQyxXQUFXLEdBQUdmLCtDQUFRQSxDQUFzQixPQUFPLHlCQUF5QjtJQUM1RixNQUFNLENBQUNnQixXQUFXQyxhQUFhLEdBQUdqQiwrQ0FBUUEsQ0FBVyxFQUFFLEdBQUcsbUNBQW1DO0lBQzdGLE1BQU0sQ0FBQ2tCLE9BQU9DLFNBQVMsR0FBR25CLCtDQUFRQSxDQUFnQjtJQUNsRCxNQUFNLENBQUNvQixXQUFXQyxhQUFhLEdBQUdyQiwrQ0FBUUEsQ0FBVSxRQUFRLHdCQUF3QjtJQUNwRixNQUFNLENBQUNzQixZQUFZQyxjQUFjLEdBQUd2QiwrQ0FBUUEsQ0FBdUQ7SUFDbkcsTUFBTXdCLGVBQWV0Qiw2Q0FBTUEsQ0FBcUMsQ0FBQztJQUVqRSxNQUFNdUIsaUJBQWlCO1FBQ25CLE9BQU9DLE9BQU9DLEtBQUs7SUFDdkI7SUFFQSx5Q0FBeUM7SUFDekMsMERBQTBEO0lBQzFEeEIsZ0RBQVNBOzhCQUFDO1lBQ04sSUFBSSxJQUE2QixFQUFFO2dCQUMvQixNQUFNeUIsZUFBZUYsT0FBT0csWUFBWSxDQUFDQyxPQUFPLENBQUM7Z0JBQ2pELElBQUlGLGdCQUFnQixDQUFDbEIsUUFBUTtvQkFDekJDLFVBQVVpQjtnQkFDZDtZQUNKO1FBQ0o7NkJBQUcsRUFBRTtJQUVMLCtDQUErQztJQUMvQ3pCLGdEQUFTQTs4QkFBQztZQUNOLElBQUksS0FBNkIsSUFBSU8sUUFBUTtnQkFDekNnQixPQUFPRyxZQUFZLENBQUNF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QixhQUFhLEVBQUUsR0FBRyx3Q0FBd0M7WUFDOUQ7UUFDSjs2QkFBRztRQUFDUDtLQUFPO0lBR1gsT0FBTztRQUNIQTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBRTtRQUNBVTtRQUNBbUI7UUFDQW9EO1FBQ0FtQyxlQUFlM0I7UUFDZmU7UUFDQUk7UUFDQUM7UUFDQXRIO1FBQ0FFO1FBQ0FFO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL3NyYy9ob29rcy91c2VOb3N0ci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBmZXRjaE5vc3RyRmVlZCwgZmV0Y2hOb3N0clByb2ZpbGUsIGdldEhlYWx0aHlSZWxheXMgfSBmcm9tIFwiQC9saWIvbm9zdHIvcmVsYXlcIjtcblxuLy8gRXh0ZW5kIEZlZWRPcHRpb25zIHRvIGluY2x1ZGUgJ2F1dGhvcnMnXG5leHBvcnQgaW50ZXJmYWNlIEZlZWRPcHRpb25zIHtcbiAgICBsaW1pdD86IG51bWJlcjtcbiAgICB1bnRpbD86IG51bWJlcjtcbiAgICBraW5kcz86IG51bWJlcltdO1xuICAgIGF1dGhvcnM/OiBzdHJpbmdbXTsgLy8gQWRkZWQgYXV0aG9ycyBwcm9wZXJ0eSB0byBtYXRjaCB1c2FnZVxufVxuaW1wb3J0IHsgU2ltcGxlUG9vbCwgbmlwMTksIHR5cGUgRXZlbnQgYXMgTm9zdHJUb29sc0V2ZW50LCB0eXBlIFVuc2lnbmVkRXZlbnQsIGdldEV2ZW50SGFzaCB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuXG4vLyBEZWZpbmUgdGhlIE5JUC0wNyB3aW5kb3cubm9zdHIgaW50ZXJmYWNlXG5pbnRlcmZhY2UgV2luZG93Tm9zdHIge1xuICAgIGdldFB1YmxpY0tleSgpOiBQcm9taXNlPHN0cmluZz47XG4gICAgc2lnbkV2ZW50KGV2ZW50OiBVbnNpZ25lZEV2ZW50KTogUHJvbWlzZTxOb3N0clRvb2xzRXZlbnQ+O1xuICAgIHNpZ25NZXNzYWdlPyhtZXNzYWdlOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz47IC8vIE9wdGlvbmFsIE5JUC00MiBvciBjdXN0b20gdXNhZ2VcbiAgICBnZXRSZWxheXM/KCk6IFByb21pc2U8eyBbdXJsOiBzdHJpbmddOiB7IHJlYWQ6IGJvb2xlYW47IHdyaXRlOiBib29sZWFuIH0gfT47IC8vIE9wdGlvbmFsXG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICAgICAgbm9zdHI/OiBXaW5kb3dOb3N0cjtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBSRUxBWVMgPSBbXG4gICAgXCJ3c3M6Ly9yZWxheS5kYW11cy5pb1wiLFxuICAgIFwid3NzOi8vcmVsYXkubm9zdHIuYmFuZFwiLFxuICAgIFwid3NzOi8vbm9zdHItcHViLndlbGxvcmRlci5uZXRcIixcbiAgICAvLyBBZGQgbW9yZSBkZWZhdWx0IHJlbGF5cyBvciBtYWtlIHRoaXMgY29uZmlndXJhYmxlXG5dO1xuXG5leHBvcnQgaW50ZXJmYWNlIE5vc3RyUHJvZmlsZSB7XG4gICAgdXNlcm5hbWU/OiBzdHJpbmc7IC8vIEFsd2F5cyBzZXQ6IG1hcHBlZCBmcm9tICduYW1lJyBpbiBOb3N0ciBzcGVjXG4gICAgZGlzcGxheV9uYW1lPzogc3RyaW5nO1xuICAgIGFib3V0Pzogc3RyaW5nO1xuICAgIHBpY3R1cmU/OiBzdHJpbmc7XG4gICAgYmFubmVyPzogc3RyaW5nO1xuICAgIHdlYnNpdGU/OiBzdHJpbmc7XG4gICAgbHVkMDY/OiBzdHJpbmc7XG4gICAgbHVkMTY/OiBzdHJpbmc7XG4gICAgbmlwMDU/OiBzdHJpbmc7XG4gICAgcHVia2V5Pzogc3RyaW5nOyAvLyBBZGRlZCBmb3IgY29udmVuaWVuY2Vcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOb3N0ckV2ZW50IHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHB1YmtleTogc3RyaW5nO1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICBjcmVhdGVkX2F0OiBudW1iZXI7XG4gICAga2luZDogbnVtYmVyO1xuICAgIHRhZ3M6IHN0cmluZ1tdW107XG4gICAgbWVkaWE6IHN0cmluZ1tdOyAvLyBDdXN0b20gZGVyaXZlZCBmaWVsZFxuICAgIHByb2ZpbGU/OiBOb3N0clByb2ZpbGU7IC8vIEN1c3RvbSBkZXJpdmVkIGZpZWxkXG4gICAgLy8gQWRkIG90aGVyIGV2ZW50IGZpZWxkcyBpZiBuZWVkZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZU5vc3RyKCkge1xuICAgIGNvbnN0IFtwdWJrZXksIHNldFB1YmtleV0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbZXZlbnRzLCBzZXRFdmVudHNdID0gdXNlU3RhdGU8Tm9zdHJFdmVudFtdPihbXSk7XG4gICAgY29uc3QgW3Byb2ZpbGUsIHNldFByb2ZpbGVdID0gdXNlU3RhdGU8Tm9zdHJQcm9maWxlIHwgbnVsbD4obnVsbCk7IC8vIEN1cnJlbnQgdXNlcidzIHByb2ZpbGVcbiAgICBjb25zdCBbZm9sbG93aW5nLCBzZXRGb2xsb3dpbmddID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTsgLy8gTGlzdCBvZiBwdWJrZXlzIHRoZSB1c2VyIGZvbGxvd3NcbiAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7IC8vIEdlbmVyYWwgbG9hZGluZyBzdGF0ZVxuICAgIGNvbnN0IFtyZWxheVN0YXRzLCBzZXRSZWxheVN0YXRzXSA9IHVzZVN0YXRlPHsgaGVhbHRoeUNvdW50OiBudW1iZXI7IHRvdGFsQ291bnQ6IG51bWJlcjsgfSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHByb2ZpbGVDYWNoZSA9IHVzZVJlZjx7IFtwdWJrZXk6IHN0cmluZ106IE5vc3RyUHJvZmlsZSB9Pih7fSk7XG5cbiAgICBjb25zdCBnZXRXaW5kb3dOb3N0ciA9ICgpOiBXaW5kb3dOb3N0ciB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cubm9zdHI7XG4gICAgfTtcblxuICAgIC8vIC0tLSBQZXJzaXN0IHB1YmtleSBpbiBsb2NhbFN0b3JhZ2UgLS0tXG4gICAgLy8gT24gbW91bnQsIHJlaHlkcmF0ZSBwdWJrZXkgZnJvbSBsb2NhbFN0b3JhZ2UgaWYgcHJlc2VudFxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkUHVia2V5ID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdub3N0cl9wdWJrZXknKTtcbiAgICAgICAgICAgIGlmIChzdG9yZWRQdWJrZXkgJiYgIXB1YmtleSkge1xuICAgICAgICAgICAgICAgIHNldFB1YmtleShzdG9yZWRQdWJrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8gV2hlbiBwdWJrZXkgY2hhbmdlcywgcGVyc2lzdCB0byBsb2NhbFN0b3JhZ2VcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHVia2V5KSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ25vc3RyX3B1YmtleScsIHB1YmtleSk7XG4gICAgICAgIH1cbiAgICB9LCBbcHVia2V5XSk7XG5cbiAgICAvLyBBdXRoL2xvZ2luXG4gICAgY29uc3QgbG9naW4gPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vc3RyID0gZ2V0V2luZG93Tm9zdHIoKTtcbiAgICAgICAgaWYgKG5vc3RyKSB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGsgPSBhd2FpdCBub3N0ci5nZXRQdWJsaWNLZXkoKTtcbiAgICAgICAgICAgICAgICBzZXRQdWJrZXkocGspO1xuXG4gICAgICAgICAgICAgICAgLy8gT3B0aW9uYWw6IFNjaG5vcnIgc2lnbmluZyBmb3IgY3VzdG9tIG1lc3NhZ2UgKGUuZy4sIE5JUC00MiBhdXRoKVxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgTG9naW4gdG8gUkFXLlJPQ0tTOiAke0RhdGUubm93KCl9YDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vc3RyLnNpZ25NZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IG5vc3RyLnNpZ25NZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTaWduZWQgbG9naW4gbWVzc2FnZTpcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJzaWduTWVzc2FnZSBmb3IgbG9naW4gZmFpbGVkOlwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwic2lnbk1lc3NhZ2UgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIE5PU1RSIGV4dGVuc2lvbi5cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTG9hZCBwcm9maWxlIGZyb20gcmVsYXlzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBoZWFsdGh5UmVsYXlzIH0gPSBhd2FpdCBnZXRIZWFsdGh5UmVsYXlzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWx0aHlSZWxheXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyUHJvZmlsZURhdGEgPSBhd2FpdCBmZXRjaE5vc3RyUHJvZmlsZShoZWFsdGh5UmVsYXlzLCBwayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyUHJvZmlsZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9maWxlOiBOb3N0clByb2ZpbGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4udXNlclByb2ZpbGVEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YmtleTogcGssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IHVzZXJQcm9maWxlRGF0YS5uYW1lIHx8IHBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb2ZpbGUodXNlclByb2ZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZUNhY2hlLmN1cnJlbnRbcGtdID0gdXNlclByb2ZpbGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJObyBoZWFsdGh5IHJlbGF5cyB0byBmZXRjaCBpbml0aWFsIHByb2ZpbGUuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkxvZ2luIGZhaWxlZDpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkxvZ2luIGZhaWxlZC4gUGxlYXNlIGVuc3VyZSB5b3VyIE5PU1RSIGV4dGVuc2lvbiBpcyBjb25maWd1cmVkLlwiKTtcbiAgICAgICAgICAgICAgICBzZXRQdWJrZXkobnVsbCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRFcnJvcihcIk5PU1RSIGV4dGVuc2lvbiBub3QgZm91bmQuIFBsZWFzZSBpbnN0YWxsIGEgTk9TVFIgYnJvd3NlciBleHRlbnNpb24uXCIpO1xuICAgICAgICAgICAgLy8gYWxlcnQoXCJOT1NUUiBleHRlbnNpb24gbm90IGZvdW5kLiBQbGVhc2UgaW5zdGFsbCBhIE5PU1RSIGJyb3dzZXIgZXh0ZW5zaW9uLlwiKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIC8vIEZldGNoIGZlZWQgd2l0aCBwYWdpbmF0aW9uIHN1cHBvcnRcbiAgICBjb25zdCBmZXRjaEV2ZW50cyA9IHVzZUNhbGxiYWNrKGFzeW5jIChvcHRpb25zPzogRmVlZE9wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGVhbHRoeVJlbGF5cywgaGVhbHRoeUNvdW50LCB0b3RhbENvdW50IH0gPSBhd2FpdCBnZXRIZWFsdGh5UmVsYXlzKCk7XG4gICAgICAgICAgICBzZXRSZWxheVN0YXRzKHsgaGVhbHRoeUNvdW50LCB0b3RhbENvdW50IH0pO1xuXG4gICAgICAgICAgICBpZiAoIWhlYWx0aHlSZWxheXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoXCJObyBoZWFsdGh5IHJlbGF5cyBhdmFpbGFibGUgdG8gZmV0Y2ggZmVlZC5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBmZXRjaGVkTm9zdHJFdmVudHMgPSBhd2FpdCBmZXRjaE5vc3RyRmVlZChoZWFsdGh5UmVsYXlzLCB7XG4gICAgICAgICAgICAgICAgbGltaXQ6IDIwLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB1bmlxdWVQdWJrZXlzID0gQXJyYXkuZnJvbShuZXcgU2V0KGZldGNoZWROb3N0ckV2ZW50cy5tYXAoZXYgPT4gZXYucHVia2V5KSkpO1xuICAgICAgICAgICAgY29uc3QgcHJvZmlsZXNUb0ZldGNoID0gdW5pcXVlUHVia2V5cy5maWx0ZXIocGsgPT4gIXByb2ZpbGVDYWNoZS5jdXJyZW50W3BrXSk7XG5cbiAgICAgICAgICAgIGlmIChwcm9maWxlc1RvRmV0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb2ZpbGVzVG9GZXRjaC5tYXAoYXN5bmMgKHBrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBhd2FpdCBmZXRjaE5vc3RyUHJvZmlsZShoZWFsdGh5UmVsYXlzLCBwayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9maWxlQ2FjaGUuY3VycmVudFtwa10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWV0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJrZXk6IHBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBtZXRhLm5hbWUgfHwgcGssXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRGZWVkID0gZmV0Y2hlZE5vc3RyRXZlbnRzLm1hcCgoZXYpOiBOb3N0ckV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbWVkaWE6IHN0cmluZ1tdID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsUmVnZXggPSAvKGh0dHBzPzpcXC9cXC8oPzpbXFx3LV0rXFwuKStbXFx3LV0rKD86XFwvW1xcd1xcLS5ffjovPyNbXFxdQCEkJicoKSorLDs9XSopP1xcLig/OmpwZ3xqcGVnfHBuZ3xnaWZ8bXA0fHdlYm0pKS9naTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHVybFJlZ2V4LmV4ZWMoZXYuY29udGVudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lZGlhLnB1c2gobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJQcm9mID0gcHJvZmlsZUNhY2hlLmN1cnJlbnRbZXYucHVia2V5XSB8fCB7IHB1YmtleTogZXYucHVia2V5LCB1c2VybmFtZTogZXYucHVia2V5IH07XG4gICAgICAgICAgICAgICAgY29uc3QgcGljdHVyZSA9IHVzZXJQcm9mLnBpY3R1cmUgfHwgXCIvZmlsZS5zdmdcIjsgLy8gRGVmYXVsdCBhdmF0YXJcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmV2LFxuICAgICAgICAgICAgICAgICAgICBtZWRpYSxcbiAgICAgICAgICAgICAgICAgICAgcHJvZmlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4udXNlclByb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IHVzZXJQcm9mLmRpc3BsYXlfbmFtZSB8fCB1c2VyUHJvZi51c2VybmFtZSB8fCBgJHtldi5wdWJrZXkuc2xpY2UoMCwgNil9Li4uJHtldi5wdWJrZXkuc2xpY2UoLTQpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWN0dXJlOiB1c2VyUHJvZi5waWN0dXJlIHx8IFwiL2ZpbGUuc3ZnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogdXNlclByb2YudXNlcm5hbWUgfHwgZXYucHVia2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHVia2V5OiBldi5wdWJrZXksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucz8udW50aWwpIHtcbiAgICAgICAgICAgICAgICBzZXRFdmVudHMocHJldiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSWRzID0gbmV3IFNldChwcmV2Lm1hcChlID0+IGUuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RXZlbnRzID0gcHJvY2Vzc2VkRmVlZC5maWx0ZXIoZSA9PiAhZXhpc3RpbmdJZHMuaGFzKGUuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5wcmV2LCAuLi5uZXdFdmVudHNdLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEV2ZW50cyhwcm9jZXNzZWRGZWVkLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NlZEZlZWQubGVuZ3RoID4gMDtcbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBldmVudHM6XCIsIGVycik7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBmZXRjaCBwb3N0cy4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgLy8gSGVscGVyIHRvIHB1Ymxpc2ggYSBzaWduZWQgZXZlbnRcbiAgICBjb25zdCBwdWJsaXNoRXZlbnQgPSBhc3luYyAoc2lnbmVkRXZlbnQ6IE5vc3RyVG9vbHNFdmVudCk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBoZWFsdGh5UmVsYXlzIH0gPSBhd2FpdCBnZXRIZWFsdGh5UmVsYXlzKCk7XG4gICAgICAgICAgICBpZiAoIWhlYWx0aHlSZWxheXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoXCJObyBoZWFsdGh5IHJlbGF5cyBhdmFpbGFibGUgdG8gcHVibGlzaCBldmVudC5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9vbCA9IG5ldyBTaW1wbGVQb29sKCk7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IHBvb2wucHVibGlzaChoZWFsdGh5UmVsYXlzLCBzaWduZWRFdmVudCk7XG4gICAgICAgICAgICAvLyBXYWl0IGZvciBhdCBsZWFzdCBvbmUgc3VjY2Vzc2Z1bCBwdWJsaXNoIG9yIHRpbWVvdXRcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIHZlcnNpb247IG5vc3RyLXRvb2xzJyBwdWJsaXNoIHJldHVybnMgcHJvbWlzZXMgZm9yIGVhY2ggcmVsYXlcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYW55KHByb21pc2VzLm1hcChwID0+IFByb21pc2UucmFjZShbcCwgbmV3IFByb21pc2UoKF8sIHJlaikgPT4gc2V0VGltZW91dCgoKSA9PiByZWoobmV3IEVycm9yKCd0aW1lb3V0JykpLCA1MDAwKSldKSkpO1xuICAgICAgICAgICAgcG9vbC5jbG9zZShoZWFsdGh5UmVsYXlzKTsgLy8gQ2xvc2UgY29ubmVjdGlvbnMgYWZ0ZXIgcHVibGlzaGluZ1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IHRvIHJlbGF5czpcIiwgZXJyKTtcbiAgICAgICAgICAgIHNldEVycm9yKFwiRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQuIFNvbWUgcmVsYXlzIG1pZ2h0IGJlIG9mZmxpbmUuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFBvc3QgZXZlbnQgKHNpZ24gYW5kIHB1Ymxpc2ggdXNpbmcgZXh0ZW5zaW9uKVxuICAgIGNvbnN0IHBvc3QgPSB1c2VDYWxsYmFjayhhc3luYyAoY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vc3RyID0gZ2V0V2luZG93Tm9zdHIoKTtcbiAgICAgICAgaWYgKCFwdWJrZXkgfHwgIW5vc3RyKSB7XG4gICAgICAgICAgICBzZXRFcnJvcihcIk5vdCBsb2dnZWQgaW4gb3IgTk9TVFIgZXh0ZW5zaW9uIG5vdCBmb3VuZC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkRXZlbnQ6IFVuc2lnbmVkRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAga2luZDogMSxcbiAgICAgICAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCksXG4gICAgICAgICAgICAgICAgdGFnczogW10sXG4gICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IG5vc3RyLnNpZ25FdmVudCh1bnNpZ25lZEV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKGF3YWl0IHB1Ymxpc2hFdmVudChzaWduZWRFdmVudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBPcHRpbWlzdGljIHVwZGF0ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQcm9maWxlID0gcHJvZmlsZUNhY2hlLmN1cnJlbnRbcHVia2V5XSB8fCB7IHB1YmtleSwgdXNlcm5hbWU6IHB1YmtleSB9O1xuICAgICAgICAgICAgICAgIHNldEV2ZW50cyhwcmV2ID0+IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNpZ25lZEV2ZW50LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHVia2V5OiBzaWduZWRFdmVudC5wdWJrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBzaWduZWRFdmVudC5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogc2lnbmVkRXZlbnQuY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IHNpZ25lZEV2ZW50LmtpbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdzOiBzaWduZWRFdmVudC50YWdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVkaWE6IFtdLCAvLyBEZXJpdmUgbWVkaWEgaWYgbmVlZGVkLCBvciBsZWF2ZSBmb3IgZGlzcGxheSBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWU6IGN1cnJlbnRQcm9maWxlLmRpc3BsYXlfbmFtZSB8fCBjdXJyZW50UHJvZmlsZS51c2VybmFtZSB8fCBgJHtwdWJrZXkuc2xpY2UoMCwgNil9Li4uJHtwdWJrZXkuc2xpY2UoLTQpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6IGN1cnJlbnRQcm9maWxlLnVzZXJuYW1lIHx8IHB1YmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaWN0dXJlOiBjdXJyZW50UHJvZmlsZS5waWN0dXJlIHx8IFwiL2ZpbGUuc3ZnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVia2V5OiBwdWJrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICAgICAgXS5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gcG9zdCBldmVudDpcIiwgZXJyKTtcbiAgICAgICAgICAgIHNldEVycm9yKGVyci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIHBvc3QuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW3B1YmtleSwgcHJvZmlsZV0pO1xuXG4gICAgLy8gVXBkYXRlIHByb2ZpbGUgKEtpbmQgMClcbiAgICBjb25zdCB1cGRhdGVQcm9maWxlTWV0YWRhdGEgPSB1c2VDYWxsYmFjayhhc3luYyAobmV3UHJvZmlsZURhdGE6IE5vc3RyUHJvZmlsZSkgPT4ge1xuICAgICAgICBjb25zdCBub3N0ciA9IGdldFdpbmRvd05vc3RyKCk7XG4gICAgICAgIGlmICghcHVia2V5IHx8ICFub3N0cikge1xuICAgICAgICAgICAgc2V0RXJyb3IoXCJOb3QgbG9nZ2VkIGluIG9yIE5PU1RSIGV4dGVuc2lvbiBub3QgZm91bmQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgb25seSB2YWxpZCBwcm9maWxlIGZpZWxkcyBhcmUgaW5jbHVkZWRcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRQYXlsb2FkOiBhbnkgPSB7fTtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS51c2VybmFtZSAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5uYW1lID0gbmV3UHJvZmlsZURhdGEudXNlcm5hbWU7IC8vIEFsd2F5cyBzZXQgJ25hbWUnIGZyb20gJ3VzZXJuYW1lJ1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLmRpc3BsYXlfbmFtZSAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5kaXNwbGF5X25hbWUgPSBuZXdQcm9maWxlRGF0YS5kaXNwbGF5X25hbWU7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEuYWJvdXQgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQuYWJvdXQgPSBuZXdQcm9maWxlRGF0YS5hYm91dDtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS5waWN0dXJlICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLnBpY3R1cmUgPSBuZXdQcm9maWxlRGF0YS5waWN0dXJlO1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLmJhbm5lciAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5iYW5uZXIgPSBuZXdQcm9maWxlRGF0YS5iYW5uZXI7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEud2Vic2l0ZSAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC53ZWJzaXRlID0gbmV3UHJvZmlsZURhdGEud2Vic2l0ZTtcbiAgICAgICAgICAgIGlmIChuZXdQcm9maWxlRGF0YS5sdWQwNiAhPT0gdW5kZWZpbmVkKSBjb250ZW50UGF5bG9hZC5sdWQwNiA9IG5ld1Byb2ZpbGVEYXRhLmx1ZDA2O1xuICAgICAgICAgICAgaWYgKG5ld1Byb2ZpbGVEYXRhLmx1ZDE2ICE9PSB1bmRlZmluZWQpIGNvbnRlbnRQYXlsb2FkLmx1ZDE2ID0gbmV3UHJvZmlsZURhdGEubHVkMTY7XG4gICAgICAgICAgICBpZiAobmV3UHJvZmlsZURhdGEubmlwMDUgIT09IHVuZGVmaW5lZCkgY29udGVudFBheWxvYWQubmlwMDUgPSBuZXdQcm9maWxlRGF0YS5uaXAwNTtcblxuXG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZEV2ZW50OiBVbnNpZ25lZEV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IDAsXG4gICAgICAgICAgICAgICAgcHVia2V5LFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICAgICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KGNvbnRlbnRQYXlsb2FkKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IG5vc3RyLnNpZ25FdmVudCh1bnNpZ25lZEV2ZW50KTtcbiAgICAgICAgICAgIGlmIChhd2FpdCBwdWJsaXNoRXZlbnQoc2lnbmVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEZ1bGxQcm9maWxlID0geyAuLi5wcm9maWxlLCAuLi5uZXdQcm9maWxlRGF0YSwgcHVia2V5LCB1c2VybmFtZTogbmV3UHJvZmlsZURhdGEudXNlcm5hbWUgfTtcbiAgICAgICAgICAgICAgICBzZXRQcm9maWxlKHVwZGF0ZWRGdWxsUHJvZmlsZSk7XG4gICAgICAgICAgICAgICAgcHJvZmlsZUNhY2hlLmN1cnJlbnRbcHVia2V5XSA9IHVwZGF0ZWRGdWxsUHJvZmlsZTsgLy8gVXBkYXRlIGNhY2hlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHVwZGF0ZSBwcm9maWxlOlwiLCBlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gdXBkYXRlIHByb2ZpbGUuIFBsZWFzZSB0cnkgYWdhaW4uXCIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgW3B1YmtleSwgcHJvZmlsZV0pO1xuXG4gICAgLy8gTWFuYWdlIGNvbnRhY3QgbGlzdCAoS2luZCAzKVxuICAgIGNvbnN0IHVwZGF0ZUNvbnRhY3RMaXN0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKG5ld0ZvbGxvd2luZ1B1YmtleXM6IHN0cmluZ1tdKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vc3RyID0gZ2V0V2luZG93Tm9zdHIoKTtcbiAgICAgICAgaWYgKCFwdWJrZXkgfHwgIW5vc3RyKSB7XG4gICAgICAgICAgICBzZXRFcnJvcihcIk5vdCBsb2dnZWQgaW4gb3IgTk9TVFIgZXh0ZW5zaW9uIG5vdCBmb3VuZC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5JUC0wMiByZWNvbW1lbmRzIHByZXNlcnZpbmcgZXhpc3Rpbmcgbm9uLVwicFwiIHRhZ3MgaWYgYW55LlxuICAgICAgICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHRoaXMgZXhhbXBsZSBvbmx5IG1hbmFnZXMgXCJwXCIgdGFncy5cbiAgICAgICAgICAgIC8vIEZldGNoIGV4aXN0aW5nIGNvbnRhY3QgbGlzdCB0byBwcmVzZXJ2ZSBvdGhlciB0YWdzIGlmIG5lY2Vzc2FyeSAobW9yZSBjb21wbGV4KVxuXG4gICAgICAgICAgICBjb25zdCB0YWdzID0gbmV3Rm9sbG93aW5nUHVia2V5cy5tYXAocGsgPT4gW1wicFwiLCBwa10pO1xuICAgICAgICAgICAgY29uc3QgdW5zaWduZWRFdmVudDogVW5zaWduZWRFdmVudCA9IHtcbiAgICAgICAgICAgICAgICBraW5kOiAzLFxuICAgICAgICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSxcbiAgICAgICAgICAgICAgICB0YWdzOiB0YWdzLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsIC8vIE9yIEpTT04gc3RyaW5nIG9mIHJlbGF5IGhpbnRzIHBlciBOSVAtMDJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IG5vc3RyLnNpZ25FdmVudCh1bnNpZ25lZEV2ZW50KTtcbiAgICAgICAgICAgIGlmIChhd2FpdCBwdWJsaXNoRXZlbnQoc2lnbmVkRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgc2V0Rm9sbG93aW5nKG5ld0ZvbGxvd2luZ1B1YmtleXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byB1cGRhdGUgY29udGFjdCBsaXN0OlwiLCBlcnIpO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gdXBkYXRlIGNvbnRhY3QgbGlzdC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBbcHVia2V5XSk7XG5cbiAgICBjb25zdCBmb2xsb3dVc2VyID0gdXNlQ2FsbGJhY2soYXN5bmMgKHVzZXJQdWJrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoZm9sbG93aW5nLmluY2x1ZGVzKHVzZXJQdWJrZXkpKSByZXR1cm4gdHJ1ZTsgLy8gQWxyZWFkeSBmb2xsb3dpbmdcbiAgICAgICAgY29uc3QgbmV3Rm9sbG93aW5nTGlzdCA9IFsuLi5mb2xsb3dpbmcsIHVzZXJQdWJrZXldO1xuICAgICAgICByZXR1cm4gYXdhaXQgdXBkYXRlQ29udGFjdExpc3QobmV3Rm9sbG93aW5nTGlzdCk7XG4gICAgfSwgW2ZvbGxvd2luZywgdXBkYXRlQ29udGFjdExpc3RdKTtcblxuICAgIGNvbnN0IHVuZm9sbG93VXNlciA9IHVzZUNhbGxiYWNrKGFzeW5jICh1c2VyUHVia2V5OiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKCFmb2xsb3dpbmcuaW5jbHVkZXModXNlclB1YmtleSkpIHJldHVybiB0cnVlOyAvLyBOb3QgZm9sbG93aW5nXG4gICAgICAgIGNvbnN0IG5ld0ZvbGxvd2luZ0xpc3QgPSBmb2xsb3dpbmcuZmlsdGVyKHBrID0+IHBrICE9PSB1c2VyUHVia2V5KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHVwZGF0ZUNvbnRhY3RMaXN0KG5ld0ZvbGxvd2luZ0xpc3QpO1xuICAgIH0sIFtmb2xsb3dpbmcsIHVwZGF0ZUNvbnRhY3RMaXN0XSk7XG5cblxuICAgIGNvbnN0IGlzRm9sbG93aW5nID0gdXNlQ2FsbGJhY2soKHVzZXJQdWJrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICByZXR1cm4gZm9sbG93aW5nLmluY2x1ZGVzKHVzZXJQdWJrZXkpO1xuICAgIH0sIFtmb2xsb3dpbmddKTtcblxuICAgIC8vIEVmZmVjdCB0byBsb2FkIGluaXRpYWwgZm9sbG93aW5nIGxpc3QgZm9yIHRoZSBsb2dnZWQtaW4gdXNlclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwdWJrZXkpIHtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBoZWFsdGh5UmVsYXlzIH0gPSBhd2FpdCBnZXRIZWFsdGh5UmVsYXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWFsdGh5UmVsYXlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBjb3JyZWN0IGZpbHRlciB0eXBlIGZvciBub3N0ci10b29sc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kczogWzNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aG9yczogW3B1YmtleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW1pdDogMSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogRmlsdGVyIHR5cGUgaXMgYnJvYWRlciB0aGFuIEZlZWRPcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhY3RMaXN0RXZlbnRzID0gYXdhaXQgZmV0Y2hOb3N0ckZlZWQoaGVhbHRoeVJlbGF5cywgZmlsdGVyKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdExpc3RFdmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF0ZXN0Q29udGFjdExpc3QgPSBjb250YWN0TGlzdEV2ZW50cy5zb3J0KChhOiBhbnksIGI6IGFueSkgPT4gYi5jcmVhdGVkX2F0IC0gYS5jcmVhdGVkX2F0KVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvbGxvd2VkUHVia2V5cyA9IGxhdGVzdENvbnRhY3RMaXN0LnRhZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh0YWc6IHN0cmluZ1tdKSA9PiB0YWdbMF0gPT09ICdwJyAmJiB0YWdbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgodGFnOiBzdHJpbmdbXSkgPT4gdGFnWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEZvbGxvd2luZyhmb2xsb3dlZFB1YmtleXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggaW5pdGlhbCBjb250YWN0IGxpc3Q6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldEZvbGxvd2luZyhbXSk7IC8vIENsZWFyIGZvbGxvd2luZyBsaXN0IGlmIG5vdCBsb2dnZWQgaW5cbiAgICAgICAgfVxuICAgIH0sIFtwdWJrZXldKTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHVia2V5LFxuICAgICAgICBldmVudHMsXG4gICAgICAgIHByb2ZpbGUsXG4gICAgICAgIGZvbGxvd2luZyxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGlzTG9hZGluZyxcbiAgICAgICAgcmVsYXlTdGF0cyxcbiAgICAgICAgbG9naW4sXG4gICAgICAgIGZldGNoRXZlbnRzLFxuICAgICAgICBwb3N0LFxuICAgICAgICB1cGRhdGVQcm9maWxlOiB1cGRhdGVQcm9maWxlTWV0YWRhdGEsIC8vIFJlbmFtZWQgZm9yIGNsYXJpdHlcbiAgICAgICAgZm9sbG93VXNlcixcbiAgICAgICAgdW5mb2xsb3dVc2VyLFxuICAgICAgICBpc0ZvbGxvd2luZyxcbiAgICAgICAgc2V0RXZlbnRzLCAvLyBFeHBvc2luZyBzZXR0ZXJzIGNhbiBiZSB1c2VmdWwgYnV0IHVzZSB3aXRoIGNhdXRpb25cbiAgICAgICAgc2V0UHJvZmlsZSxcbiAgICAgICAgc2V0Rm9sbG93aW5nLFxuICAgIH07XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJmZXRjaE5vc3RyRmVlZCIsImZldGNoTm9zdHJQcm9maWxlIiwiZ2V0SGVhbHRoeVJlbGF5cyIsIlNpbXBsZVBvb2wiLCJSRUxBWVMiLCJ1c2VOb3N0ciIsInB1YmtleSIsInNldFB1YmtleSIsImV2ZW50cyIsInNldEV2ZW50cyIsInByb2ZpbGUiLCJzZXRQcm9maWxlIiwiZm9sbG93aW5nIiwic2V0Rm9sbG93aW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsInJlbGF5U3RhdHMiLCJzZXRSZWxheVN0YXRzIiwicHJvZmlsZUNhY2hlIiwiZ2V0V2luZG93Tm9zdHIiLCJ3aW5kb3ciLCJub3N0ciIsInN0b3JlZFB1YmtleSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzZXRJdGVtIiwibG9naW4iLCJwayIsImdldFB1YmxpY0tleSIsIm1lc3NhZ2UiLCJEYXRlIiwibm93Iiwic2lnbk1lc3NhZ2UiLCJzaWduYXR1cmUiLCJjb25zb2xlIiwibG9nIiwiZXJyIiwid2FybiIsImhlYWx0aHlSZWxheXMiLCJsZW5ndGgiLCJ1c2VyUHJvZmlsZURhdGEiLCJ1c2VyUHJvZmlsZSIsInVzZXJuYW1lIiwibmFtZSIsImN1cnJlbnQiLCJmZXRjaEV2ZW50cyIsIm9wdGlvbnMiLCJoZWFsdGh5Q291bnQiLCJ0b3RhbENvdW50IiwiZmV0Y2hlZE5vc3RyRXZlbnRzIiwibGltaXQiLCJ1bmlxdWVQdWJrZXlzIiwiQXJyYXkiLCJmcm9tIiwiU2V0IiwibWFwIiwiZXYiLCJwcm9maWxlc1RvRmV0Y2giLCJmaWx0ZXIiLCJQcm9taXNlIiwiYWxsIiwibWV0YSIsInByb2Nlc3NlZEZlZWQiLCJtZWRpYSIsInVybFJlZ2V4IiwibWF0Y2giLCJleGVjIiwiY29udGVudCIsInB1c2giLCJ1c2VyUHJvZiIsInBpY3R1cmUiLCJkaXNwbGF5X25hbWUiLCJzbGljZSIsInVudGlsIiwicHJldiIsImV4aXN0aW5nSWRzIiwiZSIsImlkIiwibmV3RXZlbnRzIiwiaGFzIiwic29ydCIsImEiLCJiIiwiY3JlYXRlZF9hdCIsInB1Ymxpc2hFdmVudCIsInNpZ25lZEV2ZW50IiwicG9vbCIsInByb21pc2VzIiwicHVibGlzaCIsImFueSIsInAiLCJyYWNlIiwiXyIsInJlaiIsInNldFRpbWVvdXQiLCJFcnJvciIsImNsb3NlIiwicG9zdCIsInVuc2lnbmVkRXZlbnQiLCJraW5kIiwiTWF0aCIsImZsb29yIiwidGFncyIsInNpZ25FdmVudCIsImN1cnJlbnRQcm9maWxlIiwidXBkYXRlUHJvZmlsZU1ldGFkYXRhIiwibmV3UHJvZmlsZURhdGEiLCJjb250ZW50UGF5bG9hZCIsInVuZGVmaW5lZCIsImFib3V0IiwiYmFubmVyIiwid2Vic2l0ZSIsImx1ZDA2IiwibHVkMTYiLCJuaXAwNSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1cGRhdGVkRnVsbFByb2ZpbGUiLCJ1cGRhdGVDb250YWN0TGlzdCIsIm5ld0ZvbGxvd2luZ1B1YmtleXMiLCJmb2xsb3dVc2VyIiwidXNlclB1YmtleSIsImluY2x1ZGVzIiwibmV3Rm9sbG93aW5nTGlzdCIsInVuZm9sbG93VXNlciIsImlzRm9sbG93aW5nIiwia2luZHMiLCJhdXRob3JzIiwiY29udGFjdExpc3RFdmVudHMiLCJsYXRlc3RDb250YWN0TGlzdCIsImZvbGxvd2VkUHVia2V5cyIsInRhZyIsInVwZGF0ZVByb2ZpbGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useNostr.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/nostr/RelayManager.tsx":
/*!****************************************!*\
  !*** ./src/lib/nostr/RelayManager.tsx ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/../node_modules/nostr-tools/lib/esm/index.js\");\n\nclass RelayManager {\n    // Subscribe to relay status changes\n    subscribe(listener) {\n        this.listeners.add(listener);\n        return ()=>this.listeners.delete(listener);\n    }\n    notify() {\n        this.listeners.forEach((fn)=>fn());\n    }\n    persist() {\n        if (true) {\n            localStorage.setItem(\"nostr-relay-status\", JSON.stringify(Array.from(this.relays.values())));\n        }\n    }\n    getAllRelays() {\n        return Array.from(this.relays.values());\n    }\n    getHealthyRelays() {\n        let min = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;\n        const healthy = Array.from(this.relays.values()).filter((r)=>r.healthy);\n        if (healthy.length < min) {\n            // Fallback: include some recently failed relays\n            const fallback = Array.from(this.relays.values()).filter((r)=>!r.healthy && Date.now() - r.lastChecked > this.retryDelay).slice(0, min - healthy.length);\n            return healthy.concat(fallback);\n        }\n        return healthy;\n    }\n    markRelay(url, healthy) {\n        const r = this.relays.get(url);\n        if (r) {\n            r.healthy = healthy;\n            r.lastChecked = Date.now();\n            r.failCount = healthy ? 0 : r.failCount + 1;\n            if (r.failCount >= this.maxFail) r.healthy = false;\n            this.persist();\n            this.notify();\n        }\n    }\n    async checkRelay(url) {\n        // Simple check: try to connect and fetch a dummy event\n        const pool = new nostr_tools__WEBPACK_IMPORTED_MODULE_0__.SimplePool();\n        try {\n            await pool.querySync([\n                url\n            ], {\n                limit: 1\n            });\n            this.markRelay(url, true);\n            return true;\n        } catch (e) {\n            this.markRelay(url, false);\n            return false;\n        } finally{\n            pool.close([\n                url\n            ]);\n        }\n    }\n    async checkAllRelays() {\n        await Promise.all(Array.from(this.relays.keys()).map((url)=>this.checkRelay(url)));\n    }\n    // Fetch with retry/aggregation\n    async fetchWithRetry(filter) {\n        let minRelays = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3, maxAttempts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n        let relays = this.getHealthyRelays(minRelays).map((r)=>r.url);\n        let results = [];\n        let tried = new Set();\n        let attempts = 0;\n        while(results.length === 0 && attempts < maxAttempts && relays.length > 0){\n            const pool = new nostr_tools__WEBPACK_IMPORTED_MODULE_0__.SimplePool();\n            try {\n                const res = await pool.querySync(relays, filter);\n                results = res || [];\n                // Mark all as healthy\n                relays.forEach((url)=>this.markRelay(url, true));\n            } catch (e) {\n                // Mark all as failed\n                relays.forEach((url)=>this.markRelay(url, false));\n            } finally{\n                pool.close(relays);\n            }\n            // Prepare next attempt\n            relays.forEach((url)=>tried.add(url));\n            relays = this.getAllRelays().filter((r)=>!tried.has(r.url) && r.healthy).map((r)=>r.url);\n            attempts++;\n        }\n        return results;\n    }\n    // Add/remove relays (for power users)\n    addRelay(url) {\n        if (!this.relays.has(url)) {\n            this.relays.set(url, {\n                url,\n                healthy: true,\n                lastChecked: 0,\n                failCount: 0\n            });\n            this.persist();\n            this.notify();\n        }\n    }\n    removeRelay(url) {\n        if (this.relays.has(url)) {\n            this.relays.delete(url);\n            this.persist();\n            this.notify();\n        }\n    }\n    constructor(initialRelays = []){\n        this.relays = new Map();\n        this.listeners = new Set();\n        this.maxFail = 3;\n        this.retryDelay = 60 * 1000 // 1 min\n        ;\n        // Load from localStorage or use initial\n        const saved =  true ? localStorage.getItem(\"nostr-relay-status\") : 0;\n        if (saved) {\n            try {\n                const arr = JSON.parse(saved);\n                arr.forEach((r)=>this.relays.set(r.url, r));\n            } catch (e) {}\n        }\n        initialRelays.forEach((url)=>{\n            if (!this.relays.has(url)) {\n                this.relays.set(url, {\n                    url,\n                    healthy: true,\n                    lastChecked: 0,\n                    failCount: 0\n                });\n            }\n        });\n    }\n}\n// Singleton instance with default relays\nconst DEFAULT_RELAYS = [\n    \"wss://relay.damus.io\",\n    \"wss://relay.nostr.band\",\n    \"wss://nostr.wine\",\n    \"wss://nostr-pub.wellorder.net\",\n    \"wss://nostr.oxtr.dev\",\n    \"wss://nostr.mom\"\n];\nconst relayManager = new RelayManager(DEFAULT_RELAYS);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (relayManager);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbm9zdHIvUmVsYXlNYW5hZ2VyLnRzeCIsIm1hcHBpbmdzIjoiOzs7OztBQUF5QztBQVV6QyxNQUFNQztJQXNCSixvQ0FBb0M7SUFDcENDLFVBQVVDLFFBQW9CLEVBQUU7UUFDOUIsSUFBSSxDQUFDQyxTQUFTLENBQUNDLEdBQUcsQ0FBQ0Y7UUFDbkIsT0FBTyxJQUFNLElBQUksQ0FBQ0MsU0FBUyxDQUFDRSxNQUFNLENBQUNIO0lBQ3JDO0lBQ1FJLFNBQVM7UUFDZixJQUFJLENBQUNILFNBQVMsQ0FBQ0ksT0FBTyxDQUFDQyxDQUFBQSxLQUFNQTtJQUMvQjtJQUNRQyxVQUFVO1FBQ2hCLElBQUksSUFBNkIsRUFBRTtZQUNqQ0MsYUFBYUMsT0FBTyxDQUNsQixzQkFDQUMsS0FBS0MsU0FBUyxDQUFDQyxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDQyxNQUFNLENBQUNDLE1BQU07UUFFaEQ7SUFDRjtJQUVBQyxlQUFlO1FBQ2IsT0FBT0osTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxNQUFNO0lBQ3RDO0lBQ0FFLG1CQUEwQjtZQUFUQyxNQUFBQSxpRUFBTTtRQUNyQixNQUFNQyxVQUFVUCxNQUFNQyxJQUFJLENBQUMsSUFBSSxDQUFDQyxNQUFNLENBQUNDLE1BQU0sSUFBSUssTUFBTSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFRixPQUFPO1FBQ3RFLElBQUlBLFFBQVFHLE1BQU0sR0FBR0osS0FBSztZQUN4QixnREFBZ0Q7WUFDaEQsTUFBTUssV0FBV1gsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxNQUFNLElBQzNDSyxNQUFNLENBQUNDLENBQUFBLElBQUssQ0FBQ0EsRUFBRUYsT0FBTyxJQUFJSyxLQUFLQyxHQUFHLEtBQUtKLEVBQUVLLFdBQVcsR0FBRyxJQUFJLENBQUNDLFVBQVUsRUFDdEVDLEtBQUssQ0FBQyxHQUFHVixNQUFNQyxRQUFRRyxNQUFNO1lBQ2hD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QUF5QztBQUN6QyxNQUFNK0IsaUJBQWlCO0lBQ3JCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsZUFBZSxJQUFJbkUsYUFBYWtFO0FBQ3RDLGlFQUFlQyxZQUFZQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvc2Nhcm5lcy93b3Jrc3BhY2Uvc3JjL2xpYi9ub3N0ci9SZWxheU1hbmFnZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNpbXBsZVBvb2wgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcblxuLy8gVHlwZSBmb3IgcmVsYXkgc3RhdHVzXG5leHBvcnQgdHlwZSBSZWxheVN0YXR1cyA9IHtcbiAgdXJsOiBzdHJpbmc7XG4gIGhlYWx0aHk6IGJvb2xlYW47XG4gIGxhc3RDaGVja2VkOiBudW1iZXI7XG4gIGZhaWxDb3VudDogbnVtYmVyO1xufTtcblxuY2xhc3MgUmVsYXlNYW5hZ2VyIHtcbiAgcHJpdmF0ZSByZWxheXM6IE1hcDxzdHJpbmcsIFJlbGF5U3RhdHVzPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBsaXN0ZW5lcnM6IFNldDwoKSA9PiB2b2lkPiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSByZWFkb25seSBtYXhGYWlsID0gMztcbiAgcHJpdmF0ZSByZWFkb25seSByZXRyeURlbGF5ID0gNjAgKiAxMDAwOyAvLyAxIG1pblxuXG4gIGNvbnN0cnVjdG9yKGluaXRpYWxSZWxheXM6IHN0cmluZ1tdID0gW10pIHtcbiAgICAvLyBMb2FkIGZyb20gbG9jYWxTdG9yYWdlIG9yIHVzZSBpbml0aWFsXG4gICAgY29uc3Qgc2F2ZWQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwibm9zdHItcmVsYXktc3RhdHVzXCIpIDogbnVsbDtcbiAgICBpZiAoc2F2ZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFycjogUmVsYXlTdGF0dXNbXSA9IEpTT04ucGFyc2Uoc2F2ZWQpO1xuICAgICAgICBhcnIuZm9yRWFjaChyID0+IHRoaXMucmVsYXlzLnNldChyLnVybCwgcikpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICBpbml0aWFsUmVsYXlzLmZvckVhY2godXJsID0+IHtcbiAgICAgIGlmICghdGhpcy5yZWxheXMuaGFzKHVybCkpIHtcbiAgICAgICAgdGhpcy5yZWxheXMuc2V0KHVybCwgeyB1cmwsIGhlYWx0aHk6IHRydWUsIGxhc3RDaGVja2VkOiAwLCBmYWlsQ291bnQ6IDAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBTdWJzY3JpYmUgdG8gcmVsYXkgc3RhdHVzIGNoYW5nZXNcbiAgc3Vic2NyaWJlKGxpc3RlbmVyOiAoKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfVxuICBwcml2YXRlIG5vdGlmeSgpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGZuID0+IGZuKCkpO1xuICB9XG4gIHByaXZhdGUgcGVyc2lzdCgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICBcIm5vc3RyLXJlbGF5LXN0YXR1c1wiLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKHRoaXMucmVsYXlzLnZhbHVlcygpKSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZ2V0QWxsUmVsYXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucmVsYXlzLnZhbHVlcygpKTtcbiAgfVxuICBnZXRIZWFsdGh5UmVsYXlzKG1pbiA9IDMpIHtcbiAgICBjb25zdCBoZWFsdGh5ID0gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cy52YWx1ZXMoKSkuZmlsdGVyKHIgPT4gci5oZWFsdGh5KTtcbiAgICBpZiAoaGVhbHRoeS5sZW5ndGggPCBtaW4pIHtcbiAgICAgIC8vIEZhbGxiYWNrOiBpbmNsdWRlIHNvbWUgcmVjZW50bHkgZmFpbGVkIHJlbGF5c1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSBBcnJheS5mcm9tKHRoaXMucmVsYXlzLnZhbHVlcygpKVxuICAgICAgICAuZmlsdGVyKHIgPT4gIXIuaGVhbHRoeSAmJiBEYXRlLm5vdygpIC0gci5sYXN0Q2hlY2tlZCA+IHRoaXMucmV0cnlEZWxheSlcbiAgICAgICAgLnNsaWNlKDAsIG1pbiAtIGhlYWx0aHkubGVuZ3RoKTtcbiAgICAgIHJldHVybiBoZWFsdGh5LmNvbmNhdChmYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiBoZWFsdGh5O1xuICB9XG4gIG1hcmtSZWxheSh1cmw6IHN0cmluZywgaGVhbHRoeTogYm9vbGVhbikge1xuICAgIGNvbnN0IHIgPSB0aGlzLnJlbGF5cy5nZXQodXJsKTtcbiAgICBpZiAocikge1xuICAgICAgci5oZWFsdGh5ID0gaGVhbHRoeTtcbiAgICAgIHIubGFzdENoZWNrZWQgPSBEYXRlLm5vdygpO1xuICAgICAgci5mYWlsQ291bnQgPSBoZWFsdGh5ID8gMCA6IHIuZmFpbENvdW50ICsgMTtcbiAgICAgIGlmIChyLmZhaWxDb3VudCA+PSB0aGlzLm1heEZhaWwpIHIuaGVhbHRoeSA9IGZhbHNlO1xuICAgICAgdGhpcy5wZXJzaXN0KCk7XG4gICAgICB0aGlzLm5vdGlmeSgpO1xuICAgIH1cbiAgfVxuICBhc3luYyBjaGVja1JlbGF5KHVybDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgLy8gU2ltcGxlIGNoZWNrOiB0cnkgdG8gY29ubmVjdCBhbmQgZmV0Y2ggYSBkdW1teSBldmVudFxuICAgIGNvbnN0IHBvb2wgPSBuZXcgU2ltcGxlUG9vbCgpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwb29sLnF1ZXJ5U3luYyhbdXJsXSwgeyBsaW1pdDogMSB9KTtcbiAgICAgIHRoaXMubWFya1JlbGF5KHVybCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRoaXMubWFya1JlbGF5KHVybCwgZmFsc2UpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBwb29sLmNsb3NlKFt1cmxdKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY2hlY2tBbGxSZWxheXMoKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBBcnJheS5mcm9tKHRoaXMucmVsYXlzLmtleXMoKSkubWFwKHVybCA9PiB0aGlzLmNoZWNrUmVsYXkodXJsKSlcbiAgICApO1xuICB9XG4gIC8vIEZldGNoIHdpdGggcmV0cnkvYWdncmVnYXRpb25cbiAgYXN5bmMgZmV0Y2hXaXRoUmV0cnkoZmlsdGVyOiBhbnksIG1pblJlbGF5cyA9IDMsIG1heEF0dGVtcHRzID0gMikge1xuICAgIGxldCByZWxheXMgPSB0aGlzLmdldEhlYWx0aHlSZWxheXMobWluUmVsYXlzKS5tYXAociA9PiByLnVybCk7XG4gICAgbGV0IHJlc3VsdHM6IGFueVtdID0gW107XG4gICAgbGV0IHRyaWVkID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgbGV0IGF0dGVtcHRzID0gMDtcbiAgICB3aGlsZSAocmVzdWx0cy5sZW5ndGggPT09IDAgJiYgYXR0ZW1wdHMgPCBtYXhBdHRlbXB0cyAmJiByZWxheXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcG9vbCA9IG5ldyBTaW1wbGVQb29sKCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBwb29sLnF1ZXJ5U3luYyhyZWxheXMsIGZpbHRlcik7XG4gICAgICAgIHJlc3VsdHMgPSByZXMgfHwgW107XG4gICAgICAgIC8vIE1hcmsgYWxsIGFzIGhlYWx0aHlcbiAgICAgICAgcmVsYXlzLmZvckVhY2godXJsID0+IHRoaXMubWFya1JlbGF5KHVybCwgdHJ1ZSkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIE1hcmsgYWxsIGFzIGZhaWxlZFxuICAgICAgICByZWxheXMuZm9yRWFjaCh1cmwgPT4gdGhpcy5tYXJrUmVsYXkodXJsLCBmYWxzZSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcG9vbC5jbG9zZShyZWxheXMpO1xuICAgICAgfVxuICAgICAgLy8gUHJlcGFyZSBuZXh0IGF0dGVtcHRcbiAgICAgIHJlbGF5cy5mb3JFYWNoKHVybCA9PiB0cmllZC5hZGQodXJsKSk7XG4gICAgICByZWxheXMgPSB0aGlzLmdldEFsbFJlbGF5cygpXG4gICAgICAgIC5maWx0ZXIociA9PiAhdHJpZWQuaGFzKHIudXJsKSAmJiByLmhlYWx0aHkpXG4gICAgICAgIC5tYXAociA9PiByLnVybCk7XG4gICAgICBhdHRlbXB0cysrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICAvLyBBZGQvcmVtb3ZlIHJlbGF5cyAoZm9yIHBvd2VyIHVzZXJzKVxuICBhZGRSZWxheSh1cmw6IHN0cmluZykge1xuICAgIGlmICghdGhpcy5yZWxheXMuaGFzKHVybCkpIHtcbiAgICAgIHRoaXMucmVsYXlzLnNldCh1cmwsIHsgdXJsLCBoZWFsdGh5OiB0cnVlLCBsYXN0Q2hlY2tlZDogMCwgZmFpbENvdW50OiAwIH0pO1xuICAgICAgdGhpcy5wZXJzaXN0KCk7XG4gICAgICB0aGlzLm5vdGlmeSgpO1xuICAgIH1cbiAgfVxuICByZW1vdmVSZWxheSh1cmw6IHN0cmluZykge1xuICAgIGlmICh0aGlzLnJlbGF5cy5oYXModXJsKSkge1xuICAgICAgdGhpcy5yZWxheXMuZGVsZXRlKHVybCk7XG4gICAgICB0aGlzLnBlcnNpc3QoKTtcbiAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgfVxuICB9XG59XG5cbi8vIFNpbmdsZXRvbiBpbnN0YW5jZSB3aXRoIGRlZmF1bHQgcmVsYXlzXG5jb25zdCBERUZBVUxUX1JFTEFZUyA9IFtcbiAgXCJ3c3M6Ly9yZWxheS5kYW11cy5pb1wiLFxuICBcIndzczovL3JlbGF5Lm5vc3RyLmJhbmRcIixcbiAgXCJ3c3M6Ly9ub3N0ci53aW5lXCIsXG4gIFwid3NzOi8vbm9zdHItcHViLndlbGxvcmRlci5uZXRcIixcbiAgXCJ3c3M6Ly9ub3N0ci5veHRyLmRldlwiLFxuICBcIndzczovL25vc3RyLm1vbVwiLFxuXTtcblxuY29uc3QgcmVsYXlNYW5hZ2VyID0gbmV3IFJlbGF5TWFuYWdlcihERUZBVUxUX1JFTEFZUyk7XG5leHBvcnQgZGVmYXVsdCByZWxheU1hbmFnZXI7XG4iXSwibmFtZXMiOlsiU2ltcGxlUG9vbCIsIlJlbGF5TWFuYWdlciIsInN1YnNjcmliZSIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwiYWRkIiwiZGVsZXRlIiwibm90aWZ5IiwiZm9yRWFjaCIsImZuIiwicGVyc2lzdCIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwiQXJyYXkiLCJmcm9tIiwicmVsYXlzIiwidmFsdWVzIiwiZ2V0QWxsUmVsYXlzIiwiZ2V0SGVhbHRoeVJlbGF5cyIsIm1pbiIsImhlYWx0aHkiLCJmaWx0ZXIiLCJyIiwibGVuZ3RoIiwiZmFsbGJhY2siLCJEYXRlIiwibm93IiwibGFzdENoZWNrZWQiLCJyZXRyeURlbGF5Iiwic2xpY2UiLCJjb25jYXQiLCJtYXJrUmVsYXkiLCJ1cmwiLCJnZXQiLCJmYWlsQ291bnQiLCJtYXhGYWlsIiwiY2hlY2tSZWxheSIsInBvb2wiLCJxdWVyeVN5bmMiLCJsaW1pdCIsImNsb3NlIiwiY2hlY2tBbGxSZWxheXMiLCJQcm9taXNlIiwiYWxsIiwia2V5cyIsIm1hcCIsImZldGNoV2l0aFJldHJ5IiwibWluUmVsYXlzIiwibWF4QXR0ZW1wdHMiLCJyZXN1bHRzIiwidHJpZWQiLCJTZXQiLCJhdHRlbXB0cyIsInJlcyIsImhhcyIsImFkZFJlbGF5Iiwic2V0IiwicmVtb3ZlUmVsYXkiLCJjb25zdHJ1Y3RvciIsImluaXRpYWxSZWxheXMiLCJNYXAiLCJzYXZlZCIsImdldEl0ZW0iLCJhcnIiLCJwYXJzZSIsIkRFRkFVTFRfUkVMQVlTIiwicmVsYXlNYW5hZ2VyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/nostr/RelayManager.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/nostr/relay.ts":
/*!********************************!*\
  !*** ./src/lib/nostr/relay.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addUserRelay: () => (/* binding */ addUserRelay),\n/* harmony export */   checkAllRelays: () => (/* binding */ checkAllRelays),\n/* harmony export */   clearBadRelayCache: () => (/* binding */ clearBadRelayCache),\n/* harmony export */   fetchNostrFeed: () => (/* binding */ fetchNostrFeed),\n/* harmony export */   fetchNostrProfile: () => (/* binding */ fetchNostrProfile),\n/* harmony export */   getAllRelays: () => (/* binding */ getAllRelays),\n/* harmony export */   getHealthyRelays: () => (/* binding */ getHealthyRelays),\n/* harmony export */   removeUserRelay: () => (/* binding */ removeUserRelay)\n/* harmony export */ });\n/* harmony import */ var _RelayManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RelayManager */ \"(app-pages-browser)/./src/lib/nostr/RelayManager.tsx\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/../node_modules/nostr-tools/lib/esm/index.js\");\n// nostr-relay.ts\n// Simple NOSTR relay fetcher using nostr-tools\n\n\n// --- RELAY MANAGEMENT (delegated to RelayManager) ---\nfunction addUserRelay(url) {\n    _RelayManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addRelay(url);\n}\nfunction removeUserRelay(url) {\n    _RelayManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"].removeRelay(url);\n}\nfunction getAllRelays() {\n    return _RelayManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getAllRelays().map((r)=>r.url);\n}\n// --- FEED FETCHING ---\nasync function fetchNostrFeed(relayUrls) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    // Use provided relays or healthy relays from manager\n    const relays = relayUrls && relayUrls.length ? relayUrls : _RelayManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getHealthyRelays().map((r)=>r.url);\n    const pool = new nostr_tools__WEBPACK_IMPORTED_MODULE_1__.SimplePool();\n    const filter = {\n        kinds: [\n            1\n        ],\n        limit: options.limit || 20,\n        ...options.until ? {\n            until: options.until\n        } : {}\n    };\n    try {\n        const events = await pool.querySync(relays, filter);\n        return events.sort((a, b)=>b.created_at - a.created_at);\n    } finally{\n        pool.close(relays);\n    }\n}\n// --- PROFILE FETCHING ---\nasync function fetchNostrProfile(relayUrls, pubkey) {\n    const relays = relayUrls && relayUrls.length ? relayUrls : _RelayManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getHealthyRelays().map((r)=>r.url);\n    const pool = new nostr_tools__WEBPACK_IMPORTED_MODULE_1__.SimplePool();\n    const filter = {\n        kinds: [\n            0\n        ],\n        authors: [\n            pubkey\n        ],\n        limit: 1\n    };\n    try {\n        const events = await pool.querySync(relays, filter);\n        if (events.length > 0) {\n            try {\n                return JSON.parse(events[0].content);\n            } catch (err) {\n                console.warn(\"Failed to parse profile content for \".concat(pubkey, \":\"), err);\n                return null;\n            }\n        }\n        return null;\n    } finally{\n        pool.close(relays);\n    }\n}\n// --- RELAY HEALTH ---\nasync function getHealthyRelays() {\n    const healthy = _RelayManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getHealthyRelays();\n    const all = _RelayManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getAllRelays();\n    return {\n        healthyRelays: healthy.map((r)=>r.url),\n        healthyCount: healthy.length,\n        totalCount: all.length\n    };\n}\nasync function checkAllRelays() {\n    await _RelayManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"].checkAllRelays();\n}\nfunction clearBadRelayCache() {\n    // For compatibility, just re-check all relays and mark all as healthy\n    _RelayManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getAllRelays().forEach((r)=>_RelayManager__WEBPACK_IMPORTED_MODULE_0__[\"default\"].markRelay(r.url, true));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbm9zdHIvcmVsYXkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLGlCQUFpQjtBQUNqQiwrQ0FBK0M7QUFDTDtBQUN3QjtBQU9sRSx1REFBdUQ7QUFDaEQsU0FBU0UsYUFBYUMsR0FBVztJQUN0Q0gscURBQVlBLENBQUNJLFFBQVEsQ0FBQ0Q7QUFDeEI7QUFDTyxTQUFTRSxnQkFBZ0JGLEdBQVc7SUFDekNILHFEQUFZQSxDQUFDTSxXQUFXLENBQUNIO0FBQzNCO0FBQ08sU0FBU0k7SUFDZCxPQUFPUCxxREFBWUEsQ0FBQ08sWUFBWSxHQUFHQyxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVOLEdBQUc7QUFDbkQ7QUFFQSx3QkFBd0I7QUFDakIsZUFBZU8sZUFBZUMsU0FBb0I7UUFBRUMsVUFBQUEsaUVBQXVCLENBQUM7SUFDakYscURBQXFEO0lBQ3JELE1BQU1DLFNBQVNGLGFBQWFBLFVBQVVHLE1BQU0sR0FBR0gsWUFBWVgscURBQVlBLENBQUNlLGdCQUFnQixHQUFHUCxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVOLEdBQUc7SUFDekcsTUFBTWEsT0FBTyxJQUFJZixtREFBVUE7SUFDM0IsTUFBTWdCLFNBQWlCO1FBQ3JCQyxPQUFPO1lBQUM7U0FBRTtRQUNWQyxPQUFPUCxRQUFRTyxLQUFLLElBQUk7UUFDeEIsR0FBSVAsUUFBUVEsS0FBSyxHQUFHO1lBQUVBLE9BQU9SLFFBQVFRLEtBQUs7UUFBQyxJQUFJLENBQUMsQ0FBQztJQUNuRDtJQUNBLElBQUk7UUFDRixNQUFNQyxTQUFTLE1BQU1MLEtBQUtNLFNBQVMsQ0FBQ1QsUUFBUUk7UUFDNUMsT0FBT0ksT0FBT0UsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1BLEVBQUVDLFVBQVUsR0FBR0YsRUFBRUUsVUFBVTtJQUMxRCxTQUFVO1FBQ1JWLEtBQUtXLEtBQUssQ0FBQ2Q7SUFDYjtBQUNGO0FBRUEsMkJBQTJCO0FBQ3BCLGVBQWVlLGtCQUFrQmpCLFNBQW1CLEVBQUVrQixNQUFjO0lBQ3pFLE1BQU1oQixTQUFTRixhQUFhQSxVQUFVRyxNQUFNLEdBQUdILFlBQVlYLHFEQUFZQSxDQUFDZSxnQkFBZ0IsR0FBR1AsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFTixHQUFHO0lBQ3pHLE1BQU1hLE9BQU8sSUFBSWYsbURBQVVBO0lBQzNCLE1BQU1nQixTQUFpQjtRQUNyQkMsT0FBTztZQUFDO1NBQUU7UUFDVlksU0FBUztZQUFDRDtTQUFPO1FBQ2pCVixPQUFPO0lBQ1Q7SUFDQSxJQUFJO1FBQ0YsTUFBTUUsU0FBUyxNQUFNTCxLQUFLTSxTQUFTLENBQUNULFFBQVFJO1FBQzVDLElBQUlJLE9BQU9QLE1BQU0sR0FBRyxHQUFHO1lBQ3JCLElBQUk7Z0JBQ0YsT0FBT2lCLEtBQUtDLEtBQUssQ0FBQ1gsTUFBTSxDQUFDLEVBQUUsQ0FBQ1ksT0FBTztZQUNyQyxFQUFFLE9BQU9DLEtBQUs7Z0JBQ1pDLFFBQVFDLElBQUksQ0FBQyx1Q0FBOEMsT0FBUFAsUUFBTyxNQUFJSztnQkFDL0QsT0FBTztZQUNUO1FBQ0Y7UUFDQSxPQUFPO0lBQ1QsU0FBVTtRQUNSbEIsS0FBS1csS0FBSyxDQUFDZDtJQUNiO0FBQ0Y7QUFFQSx1QkFBdUI7QUFDaEIsZUFBZUU7SUFDcEIsTUFBTXNCLFVBQVVyQyxxREFBWUEsQ0FBQ2UsZ0JBQWdCO0lBQzdDLE1BQU11QixNQUFNdEMscURBQVlBLENBQUNPLFlBQVk7SUFDckMsT0FBTztRQUNMZ0MsZUFBZUYsUUFBUTdCLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRU4sR0FBRztRQUNyQ3FDLGNBQWNILFFBQVF2QixNQUFNO1FBQzVCMkIsWUFBWUgsSUFBSXhCLE1BQU07SUFDeEI7QUFDRjtBQUVPLGVBQWU0QjtJQUNwQixNQUFNMUMscURBQVlBLENBQUMwQyxjQUFjO0FBQ25DO0FBRU8sU0FBU0M7SUFDZCxzRUFBc0U7SUFDdEUzQyxxREFBWUEsQ0FBQ08sWUFBWSxHQUFHcUMsT0FBTyxDQUFDbkMsQ0FBQUEsSUFBS1QscURBQVlBLENBQUM2QyxTQUFTLENBQUNwQyxFQUFFTixHQUFHLEVBQUU7QUFDekUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zY2FybmVzL3dvcmtzcGFjZS9zcmMvbGliL25vc3RyL3JlbGF5LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIG5vc3RyLXJlbGF5LnRzXG4vLyBTaW1wbGUgTk9TVFIgcmVsYXkgZmV0Y2hlciB1c2luZyBub3N0ci10b29sc1xuaW1wb3J0IHJlbGF5TWFuYWdlciBmcm9tIFwiLi9SZWxheU1hbmFnZXJcIjtcbmltcG9ydCB7IFNpbXBsZVBvb2wsIHR5cGUgRXZlbnQsIHR5cGUgRmlsdGVyIH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmVlZE9wdGlvbnMge1xuICBsaW1pdD86IG51bWJlcjtcbiAgdW50aWw/OiBudW1iZXI7XG59XG5cbi8vIC0tLSBSRUxBWSBNQU5BR0VNRU5UIChkZWxlZ2F0ZWQgdG8gUmVsYXlNYW5hZ2VyKSAtLS1cbmV4cG9ydCBmdW5jdGlvbiBhZGRVc2VyUmVsYXkodXJsOiBzdHJpbmcpIHtcbiAgcmVsYXlNYW5hZ2VyLmFkZFJlbGF5KHVybCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlVXNlclJlbGF5KHVybDogc3RyaW5nKSB7XG4gIHJlbGF5TWFuYWdlci5yZW1vdmVSZWxheSh1cmwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFJlbGF5cygpOiBzdHJpbmdbXSB7XG4gIHJldHVybiByZWxheU1hbmFnZXIuZ2V0QWxsUmVsYXlzKCkubWFwKHIgPT4gci51cmwpO1xufVxuXG4vLyAtLS0gRkVFRCBGRVRDSElORyAtLS1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaE5vc3RyRmVlZChyZWxheVVybHM/OiBzdHJpbmdbXSwgb3B0aW9uczogRmVlZE9wdGlvbnMgPSB7fSk6IFByb21pc2U8RXZlbnRbXT4ge1xuICAvLyBVc2UgcHJvdmlkZWQgcmVsYXlzIG9yIGhlYWx0aHkgcmVsYXlzIGZyb20gbWFuYWdlclxuICBjb25zdCByZWxheXMgPSByZWxheVVybHMgJiYgcmVsYXlVcmxzLmxlbmd0aCA/IHJlbGF5VXJscyA6IHJlbGF5TWFuYWdlci5nZXRIZWFsdGh5UmVsYXlzKCkubWFwKHIgPT4gci51cmwpO1xuICBjb25zdCBwb29sID0gbmV3IFNpbXBsZVBvb2woKTtcbiAgY29uc3QgZmlsdGVyOiBGaWx0ZXIgPSB7XG4gICAga2luZHM6IFsxXSxcbiAgICBsaW1pdDogb3B0aW9ucy5saW1pdCB8fCAyMCxcbiAgICAuLi4ob3B0aW9ucy51bnRpbCA/IHsgdW50aWw6IG9wdGlvbnMudW50aWwgfSA6IHt9KSxcbiAgfTtcbiAgdHJ5IHtcbiAgICBjb25zdCBldmVudHMgPSBhd2FpdCBwb29sLnF1ZXJ5U3luYyhyZWxheXMsIGZpbHRlcik7XG4gICAgcmV0dXJuIGV2ZW50cy5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQpO1xuICB9IGZpbmFsbHkge1xuICAgIHBvb2wuY2xvc2UocmVsYXlzKTtcbiAgfVxufVxuXG4vLyAtLS0gUFJPRklMRSBGRVRDSElORyAtLS1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaE5vc3RyUHJvZmlsZShyZWxheVVybHM6IHN0cmluZ1tdLCBwdWJrZXk6IHN0cmluZykge1xuICBjb25zdCByZWxheXMgPSByZWxheVVybHMgJiYgcmVsYXlVcmxzLmxlbmd0aCA/IHJlbGF5VXJscyA6IHJlbGF5TWFuYWdlci5nZXRIZWFsdGh5UmVsYXlzKCkubWFwKHIgPT4gci51cmwpO1xuICBjb25zdCBwb29sID0gbmV3IFNpbXBsZVBvb2woKTtcbiAgY29uc3QgZmlsdGVyOiBGaWx0ZXIgPSB7XG4gICAga2luZHM6IFswXSxcbiAgICBhdXRob3JzOiBbcHVia2V5XSxcbiAgICBsaW1pdDogMSxcbiAgfTtcbiAgdHJ5IHtcbiAgICBjb25zdCBldmVudHMgPSBhd2FpdCBwb29sLnF1ZXJ5U3luYyhyZWxheXMsIGZpbHRlcik7XG4gICAgaWYgKGV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShldmVudHNbMF0uY29udGVudCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gcGFyc2UgcHJvZmlsZSBjb250ZW50IGZvciAke3B1YmtleX06YCwgZXJyKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9IGZpbmFsbHkge1xuICAgIHBvb2wuY2xvc2UocmVsYXlzKTtcbiAgfVxufVxuXG4vLyAtLS0gUkVMQVkgSEVBTFRIIC0tLVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEhlYWx0aHlSZWxheXMoKTogUHJvbWlzZTx7IGhlYWx0aHlSZWxheXM6IHN0cmluZ1tdOyBoZWFsdGh5Q291bnQ6IG51bWJlcjsgdG90YWxDb3VudDogbnVtYmVyIH0+IHtcbiAgY29uc3QgaGVhbHRoeSA9IHJlbGF5TWFuYWdlci5nZXRIZWFsdGh5UmVsYXlzKCk7XG4gIGNvbnN0IGFsbCA9IHJlbGF5TWFuYWdlci5nZXRBbGxSZWxheXMoKTtcbiAgcmV0dXJuIHtcbiAgICBoZWFsdGh5UmVsYXlzOiBoZWFsdGh5Lm1hcChyID0+IHIudXJsKSxcbiAgICBoZWFsdGh5Q291bnQ6IGhlYWx0aHkubGVuZ3RoLFxuICAgIHRvdGFsQ291bnQ6IGFsbC5sZW5ndGgsXG4gIH07XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja0FsbFJlbGF5cygpIHtcbiAgYXdhaXQgcmVsYXlNYW5hZ2VyLmNoZWNrQWxsUmVsYXlzKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckJhZFJlbGF5Q2FjaGUoKSB7XG4gIC8vIEZvciBjb21wYXRpYmlsaXR5LCBqdXN0IHJlLWNoZWNrIGFsbCByZWxheXMgYW5kIG1hcmsgYWxsIGFzIGhlYWx0aHlcbiAgcmVsYXlNYW5hZ2VyLmdldEFsbFJlbGF5cygpLmZvckVhY2gociA9PiByZWxheU1hbmFnZXIubWFya1JlbGF5KHIudXJsLCB0cnVlKSk7XG59XG4iXSwibmFtZXMiOlsicmVsYXlNYW5hZ2VyIiwiU2ltcGxlUG9vbCIsImFkZFVzZXJSZWxheSIsInVybCIsImFkZFJlbGF5IiwicmVtb3ZlVXNlclJlbGF5IiwicmVtb3ZlUmVsYXkiLCJnZXRBbGxSZWxheXMiLCJtYXAiLCJyIiwiZmV0Y2hOb3N0ckZlZWQiLCJyZWxheVVybHMiLCJvcHRpb25zIiwicmVsYXlzIiwibGVuZ3RoIiwiZ2V0SGVhbHRoeVJlbGF5cyIsInBvb2wiLCJmaWx0ZXIiLCJraW5kcyIsImxpbWl0IiwidW50aWwiLCJldmVudHMiLCJxdWVyeVN5bmMiLCJzb3J0IiwiYSIsImIiLCJjcmVhdGVkX2F0IiwiY2xvc2UiLCJmZXRjaE5vc3RyUHJvZmlsZSIsInB1YmtleSIsImF1dGhvcnMiLCJKU09OIiwicGFyc2UiLCJjb250ZW50IiwiZXJyIiwiY29uc29sZSIsIndhcm4iLCJoZWFsdGh5IiwiYWxsIiwiaGVhbHRoeVJlbGF5cyIsImhlYWx0aHlDb3VudCIsInRvdGFsQ291bnQiLCJjaGVja0FsbFJlbGF5cyIsImNsZWFyQmFkUmVsYXlDYWNoZSIsImZvckVhY2giLCJtYXJrUmVsYXkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/nostr/relay.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/utils/link-preview.ts":
/*!***************************************!*\
  !*** ./src/lib/utils/link-preview.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchLinkPreview: () => (/* binding */ fetchLinkPreview)\n/* harmony export */ });\n// link-preview.ts\n// Fetch OpenGraph/Twitter Card metadata for a given URL (server-side)\nasync function fetchLinkPreview(url) {\n    try {\n        const res = await fetch(\"https://opengraph.rocks/api/preview?url=\".concat(encodeURIComponent(url)));\n        if (!res.ok) return null;\n        const data = await res.json();\n        return {\n            url,\n            title: data.title,\n            description: data.description,\n            image: data.image,\n            siteName: data.site_name,\n            favicon: data.favicon\n        };\n    } catch (e) {\n        return null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvdXRpbHMvbGluay1wcmV2aWV3LnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxrQkFBa0I7QUFDbEIsc0VBQXNFO0FBVy9ELGVBQWVBLGlCQUFpQkMsR0FBVztJQUM5QyxJQUFJO1FBQ0EsTUFBTUMsTUFBTSxNQUFNQyxNQUFNLDJDQUFtRSxPQUF4QkMsbUJBQW1CSDtRQUN0RixJQUFJLENBQUNDLElBQUlHLEVBQUUsRUFBRSxPQUFPO1FBQ3BCLE1BQU1DLE9BQU8sTUFBTUosSUFBSUssSUFBSTtRQUMzQixPQUFPO1lBQ0hOO1lBQ0FPLE9BQU9GLEtBQUtFLEtBQUs7WUFDakJDLGFBQWFILEtBQUtHLFdBQVc7WUFDN0JDLE9BQU9KLEtBQUtJLEtBQUs7WUFDakJDLFVBQVVMLEtBQUtNLFNBQVM7WUFDeEJDLFNBQVNQLEtBQUtPLE9BQU87UUFDekI7SUFDSixFQUFFLFVBQU07UUFDSixPQUFPO0lBQ1g7QUFDSiIsInNvdXJjZXMiOlsiL1VzZXJzL3NjYXJuZXMvd29ya3NwYWNlL3NyYy9saWIvdXRpbHMvbGluay1wcmV2aWV3LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGxpbmstcHJldmlldy50c1xuLy8gRmV0Y2ggT3BlbkdyYXBoL1R3aXR0ZXIgQ2FyZCBtZXRhZGF0YSBmb3IgYSBnaXZlbiBVUkwgKHNlcnZlci1zaWRlKVxuXG5leHBvcnQgaW50ZXJmYWNlIExpbmtQcmV2aWV3IHtcbiAgICB1cmw6IHN0cmluZztcbiAgICB0aXRsZT86IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgICBpbWFnZT86IHN0cmluZztcbiAgICBzaXRlTmFtZT86IHN0cmluZztcbiAgICBmYXZpY29uPzogc3RyaW5nO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hMaW5rUHJldmlldyh1cmw6IHN0cmluZyk6IFByb21pc2U8TGlua1ByZXZpZXcgfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vb3BlbmdyYXBoLnJvY2tzL2FwaS9wcmV2aWV3P3VybD0ke2VuY29kZVVSSUNvbXBvbmVudCh1cmwpfWApO1xuICAgICAgICBpZiAoIXJlcy5vaykgcmV0dXJuIG51bGw7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgdGl0bGU6IGRhdGEudGl0bGUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZGF0YS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGltYWdlOiBkYXRhLmltYWdlLFxuICAgICAgICAgICAgc2l0ZU5hbWU6IGRhdGEuc2l0ZV9uYW1lLFxuICAgICAgICAgICAgZmF2aWNvbjogZGF0YS5mYXZpY29uLFxuICAgICAgICB9O1xuICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiZmV0Y2hMaW5rUHJldmlldyIsInVybCIsInJlcyIsImZldGNoIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwib2siLCJkYXRhIiwianNvbiIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJpbWFnZSIsInNpdGVOYW1lIiwic2l0ZV9uYW1lIiwiZmF2aWNvbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/utils/link-preview.ts\n"));

/***/ })

});